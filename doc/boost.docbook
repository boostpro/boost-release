<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book><title>The Boost C++ Libraries</title><part id="libraries"><title>The Boost C++ Libraries</title><para>
      Documentation for some libraries is available in alternative formats:
       <itemizedlist><listitem><simpara><ulink url="http://www.boost.org/doc/boost-doc-html.tar.gz">HTML (tarred, gzipped)</ulink></simpara></listitem><listitem><simpara><ulink url="http://www.boost.org/doc/boost.pdf">PDF</ulink></simpara></listitem><listitem><simpara><ulink url="http://www.boost.org/doc/boost-doc-man.tar.gz">Unix man pages</ulink></simpara></listitem><listitem><simpara><ulink url="../boost.docbook">DocBook</ulink></simpara></listitem><listitem><simpara><ulink url="../boost.fo">XSL Formatting Objects</ulink></simpara></listitem></itemizedlist></para><section><title>Libraries Listed Alphabetically</title><itemizedlist spacing="compact"><listitem><simpara><link linkend="any">Any</link> - 
      Safe, generic container for single values of different value types
    , from Kevlin Henney.</simpara></listitem><listitem><simpara><link linkend="array">Array</link> - STL compliant container wrapper for arrays of constant size, from Nicolai Josuttis.</simpara></listitem><listitem><simpara><ulink url="../../libs/bind/index.html">Bind</ulink> - Generalized binders for function/object/pointers and member functions, from Peter Dimov.</simpara></listitem><listitem><simpara><ulink url="../../libs/crc/index.html">CRC</ulink> - Cyclic Redundancy Code, from Daryle Walker.</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/call_traits.htm">Call Traits</ulink> - Defines types for passing parameters, from John Maddock and Howard Hinnant.</simpara></listitem><listitem><simpara><ulink url="../../libs/compatibility/index.html">Compatibility</ulink> - Help for non-conforming standard libraries, from Ralf Grosse-Kunstleve and Jens Maurer.</simpara></listitem><listitem><simpara><ulink url="../../libs/compose/index.htm">Compose</ulink> - Functional composition adapters for the STL, from Nicolai Josuttis.</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/compressed_pair.htm">Compressed Pair</ulink> - Empty member optimization, from John Maddock and Howard Hinnant.</simpara></listitem><listitem><simpara><ulink url="../../libs/concept_check/index.html">Concept Check</ulink> - Tools for generic programming, from Jeremy Siek.</simpara></listitem><listitem><simpara><ulink url="../../libs/config/index.html">Config</ulink> - Helps boost library developers adapt to compiler idiosyncrasies; not intended for library users, from John Maddock, Beman Dawes, and Vesa Karvonen.</simpara></listitem><listitem><simpara><ulink url="../../libs/conversion/index.html">Conversion</ulink> - Numeric, polymorphic, and lexical casts, from Dave Abrahams and Kevlin Henney.</simpara></listitem><listitem><simpara><link linkend="date_time">Date Time</link> - A set of facilities to ease programming with dates and times.
  , from Jeff Garland.</simpara></listitem><listitem><simpara><ulink url="../../libs/dynamic_bitset/index.html">Dynamic Bitset</ulink> - A runtime sized version of <computeroutput>std::bitset</computeroutput>, from Jeremy Siek and Chuck Allison.</simpara></listitem><listitem><simpara><ulink url="../../libs/filesystem/index.html">Filesystem</ulink> - Portable paths, iteration over directories, and other useful filesystem operations, from Beman Dawes.</simpara></listitem><listitem><simpara><ulink url="../../libs/format/index.html">Format</ulink> - Type-safe 'printf-like' format operations, from Samuel Krempp.</simpara></listitem><listitem><simpara><link linkend="function">Function</link> - Function object wrappers for deferred calls or callbacks, from Douglas Gregor.</simpara></listitem><listitem><simpara><ulink url="../../libs/functional/index.html">Functional</ulink> - Enhanced function object adaptors, from Mark Rodgers.</simpara></listitem><listitem><simpara><ulink url="../../libs/graph/index.html">Graph</ulink> - Generic graph components and algorithms, from Jeremy Siek and University of Notre Dame Team.</simpara></listitem><listitem><simpara><ulink url="../../libs/io/index.html">I/O State Savers</ulink> - Save I/O state to prevent jumbled data, from Daryle Walker.</simpara></listitem><listitem><simpara><ulink url="../../libs/integer/index.html">Integer</ulink> - Headers to ease dealing with integral types, from various authors.</simpara></listitem><listitem><simpara><ulink url="../../libs/numeric/interval/doc/index.html">Interval</ulink> - Extends the usual arithmetic functions to mathematical intervals, from Guillaume Melquiond, Herv&#xE9; Br&#xF6;nnimann, and Sylvain Pion.</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/iterator_adaptors.htm">Iterator Adaptors</ulink> - Adapt a base type into a standard conforming iterator, from Dave Abrahams, Jeremy Siek, and John Potter.</simpara></listitem><listitem><simpara><link linkend="lambda">Lambda</link> - Define small unnamed function objects at the actual call site, and more, from Jaakko J&#xE4;rvi.</simpara></listitem><listitem><simpara><ulink url="../../libs/mpl/index.html">MPL</ulink> - Template metaprogramming framework of compile-time algorithms, sequences and metafunction classes, from Aleksey Gurtovoy.</simpara></listitem><listitem><simpara><ulink url="../../libs/math/index.html">Math</ulink> - Several contributions in the domain of mathematics, from various authors.</simpara></listitem><listitem><simpara><ulink url="../../libs/math/doc/common_factor.html">Math/Common Factor</ulink> - Greatest common divisor and least common multiple, from Daryle Walker.</simpara></listitem><listitem><simpara><ulink url="../../libs/math/octonion/index.html">Math/Octonion</ulink> - Octonions, from Hubert Holin.</simpara></listitem><listitem><simpara><ulink url="../../libs/math/quaternion/index.html">Math/Quaternion</ulink> - Quaternions, from Hubert Holin.</simpara></listitem><listitem><simpara><ulink url="../../libs/math/special_functions/index.html">Math/Special Functions</ulink> - Mathematical special functions such as atanh, sinc, and sinhc, from Hubert Holin.</simpara></listitem><listitem><simpara><ulink url="../../libs/bind/mem_fn.html">Mem_fn</ulink> - Generalized binders for member functions, from Peter Dimov.</simpara></listitem><listitem><simpara><ulink url="../../libs/multi_array/index.html">Multi Array</ulink> - Multidimensional containers and adaptors for arrays of contiguous data, from Ron Garcia.</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/index.html">Operators</ulink> - Templates ease arithmetic classes and iterators, from Dave Abrahams and Jeremy Siek.</simpara></listitem><listitem><simpara><ulink url="../../libs/optional/index.html">Optional</ulink> - Discriminated-union wrapper for optional values, from Fernando Cacciola.</simpara></listitem><listitem><simpara><ulink url="../../libs/pool/index.html">Pool</ulink> - Memory pool management, from Steve Cleary.</simpara></listitem><listitem><simpara><ulink url="../../libs/preprocessor/index.html">Preprocessor</ulink> - Preprocessor metaprogramming tools including repetition and recursion, from Vesa Karvonen and Paul Mensonides.</simpara></listitem><listitem><simpara><link linkend="program_options">Program_options</link> - 
      Facilities to obtain configuration data from command line, config files
      and other sources, from Vladimir Prus.</simpara></listitem><listitem><simpara><ulink url="../../libs/property_map/index.html">Property Map</ulink> - Concepts defining interfaces which map key objects to value objects, from Jeremy Siek.</simpara></listitem><listitem><simpara><ulink url="../../libs/python/index.html">Python</ulink> - Reflects C++ classes and functions into <ulink url="http://www.python.org">Python</ulink>, from Dave Abrahams.</simpara></listitem><listitem><simpara><ulink url="../../libs/random/index.html">Random</ulink> - A complete system for random number generation, from Jens Maurer.</simpara></listitem><listitem><simpara><ulink url="../../libs/rational/index.html">Rational</ulink> - A rational number class, from Paul Moore.</simpara></listitem><listitem><simpara><link linkend="ref">Ref</link> - A utility library for passing references to generic functions, from Jaakko J&#xE4;rvi, Peter Dimov, Douglas Gregor, and Dave Abrahams.</simpara></listitem><listitem><simpara><ulink url="../../libs/regex/index.html">Regex</ulink> - Regular expression library, from John Maddock.</simpara></listitem><listitem><simpara><ulink url="../../libs/serialization/index.html">Serialization</ulink> - Serialization of C++ objects for persistence and marshalling, from Robert Ramey.</simpara></listitem><listitem><simpara><link linkend="signals">Signals</link> - Managed signals &amp; slots callback implementation, from Douglas Gregor.</simpara></listitem><listitem><simpara><ulink url="../../libs/smart_ptr/index.html">Smart Pointer</ulink> - Five smart pointer class templates, from Greg Colvin, Beman Dawes, Peter Dimov, and Darin Adler.</simpara></listitem><listitem><simpara><ulink url="../../libs/spirit/index.html">Spirit</ulink> - LL parser framework represents parsers directly as EBNF grammars in inlined C++, from Joel de Guzman and team .</simpara></listitem><listitem><simpara><ulink url="../../libs/static_assert/index.html">Static Assert</ulink> - Static assertions (compile time assertions), from John Maddock.</simpara></listitem><listitem><simpara><link linkend="string_algo">String Algorithms</link> - 
            A set of generic string-related algorithms and utilities
        , from Pavol Droba.</simpara></listitem><listitem><simpara><ulink url="../../libs/test/index.html">Test</ulink> - Support for simple program testing, full unit testing, and for program execution monitoring, from Gennadiy Rozental.</simpara></listitem><listitem><simpara><link linkend="threads">Threads</link> - Portable C++ multi-threading, from William Kempf.</simpara></listitem><listitem><simpara><ulink url="../../libs/timer/index.html">Timer</ulink> - Event timer, progress timer, and progress display classes, from Beman Dawes.</simpara></listitem><listitem><simpara><ulink url="../../libs/tokenizer/index.html">Tokenizer</ulink> - Break of a string or other character sequence into a series of tokens, from John Bandela.</simpara></listitem><listitem><simpara><link linkend="tribool">Tribool</link> - Three-state boolean type, from Douglas Gregor.</simpara></listitem><listitem><simpara><ulink url="../../libs/tuple/index.html">Tuple</ulink> - Ease definition of functions returning multiple values, and more, from Jaakko J&#xE4;rvi.</simpara></listitem><listitem><simpara><ulink url="../../libs/type_traits/index.html">Type Traits</ulink> - Templates for fundamental properties of types, from John Maddock, Steve Cleary, and others .</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/index.html">Utility</ulink> - Class noncopyable  plus checked_delete, checked_array_delete, next,  prior  function templates, plus base-from-member idiom, from Dave Abrahams and others .</simpara></listitem><listitem><simpara><link linkend="variant">Variant</link> - Safe, generic, stack-based discriminated union container, from Eric Friedman and Itay Maman.</simpara></listitem><listitem><simpara><ulink url="../../libs/numeric/ublas/index.html">uBLAS</ulink> - Basic linear algebra for dense, packed and sparse matrices, from Joerg Walter and Mathias Koch.</simpara></listitem></itemizedlist></section><section><title>Libraries Listed by Category</title><section><title>
          String and text processing
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/format/index.html">Format</ulink> - Type-safe 'printf-like' format operations, from Samuel Krempp.</simpara></listitem><listitem><simpara><ulink url="../../libs/regex/index.html">Regex</ulink> - Regular expression library, from John Maddock.</simpara></listitem><listitem><simpara><link linkend="string_algo">String Algorithms</link> - 
            A set of generic string-related algorithms and utilities
        , from Pavol Droba.</simpara></listitem><listitem><simpara><ulink url="../../libs/tokenizer/index.html">Tokenizer</ulink> - Break of a string or other character sequence into a series of tokens, from John Bandela.</simpara></listitem></itemizedlist></section><section><title>
          Containers
        </title><itemizedlist spacing="compact"><listitem><simpara><link linkend="array">Array</link> - STL compliant container wrapper for arrays of constant size, from Nicolai Josuttis.</simpara></listitem><listitem><simpara><ulink url="../../libs/dynamic_bitset/index.html">Dynamic Bitset</ulink> - A runtime sized version of <computeroutput>std::bitset</computeroutput>, from Jeremy Siek and Chuck Allison.</simpara></listitem><listitem><simpara><ulink url="../../libs/graph/index.html">Graph</ulink> - Generic graph components and algorithms, from Jeremy Siek and University of Notre Dame Team.</simpara></listitem><listitem><simpara><ulink url="../../libs/multi_array/index.html">Multi Array</ulink> - Multidimensional containers and adaptors for arrays of contiguous data, from Ron Garcia.</simpara></listitem><listitem><simpara><ulink url="../../libs/property_map/index.html">Property Map</ulink> - Concepts defining interfaces which map key objects to value objects, from Jeremy Siek.</simpara></listitem><listitem><simpara><link linkend="variant">Variant</link> - Safe, generic, stack-based discriminated union container, from Eric Friedman and Itay Maman.</simpara></listitem></itemizedlist></section><section><title>
          Iterators
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/graph/index.html">Graph</ulink> - Generic graph components and algorithms, from Jeremy Siek and University of Notre Dame Team.</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/iterator_adaptors.htm">Iterator Adaptors</ulink> - Adapt a base type into a standard conforming iterator, from Dave Abrahams, Jeremy Siek, and John Potter.</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/index.html">Operators</ulink> - Templates ease arithmetic classes and iterators, from Dave Abrahams and Jeremy Siek.</simpara></listitem><listitem><simpara><ulink url="../../libs/tokenizer/index.html">Tokenizer</ulink> - Break of a string or other character sequence into a series of tokens, from John Bandela.</simpara></listitem></itemizedlist></section><section><title>
          Algorithms
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/graph/index.html">Graph</ulink> - Generic graph components and algorithms, from Jeremy Siek and University of Notre Dame Team.</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/index.html">Utility</ulink> - Class noncopyable  plus checked_delete, checked_array_delete, next,  prior  function templates, plus base-from-member idiom, from Dave Abrahams and others .</simpara></listitem></itemizedlist></section><section><title>
          Function objects and higher-order programming
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/bind/index.html">Bind</ulink> - Generalized binders for function/object/pointers and member functions, from Peter Dimov.</simpara></listitem><listitem><simpara><ulink url="../../libs/compose/index.htm">Compose</ulink> - Functional composition adapters for the STL, from Nicolai Josuttis.</simpara></listitem><listitem><simpara><link linkend="function">Function</link> - Function object wrappers for deferred calls or callbacks, from Douglas Gregor.</simpara></listitem><listitem><simpara><ulink url="../../libs/functional/index.html">Functional</ulink> - Enhanced function object adaptors, from Mark Rodgers.</simpara></listitem><listitem><simpara><link linkend="lambda">Lambda</link> - Define small unnamed function objects at the actual call site, and more, from Jaakko J&#xE4;rvi.</simpara></listitem><listitem><simpara><ulink url="../../libs/bind/mem_fn.html">Mem_fn</ulink> - Generalized binders for member functions, from Peter Dimov.</simpara></listitem><listitem><simpara><link linkend="ref">Ref</link> - A utility library for passing references to generic functions, from Jaakko J&#xE4;rvi, Peter Dimov, Douglas Gregor, and Dave Abrahams.</simpara></listitem><listitem><simpara><link linkend="signals">Signals</link> - Managed signals &amp; slots callback implementation, from Douglas Gregor.</simpara></listitem></itemizedlist></section><section><title> 
          Generic programming
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/utility/call_traits.htm">Call Traits</ulink> - Defines types for passing parameters, from John Maddock and Howard Hinnant.</simpara></listitem><listitem><simpara><ulink url="../../libs/concept_check/index.html">Concept Check</ulink> - Tools for generic programming, from Jeremy Siek.</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/index.html">Operators</ulink> - Templates ease arithmetic classes and iterators, from Dave Abrahams and Jeremy Siek.</simpara></listitem><listitem><simpara><ulink url="../../libs/property_map/index.html">Property Map</ulink> - Concepts defining interfaces which map key objects to value objects, from Jeremy Siek.</simpara></listitem><listitem><simpara><ulink url="../../libs/static_assert/index.html">Static Assert</ulink> - Static assertions (compile time assertions), from John Maddock.</simpara></listitem><listitem><simpara><ulink url="../../libs/type_traits/index.html">Type Traits</ulink> - Templates for fundamental properties of types, from John Maddock, Steve Cleary, and others .</simpara></listitem></itemizedlist></section><section><title> 
          Template metaprogramming
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/mpl/index.html">MPL</ulink> - Template metaprogramming framework of compile-time algorithms, sequences and metafunction classes, from Aleksey Gurtovoy.</simpara></listitem><listitem><simpara><ulink url="../../libs/static_assert/index.html">Static Assert</ulink> - Static assertions (compile time assertions), from John Maddock.</simpara></listitem><listitem><simpara><ulink url="../../libs/type_traits/index.html">Type Traits</ulink> - Templates for fundamental properties of types, from John Maddock, Steve Cleary, and others .</simpara></listitem></itemizedlist></section><section><title> 
          Preprocessor metaprogramming
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/preprocessor/index.html">Preprocessor</ulink> - Preprocessor metaprogramming tools including repetition and recursion, from Vesa Karvonen and Paul Mensonides.</simpara></listitem></itemizedlist></section><section><title> 
          Concurrent programming
        </title><itemizedlist spacing="compact"><listitem><simpara><link linkend="threads">Threads</link> - Portable C++ multi-threading, from William Kempf.</simpara></listitem></itemizedlist></section><section><title>
          Math and numerics
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/integer/index.html">Integer</ulink> - Headers to ease dealing with integral types, from various authors.</simpara></listitem><listitem><simpara><ulink url="../../libs/numeric/interval/doc/index.html">Interval</ulink> - Extends the usual arithmetic functions to mathematical intervals, from Guillaume Melquiond, Herv&#xE9; Br&#xF6;nnimann, and Sylvain Pion.</simpara></listitem><listitem><simpara><ulink url="../../libs/math/index.html">Math</ulink> - Several contributions in the domain of mathematics, from various authors.</simpara></listitem><listitem><simpara><ulink url="../../libs/math/doc/common_factor.html">Math/Common Factor</ulink> - Greatest common divisor and least common multiple, from Daryle Walker.</simpara></listitem><listitem><simpara><ulink url="../../libs/math/octonion/index.html">Math/Octonion</ulink> - Octonions, from Hubert Holin.</simpara></listitem><listitem><simpara><ulink url="../../libs/math/quaternion/index.html">Math/Quaternion</ulink> - Quaternions, from Hubert Holin.</simpara></listitem><listitem><simpara><ulink url="../../libs/math/special_functions/index.html">Math/Special Functions</ulink> - Mathematical special functions such as atanh, sinc, and sinhc, from Hubert Holin.</simpara></listitem><listitem><simpara><ulink url="../../libs/multi_array/index.html">Multi Array</ulink> - Multidimensional containers and adaptors for arrays of contiguous data, from Ron Garcia.</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/index.html">Operators</ulink> - Templates ease arithmetic classes and iterators, from Dave Abrahams and Jeremy Siek.</simpara></listitem><listitem><simpara><ulink url="../../libs/random/index.html">Random</ulink> - A complete system for random number generation, from Jens Maurer.</simpara></listitem><listitem><simpara><ulink url="../../libs/rational/index.html">Rational</ulink> - A rational number class, from Paul Moore.</simpara></listitem><listitem><simpara><ulink url="../../libs/numeric/ublas/index.html">uBLAS</ulink> - Basic linear algebra for dense, packed and sparse matrices, from Joerg Walter and Mathias Koch.</simpara></listitem></itemizedlist></section><section><title>
          Correctness and testing
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/concept_check/index.html">Concept Check</ulink> - Tools for generic programming, from Jeremy Siek.</simpara></listitem><listitem><simpara><ulink url="../../libs/static_assert/index.html">Static Assert</ulink> - Static assertions (compile time assertions), from John Maddock.</simpara></listitem><listitem><simpara><ulink url="../../libs/test/index.html">Test</ulink> - Support for simple program testing, full unit testing, and for program execution monitoring, from Gennadiy Rozental.</simpara></listitem></itemizedlist></section><section><title>
          Data structures
        </title><itemizedlist spacing="compact"><listitem><simpara><link linkend="any">Any</link> - 
      Safe, generic container for single values of different value types
    , from Kevlin Henney.</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/compressed_pair.htm">Compressed Pair</ulink> - Empty member optimization, from John Maddock and Howard Hinnant.</simpara></listitem><listitem><simpara><ulink url="../../libs/optional/index.html">Optional</ulink> - Discriminated-union wrapper for optional values, from Fernando Cacciola.</simpara></listitem><listitem><simpara><link linkend="program_options">Program_options</link> - 
      Facilities to obtain configuration data from command line, config files
      and other sources, from Vladimir Prus.</simpara></listitem><listitem><simpara><ulink url="../../libs/tuple/index.html">Tuple</ulink> - Ease definition of functions returning multiple values, and more, from Jaakko J&#xE4;rvi.</simpara></listitem><listitem><simpara><link linkend="variant">Variant</link> - Safe, generic, stack-based discriminated union container, from Eric Friedman and Itay Maman.</simpara></listitem></itemizedlist></section><section><title>
          Input/Output
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/format/index.html">Format</ulink> - Type-safe 'printf-like' format operations, from Samuel Krempp.</simpara></listitem><listitem><simpara><ulink url="../../libs/io/index.html">I/O State Savers</ulink> - Save I/O state to prevent jumbled data, from Daryle Walker.</simpara></listitem><listitem><simpara><ulink url="../../libs/serialization/index.html">Serialization</ulink> - Serialization of C++ objects for persistence and marshalling, from Robert Ramey.</simpara></listitem></itemizedlist></section><section><title>
          Inter-language support
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/python/index.html">Python</ulink> - Reflects C++ classes and functions into <ulink url="http://www.python.org">Python</ulink>, from Dave Abrahams.</simpara></listitem></itemizedlist></section><section><title>
          Memory
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/pool/index.html">Pool</ulink> - Memory pool management, from Steve Cleary.</simpara></listitem><listitem><simpara><ulink url="../../libs/smart_ptr/index.html">Smart Pointer</ulink> - Five smart pointer class templates, from Greg Colvin, Beman Dawes, Peter Dimov, and Darin Adler.</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/index.html">Utility</ulink> - Class noncopyable  plus checked_delete, checked_array_delete, next,  prior  function templates, plus base-from-member idiom, from Dave Abrahams and others .</simpara></listitem></itemizedlist></section><section><title>
          Parsing
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/spirit/index.html">Spirit</ulink> - LL parser framework represents parsers directly as EBNF grammars in inlined C++, from Joel de Guzman and team .</simpara></listitem></itemizedlist></section><section><title> 
          Miscellaneous
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/crc/index.html">CRC</ulink> - Cyclic Redundancy Code, from Daryle Walker.</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/compressed_pair.htm">Compressed Pair</ulink> - Empty member optimization, from John Maddock and Howard Hinnant.</simpara></listitem><listitem><simpara><ulink url="../../libs/conversion/index.html">Conversion</ulink> - Numeric, polymorphic, and lexical casts, from Dave Abrahams and Kevlin Henney.</simpara></listitem><listitem><simpara><link linkend="date_time">Date Time</link> - A set of facilities to ease programming with dates and times.
  , from Jeff Garland.</simpara></listitem><listitem><simpara><ulink url="../../libs/filesystem/index.html">Filesystem</ulink> - Portable paths, iteration over directories, and other useful filesystem operations, from Beman Dawes.</simpara></listitem><listitem><simpara><ulink url="../../libs/optional/index.html">Optional</ulink> - Discriminated-union wrapper for optional values, from Fernando Cacciola.</simpara></listitem><listitem><simpara><ulink url="../../libs/timer/index.html">Timer</ulink> - Event timer, progress timer, and progress display classes, from Beman Dawes.</simpara></listitem><listitem><simpara><link linkend="tribool">Tribool</link> - Three-state boolean type, from Douglas Gregor.</simpara></listitem><listitem><simpara><ulink url="../../libs/utility/index.html">Utility</ulink> - Class noncopyable  plus checked_delete, checked_array_delete, next,  prior  function templates, plus base-from-member idiom, from Dave Abrahams and others .</simpara></listitem></itemizedlist></section><section><title> 
          Broken compiler workarounds
        </title><itemizedlist spacing="compact"><listitem><simpara><ulink url="../../libs/compatibility/index.html">Compatibility</ulink> - Help for non-conforming standard libraries, from Ralf Grosse-Kunstleve and Jens Maurer.</simpara></listitem><listitem><simpara><ulink url="../../libs/config/index.html">Config</ulink> - Helps boost library developers adapt to compiler idiosyncrasies; not intended for library users, from John Maddock, Beman Dawes, and Vesa Karvonen.</simpara></listitem></itemizedlist></section></section><chapter xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="any" rev:last-revision="$Date: 2003/03/15 23:12:35 $"><chapterinfo><author><firstname>Kevlin</firstname><surname>Henney</surname></author><copyright><year>2001</year><holder>Kevlin Henney</holder></copyright></chapterinfo><title>Boost.Any</title><section><title>Introduction</title><para>There are times when a generic (in the sense of
    <emphasis>general</emphasis> as opposed to
    <emphasis>template-based programming</emphasis>) type is needed:
    variables that are truly variable, accommodating values of many
    other more specific types rather than C++'s normal strict and
    static types. We can distinguish three basic kinds of generic
    type:</para><itemizedlist><listitem><para>Converting types that can hold one of a number of
        possible value types, e.g. <computeroutput>int</computeroutput> and
        <computeroutput>string</computeroutput>, and freely convert between them, for
        instance interpreting <computeroutput>5</computeroutput> as <computeroutput>"5"</computeroutput> or
        vice-versa.  Such types are common in scripting and other
        interpreted
        languages. 
        <computeroutput>boost::lexical_cast</computeroutput>
        supports such conversion functionality.</para></listitem><listitem><para>
        Discriminated types that contain values of different types but
        do not attempt conversion between them, i.e. <computeroutput>5</computeroutput> is
        held strictly as an <computeroutput>int</computeroutput> and is not implicitly
        convertible either to <computeroutput>"5"</computeroutput> or to
        <computeroutput>5.0</computeroutput>. Their indifference to interpretation but
        awareness of type effectively makes them safe, generic
        containers of single values, with no scope for surprises from
        ambiguous conversions.</para></listitem><listitem><para>
        Indiscriminate types that can refer to anything but are
        oblivious to the actual underlying type, entrusting all forms
        of access and interpretation to the programmer. This niche is
        dominated by <computeroutput>void *</computeroutput>, which offers plenty of scope
        for surprising, undefined behavior.</para></listitem></itemizedlist><para>The <computeroutput><link linkend="boost.any">boost::any</link></computeroutput> class
    (based on the class of the same name described in <ulink url="http://www.two-sdg.demon.co.uk/curbralan/papers/ValuedConversions.pdf">"Valued
    Conversions"</ulink> by Kevlin Henney, <emphasis>C++
    Report</emphasis> 12(7), July/August 2000) is a variant value type
    based on the second category. It supports copying of any value
    type and safe checked extraction of that value strictly against
    its type. A similar design, offering more appropriate operators,
    can be used for a generalized function adaptor,
    <computeroutput>any_function</computeroutput>, a generalized iterator adaptor,
    <computeroutput>any_iterator</computeroutput>, and other object types that need
    uniform runtime treatment but support only compile-time template
    parameter conformance.</para></section><section><title>Examples</title><para>The following code demonstrates the syntax for using
    implicit conversions to and copying of any objects:</para><programlisting>
#include &lt;list&gt;
#include &lt;boost/any.hpp&gt;

using <link linkend="any_cast">boost::any_cast</link>;
typedef std::list&lt;<link linkend="boost.any">boost::any</link>&gt; many;

void append_int(many &amp; values, int value)
{
    <link linkend="boost.any">boost::any</link> to_append = value;
    values.push_back(to_append);
}

void append_string(many &amp; values, const std::string &amp; value)
{
    values.push_back(value);
}

void append_char_ptr(many &amp; values, const char * value)
{
    values.push_back(value);
}

void append_any(many &amp; values, const <link linkend="boost.any">boost::any</link> &amp; value)
{
    values.push_back(value);
}

void append_nothing(many &amp; values)
{
    values.push_back(<link linkend="boost.any">boost::any</link>());
}
</programlisting><para>The following predicates follow on from the previous
    definitions and demonstrate the use of queries on any
    objects:</para><programlisting>
bool is_empty(const <link linkend="boost.any">boost::any</link> &amp; operand)
{
    return operand.<link linkend="id141181-bb">empty</link>();
}

bool is_int(const <link linkend="boost.any">boost::any</link> &amp; operand)
{
    return operand.<link linkend="id141206-bb">type</link>() == typeid(int);
}

bool is_char_ptr(const <link linkend="boost.any">boost::any</link> &amp; operand)
{
    try
    {
        <link linkend="any_cast">any_cast</link>&lt;const char *&gt;(operand);
        return true;
    }
    catch(const <link linkend="bad_any_cast">boost::bad_any_cast</link> &amp;)
    {
        return false;
    }
}

bool is_string(const <link linkend="boost.any">boost::any</link> &amp; operand)
{
    return <link linkend="any_cast">any_cast</link>&lt;std::string&gt;(&amp;operand);
}

void count_all(many &amp; values, std::ostream &amp; out)
{
    out &lt;&lt; "#empty == "
        &lt;&lt; std::count_if(values.begin(), values.end(), is_empty) &lt;&lt; std::endl;
    out &lt;&lt; "#int == "
        &lt;&lt; std::count_if(values.begin(), values.end(), is_int) &lt;&lt; std::endl;
    out &lt;&lt; "#const char * == "
        &lt;&lt; std::count_if(values.begin(), values.end(), is_char_ptr) &lt;&lt; std::endl;
    out &lt;&lt; "#string == "
        &lt;&lt; std::count_if(values.begin(), values.end(), is_string) &lt;&lt; std::endl;
}
</programlisting><para>The following type, patterned after the OMG's Property Service, defines name-value pairs for arbitrary value types:</para><programlisting>
struct property
{
    property();
    property(const std::string &amp;, const <link linkend="boost.any">boost::any</link> &amp;);

    std::string name;
    <link linkend="boost.any">boost::any</link> value;
};

typedef std::list&lt;property&gt; properties;
</programlisting><para>The following base class demonstrates one approach to
    runtime polymorphism based callbacks that also require arbitrary
    argument types. The absence of virtual member templates requires
    that different solutions have different trade-offs in terms of
    efficiency, safety, and generality. Using a checked variant type
    offers one approach:</para><programlisting>
class consumer
{
public:
    virtual void notify(const <link linkend="boost.any">any</link> &amp;) = 0;
    ...
};
</programlisting></section><section id="any.reference"><title>Reference</title><section id="any.ValueType"><title><emphasis>ValueType</emphasis> requirements</title><para>Values are strongly informational objects for which
      identity is not significant, i.e. the focus is principally on
      their state content and any behavior organized around
      that. Another distinguishing feature of values is their
      granularity: normally fine-grained objects representing simple
      concepts in the system such as quantities.</para><para>As the emphasis of a value lies in its state not its
      identity, values can be copied and typically assigned one to
      another, requiring the explicit or implicit definition of a
      public copy constructor and public assignment operator. Values
      typically live within other scopes, i.e. within objects or
      blocks, rather than on the heap. Values are therefore normally
      passed around and manipulated directly as variables or through
      references, but not as pointers that emphasize identity and
      indirection.</para><para>The specific requirements on value types to be used in an
      <computeroutput><link linkend="boost.any">any</link></computeroutput>
      are:</para><itemizedlist spacing="compact"><listitem><simpara>A <emphasis>ValueType</emphasis> is
          <emphasis>CopyConstructible</emphasis> [20.1.3].</simpara></listitem><listitem><simpara>A <emphasis>ValueType</emphasis> is
        optionally <emphasis>Assignable</emphasis> [23.1]. The strong
        exception-safety guarantee is required for all forms of
        assignment.</simpara></listitem><listitem><simpara>The destructor for a
        <emphasis>ValueType</emphasis> upholds the no-throw
        exception-safety guarantee.</simpara></listitem></itemizedlist></section><section id="header.boost.any.hpp"><title>Header &lt;<ulink url="../../boost/any.hpp">boost/any.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="bad_any_cast">bad_any_cast</link>;
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="boost.any">any</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ValueType&gt; <type>ValueType</type> <link linkend="any_cast">any_cast</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.any">any</link> &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ValueType&gt; <type><emphasis role="bold">const</emphasis> ValueType *</type> <link linkend="any_cast">any_cast</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.any">any</link> *);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ValueType&gt; <type>ValueType *</type> <link linkend="any_cast">any_cast</link>(<link linkend="boost.any">any</link> *);
}</synopsis><refentry id="bad_any_cast"><refmeta><refentrytitle>Class bad_any_cast</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::bad_any_cast</refname><refpurpose>The exception thrown in the event of a failed
          <computeroutput><link linkend="any_cast">any_cast</link></computeroutput> of an
          <computeroutput><link linkend="boost.any">any</link></computeroutput> value.</refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> bad_any_cast : <emphasis role="bold">public</emphasis> std::bad_cast {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis role="bold">virtual</emphasis> <type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <link linkend="id141415-bb">what</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para><literallayout class="monospaced"><emphasis role="bold">virtual</emphasis> <type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <anchor id="id141415-bb"/>what() <emphasis role="bold">const</emphasis>;</literallayout></para></refsect1></refentry><refentry id="boost.any"><refmeta><refentrytitle>Class any</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::any</refname><refpurpose>A class whose instances can hold instances of any
          type that satisfies <link linkend="any.ValueType">ValueType</link>
          requirements.</refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> any {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="boost.anyconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id141439-bb">any</link>();
&#xA0;&#xA0;<link linkend="id141452-bb">any</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.any">any</link> &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ValueType&gt; <link linkend="id140965-bb">any</link>(<emphasis role="bold">const</emphasis> ValueType &amp;);
&#xA0;&#xA0;<type><link linkend="boost.any">any</link> &amp;</type> <link linkend="id141022-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.any">any</link> &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ValueType&gt; <type><link linkend="boost.any">any</link> &amp;</type> <link linkend="id141077-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> ValueType &amp;);
&#xA0;&#xA0;<link linkend="id141007-bb">~any</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id141128-bb">modifiers</link></emphasis>
&#xA0;&#xA0;<type><link linkend="boost.any">any</link> &amp;</type> <link linkend="id141132-bb">swap</link>(<link linkend="boost.any">any</link> &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id141177-bb">queries</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id141181-bb">empty</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> std::type_info &amp;</type> <link linkend="id141206-bb">type</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="boost.anyconstruct-copy-destruct"/><computeroutput>any</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id141439-bb"/>any();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><simpara><computeroutput>this-&gt;<link linkend="id141181-bb">empty</link>()</computeroutput></simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id141452-bb"/>any(<emphasis role="bold">const</emphasis> <link linkend="boost.any">any</link> &amp; other);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara> Copy constructor that copies content of
            <computeroutput>other</computeroutput> into new instance, so that any content
            is equivalent in both type and value to the content of
            <computeroutput>other</computeroutput>, or empty if <computeroutput>other</computeroutput> is
            empty. </simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>May fail with a
            <computeroutput>std::bad_alloc</computeroutput>
            exception or any exceptions arising from the copy
            constructor of the contained type.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ValueType&gt; <anchor id="id140965-bb"/>any(<emphasis role="bold">const</emphasis> ValueType &amp; value);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Makes a copy of <computeroutput>value</computeroutput>, so
            that the initial content of the new instance is equivalent
            in both type and value to
            <computeroutput>value</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara><computeroutput>std::bad_alloc</computeroutput>
            or any exceptions arising from the copy constructor of the
            contained type.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="boost.any">any</link> &amp;</type> <anchor id="id141022-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> <link linkend="boost.any">any</link> &amp; rhs);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Copies content of <computeroutput>rhs</computeroutput> into
            current instance, discarding previous content, so that the
            new content is equivalent in both type and value to the
            content of <computeroutput>rhs</computeroutput>, or empty if
            <computeroutput>rhs.<link linkend="id141181-bb">empty</link>()</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara><computeroutput>std::bad_alloc</computeroutput>
            or any exceptions arising from the copy constructor of the
            contained type. Assignment satisfies the strong guarantee
            of exception safety.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ValueType&gt; <type><link linkend="boost.any">any</link> &amp;</type> <anchor id="id141077-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> ValueType &amp; rhs);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Makes a copy of <computeroutput>rhs</computeroutput>,
            discarding previous content, so that the new content of is
            equivalent in both type and value to
            <computeroutput>rhs</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara><computeroutput>std::bad_alloc</computeroutput>
            or any exceptions arising from the copy constructor of the
            contained type. Assignment satisfies the strong guarantee
            of exception safety.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id141007-bb"/>~any();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Releases any and all resources used in
            management of instance.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Nothing.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id141128-bb"/><computeroutput>any</computeroutput> modifiers</title><orderedlist><listitem><para><literallayout class="monospaced"><type><link linkend="boost.any">any</link> &amp;</type> <anchor id="id141132-bb"/>swap(<link linkend="boost.any">any</link> &amp; rhs);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Exchange of the contents of
              <computeroutput>*this</computeroutput> and
              <computeroutput>rhs</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara><computeroutput>*this</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Nothing.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id141177-bb"/><computeroutput>any</computeroutput> queries</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id141181-bb"/>empty() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>true</computeroutput> if instance is
              empty, otherwise <computeroutput>false</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> std::type_info &amp;</type> <anchor id="id141206-bb"/>type() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>the <computeroutput>typeid</computeroutput> of the
              contained value if instance is non-empty, otherwise
              <computeroutput>typeid(void)</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Notes</term><listitem><simpara>Useful for querying against types known
              either at compile time or only at
              runtime.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="any_cast"><refmeta><refentrytitle>Function any_cast</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::any_cast</refname><refpurpose><simpara>Custom keyword cast for extracting a value
          of a given type from an
          <computeroutput><link linkend="boost.any">any</link></computeroutput>.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ValueType&gt; <type>ValueType</type> any_cast(<emphasis role="bold">const</emphasis> <link linkend="boost.any">any</link> &amp; operand);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ValueType&gt; <type><emphasis role="bold">const</emphasis> ValueType *</type> any_cast(<emphasis role="bold">const</emphasis> <link linkend="boost.any">any</link> * operand);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ValueType&gt; <type>ValueType *</type> any_cast(<link linkend="boost.any">any</link> * operand);</synopsis></refsynopsisdiv><refsect1><title>Description</title><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara> If passed a pointer, it returns a
          similarly qualified pointer to the value content if
          successful, otherwise null is returned. If passed a value or
          reference, it returns a copy of the value content if
          successful.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Overloads taking an
          <computeroutput><link linkend="boost.any">any</link></computeroutput> pointer do not
          throw; the overload taking an
          <computeroutput><link linkend="boost.any">any</link></computeroutput> value or reference
          throws <computeroutput><link linkend="bad_any_cast">bad_any_cast</link></computeroutput> if
          unsuccessful.</simpara></listitem></varlistentry><varlistentry><term>Rationale</term><listitem><simpara>The value/reference version returns a
          copy because the C++ keyword casts return
          copies.</simpara></listitem></varlistentry></variablelist></refsect1></refentry></section></section><section><title>Acknowledgements</title><para>Doug Gregor ported the documentation to the BoostBook format.</para></section></chapter><chapter xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="array" rev:last-revision="$Date: 2004/01/30 03:51:06 $"><chapterinfo><author><firstname>Nicolai</firstname><surname>Josuttis</surname></author><copyright><year>2001</year><year>2002</year><year>2003</year><year>2004</year><holder>Nicolai M. Josuttis</holder></copyright><legalnotice><para>Permission to copy, use, modify, sell and distribute this
      software is granted provided this copyright notice appears in
      all copies. This software is provided "as is" without express or
      implied warranty, and with no claim as to its suitability for
      any purpose.</para></legalnotice></chapterinfo><title>Boost.Array</title><section id="array.intro"><title>Introduction</title><para>The C++ Standard Template Library STL as part of the C++
    Standard Library provides a framework for processing algorithms on
    different kind of containers. However, ordinary arrays don't
    provide the interface of STL containers (although, they provide
    the iterator interface of STL containers).</para><para>As replacement for ordinary arrays, the STL provides class
    <computeroutput>std::vector</computeroutput>.  However,
    <computeroutput>std::vector&lt;&gt;</computeroutput> provides
    the semantics of dynamic arrays. Thus, it manages data to be able
    to change the number of elements. This results in some overhead in
    case only arrays with static size are needed.</para><para>In his book, <emphasis>Generic Programming and the
    STL</emphasis>, Matthew H. Austern introduces a useful wrapper
    class for ordinary arrays with static size, called
    <computeroutput>block</computeroutput>.  It is safer and has no worse performance than
    ordinary arrays. In <emphasis>The C++ Programming
    Language</emphasis>, 3rd edition, Bjarne Stroustrup introduces a
    similar class, called <computeroutput>c_array</computeroutput>, which I (<ulink url="http://www.josuttis.com">Nicolai Josuttis</ulink>) present
    slightly modified in my book <emphasis>The C++ Standard Library -
    A Tutorial and Reference</emphasis>, called
    <computeroutput>carray</computeroutput>. This is the essence of these approaches
    spiced with many feedback from <ulink url="http://www.boost.org">boost</ulink>.</para><para>After considering different names, we decided to name this
    class simply <computeroutput><link linkend="boost.array">array</link></computeroutput>.</para><para>Note that this class is suggested to be part of the next
    Technical Report, which will extend the C++ Standard (see
    <ulink>http://std.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1548.htm</ulink>).</para><para>Class <computeroutput><link linkend="boost.array">array</link></computeroutput> fulfills most
    but not all of the requirements of "reversible containers" (see
    Section 23.1, [lib.container.requirements] of the C++
    Standard). The reasons array is not an reversible STL container is
    because:
      <itemizedlist spacing="compact"><listitem><simpara>No constructors are provided.</simpara></listitem><listitem><simpara>Elements may have an undetermined initial value (see <xref linkend="array.rationale"/>).</simpara></listitem><listitem><simpara><link linkend="id227567">swap</link>() has no constant complexity.</simpara></listitem><listitem><simpara><link linkend="id229934-bb">size</link>() is always constant, based on the second template argument of the type.</simpara></listitem><listitem><simpara>The container provides no allocator support.</simpara></listitem></itemizedlist></para><para>It doesn't fulfill the requirements of a "sequence" (see Section 23.1.1, [lib.sequence.reqmts] of the C++ Standard), except that:
      <itemizedlist spacing="compact"><listitem><simpara><link linkend="id227365-bb">front</link>() and <link linkend="id227401-bb">back</link>() are provided.</simpara></listitem><listitem><simpara><link linkend="id227255-bb">operator[]</link> and <link linkend="id227310-bb">at</link>() are provided.</simpara></listitem></itemizedlist></para></section><section id="array.reference"><title>Reference</title><section id="header.boost.array.hpp"><title>Header &lt;<ulink url="../../boost/array.hpp">boost/array.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; <emphasis role="bold">class</emphasis> <link linkend="boost.array">array</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; <type><emphasis role="bold">void</emphasis></type> <link linkend="id227567">swap</link>(<link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id287139"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id287205"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id287261"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id287331"><emphasis role="bold">operator</emphasis>&gt;</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id287385"><emphasis role="bold">operator</emphasis>&lt;=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id287439"><emphasis role="bold">operator</emphasis>&gt;=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);
}</synopsis><refentry id="boost.array"><refmeta><refentrytitle>Class template array</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::array</refname><refpurpose><para>STL compliant container wrapper for arrays of constant size</para></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
<emphasis role="bold">class</emphasis> array {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; value_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T*&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; iterator;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis role="bold">const</emphasis> T*&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; const_iterator;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::reverse_iterator&lt;iterator&gt;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; reverse_iterator;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T&amp;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; reference;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis role="bold">const</emphasis> T&amp;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; const_reference;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::size_t&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; size_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::ptrdiff_t&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; difference_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// static constants</emphasis>
&#xA0;&#xA0;<emphasis role="bold">static</emphasis> <emphasis role="bold">const</emphasis> size_type static_size = N;

&#xA0;&#xA0;<emphasis>// <link linkend="boost.arrayconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U&gt; array&amp; <link linkend="id229768-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;U, N&gt;&amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id229808-bb">iterator support</link></emphasis>
&#xA0;&#xA0;<type>iterator</type> <link linkend="id229815-bb">begin</link>();
&#xA0;&#xA0;<type>const_iterator</type> <link linkend="id229822-bb">begin</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>iterator</type> <link linkend="id229845-bb">end</link>();
&#xA0;&#xA0;<type>const_iterator</type> <link linkend="id229852-bb">end</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id229873-bb">reverse iterator support</link></emphasis>
&#xA0;&#xA0;<type>reverse_iterator</type> <link linkend="id229880-bb">rbegin</link>();
&#xA0;&#xA0;<type>const_reverse_iterator</type> <link linkend="id229887-bb">rbegin</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>reverse_iterator</type> <link linkend="id229906-bb">rend</link>();
&#xA0;&#xA0;<type>const_reverse_iterator</type> <link linkend="id229913-bb">rend</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id229930-bb">capacity</link></emphasis>
&#xA0;&#xA0;<type>size_type</type> <link linkend="id229934-bb">size</link>();
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id227212-bb">empty</link>();
&#xA0;&#xA0;<type>size_type</type> <link linkend="id227231-bb">max_size</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id227251-bb">element access</link></emphasis>
&#xA0;&#xA0;<type>reference</type> <link linkend="id227259-bb"><emphasis role="bold">operator</emphasis>[]</link>(size_type);
&#xA0;&#xA0;<type>const_reference</type> <link linkend="id227274-bb"><emphasis role="bold">operator</emphasis>[]</link>(size_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>reference</type> <link linkend="id227314-bb">at</link>(size_type);
&#xA0;&#xA0;<type>const_reference</type> <link linkend="id227329-bb">at</link>(size_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>reference</type> <link linkend="id227369-bb">front</link>();
&#xA0;&#xA0;<type>const_reference</type> <link linkend="id227376-bb">front</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>reference</type> <link linkend="id227405-bb">back</link>();
&#xA0;&#xA0;<type>const_reference</type> <link linkend="id227412-bb">back</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> T*</type> <link linkend="id227437-bb">data</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>T*</type> <link linkend="id227458-bb">c_array</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id227478-bb">modifiers</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id227482-bb">swap</link>(<link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id227525-bb">assign</link>(<emphasis role="bold">const</emphasis> T&amp;);

&#xA0;&#xA0;T elems[N];
};

<emphasis>// <link linkend="id227563-bb">specialized algorithms</link></emphasis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; <type><emphasis role="bold">void</emphasis></type> <link linkend="id227567">swap</link>(<link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);

<emphasis>// <link linkend="id287136-bb">comparisons</link></emphasis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id287139"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id287205"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id287261"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id287331"><emphasis role="bold">operator</emphasis>&gt;</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id287385"><emphasis role="bold">operator</emphasis>&lt;=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id287439"><emphasis role="bold">operator</emphasis>&gt;=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp;);</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="boost.arrayconstruct-copy-destruct"/><computeroutput>array</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U&gt; array&amp; <anchor id="id229768-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;U, N&gt;&amp; other);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara><computeroutput>std::copy(rhs.<link linkend="id229811-bb">begin</link>(),rhs.<link linkend="id229841-bb">end</link>(), <link linkend="id229811-bb">begin</link>())</computeroutput></simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id229808-bb"/><computeroutput>array</computeroutput> iterator support</title><orderedlist><listitem><para id="id229811-bb"><literallayout class="monospaced"><type>iterator</type> <anchor id="id229815-bb"/>begin();
<type>const_iterator</type> <anchor id="id229822-bb"/>begin() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>iterator for the first element</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>will not throw</simpara></listitem></varlistentry></variablelist></listitem><listitem><para id="id229841-bb"><literallayout class="monospaced"><type>iterator</type> <anchor id="id229845-bb"/>end();
<type>const_iterator</type> <anchor id="id229852-bb"/>end() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>iterator for position after the last element</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>will not throw</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id229873-bb"/><computeroutput>array</computeroutput> reverse iterator support</title><orderedlist><listitem><para id="id229876-bb"><literallayout class="monospaced"><type>reverse_iterator</type> <anchor id="id229880-bb"/>rbegin();
<type>const_reverse_iterator</type> <anchor id="id229887-bb"/>rbegin() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>reverse iterator for the first element of reverse iteration</simpara></listitem></varlistentry></variablelist></listitem><listitem><para id="id229903-bb"><literallayout class="monospaced"><type>reverse_iterator</type> <anchor id="id229906-bb"/>rend();
<type>const_reverse_iterator</type> <anchor id="id229913-bb"/>rend() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>reverse iterator for position after the last element in reverse iteration</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id229930-bb"/><computeroutput>array</computeroutput> capacity</title><orderedlist><listitem><para><literallayout class="monospaced"><type>size_type</type> <anchor id="id229934-bb"/>size();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>N</computeroutput></simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id227212-bb"/>empty();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>N==0</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>will not throw</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>size_type</type> <anchor id="id227231-bb"/>max_size();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>N</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>will not throw</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id227251-bb"/><computeroutput>array</computeroutput> element access</title><orderedlist><listitem><para id="id227255-bb"><literallayout class="monospaced"><type>reference</type> <anchor id="id227259-bb"/><emphasis role="bold">operator</emphasis>[](size_type i);
<type>const_reference</type> <anchor id="id227274-bb"/><emphasis role="bold">operator</emphasis>[](size_type i) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara><computeroutput>i &lt; N</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara>element with index <computeroutput>i</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para id="id227310-bb"><literallayout class="monospaced"><type>reference</type> <anchor id="id227314-bb"/>at(size_type i);
<type>const_reference</type> <anchor id="id227329-bb"/>at(size_type i) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>element with index <computeroutput>i</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara><computeroutput>std::range_error</computeroutput> if <computeroutput>i &gt;= N</computeroutput></simpara></listitem></varlistentry></variablelist></listitem><listitem><para id="id227365-bb"><literallayout class="monospaced"><type>reference</type> <anchor id="id227369-bb"/>front();
<type>const_reference</type> <anchor id="id227376-bb"/>front() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara><computeroutput>N &gt; 0</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara>the first element</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>will not throw</simpara></listitem></varlistentry></variablelist></listitem><listitem><para id="id227401-bb"><literallayout class="monospaced"><type>reference</type> <anchor id="id227405-bb"/>back();
<type>const_reference</type> <anchor id="id227412-bb"/>back() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara><computeroutput>N &gt; 0</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara>the last element</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>will not throw</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> T*</type> <anchor id="id227437-bb"/>data() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>elems</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>will not throw</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>T*</type> <anchor id="id227458-bb"/>c_array();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>elems</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>will not throw</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id227478-bb"/><computeroutput>array</computeroutput> modifiers</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id227482-bb"/>swap(<link linkend="boost.array">array</link>&lt;T, N&gt;&amp; other);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara><computeroutput>std::swap_ranges(<link linkend="id229811-bb">begin</link>(), <link linkend="id229841-bb">end</link>(), other.<link linkend="id229811-bb">begin</link>())</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Complexity</term><listitem><simpara>linear in <computeroutput>N</computeroutput></simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id227525-bb"/>assign(<emphasis role="bold">const</emphasis> T&amp; value);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara><computeroutput>std::fill_n(<link linkend="id229811-bb">begin</link>(), N, value)</computeroutput></simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id227563-bb"/><computeroutput>array</computeroutput> specialized algorithms</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; <type><emphasis role="bold">void</emphasis></type> <anchor id="id227567"/>swap(<link linkend="boost.array">array</link>&lt;T, N&gt;&amp; x, <link linkend="boost.array">array</link>&lt;T, N&gt;&amp; y);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara><computeroutput>x.<link linkend="id227482-bb">swap</link>(y)</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>will not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id287136-bb"/><computeroutput>array</computeroutput> comparisons</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id287139"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp; x, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp; y);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>std::equal(x.<link linkend="id229811-bb">begin</link>(), x.<link linkend="id229841-bb">end</link>(), y.<link linkend="id229811-bb">begin</link>())</computeroutput></simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id287205"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp; x, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp; y);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>!(x == y)</computeroutput></simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id287261"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp; x, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp; y);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>std::lexicographical_compare(x.<link linkend="id229811-bb">begin</link>(), x.<link linkend="id229841-bb">end</link>(), y.<link linkend="id229811-bb">begin</link>(), y.<link linkend="id229841-bb">end</link>())</computeroutput></simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id287331"/><emphasis role="bold">operator</emphasis>&gt;(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp; x, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp; y);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>y &lt; x</computeroutput></simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id287385"/><emphasis role="bold">operator</emphasis>&lt;=(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp; x, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp; y);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>!(y &lt; x)</computeroutput></simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, std::size_t N&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id287439"/><emphasis role="bold">operator</emphasis>&gt;=(<emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp; x, <emphasis role="bold">const</emphasis> <link linkend="boost.array">array</link>&lt;T, N&gt;&amp; y);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>!(x &lt; y)</computeroutput></simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section></section><section id="array.rationale"><title>Design Rationale</title><para>There was an important design tradeoff regarding the
  constructors: We could implement array as an "aggregate" (see
  Section 8.5.1, [dcl.init.aggr], of the C++ Standard). This would
  mean:
    <itemizedlist><listitem><simpara>An array can be initialized with a
      brace-enclosing, comma-separated list of initializers for the
      elements of the container, written in increasing subscript
      order:</simpara><programlisting><link linkend="boost.array">boost::array</link>&lt;int,4&gt; a = { { 1, 2, 3 } };</programlisting><simpara>Note that if there are fewer elements in the
      initializer list, then each remaining element gets
      default-initialized (thus, it has a defined value).</simpara></listitem></itemizedlist></para><para>However, this approach has its drawbacks: <emphasis role="bold"> passing no initializer list means that the elements
  have an indetermined initial value</emphasis>, because the rule says
  that aggregates may have:
    <itemizedlist><listitem><simpara>No user-declared constructors.</simpara></listitem><listitem><simpara>No private or protected non-static data members.</simpara></listitem><listitem><simpara>No base classes.</simpara></listitem><listitem><simpara>No virtual functions.</simpara></listitem></itemizedlist></para><para>Nevertheless, The current implementation uses this approach.</para><para>Note that for standard conforming compilers it is possible to
  use fewer braces (according to 8.5.1 (11) of the Standard). That is,
  you can initialize an array as follows:</para><programlisting><link linkend="boost.array">boost::array</link>&lt;int,4&gt; a = { 1, 2, 3 };
</programlisting><para>I'd appreciate any constructive feedback. <emphasis role="bold">Please note: I don't have time to read all boost
  mails. Thus, to make sure that feedback arrives to me, please send
  me a copy of each mail regarding this class.</emphasis></para><para>The code is provided "as is" without expressed or implied
  warranty.</para></section><section id="array.more.info"><title>For more information...</title><para>To find more details about using ordinary arrays in C++ and
  the framework of the STL, see e.g.

    <literallayout>The C++ Standard Library - A Tutorial and Reference
by Nicolai M. Josuttis
Addison Wesley Longman, 1999
ISBN 0-201-37926-0</literallayout></para><para><ulink url="http://www.josuttis.com/">Home Page of Nicolai
  Josuttis</ulink></para></section><section id="array.ack"><title>Acknowledgements</title><para>Doug Gregor ported the documentation to the BoostBook format.</para></section></chapter><section id="concepts.reference"><section><title>Concepts</title><itemizedlist><listitem><link linkend="Assignable">Assignable</link></listitem><listitem><link linkend="InputIterator">InputIterator</link></listitem><listitem><link linkend="OutputIterator">OutputIterator</link></listitem><listitem><link linkend="ForwardIterator">ForwardIterator</link></listitem><listitem><link linkend="BidirectionalIterator">BidirectionalIterator</link></listitem><listitem><link linkend="RandomAccessIterator">RandomAccessIterator</link></listitem><listitem><link linkend="DefaultConstructible">DefaultConstructible</link></listitem><listitem><link linkend="CopyConstructible">CopyConstructible</link></listitem><listitem><link linkend="EqualityComparable">EqualityComparable</link></listitem><listitem><link linkend="LessThanComparable">LessThanComparable</link></listitem><listitem><link linkend="SignedInteger">SignedInteger</link></listitem></itemizedlist></section><sectioninfo><copyright><year>2001</year><year>2002</year><holder>Indiana University</holder></copyright><copyright><year>2000</year><year>2001</year><holder>University of Notre Dame du Lac</holder></copyright><copyright><year>2000</year><holder>Jeremy Siek</holder><holder>Lie-Quan Lee</holder><holder>Andrew Lumsdaine</holder></copyright><copyright><year>1996</year><year>1997</year><year>1998</year><year>1999</year><holder>Silicon Graphics Computer Systems, Inc.</holder></copyright><copyright><year>1994</year><holder>Hewlett-Packard Company</holder></copyright><legalnotice><para>This product includes software developed at the University
      of Notre Dame and the Pervasive Technology Labs at Indiana
      University. For technical information contact Andrew Lumsdaine
      at the Pervasive Technology Labs at Indiana University.  For
      administrative and license questions contact the Advanced
      Research and Technology Institute at 351 West 10th Street.
      Indianapolis, Indiana 46202, phone 317-278-4100, fax
      317-274-5902.</para><para>Some concepts based on versions from the MTL draft manual
      and Boost Graph and Property Map documentation, the SGI Standard
      Template Library documentation and the Hewlett-Packard STL,
      under the following license: 
        <blockquote>Permission to use, copy, modify, distribute and
        sell this software and its documentation for any purpose is
        hereby granted without fee, provided that the above copyright
        notice appears in all copies and that both that copyright
        notice and this permission notice appear in supporting
        documentation.  Silicon Graphics makes no representations
        about the suitability of this software for any purpose.  It is
        provided "as is" without express or implied
        warranty.</blockquote></para></legalnotice></sectioninfo><title>Concept reference</title><refentry id="Assignable"><refmeta><refentrytitle>Concept Assignable</refentrytitle><manvolnum>7</manvolnum></refmeta><refnamediv><refname>Assignable</refname></refnamediv><refsect1><title>Description</title><para>Assignable types must have copy constructors,
    <computeroutput>operator=</computeroutput> for assignment, and the <computeroutput>swap()</computeroutput>
    function defined.</para></refsect1><refsect1><title>Refinement of</title><itemizedlist><listitem><para><link linkend="CopyConstructible">CopyConstructible</link></para></listitem></itemizedlist></refsect1><refsect1><title>Notation</title><variablelist><varlistentry><term>X</term><listitem><simpara>A type playing the role of assignable-type in the <link linkend="Assignable">Assignable</link> concept.</simpara></listitem></varlistentry><varlistentry><term><varname>x</varname></term><term><varname>y</varname></term><listitem><simpara>Objects of type X</simpara></listitem></varlistentry></variablelist></refsect1><refsect1><title>Valid expressions</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Expression</entry><entry>Type</entry><entry>Semantics</entry></row></thead><tbody><row><entry><simpara>Assignment</simpara></entry><entry><simpara>x = y</simpara></entry><entry><simpara><type>X &amp;</type></simpara></entry><entry><simpara>Require <computeroutput>operator=</computeroutput></simpara></entry></row><row><entry><simpara>Swap</simpara></entry><entry><simpara>swap(x, y)</simpara></entry><entry><simpara><type>void</type></simpara></entry><entry><simpara>Require <computeroutput>swap()</computeroutput> function</simpara></entry></row></tbody></tgroup></informaltable></refsect1><refsect1><title>Models</title><itemizedlist><listitem><simplelist type="inline"><member><type>int</type></member></simplelist></listitem></itemizedlist></refsect1><refsect1><title>See also</title><itemizedlist><listitem><para><link linkend="CopyConstructible">CopyConstructible</link></para></listitem></itemizedlist></refsect1></refentry><refentry id="InputIterator"><refmeta><refentrytitle>Concept InputIterator</refentrytitle><manvolnum>7</manvolnum></refmeta><refnamediv><refname>InputIterator</refname></refnamediv><refsect1><title>Description</title><para>An input iterator is an iterator that can read through a sequence of
  values.  It is single-pass (old values of the iterator cannot be
  re-used), and read-only.</para><para>An input iterator represents a position in a sequence.  Therefore, the
  iterator can point into the sequence (returning a value when dereferenced
  and being incrementable), or be off-the-end (and not dereferenceable or
  incrementable).</para></refsect1><refsect1><title>Refinement of</title><itemizedlist><listitem><para><link linkend="Assignable">Assignable</link></para></listitem><listitem><para><link linkend="DefaultConstructible">DefaultConstructible</link></para></listitem><listitem><para><link linkend="EqualityComparable">EqualityComparable</link></para></listitem></itemizedlist></refsect1><refsect1><title>Associated types</title><itemizedlist><listitem><para><emphasis role="bold">value_type</emphasis><literallayout class="monospaced">std::iterator_traits&lt;Iter&gt;::value_type</literallayout><simpara>The value type of the iterator (not necessarily what
    <computeroutput>*i</computeroutput> returns)</simpara></para></listitem><listitem><para><emphasis role="bold">difference_type</emphasis><literallayout class="monospaced">std::iterator_traits&lt;Iter&gt;::difference_type</literallayout><simpara>The difference type of the iterator</simpara></para></listitem><listitem><para><emphasis role="bold">category</emphasis><literallayout class="monospaced">std::iterator_traits&lt;Iter&gt;::iterator_category</literallayout><simpara>The category of the iterator</simpara></para></listitem></itemizedlist></refsect1><refsect1><title>Notation</title><variablelist><varlistentry><term>Iter</term><listitem><simpara>A type playing the role of iterator-type in the <link linkend="InputIterator">InputIterator</link> concept.</simpara></listitem></varlistentry><varlistentry><term><varname>i</varname></term><term><varname>j</varname></term><listitem><simpara>Objects of type Iter</simpara></listitem></varlistentry><varlistentry><term><varname>x</varname></term><listitem><simpara>Object of type value_type</simpara></listitem></varlistentry></variablelist></refsect1><refsect1><title>Type expressions</title><variablelist><varlistentry><term>Category tag</term><listitem><para><type>category</type> must be 
                  derived from <type>std::input_iterator_tag</type>,  a model  of <link linkend="DefaultConstructible">DefaultConstructible</link>,  and  a model  of <link linkend="CopyConstructible">CopyConstructible</link>.
                </para></listitem></varlistentry><varlistentry><term>Value type copy constructibility</term><listitem><para><type>value_type</type> must be 
                   a model  of <link linkend="CopyConstructible">CopyConstructible</link>.
                </para></listitem></varlistentry><varlistentry><term>Difference type properties</term><listitem><para><type>difference_type</type> must be 
                   a model  of <link linkend="SignedInteger">SignedInteger</link>.
                </para></listitem></varlistentry></variablelist></refsect1><refsect1><title>Valid expressions</title><informaltable><tgroup cols="6"><thead><row><entry>Name</entry><entry>Expression</entry><entry>Type</entry><entry>Precondition</entry><entry>Semantics</entry><entry>Postcondition</entry></row></thead><tbody><row><entry><simpara>Dereference</simpara></entry><entry><simpara>*i</simpara></entry><entry><simpara>Convertible to <type>value_type</type></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end)</simpara></entry><entry/><entry/></row><row><entry><simpara>Preincrement</simpara></entry><entry><simpara>++i</simpara></entry><entry><simpara><type>Iter &amp;</type></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end)</simpara></entry><entry/><entry/></row><row><entry><simpara>Postincrement</simpara></entry><entry><simpara>i++</simpara></entry><entry><simpara/></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end)</simpara></entry><entry><simpara>Equivalent to <computeroutput>(void)(++i)</computeroutput></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is dereferenceable or
    off-the-end</simpara></entry></row><row><entry><simpara>Postincrement and dereference</simpara></entry><entry><simpara>*i++</simpara></entry><entry><simpara>Convertible to <type>value_type</type></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end)</simpara></entry><entry><simpara>Equivalent to <computeroutput>{value_type t = *i; ++i; return t;}</computeroutput></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is dereferenceable or
    off-the-end</simpara></entry></row></tbody></tgroup></informaltable></refsect1><refsect1><title>Complexity</title><para>
  All iterator operations must take amortized constant time.
  </para></refsect1><refsect1><title>Models</title><itemizedlist><listitem><simplelist type="inline"><member><type>std::istream_iterator</type></member></simplelist></listitem></itemizedlist></refsect1><refsect1><title>See also</title><itemizedlist><listitem><para><link linkend="DefaultConstructible">DefaultConstructible</link></para></listitem><listitem><para><link linkend="EqualityComparable">EqualityComparable</link></para></listitem><listitem><para><link linkend="ForwardIterator">ForwardIterator</link></para></listitem><listitem><para><link linkend="OutputIterator">OutputIterator</link></para></listitem></itemizedlist></refsect1></refentry><refentry id="OutputIterator"><refmeta><refentrytitle>Concept OutputIterator</refentrytitle><manvolnum>7</manvolnum></refmeta><refnamediv><refname>OutputIterator</refname></refnamediv><refsect1><title>Description</title><para>An output iterator is an iterator that can write a sequence of
  values.  It is single-pass (old values of the iterator cannot be
  re-used), and write-only.</para><para>An output iterator represents a position in a (possibly infinite)
  sequence.  Therefore, the iterator can point into the sequence (returning
  a value when dereferenced and being incrementable), or be off-the-end
  (and not dereferenceable or incrementable).</para></refsect1><refsect1><title>Associated types</title><itemizedlist><listitem><para><emphasis role="bold">value_type</emphasis><literallayout class="monospaced">std::iterator_traits&lt;Iter&gt;::value_type</literallayout><simpara>The stated value type of the iterator (should be
    <computeroutput>void</computeroutput> for an output iterator that does not model some other
    iterator concept).</simpara></para></listitem><listitem><para><emphasis role="bold">difference_type</emphasis><literallayout class="monospaced">std::iterator_traits&lt;Iter&gt;::difference_type</literallayout><simpara>The difference type of the iterator</simpara></para></listitem><listitem><para><emphasis role="bold">category</emphasis><literallayout class="monospaced">std::iterator_traits&lt;Iter&gt;::iterator_category</literallayout><simpara>The category of the iterator</simpara></para></listitem></itemizedlist></refsect1><refsect1><title>Notation</title><variablelist><varlistentry><term>Iter</term><listitem><simpara>A type playing the role of iterator-type in the <link linkend="OutputIterator">OutputIterator</link> concept.</simpara></listitem></varlistentry><varlistentry><term>ValueType</term><listitem><simpara>A type playing the role of value-type in the <link linkend="OutputIterator">OutputIterator</link> concept.</simpara></listitem></varlistentry><varlistentry><term><varname>i</varname></term><term><varname>j</varname></term><listitem><simpara>Objects of type Iter</simpara></listitem></varlistentry><varlistentry><term><varname>x</varname></term><listitem><simpara>Object of type ValueType</simpara></listitem></varlistentry></variablelist></refsect1><refsect1><title>Type expressions</title><variablelist><varlistentry><term/><listitem><para>The type <type>Iter</type> must be a model of <link linkend="Assignable">Assignable</link>.</para></listitem></varlistentry><varlistentry><term/><listitem><para>The type <type>ValueType</type> must be a model of <link linkend="Assignable">Assignable</link>.</para></listitem></varlistentry><varlistentry><term/><listitem><para>The type <type>Iter</type> must be a model of <link linkend="DefaultConstructible">DefaultConstructible</link>.</para></listitem></varlistentry><varlistentry><term/><listitem><para>The type <type>Iter</type> must be a model of
  <link linkend="EqualityComparable">EqualityComparable</link>.</para></listitem></varlistentry><varlistentry><term>Category tag</term><listitem><para><type>category</type> must be 
                  derived from <type>std::output_iterator_tag</type>,  a model  of <link linkend="DefaultConstructible">DefaultConstructible</link>,  and  a model  of <link linkend="CopyConstructible">CopyConstructible</link>.
                </para></listitem></varlistentry><varlistentry><term>Difference type properties</term><listitem><para><type>difference_type</type> must be 
                   a model  of <link linkend="SignedInteger">SignedInteger</link>.
                </para></listitem></varlistentry></variablelist></refsect1><refsect1><title>Valid expressions</title><informaltable><tgroup cols="6"><thead><row><entry>Name</entry><entry>Expression</entry><entry>Type</entry><entry>Precondition</entry><entry>Semantics</entry><entry>Postcondition</entry></row></thead><tbody><row><entry><simpara>Dereference</simpara></entry><entry><simpara>*i</simpara></entry><entry><simpara/></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end)</simpara></entry><entry/><entry/></row><row><entry><simpara>Dereference and assign</simpara></entry><entry><simpara>*i = x</simpara></entry><entry><simpara/></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end)</simpara></entry><entry/><entry><simpara><computeroutput>*i</computeroutput> may not be written to again until it has
    been incremented.</simpara></entry></row><row><entry><simpara>Preincrement</simpara></entry><entry><simpara>++i</simpara></entry><entry><simpara><type>Iter &amp;</type></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end)</simpara></entry><entry/><entry/></row><row><entry><simpara>Postincrement</simpara></entry><entry><simpara>i++</simpara></entry><entry><simpara/></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end)</simpara></entry><entry><simpara>Equivalent to <computeroutput>(void)(++i)</computeroutput></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is dereferenceable or
    off-the-end</simpara></entry></row><row><entry><simpara>Postincrement, dereference, and assign</simpara></entry><entry><simpara>*i++ = x</simpara></entry><entry><simpara/></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end)</simpara></entry><entry><simpara>Equivalent to <computeroutput>{*i = t; ++i;}</computeroutput></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is dereferenceable or
    off-the-end</simpara></entry></row></tbody></tgroup></informaltable></refsect1><refsect1><title>Complexity</title><para>
  All iterator operations must take amortized constant time.
  </para></refsect1><refsect1><title>Models</title><itemizedlist><listitem><simplelist type="inline"><member><type>std::ostream_iterator</type></member><member><type>...</type></member></simplelist></listitem><listitem><simplelist type="inline"><member><type>std::insert_iterator</type></member><member><type>...</type></member></simplelist></listitem><listitem><simplelist type="inline"><member><type>std::front_insert_iterator</type></member><member><type>...</type></member></simplelist></listitem><listitem><simplelist type="inline"><member><type>std::back_insert_iterator</type></member><member><type>...</type></member></simplelist></listitem></itemizedlist></refsect1><refsect1><title>See also</title><itemizedlist/></refsect1></refentry><refentry id="ForwardIterator"><refmeta><refentrytitle>Concept ForwardIterator</refentrytitle><manvolnum>7</manvolnum></refmeta><refnamediv><refname>ForwardIterator</refname></refnamediv><refsect1><title>Description</title><para>A forward iterator is an iterator that can read through a sequence of
  values.  It is multi-pass (old values of the iterator can be
  re-used), and can be either mutable (data pointed to by it can be
  changed) or not mutable.</para><para>An iterator represents a position in a sequence.  Therefore, the
  iterator can point into the sequence (returning a value when dereferenced
  and being incrementable), or be off-the-end (and not dereferenceable or
  incrementable).</para></refsect1><refsect1><title>Refinement of</title><itemizedlist><listitem><para><link linkend="InputIterator">InputIterator</link></para></listitem><listitem><para><link linkend="OutputIterator">OutputIterator</link></para></listitem></itemizedlist></refsect1><refsect1><title>Associated types</title><itemizedlist><listitem><para><emphasis role="bold">value_type</emphasis><literallayout class="monospaced">std::iterator_traits&lt;Iter&gt;::value_type</literallayout><simpara>The value type of the iterator</simpara></para></listitem><listitem><para><emphasis role="bold">category</emphasis><literallayout class="monospaced">std::iterator_traits&lt;Iter&gt;::iterator_category</literallayout><simpara>The category of the iterator</simpara></para></listitem></itemizedlist></refsect1><refsect1><title>Notation</title><variablelist><varlistentry><term>Iter</term><listitem><simpara>A type playing the role of iterator-type in the <link linkend="ForwardIterator">ForwardIterator</link> concept.</simpara></listitem></varlistentry><varlistentry><term><varname>i</varname></term><term><varname>j</varname></term><listitem><simpara>Objects of type Iter</simpara></listitem></varlistentry><varlistentry><term><varname>x</varname></term><listitem><simpara>Object of type value_type</simpara></listitem></varlistentry></variablelist></refsect1><refsect1><title>Type expressions</title><variablelist><varlistentry><term>Category tag</term><listitem><para><type>category</type> must be 
                  derived from <type>std::forward_iterator_tag</type>.
                </para></listitem></varlistentry></variablelist></refsect1><refsect1><title>Valid expressions</title><informaltable><tgroup cols="6"><thead><row><entry>Name</entry><entry>Expression</entry><entry>Type</entry><entry>Precondition</entry><entry>Semantics</entry><entry>Postcondition</entry></row></thead><tbody><row><entry><simpara>Dereference</simpara></entry><entry><simpara>*i</simpara></entry><entry><simpara><type>const-if-not-mutable value_type &amp;</type></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end)</simpara></entry><entry/><entry/></row><row><entry><simpara>Member access</simpara></entry><entry><simpara>i-&gt;{member-name} (return type is pointer-to-object type)</simpara></entry><entry><simpara><type>const-if-not-mutable value_type *</type></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end)</simpara></entry><entry/><entry/></row><row><entry><simpara>Preincrement</simpara></entry><entry><simpara>++i</simpara></entry><entry><simpara><type>Iter &amp;</type></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end)</simpara></entry><entry/><entry/></row><row><entry><simpara>Postincrement</simpara></entry><entry><simpara>i++</simpara></entry><entry><simpara><type>Iter</type></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end)</simpara></entry><entry><simpara>Equivalent to <computeroutput>{Iter j = i; ++i; return j;}</computeroutput></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is dereferenceable or
    off-the-end</simpara></entry></row></tbody></tgroup></informaltable></refsect1><refsect1><title>Complexity</title><para>
  All iterator operations must take amortized constant time.
  </para></refsect1><refsect1><title>Invariants</title><variablelist><varlistentry><term>Predecrement must return object</term><listitem><para><computeroutput>&amp;i = &amp;(++i)</computeroutput></para></listitem></varlistentry><varlistentry><term>Unique path through sequence</term><listitem><para><computeroutput>i == j</computeroutput> implies <computeroutput>++i == ++j</computeroutput></para></listitem></varlistentry></variablelist></refsect1><refsect1><title>Models</title><itemizedlist><listitem><simplelist type="inline"><member><type>T *</type></member></simplelist></listitem><listitem><simplelist type="inline"><member><type>std::hash_set&lt;T&gt;::iterator</type></member></simplelist></listitem></itemizedlist></refsect1><refsect1><title>See also</title><itemizedlist><listitem><para><link linkend="BidirectionalIterator">BidirectionalIterator</link></para></listitem></itemizedlist></refsect1></refentry><refentry id="BidirectionalIterator"><refmeta><refentrytitle>Concept BidirectionalIterator</refentrytitle><manvolnum>7</manvolnum></refmeta><refnamediv><refname>BidirectionalIterator</refname></refnamediv><refsect1><title>Description</title><para>A bidirectional iterator is an iterator that can read through a sequence
  of values.  It can move in either direction through the sequence, and can
  be either mutable (data pointed to by it can be changed) or not mutable.</para><para>An iterator represents a position in a sequence.  Therefore, the
  iterator can point into the sequence (returning a value when dereferenced
  and being incrementable), or be off-the-end (and not dereferenceable or
  incrementable).</para></refsect1><refsect1><title>Refinement of</title><itemizedlist><listitem><para><link linkend="ForwardIterator">ForwardIterator</link></para></listitem></itemizedlist></refsect1><refsect1><title>Associated types</title><itemizedlist><listitem><para><emphasis role="bold">value_type</emphasis><literallayout class="monospaced">std::iterator_traits&lt;Iter&gt;::value_type</literallayout><simpara>The value type of the iterator</simpara></para></listitem><listitem><para><emphasis role="bold">category</emphasis><literallayout class="monospaced">std::iterator_traits&lt;Iter&gt;::iterator_category</literallayout><simpara>The category of the iterator</simpara></para></listitem></itemizedlist></refsect1><refsect1><title>Notation</title><variablelist><varlistentry><term>Iter</term><listitem><simpara>A type playing the role of iterator-type in the <link linkend="BidirectionalIterator">BidirectionalIterator</link> concept.</simpara></listitem></varlistentry><varlistentry><term><varname>i</varname></term><term><varname>j</varname></term><listitem><simpara>Objects of type Iter</simpara></listitem></varlistentry><varlistentry><term><varname>x</varname></term><listitem><simpara>Object of type value_type</simpara></listitem></varlistentry></variablelist></refsect1><refsect1><title>Type expressions</title><variablelist><varlistentry><term>Category tag</term><listitem><para><type>category</type> must be 
                  derived from <type>std::bidirectional_iterator_tag</type>.
                </para></listitem></varlistentry></variablelist></refsect1><refsect1><title>Valid expressions</title><informaltable><tgroup cols="6"><thead><row><entry>Name</entry><entry>Expression</entry><entry>Type</entry><entry>Precondition</entry><entry>Semantics</entry><entry>Postcondition</entry></row></thead><tbody><row><entry><simpara>Predecrement</simpara></entry><entry><simpara>--i</simpara></entry><entry><simpara><type>Iter &amp;</type></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is incrementable (not
    off-the-end) and some dereferenceable iterator <computeroutput>j</computeroutput> exists
    such that <computeroutput>i == ++j</computeroutput></simpara></entry><entry/><entry/></row><row><entry><simpara>Postdecrement</simpara></entry><entry><simpara>i--</simpara></entry><entry><simpara><type>Iter</type></simpara></entry><entry><simpara>Same as for predecrement</simpara></entry><entry><simpara>Equivalent to <computeroutput>{Iter j = i; --i; return j;}</computeroutput></simpara></entry><entry><simpara><computeroutput>i</computeroutput> is dereferenceable or
    off-the-end</simpara></entry></row></tbody></tgroup></informaltable></refsect1><refsect1><title>Complexity</title><para>
  All iterator operations must take amortized constant time.
  </para></refsect1><refsect1><title>Invariants</title><variablelist><varlistentry><term>Predecrement must return object</term><listitem><para><computeroutput>&amp;i = &amp;(--i)</computeroutput></para></listitem></varlistentry><varlistentry><term>Unique path through sequence</term><listitem><para><computeroutput>i == j</computeroutput> implies <computeroutput>--i == --j</computeroutput></para></listitem></varlistentry><varlistentry><term>Increment and decrement are inverses</term><listitem><para><computeroutput>++i; --i;</computeroutput> and <computeroutput>--i; ++i;</computeroutput> must end up with the
  value of <computeroutput>i</computeroutput> unmodified, if <computeroutput>i</computeroutput> both of the
  operations in the pair are valid.
  </para></listitem></varlistentry></variablelist></refsect1><refsect1><title>Models</title><itemizedlist><listitem><simplelist type="inline"><member><type>T *</type></member></simplelist></listitem><listitem><simplelist type="inline"><member><type>std::list&lt;T&gt;::iterator</type></member></simplelist></listitem></itemizedlist></refsect1><refsect1><title>See also</title><itemizedlist><listitem><para><link linkend="RandomAccessIterator">RandomAccessIterator</link></para></listitem></itemizedlist></refsect1></refentry><refentry id="RandomAccessIterator"><refmeta><refentrytitle>Concept RandomAccessIterator</refentrytitle><manvolnum>7</manvolnum></refmeta><refnamediv><refname>RandomAccessIterator</refname></refnamediv><refsect1><title>Description</title><para>A random access iterator is an iterator that can read through
  a sequence of values.  It can move in either direction through the
  sequence (by any amount in constant time), and can be either mutable
  (data pointed to by it can be changed) or not mutable.</para><para>An iterator represents a position in a sequence.  Therefore,
  the iterator can point into the sequence (returning a value when
  dereferenced and being incrementable), or be off-the-end (and not
  dereferenceable or incrementable).</para></refsect1><refsect1><title>Refinement of</title><itemizedlist><listitem><para><link linkend="BidirectionalIterator">BidirectionalIterator</link></para></listitem><listitem><para><link linkend="LessThanComparable">LessThanComparable</link></para></listitem></itemizedlist></refsect1><refsect1><title>Associated types</title><itemizedlist><listitem><para><emphasis role="bold">value_type</emphasis><literallayout class="monospaced">std::iterator_traits&lt;Iter&gt;::value_type</literallayout><simpara>The value type of the iterator</simpara></para></listitem><listitem><para><emphasis role="bold">category</emphasis><literallayout class="monospaced">std::iterator_traits&lt;Iter&gt;::iterator_category</literallayout><simpara>The category of the iterator</simpara></para></listitem><listitem><para><emphasis role="bold">difference_type</emphasis><literallayout class="monospaced">std::iterator_traits&lt;Iter&gt;::difference_type</literallayout><simpara>The difference type of the iterator (measure of the number
    of steps between two iterators)</simpara></para></listitem></itemizedlist></refsect1><refsect1><title>Notation</title><variablelist><varlistentry><term>Iter</term><listitem><simpara>A type playing the role of iterator-type in the <link linkend="RandomAccessIterator">RandomAccessIterator</link> concept.</simpara></listitem></varlistentry><varlistentry><term><varname>i</varname></term><term><varname>j</varname></term><listitem><simpara>Objects of type Iter</simpara></listitem></varlistentry><varlistentry><term><varname>x</varname></term><listitem><simpara>Object of type value_type</simpara></listitem></varlistentry><varlistentry><term><varname>n</varname></term><listitem><simpara>Object of type difference_type</simpara></listitem></varlistentry><varlistentry><term><varname>int_off</varname></term><listitem><simpara>Object of type int</simpara></listitem></varlistentry></variablelist></refsect1><refsect1><title>Type expressions</title><variablelist><varlistentry><term>Category tag</term><listitem><para><type>category</type> must be 
                  derived from <type>std::random_access_iterator_tag</type>.
                </para></listitem></varlistentry></variablelist></refsect1><refsect1><title>Valid expressions</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Expression</entry><entry>Type</entry><entry>Semantics</entry></row></thead><tbody><row><entry><simpara>Motion</simpara></entry><entry><simpara>i += n</simpara></entry><entry><simpara><type>Iter &amp;</type></simpara></entry><entry><simpara>Equivalent to applying <computeroutput>i++</computeroutput><computeroutput>n</computeroutput> times
    if <computeroutput>n</computeroutput> is positive, applying <computeroutput>i--</computeroutput><computeroutput>-n</computeroutput> times if <computeroutput>n</computeroutput> is negative, and to a null
    operation if <computeroutput>n</computeroutput> is zero.</simpara></entry></row><row><entry><simpara>Motion (with integer offset)</simpara></entry><entry><simpara>i += int_off</simpara></entry><entry><simpara><type>Iter &amp;</type></simpara></entry><entry><simpara>Equivalent to applying <computeroutput>i++</computeroutput><computeroutput>n</computeroutput> times
    if <computeroutput>n</computeroutput> is positive, applying <computeroutput>i--</computeroutput><computeroutput>-n</computeroutput> times if <computeroutput>n</computeroutput> is negative, and to a null
    operation if <computeroutput>n</computeroutput> is zero.</simpara></entry></row><row><entry><simpara>Subtractive motion</simpara></entry><entry><simpara>i -= n</simpara></entry><entry><simpara><type>Iter &amp;</type></simpara></entry><entry><simpara>Equivalent to <computeroutput>i+=(-n)</computeroutput></simpara></entry></row><row><entry><simpara>Subtractive motion (with integer offset)</simpara></entry><entry><simpara>i -= int_off</simpara></entry><entry><simpara><type>Iter &amp;</type></simpara></entry><entry><simpara>Equivalent to <computeroutput>i+=(-n)</computeroutput></simpara></entry></row><row><entry><simpara>Addition</simpara></entry><entry><simpara>i + n</simpara></entry><entry><simpara><type>Iter</type></simpara></entry><entry><simpara>Equivalent to <computeroutput>{Iter j = i; j += n; return j;}</computeroutput></simpara></entry></row><row><entry><simpara>Addition with integer</simpara></entry><entry><simpara>i + int_off</simpara></entry><entry><simpara><type>Iter</type></simpara></entry><entry><simpara>Equivalent to <computeroutput>{Iter j = i; j += n; return j;}</computeroutput></simpara></entry></row><row><entry><simpara>Addition (count first)</simpara></entry><entry><simpara>n + i</simpara></entry><entry><simpara><type>Iter</type></simpara></entry><entry><simpara>Equivalent to <computeroutput>i + n</computeroutput></simpara></entry></row><row><entry><simpara>Addition with integer (count first)</simpara></entry><entry><simpara>int_off + i</simpara></entry><entry><simpara><type>Iter</type></simpara></entry><entry><simpara>Equivalent to <computeroutput>i + n</computeroutput></simpara></entry></row><row><entry><simpara>Subtraction</simpara></entry><entry><simpara>i - n</simpara></entry><entry><simpara><type>Iter</type></simpara></entry><entry><simpara>Equivalent to <computeroutput>i + (-n)</computeroutput></simpara></entry></row><row><entry><simpara>Subtraction with integer</simpara></entry><entry><simpara>i - int_off</simpara></entry><entry><simpara><type>Iter</type></simpara></entry><entry><simpara>Equivalent to <computeroutput>i + (-n)</computeroutput></simpara></entry></row><row><entry><simpara>Distance</simpara></entry><entry><simpara>i - j</simpara></entry><entry><simpara><type>difference_type</type></simpara></entry><entry><simpara>The number of times <computeroutput>i</computeroutput> must be incremented (or
    decremented if the result is negative) to reach <computeroutput>j</computeroutput>.  Not
    defined if <computeroutput>j</computeroutput> is not reachable from
    <computeroutput>i</computeroutput>.</simpara></entry></row><row><entry><simpara>Element access</simpara></entry><entry><simpara>i[n]</simpara></entry><entry><simpara><type>const-if-not-mutable value_type &amp;</type></simpara></entry><entry><simpara>Equivalent to <computeroutput>*(i + n)</computeroutput></simpara></entry></row><row><entry><simpara>Element access with integer index</simpara></entry><entry><simpara>i[int_off]</simpara></entry><entry><simpara><type>const-if-not-mutable value_type &amp;</type></simpara></entry><entry><simpara>Equivalent to <computeroutput>*(i + n)</computeroutput></simpara></entry></row></tbody></tgroup></informaltable></refsect1><refsect1><title>Complexity</title><para>
  All iterator operations must take amortized constant time.
  </para></refsect1><refsect1><title>Models</title><itemizedlist><listitem><simplelist type="inline"><member><type>T *</type></member></simplelist></listitem><listitem><simplelist type="inline"><member><type>std::vector&lt;T&gt;::iterator</type></member></simplelist></listitem><listitem><simplelist type="inline"><member><type>std::vector&lt;T&gt;::const_iterator</type></member></simplelist></listitem><listitem><simplelist type="inline"><member><type>std::deque&lt;T&gt;::iterator</type></member></simplelist></listitem><listitem><simplelist type="inline"><member><type>std::deque&lt;T&gt;::const_iterator</type></member></simplelist></listitem></itemizedlist></refsect1><refsect1><title>See also</title><itemizedlist><listitem><para><link linkend="LessThanComparable">LessThanComparable</link></para></listitem></itemizedlist></refsect1></refentry><refentry id="DefaultConstructible"><refmeta><refentrytitle>Concept DefaultConstructible</refentrytitle><manvolnum>7</manvolnum></refmeta><refnamediv><refname>DefaultConstructible</refname></refnamediv><refsect1><title>Description</title><para>DefaultConstructible objects only need to have a default
  constructor.</para></refsect1><refsect1><title>Notation</title><variablelist><varlistentry><term>X</term><listitem><simpara>A type playing the role of default-constructible-type in the <link linkend="DefaultConstructible">DefaultConstructible</link> concept.</simpara></listitem></varlistentry></variablelist></refsect1><refsect1><title>Valid expressions</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Expression</entry><entry>Type</entry><entry>Semantics</entry></row></thead><tbody><row><entry><simpara>Construction</simpara></entry><entry><simpara>X()</simpara></entry><entry><simpara><type>X</type></simpara></entry><entry><simpara>Construct an instance of the type with default parameters.</simpara></entry></row></tbody></tgroup></informaltable></refsect1><refsect1><title>Models</title><itemizedlist><listitem><simplelist type="inline"><member><type>int</type></member></simplelist></listitem><listitem><simplelist type="inline"><member><type>std::vector&lt;double&gt;</type></member></simplelist></listitem></itemizedlist></refsect1></refentry><refentry id="CopyConstructible"><refmeta><refentrytitle>Concept CopyConstructible</refentrytitle><manvolnum>7</manvolnum></refmeta><refnamediv><refname>CopyConstructible</refname></refnamediv><refsect1><title>Description</title><para>Copy constructible types must be able to be constructed from another
  member of the type.</para></refsect1><refsect1><title>Notation</title><variablelist><varlistentry><term>X</term><listitem><simpara>A type playing the role of copy-constructible-type in the <link linkend="CopyConstructible">CopyConstructible</link> concept.</simpara></listitem></varlistentry><varlistentry><term><varname>x</varname></term><term><varname>y</varname></term><listitem><simpara>Objects of type X</simpara></listitem></varlistentry></variablelist></refsect1><refsect1><title>Valid expressions</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Expression</entry><entry>Type</entry><entry>Semantics</entry></row></thead><tbody><row><entry><simpara>Copy construction</simpara></entry><entry><simpara>X(x)</simpara></entry><entry><simpara><type>X</type></simpara></entry><entry><simpara>Require copy constructor.</simpara></entry></row></tbody></tgroup></informaltable></refsect1><refsect1><title>Models</title><itemizedlist><listitem><simplelist type="inline"><member><type>int</type></member></simplelist></listitem></itemizedlist></refsect1></refentry><refentry id="EqualityComparable"><refmeta><refentrytitle>Concept EqualityComparable</refentrytitle><manvolnum>7</manvolnum></refmeta><refnamediv><refname>EqualityComparable</refname></refnamediv><refsect1><title>Description</title><para>Equality Comparable types must have <computeroutput>==</computeroutput> and
  <computeroutput>!=</computeroutput> operators.</para></refsect1><refsect1><title>Notation</title><variablelist><varlistentry><term>X</term><listitem><simpara>A type playing the role of comparable-type in the <link linkend="EqualityComparable">EqualityComparable</link> concept.</simpara></listitem></varlistentry><varlistentry><term><varname>x</varname></term><term><varname>y</varname></term><listitem><simpara>Objects of type X</simpara></listitem></varlistentry></variablelist></refsect1><refsect1><title>Valid expressions</title><informaltable><tgroup cols="3"><thead><row><entry>Name</entry><entry>Expression</entry><entry>Type</entry></row></thead><tbody><row><entry><simpara>Equality test</simpara></entry><entry><simpara>x == y</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row><row><entry><simpara>Inequality test</simpara></entry><entry><simpara>x != y</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row></tbody></tgroup></informaltable></refsect1><refsect1><title>Models</title><itemizedlist><listitem><simplelist type="inline"><member><type>int</type></member></simplelist></listitem><listitem><simplelist type="inline"><member><type>std::vector&lt;int&gt;</type></member></simplelist></listitem></itemizedlist></refsect1></refentry><refentry id="LessThanComparable"><refmeta><refentrytitle>Concept LessThanComparable</refentrytitle><manvolnum>7</manvolnum></refmeta><refnamediv><refname>LessThanComparable</refname></refnamediv><refsect1><title>Description</title><para>LessThanComparable types must have <computeroutput>&lt;</computeroutput>,
  <computeroutput>&gt;</computeroutput>, <computeroutput>&lt;=</computeroutput>, and <computeroutput>&gt;=</computeroutput>
  operators.</para></refsect1><refsect1><title>Notation</title><variablelist><varlistentry><term>X</term><listitem><simpara>A type playing the role of comparable-type in the <link linkend="LessThanComparable">LessThanComparable</link> concept.</simpara></listitem></varlistentry><varlistentry><term><varname>x</varname></term><term><varname>y</varname></term><listitem><simpara>Objects of type X</simpara></listitem></varlistentry></variablelist></refsect1><refsect1><title>Valid expressions</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Expression</entry><entry>Type</entry><entry>Semantics</entry></row></thead><tbody><row><entry><simpara>Less than</simpara></entry><entry><simpara>x &lt; y</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry><entry><simpara>Determine if one value is less than another.</simpara></entry></row><row><entry><simpara>Less than or equal</simpara></entry><entry><simpara>x &lt;= y</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry><entry><simpara>Determine if one value is less than or equal to another.</simpara></entry></row><row><entry><simpara>Greater than</simpara></entry><entry><simpara>x &gt; y</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry><entry><simpara>Determine if one value is greater than another.</simpara></entry></row><row><entry><simpara>Greater than or equal to</simpara></entry><entry><simpara>x &gt;= y</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry><entry><simpara>Determine if one value is greater than or equal to another.</simpara></entry></row></tbody></tgroup></informaltable></refsect1><refsect1><title>Models</title><itemizedlist><listitem><simplelist type="inline"><member><type>int</type></member></simplelist></listitem></itemizedlist></refsect1></refentry><refentry id="SignedInteger"><refmeta><refentrytitle>Concept SignedInteger</refentrytitle><manvolnum>7</manvolnum></refmeta><refnamediv><refname>SignedInteger</refname></refnamediv><refsect1><title>Refinement of</title><itemizedlist><listitem><para><link linkend="CopyConstructible">CopyConstructible</link></para></listitem><listitem><para><link linkend="Assignable">Assignable</link></para></listitem><listitem><para><link linkend="DefaultConstructible">DefaultConstructible</link></para></listitem><listitem><para><link linkend="EqualityComparable">EqualityComparable</link></para></listitem><listitem><para><link linkend="LessThanComparable">LessThanComparable</link></para></listitem></itemizedlist></refsect1><refsect1><title>Notation</title><variablelist><varlistentry><term>T</term><listitem><simpara>A type playing the role of integral-type in the <link linkend="SignedInteger">SignedInteger</link> concept.</simpara></listitem></varlistentry><varlistentry><term><varname>x</varname></term><term><varname>y</varname></term><term><varname>z</varname></term><listitem><simpara>Objects of type T</simpara></listitem></varlistentry><varlistentry><term><varname>a</varname></term><term><varname>b</varname></term><listitem><simpara>Objects of type int</simpara></listitem></varlistentry></variablelist></refsect1><refsect1><title>Type expressions</title><variablelist><varlistentry><term>Conversion to int</term><listitem><para><type>T</type> must be 
                  convertible to <type>int</type>.
                </para></listitem></varlistentry></variablelist></refsect1><refsect1><title>Valid expressions</title><informaltable><tgroup cols="3"><thead><row><entry>Name</entry><entry>Expression</entry><entry>Type</entry></row></thead><tbody><row><entry><simpara>Conversion from int</simpara></entry><entry><simpara>T(a)</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Preincrement</simpara></entry><entry><simpara>++x</simpara></entry><entry><simpara><type>T &amp;</type></simpara></entry></row><row><entry><simpara>Predecrement</simpara></entry><entry><simpara>--x</simpara></entry><entry><simpara><type>T &amp;</type></simpara></entry></row><row><entry><simpara>Postincrement</simpara></entry><entry><simpara>x++</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Postdecrement</simpara></entry><entry><simpara>x--</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Sum</simpara></entry><entry><simpara>x + y</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Sum with int</simpara></entry><entry><simpara>x + a</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Sum-assignment</simpara></entry><entry><simpara>x += y</simpara></entry><entry><simpara><type>T &amp;</type></simpara></entry></row><row><entry><simpara>Sum-assignment with int</simpara></entry><entry><simpara>x += a</simpara></entry><entry><simpara><type>T &amp;</type></simpara></entry></row><row><entry><simpara>Difference</simpara></entry><entry><simpara>x - y</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Difference with int</simpara></entry><entry><simpara>x - a</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Product</simpara></entry><entry><simpara>x * y</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Product with int</simpara></entry><entry><simpara>x * a</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Product-assignment with int</simpara></entry><entry><simpara>x *= a</simpara></entry><entry><simpara><type>T &amp;</type></simpara></entry></row><row><entry><simpara>Product with int on left</simpara></entry><entry><simpara>a * x</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Quotient</simpara></entry><entry><simpara>x / y</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Quotient with int</simpara></entry><entry><simpara>x / a</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Right-shift</simpara></entry><entry><simpara>x &gt;&gt; y</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Right-shift with int</simpara></entry><entry><simpara>x &gt;&gt; a</simpara></entry><entry><simpara><type>T</type></simpara></entry></row><row><entry><simpara>Right-shift-assignment with int</simpara></entry><entry><simpara>x &gt;&gt;= a</simpara></entry><entry><simpara><type>T &amp;</type></simpara></entry></row><row><entry><simpara>Less-than comparison</simpara></entry><entry><simpara>x &lt; y</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row><row><entry><simpara>Less-than comparison with int</simpara></entry><entry><simpara>x &lt; a</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row><row><entry><simpara>Less-than comparison with size_t</simpara></entry><entry><simpara>x &lt; boost::sample_value &lt; std::size_t &gt;()</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row><row><entry><simpara>Greater-than comparison</simpara></entry><entry><simpara>x &gt; y</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row><row><entry><simpara>Greater-than comparison with int</simpara></entry><entry><simpara>x &gt; a</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row><row><entry><simpara>Less-than-or-equal comparison</simpara></entry><entry><simpara>x &lt;= y</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row><row><entry><simpara>Less-than-or-equal comparison with int</simpara></entry><entry><simpara>x &lt;= a</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row><row><entry><simpara>Greater-than-or-equal comparison</simpara></entry><entry><simpara>x &gt;= y</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row><row><entry><simpara>Greater-than-or-equal comparison with int</simpara></entry><entry><simpara>x &gt;= a</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row><row><entry><simpara>Greater-than-or-equal comparison with int on left</simpara></entry><entry><simpara>a &gt;= x</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row><row><entry><simpara>Equality comparison</simpara></entry><entry><simpara>x == y</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row><row><entry><simpara>Equality comparison with int</simpara></entry><entry><simpara>x == a</simpara></entry><entry><simpara>Convertible to <type>bool</type></simpara></entry></row></tbody></tgroup></informaltable></refsect1><refsect1><title>See also</title><itemizedlist/></refsect1></refentry></section><chapter xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="date_time" rev:last-revision="$Date: 2004/07/22 01:35:15 $"><chapterinfo><author><firstname>Jeff</firstname><surname>Garland</surname></author><copyright><year>2001</year><year>2002</year><year>2003</year><year>2004</year><holder>CrystalClear Software, Inc</holder></copyright><legalnotice><para>Subject to the Boost Software License, Version 1.0. (See accompanying file
    <filename>LICENSE_1_0.txt</filename> or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)</para></legalnotice></chapterinfo><title>Boost.Date_Time</title><section id="date_time.intro"><bridgehead renderas="sect3">Introduction</bridgehead><para>
   A set of date-time libraries based on generic programming concepts.
  </para></section><section id="date_time.conceptual" xml:base="../libs/date_time/xmldoc/conceptual.xml"><title>Conceptual</title><section id="Motivation" xml:base="../libs/date_time/xmldoc/motivation.xml"><title>Motivation</title><para>
    The motivation for this library comes from working with and helping build several date-time libraries on several projects. Date-time libraries provide fundamental infrastructure for most development projects. However, most of them have limitations in their ability to calculate, format, convert, or perform some other functionality. For example, most libraries do not correctly handle leap seconds, provide concepts such as infinity, or provide the ability to use high resolution or network time sources.  These libraries also tend to be rigid in their representation of dates and times. Thus customized policies for a project or subproject are not possible.
  </para><para>
    Programming with dates and times should be almost as simple and natural as programming with strings and integers.  Applications with lots of temporal logic can be radically simplified by having a robust set of operators and calculation capabilities. Classes should provide the ability to compare dates and times, add lengths or time durations, retrieve dates and times from  clocks, and work naturally with date and time intervals.
  </para><para>
    Another motivation for development of the library was to apply modern C++ library design techniques to the date-time domain.  Really to build a framework for the construction of building temporal types. For example, by providing iterators and traits classes to control fundamental properties of the library. To the authors knowledge this library is the only substantial attempt to apply modern C++ to a date-time library.
  </para></section><section id="date_time.domain_concepts" xml:base="../libs/date_time/xmldoc/domain_concepts.xml"><title>Domain Concepts</title><para>
    The date time domain is rich in terminology and problems. 
    The following is a brief introduction to the concepts you 
    will find reflected in the library. 
  </para><para>
    The library supports 3 basic temporal types:
    <itemizedlist mark="bullet"><listitem><emphasis role="strong">Time Point</emphasis> -- Specifier 
	for a location in the time continuum.
      </listitem><listitem><emphasis role="strong">Time Duration</emphasis> -- A 
	length of time unattached to any point on the time continuum.
      </listitem><listitem><emphasis role="strong">Time Interval</emphasis> -- A duration 
	of time attached to a specific point in the time continuum. 
	Also known as a time period. 
      </listitem></itemizedlist></para><para>
    Each of these temporal types has a <emphasis role="strong">Resolution</emphasis> which is defined by the smallest representable duration. A <emphasis role="strong">Time system</emphasis> provides all these categories of temporal types as well as the rules for labeling and calculating with time points. <emphasis role="strong">Calendar Systems</emphasis> are simply time systems with a maximum resolution of one day. The <emphasis role="strong">Gregorian</emphasis> system is the most widely used calendar system today (the ISO system is basically a derivative of this). However, there are many other calendar systems as well. <emphasis role="strong">UTC (Coordinated Universal Time)</emphasis> is a widely used civil time system. UTC is adjusted for earth rotation at longitude 0 by the use of leap seconds (This is not predictable, only as necessary). Most <emphasis role="strong">local time</emphasis> systems are based on UTC but are also adjusted for earth rotation so that daylight hours are similar everywhere. In addition, some local times include <emphasis role="strong">daylight savings time (DST)</emphasis> adjustments to shift the daylight hours during the summer.
  </para><para>
    A <emphasis role="strong">Clock Device</emphasis> is software component (tied to some hardware) that provides the current date or time with respect to a time system. A clock can measure the current time to a known resolution which may be higher or lower than a particular time representation. 
  </para><para>
    The library provides support for calculating with dates and times. However, time calculations are not quite the same as calculating with integers. If you are serious about the accuracy of your time calculations need to read about <link linkend="date_time.tradeoffs">Stability, Predictability, and Approximations</link>. 
  </para><para><itemizedlist mark="bullet"><listitem><link linkend="date_time.terminology">Basic Terminology</link></listitem><listitem><link linkend="date_time.calculations">Calculations</link></listitem><listitem><link linkend="date_time.tradeoffs">Stability, Predictability, and Approximations</link></listitem><listitem><link linkend="date_time.references">References</link></listitem></itemizedlist></para></section><section id="date_time.design_concepts" xml:base="../libs/date_time/xmldoc/design_concepts.xml"><title>Design Concepts</title><para>
    A large part of the genesis of this library has been the observation that few date-time libraries are built in a fashion that allows customization and extension. A typical example, the calendar logic is built directly into the date class. Or the clock retrieval functions are built directly into the time class. These design decisions usually make it impossible to extend or change the library behavior. At a more fundamental level, there are usually assumptions about the resolution of time representation or the gregorian calendar. 
  </para><para>
    Often times, the result is that a project must settle for a less than complete library because of a requirement for high resolution time representation or other assumptions that do not match the implementation of the library. This is extremely unfortunate because development of a library of this sort is far from a trivial task. 
  </para><para>
    While the design is far from perfect the current design is far more flexible than any date-time library the author is aware of. It is expected that the various aspects of extensibility will be better documented in future versions. Information about the design goals of the library is <link linkend="date_time.design_goals">summarized here</link>. 
  </para></section><section id="date_time.conceptual.more_info"><title>More Information</title><para>
      The design of the library is currently being evolved using 
      Wiki and email discussions. You can find more information at:
      <itemizedlist mark="bullet"><listitem><ulink url="http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?GDTL">Boost Wiki GDTL Start Page</ulink></listitem><listitem><ulink url="http://www.crystalclearsoftware.com/libraries/gdtl/gdtl_ref_guide/index.html">Full Doxygen Reference Manual</ulink></listitem></itemizedlist></para></section></section><section id="date_time.gregorian" xml:base="../libs/date_time/xmldoc/gregorian.xml"><title>Gregorian</title><bridgehead renderas="sect2">Gregorian Date System</bridgehead><para><link linkend="greg_intro">Introduction</link> -- 
    <link linkend="greg_ex">Usage Examples</link></para><anchor id="greg_intro"/><bridgehead renderas="sect3">Introduction</bridgehead><para>The gregorian date system provides a date programming system based the Gregorian Calendar. The first introduction of the Gregorian calendar was in 1582 to fix an error in the Julian Calendar. However, many local jurisdictions did not adopt this change until much later. Thus there is potential confusion with historical dates. 
  </para><para>The implemented calendar is a "propleptic Gregorian calendar" which extends dates back prior to the Gregorian Calendar's first adoption in 1582. The current implementation supports dates in the range 1400-Jan-01 to 10000-Jan-01. Many references will represent dates prior to 1582 using the Julian Calendar, so caution is in order if accurate calculations are required on historic dates. See <ulink url="http://emr.cs.iit.edu/home/reingold/calendar-book/second-edition">Calendrical Calculations</ulink> by Reingold &amp; Dershowitz for more details. Date information from Calendrical Calculations has been used to cross-test the correctness of the Gregorian calendar implementation. 
  </para><para>All types for the gregorian system are found in namespace boost::gregorian. The library supports a convenience header boost/date_time/gregorian/gregorian_types.hpp that will include all the classes of the library with no input/output dependency. Another header boost/date_time/gregorian/gregorian.hpp will include the types and the input/output code. 
  </para><para>The class <link linkend="date_time.gregorian.date_class">boost::gregorian::date</link> is the primary temporal type for users. If you are interested in learning about writing programs do specialized date calculations such as finding the "first sunday in april" see the date <link linkend="date_time.gregorian.date_algorithms">generators and algorithms page</link>. 
  </para><anchor id="greg_ex"/><bridgehead renderas="sect3">Usage Examples</bridgehead><para><informaltable frame="all"><tgroup cols="2"><thead><row><entry>Example</entry><entry>Description</entry></row></thead><tbody><row><entry><link linkend="date_time.examples.days_alive">Days Alive</link><link linkend="date_time.examples.days_till_new_year">Days Till New Year</link></entry><entry>Simple date arithmetic. Retrieve current day from clock.</entry></row><row><entry><link linkend="date_time.examples.dates_as_strings">Dates as strings</link></entry><entry>Simple parsing and formatting of dates from/to strings</entry></row><row><entry><link linkend="date_time.examples.date_period_calc">Date Period Calculations</link></entry><entry>See if a date is in a set of date periods (eg: is it a holiday/weekend)</entry></row><row><entry><link linkend="date_time.examples.print_month">Print a month</link></entry><entry>Small utility program which prints out all the days in a month from command line. Need to know if 1999-Jan-1 was a Friday or a Saturday? This program shows how to do it.</entry></row><row><entry><link linkend="date_time.examples.print_holidays">Print Holidays</link></entry><entry>Uses date generators to convert abstract specification into concrete set of dates.</entry></row></tbody></tgroup></informaltable></para><section id="date_time.gregorian.date_class" xml:base="../libs/date_time/xmldoc/date_class.xml"><title>Date Class</title><link linkend="date_intro">Introduction</link> --
  <link linkend="date_header">Header</link> --
  <link linkend="date_construction">Construction</link> --
  <link linkend="date_construct_from_string">Construct from String</link> --
  <link linkend="date_construct_from_clock">Construct from Clock</link> --
  <link linkend="date_accessors">Accessors</link> --
  <link linkend="date_convert_to_string">Convert to String</link> --
  <link linkend="date_operators">Operators</link><anchor id="date_intro"/><bridgehead renderas="sect3">Introduction</bridgehead><para>
    The class boost::gregorian::date is the primary interface for date programming. In general, the date class is immutable once constructed although it does allow assignment. 
  </para><para>
    Other techniques for creating dates include <link linkend="date_time.gregorian.date_iterators">date iterators</link> and <link linkend="date_time.gregorian.date_algorithms">date algorithms or generators</link>. 
  </para><anchor id="date_header"/><bridgehead renderas="sect3">Header</bridgehead><para><programlisting>
      #include "boost/date_time/gregorian/gregorian.hpp" //include all types plus i/o
      or
      #include "boost/date_time/gregorian/gregorian_types.hpp" //no i/o just types
    </programlisting></para><anchor id="date_construction"/><bridgehead renderas="sect3">Construction</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>date(greg_year year, greg_month month, greg_day day)</entry><entry>Construct from parts of date. Throws bad_year, bad_day_of_month, or bad_day_month (derivatives of std::out_of_range) if the year, month or day are out of range.</entry><entry>date d(2002,Jan,10)</entry></row><row><entry>date(date d)</entry><entry>Copy constructor</entry><entry>date d1(d)</entry></row><row><entry>date(special_values sv)</entry><entry>Constructor for infinities, not-a-date-time, max_date_time, and min_date_time</entry><entry>
	    date d1(neg_infin);
	    date d2(pos_infin);
	    date d3(not_a_date_time);
	    date d4(max_date_time);
	    date d5(min_date_time);</entry></row><row><entry>date;</entry><entry>Default constructor. Creates a date object initialized to not_a_date_time. NOTE: this constructor can be disabled by defining DATE_TIME_NO_DEFAULT_CONSTRUCTOR (see compiler_config.hpp)</entry><entry>date d; // d =&gt; not_a_date_time</entry></row></tbody></tgroup></informaltable><anchor id="date_construct_from_string"/><bridgehead renderas="sect3">Construct from String</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>date from_string(const std::string&amp;)</entry><entry>From delimited date string where with order year-month-day eg: 2002-1-25</entry><entry>
	    std::string ds("2002/1/25");
	    date d(from_string(ds))</entry></row><row><entry>date from_undelimited_string(const std::string&amp;)</entry><entry>From iso type date string where with order year-month-day eg: 20020125</entry><entry>
	    std::string ds("20020125");
	    date d(from_undelimited_string(ds))</entry></row></tbody></tgroup></informaltable><anchor id="date_construct_from_clock"/><bridgehead renderas="sect3">Construct from Clock</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>day_clock::local_day()</entry><entry>Get the local day based on the time zone settings of the computer.</entry><entry>date d(day_clock::local_day())</entry></row><row><entry>day_clock::universal_day()</entry><entry>Get the UTC day.</entry><entry>date d(day_clock::universal_day())</entry></row></tbody></tgroup></informaltable><anchor id="date_accessors"/><bridgehead renderas="sect3">Accessors</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>greg_year year() const</entry><entry>Get the year part of the date.</entry><entry>
	    date d(2002,Jan,10); 
	    d.year() --&gt; 2002;</entry></row><row><entry>greg_month month() const</entry><entry>Get the month part of the date.</entry><entry>
	    date d(2002,Jan,10); 
	    d.month() --&gt; 1;</entry></row><row><entry>greg_day day() const</entry><entry> Get the day part of the date.</entry><entry>
	    date d(2002,Jan,10); 
	    d.day() --&gt; 10;</entry></row><row><entry>greg_ymd year_month_day() const</entry><entry>Return a year_month_day struct. More efficient when all 3 parts of the date are needed.</entry><entry>
	    date d(2002,Jan,10);
	    date::ymd_type ymd = d.year_month_day();
	    ymd.year --&gt; 2002, ymd.month --&gt; 1, ymd.day --&gt; 10</entry></row><row><entry>greg_day_of_week day_of_week() const</entry><entry>Get the day of the week (eg: Sunday, Monday, etc.</entry><entry>
	    date d(2002,Jan,10);
	    d.day() --&gt; Thursday;</entry></row><row><entry>bool is_infinity() const</entry><entry>Returns true if date is either positive or negative infinity</entry><entry>
	    date d(pos_infin); 
	    d.is_infinity() --&gt; true;</entry></row><row><entry>bool is_neg_infinity() const</entry><entry>Returns true if date is negative infinity</entry><entry>
	    date d(neg_infin);
	    d.is_neg_infinity() --&gt; true;</entry></row><row><entry>bool is_pos_infinity() const</entry><entry>Returns true if date is positive infinity</entry><entry>
	    date d(neg_infin); 
	    d.is_pos_infinity() --&gt; true;</entry></row><row><entry>bool is_not_a_date() const</entry><entry>Returns true if value is not a date</entry><entry>
	    date d(not_a_date_time);
	    d.is_not_a_date() --&gt; true;</entry></row><row><entry>long modjulian_day() const</entry><entry>Returns the modified julian day for the date.</entry><entry/></row><row><entry>long julian_day() const</entry><entry>Returns the julian day for the date.</entry><entry/></row><row><entry>int week_number() const</entry><entry>Returns the ISO 8601 week number for the date.</entry><entry/></row></tbody></tgroup></informaltable><anchor id="date_convert_to_string"/><bridgehead renderas="sect3">Convert to String</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>std::string to_simple_string(date d)</entry><entry>To YYYY-mmm-DD string where mmm 3 char month name.</entry><entry>2002-Jan-01</entry></row><row><entry>std::string to_iso_string(date d)</entry><entry>To YYYYMMDD where all components are integers.</entry><entry>20020131</entry></row><row><entry>std::string to_iso_extended_string(date d)</entry><entry> To YYYY-MM-DD where all components are integers.</entry><entry>2002-01-31</entry></row></tbody></tgroup></informaltable><anchor id="date_operators"/><bridgehead renderas="sect3">Operators</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>operator&lt;&lt;</entry><entry>Stream output operator</entry><entry>
	    date d(2002,Jan,1)
	    std::cout &lt;&lt; d &lt;&lt; std::endl;
	  </entry></row><row><entry> 
	    operator==, operator!=,
	    operator&gt;, operator&lt;
	    operator&gt;=, operator&lt;=</entry><entry>A full complement of comparison operators</entry><entry>d1 == d2, etc</entry></row><row><entry>date operator+(date_duration) const</entry><entry>Return a date adding a day offset</entry><entry>
	    date d(2002,Jan,1);
	    date_duration dd(1);
	    date d2 = d + dd;
	  </entry></row><row><entry>date operator-(date_duration) const</entry><entry>Return a date by adding a day offset</entry><entry>
	    date d(2002,Jan,1);
	    date_duration dd(1);
	    date d2 = d - dd;
	  </entry></row><row><entry>date_duration operator-(date) const</entry><entry>Return a date duration by subtracting two dates</entry><entry>
	    date d1(2002,Jan,1);
	    date d2(2002,Jan,2);
	    date_duration dd = d2-d1;
	  </entry></row></tbody></tgroup></informaltable><link linkend="top">top</link></section><section id="date_time.gregorian.date_duration" xml:base="../libs/date_time/xmldoc/date_duration.xml"><title>Date Duration (aka Days)</title><link linkend="duration_intro">Introduction</link> --
  <link linkend="duration_header">Header</link> --
  <link linkend="duration_construction">Construction</link> --
  <link linkend="duration_operators">Operators</link><anchor id="duration_intro"/><bridgehead renderas="sect3">Introduction</bridgehead><para>
    As of version 1_32 the date_duration class has been typdefed as days in the boost::gregorian namespace. Throughout the examples you will find days used instead of date_duration.
  </para><para>
    The class boost::gregorian::date_duration is a simple day count used for arithmetic with <link linkend="date_time.gregorian.date_class">gregorian::date</link>. A duration can be either positive or negative. 
  </para><anchor id="duration_header"/><bridgehead renderas="sect3">Header</bridgehead><para><programlisting>
      #include "boost/date_time/gregorian/gregorian.hpp" //include all types plus i/o
      or
      #include "boost/date_time/gregorian/gregorian_types.hpp" //no i/o just types
    </programlisting></para><anchor id="duration_construction"/><bridgehead renderas="sect3">Construction</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>date_duration(long)</entry><entry>Create a duration count.</entry><entry> date_duration dd(3); //3 days</entry></row></tbody></tgroup></informaltable><anchor id="duration_accessors"/><bridgehead renderas="sect3">Accessors</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>long days() const</entry><entry> Get the day count.</entry><entry>date_duration dd(3); dd.days() --&gt; 3</entry></row><row><entry>bool is_negative() const</entry><entry>True if number of days is less than zero.</entry><entry>date_duration dd(-1); dd.is_negative() --&gt; true</entry></row><row><entry>static date_duration unit()</entry><entry>Return smallest possible unit of duration type.</entry><entry>date_duration::unit() --&gt; date_duration(1)</entry></row></tbody></tgroup></informaltable><anchor id="duration_operators"/><bridgehead renderas="sect3">Operators</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>
	    operator==, operator!=,
	    operator&gt;, operator&lt;
	    operator&gt;=, operator&lt;=
	  </entry><entry>A full complement of comparison operators</entry><entry>dd1 == dd2, etc</entry></row><row><entry>date_duration operator+(date_duration) const</entry><entry>Add date durations.</entry><entry>
	    date_duration dd1(3);
	    date_duration dd2(5);
	    date_duration dd3 = dd1 + dd2;
	  </entry></row><row><entry>date_duration operator-(date_duration) const</entry><entry>Subtract durations.</entry><entry>
	    date_duration dd1(3);
	    date_duration dd2(5);
	    date_duration dd3 = dd1 - dd2;
	  </entry></row></tbody></tgroup></informaltable><link linkend="top">top</link></section><section id="date_time.gregorian.date_period" xml:base="../libs/date_time/xmldoc/date_period.xml"><title>Date Period</title><link linkend="period_intro">Introduction</link> --
  <link linkend="period_header">Header</link> --
  <link linkend="period_construction">Construction</link> --
  <link linkend="period_accessors">Accessors</link> --
  <link linkend="period_convert_to_string">Convert to String</link> --
  <link linkend="period_operators">Operators</link><anchor id="period_intro"/><bridgehead renderas="sect3">Introduction</bridgehead><para>
    The class boost::gregorian::date_period provides direct representation for ranges between two dates. Periods provide the ability to simplify some types of calculations by simplifying the conditional logic of the program. For example, testing if a date is within an irregular schedule such as a weekend or holiday can be accomplished using collections of date periods. This is facilitated by several methods that allow evaluation if a date_period intersects with another date period, and to generate the period resulting from the intersection. The <link linkend="date_time.examples.period_calc">period calculation example</link> provides an example of this.
  </para><para>
    Date periods used in combination with infinity values have the ability to represent complex concepts such as 'until further notice'. 
  </para><anchor id="period_header"/><bridgehead renderas="sect3">Header</bridgehead><para><programlisting>
      #include "boost/date_time/gregorian/gregorian.hpp" //include all types plus i/o
      or
      #include "boost/date_time/gregorian/gregorian_types.hpp" //no i/o just types
    </programlisting></para><anchor id="period_construction"/><bridgehead renderas="sect3">Construction</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>date_period(date begin, date end)</entry><entry> Create a period as [begin, end). If last is &lt;= begin then the period will be defined as null.</entry><entry>date_period dp(date(2002,Jan,10), date(2002,Jan,12));</entry></row><row><entry>date_period(date start, date_duration len)</entry><entry> Create a period as [begin, begin+len). If len is &lt;= zero then the period will be defined as null.</entry><entry>date_period dp(date(2002,Jan,10), date_duration(2));</entry></row><row><entry>date_period(date_period rhs)</entry><entry> Copy constructor</entry><entry> date_period dp1(dp)</entry></row></tbody></tgroup></informaltable><anchor id="period_accessors"/><bridgehead renderas="sect3">Accessors</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>date begin() const</entry><entry> Return first day of period.</entry><entry>
	    date_period dp(date(2002,Jan,1), date(2002,Jan,10));
	    dp.begin() --&gt; 2002-Jan-01
	  </entry></row><row><entry>date last() const</entry><entry>Return last date in the period</entry><entry>
	    date_period dp(date(2002,Jan,1), date(2002,Jan,10));
	    dp.last() --&gt; 2002-Jan-09
	  </entry></row><row><entry>date end() const</entry><entry>Return one past the last in period</entry><entry>
	    date_period dp(date(2002,Jan,1), date(2002,Jan,10));
	    dp.end() --&gt; 2002-Jan-10
	  </entry></row><row><entry>date_duration length() const</entry><entry>Return the length of the date_period</entry><entry>
	    date_period dp(date(2002,Jan,1), date_duration(2));
	    dp.length() --&gt; 2
	  </entry></row><row><entry>bool is_null() const</entry><entry>True if period is not well formed. eg: start less than end</entry><entry>
	    date_period dp(date(2002,Jan,10), date(2002,Jan,1));
	    dp.begin() --&gt; true
	  </entry></row><row><entry>bool contains(date) const</entry><entry>True if date is within the period</entry><entry>
	    date_period dp(date(2002,Jan,1), date(2002,Jan,10));
	    dp.contains(date(2002,Jan,2)) --&gt; true
	  </entry></row><row><entry>bool contains(date_period) const</entry><entry>True if date period is within the period</entry><entry>
	    date_period dp1(date(2002,Jan,1), date(2002,Jan,10));
	    date_period dp2(date(2002,Jan,2), date(2002,Jan,3));
	    dp1.contains(dp2) --&gt; true
	    dp2.contains(dp1) --&gt; false
	  </entry></row><row><entry>bool intersects(date_period) const</entry><entry>True if periods overlap</entry><entry>
	    date_period dp1(date(2002,Jan,1), date(2002,Jan,10));
	    date_period dp2(date(2002,Jan,2), date(2002,Jan,3));
	    dp2.intersects(dp1) --&gt; true
	  </entry></row><row><entry>date_period intersection(date_period) const</entry><entry>Calculate the intersection of 2 periods. Null if no intersection.</entry><entry>
	    date_period dp1(date(2002,Jan,1), date(2002,Jan,10));
	    date_period dp2(date(2002,Jan,2), date(2002,Jan,3));
	    dp2.intersection(dp1) --&gt; dp2
	  </entry></row><row><entry>date_period is_adjacent(date_period) const</entry><entry>Check if two periods are adjacent, but not overlapping.</entry><entry>
	    date_period dp1(date(2002,Jan,1), date(2002,Jan,3));
	    date_period dp2(date(2002,Jan,3), date(2002,Jan,10));
	    dp2.is_adjacent(dp1) --&gt; true
	  </entry></row><row><entry>date_period is_after(date) const</entry><entry>Determine the period is after a given date.</entry><entry>
	    date_period dp1(date(2002,Jan,10), date(2002,Jan,30));
	    date d(2002,Jan,3);
	    dp1.is_after(d) --&gt; true
	  </entry></row><row><entry>date_period is_before(date) const</entry><entry>Determine the period is before a given date.</entry><entry>
	    date_period dp1(date(2002,Jan,1), date(2002,Jan,3));
	    date d(2002,Jan,10);
	    dp1.is_before(d) --&gt; true
	  </entry></row><row><entry>date_period merge(date_period) const</entry><entry>Returns union of two periods. Null if no intersection.</entry><entry>
	    date_period dp1(date(2002,Jan,1), date(2002,Jan,10));
	    date_period dp2(date(2002,Jan,9), date(2002,Jan,31));
	    dp2.merge(dp1) --&gt; 2002-Jan-01/2002-Jan-31
	  </entry></row><row><entry>date_period span(date_period) const</entry><entry>Combines two periods and any gap between them such that start = min(p1.start, p2.start) and end = max(p1.end , p2.end)</entry><entry>
	    date_period dp1(date(2002,Jan,1), date(2002,Jan,5));
	    date_period dp2(date(2002,Jan,9), date(2002,Jan,31));
	    dp2.hull(dp1) --&gt; 2002-Jan-01/2002-Jan-31
	  </entry></row><row><entry>date_period shift(date_duration)</entry><entry>Add duration to both start and end.</entry><entry>
	    date_period dp1(date(2002,Jan,1), date(2002,Jan,10));
	    dp1.shift(date_duration(1)); --&gt; 2002-Jan-02/2002-Jan-11
	  </entry></row></tbody></tgroup></informaltable><anchor id="period_convert_to_string"/><bridgehead renderas="sect3">Convert to String</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>std::string to_simple_string(date_period dp)</entry><entry>To [YYYY-mmm-DD/YYYY-mmm-DD] string where mmm is 3 char month name.</entry><entry>[2002-Jan-01/2002-Jan-31]</entry></row></tbody></tgroup></informaltable><anchor id="period_operators"/><bridgehead renderas="sect3">Operators</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>operator&lt;&lt;</entry><entry>ostream operator for date_period. Uses facet to format time points. Typical output: [2002-Jan-01/2002-Jan-31].</entry><entry>std::cout &lt;&lt; dp &lt;&lt; std::endl;</entry></row><row><entry>
	    operator==, operator!=,
	    operator&gt;, operator&lt;
	  </entry><entry>A full complement of comparison operators</entry><entry> dp1 == dp2, etc</entry></row><row><entry>operator&lt;</entry><entry>True if dp1.end() less than dp2.begin()</entry><entry> dp1 &lt; dp2, etc</entry></row><row><entry>operator&gt;</entry><entry>True if dp1.begin() greater than dp2.end()</entry><entry>dp1 &gt; dp2, etc</entry></row></tbody></tgroup></informaltable><link linkend="top">top</link></section><section id="date_time.gregorian.date_iterators" xml:base="../libs/date_time/xmldoc/date_iterators.xml"><title>Date Iterators</title><link linkend="iterators_intro">Introduction</link> --
  <link linkend="iterators_header">Header</link> --
  <link linkend="iterators_overview">Overview</link><anchor id="iterators_intro"/><bridgehead renderas="sect3">Introduction</bridgehead><para>
    Date iterators provide a standard mechanism for iteration through dates. Date iterators are a model of <ulink url="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</ulink> and can be used to populate collections with dates and other date generation tasks. For example, the <link linkend="date_time.examples.print_month">print month</link> example iterates through all the days in a month and prints them. 
  </para><para>
    All of the iterators here derive from boost::gregorian::date_iterator. 
  </para><anchor id="iterators_header"/><bridgehead renderas="sect3">Header</bridgehead><para><programlisting>
      #include "boost/date_time/gregorian/gregorian.hpp" //include all types plus i/o
      or
      #include "boost/date_time/gregorian/gregorian_types.hpp" //no i/o just types
    </programlisting></para><anchor id="iterators_overview"/><bridgehead renderas="sect3">Overview</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Class</entry><entry>Construction Parameters</entry><entry>Description</entry></row></thead><tbody><row><entry>date_iterator</entry><entry/><entry>Common base class for all day level iterators.</entry></row><row><entry>day_iterator</entry><entry>date start_date, int day_count=1</entry><entry>Iterate day_count days at a time.</entry></row><row><entry>week_iterator</entry><entry> date start_date, int week_offset=1</entry><entry>Iterate week_offset weeks at a time.</entry></row><row><entry>month_iterator</entry><entry>date start_date, int month_offset=1</entry><entry>
	    Iterate month_offset months. There are special rules for handling the end of the month. These are: if start date is last day of the month, always adjust to last day of the month. If date is beyond the end of the month (eg: jan 31 + 1 month) adjust back to end of month.
	  </entry></row><row><entry>year_iterator</entry><entry>date start_date, int year_offset=1</entry><entry>Iterate year_offset years. The year_iterator will always land on the day of the date parameter except when date is Feb 28 in a non-leap year. In this case the iterator will return Feb 29 for leap years (eg: 2003-Feb-28, 2004-Feb-29, 2005-Feb-28).</entry></row></tbody></tgroup></informaltable><link linkend="top">top</link></section><section id="date_time.gregorian.date_algorithms" xml:base="../libs/date_time/xmldoc/date_algorithms.xml"><title>Date Generators/Algorithms</title><bridgehead renderas="sect2">Date Generators/Algorithms</bridgehead><link linkend="algo_intro">Introduction</link> --
  <link linkend="algo_header">Header</link> --
  <link linkend="algo_overview">Class Overview</link> --
  <link linkend="algo_func_overview">Function Overview</link><anchor id="algo_intro"/><bridgehead renderas="sect3">Introduction</bridgehead><para> 
    Date algorithms or generators are tools for generating other dates or schedules of dates. A generator function starts with some part of a date such as a month and day and is supplied another part to then generate a concrete date. This allows the programmer to represent concepts such as "The first Sunday in February" and then create a concrete set of dates when provided with one or more years.
    <emphasis>Note</emphasis>: As of boost version 1_31_0, date generator names have been changed. Old names are still available but are no longer documented and may someday be deprecated
  </para><para>Also provided are stand-alone functions for generating a date, or calculation a duration of days. These functions take a date object and a weekday object as parameters.
  </para><para>All date generator classes and functions are in the boost::gregorian namespace.
  </para><para> 
    The <link linkend="date_time.examples.print_holidays">print holidays</link> example shows a detailed usage example. 
  </para><anchor id="algo_header"/><bridgehead renderas="sect3">Header</bridgehead><para>
    #include "boost/date_time/date_generators.hpp" 
  </para><anchor id="algo_overview"/><bridgehead renderas="sect3">Overview</bridgehead><informaltable frame="all"><tgroup cols="4"><thead><row><entry>Class</entry><entry>Construction Parameters</entry><entry>get_date Parameter</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>year_based_generator</entry><entry>abstract base class</entry><entry>greg_year year</entry><entry>A unifying date_generator base type for: partial_date, nth_day_of_the_week_in_month, first_day_of_the_week_in_month, and last_day_of_the_week_in_month
          </entry><entry>
            The <link linkend="date_time.examples.print_holidays">print holidays</link> example shows a detailed usage example.
          </entry></row><row><entry>last_day_of_the_week_in_month</entry><entry>greg_weekday or weekday, greg_month or month</entry><entry>greg_year or year</entry><entry>Calculate something like last Monday of January</entry><entry>
	    last_day_of_the_week_in_month lwdm(Monday,Jan);
	    date d = lwdm.get_date(2002);//2002-Jan-28
	  </entry></row><row><entry>first_day_of_the_week_in_month</entry><entry>greg_weekday or weekday, greg_month or month</entry><entry>greg_year or year</entry><entry>Calculate something like first Monday of January</entry><entry>
	    first_day_of_the_week_in_month fdm(Monday,Jan);
	    date d = fdm.get_date(2002);//2002-Jan-07
	  </entry></row><row><entry>partial_date</entry><entry>greg_day, greg_month or month</entry><entry>greg_year</entry><entry>Generates a date by applying the year to the given month and day.</entry><entry>
	    partial_date pd(1,Jan);
	    date d = pd.get_date(2002);//2002-Jan-01
	  </entry></row><row><entry>first_day_of_the_week_after</entry><entry> greg_weekday or weekday</entry><entry><link linkend="date_time.gregorian.date_class">date</link></entry><entry>Calculate something like First Sunday after Jan 1,2002</entry><entry>
	    first_day_of_the_week_after fdaf(Monday);
	    date d = fdaf.get_date(date(2002,Jan,1));//2002-Jan-07
	  </entry></row><row><entry>first_day_of_the_week_before</entry><entry> greg_weekday or weekday</entry><entry><link linkend="date_time.gregorian.date_class">date</link></entry><entry>Calculate something like First Monday before Feb 1,2002</entry><entry>
	    first_day_of_the_week_before fdbf(Monday);
	    date d = fdbf.get_date(date(2002,Feb,1));//2002-Jan-28
	  </entry></row></tbody></tgroup></informaltable><anchor id="algo_func_overview"/><bridgehead renderas="sect3">Function Overview</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Function Prototype</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry><link linkend="date_time.gregorian.date_duration">days</link> days_until_weekday (const <link linkend="date_time.gregorian.date_class">date</link>&amp;, const greg_weekday&amp;)</entry><entry> Calculates the number of days from given date until given weekday.</entry><entry>
	    date d(2004,Jun,1); // Tuesday
	    greg_weekday gw(Friday);
	    days_until_weekday(d, gw); // 3 days
	  </entry></row><row><entry><link linkend="date_time.gregorian.date_duration">days</link> days_before_weekday (const <link linkend="date_time.gregorian.date_class">date</link>&amp;, const greg_weekday&amp;)</entry><entry> Calculates the number of day from given date to previous given weekday.</entry><entry>
	    date d(2004,Jun,1); // Tuesday
	    greg_weekday gw(Friday);
	    days_before_weekday(d, gw); // 4 days
	  </entry></row><row><entry><link linkend="date_time.gregorian.date_class">date</link> next_weekday (const <link linkend="date_time.gregorian.date_class">date</link>&amp;, const greg_weekday&amp;)</entry><entry> Generates a date object representing the date of the following weekday from the given date.</entry><entry>
	    date d(2004,Jun,1); // Tuesday
	    greg_weekday gw(Friday);
	    next_weekday(d, gw); // 2004-Jun-4
	  </entry></row><row><entry><link linkend="date_time.gregorian.date_class">date</link> previous_weekday (const <link linkend="date_time.gregorian.date_class">date</link>&amp;, const greg_weekday&amp;)</entry><entry> Generates a date object representing the date of the previous weekday from the given date.</entry><entry>
	    date d(2004,Jun,1); // Tuesday
	    greg_weekday gw(Friday);
	    previous_weekday(d, gw); // 2004-May-28
	  </entry></row></tbody></tgroup></informaltable><link linkend="top">top</link></section><section id="date_time.gregorian.gregorian_calendar" xml:base="../libs/date_time/xmldoc/gregorian_calendar.xml"><title>Gregorian Calendar</title><link linkend="gregcal_intro">Introduction</link> --
  <link linkend="gregcal_header">Header</link> --
  <link linkend="gregcal_functions">Functions</link><anchor id="gregcal_intro"/><bridgehead renderas="sect3">Introduction</bridgehead><para>
    The class boost::gregorian::gregorian_calendar implements the functions necessary to create the gregorian date system. It converts to the year-month-day form of a date to a day number representation and back. 
  </para><para>
    For most purposes this class is simply accessed by <link linkend="date_time.gregorian.date_class">gregorian::date</link> and is not used directly by the user. However, there are useful functions that might be of use such as the end_of_month_day function. 
  </para><para>
    The <link linkend="date_time.examples.print_month">print month</link> example demonstrates this. 
  </para><anchor id="gregcal_header"/><bridgehead renderas="sect3">Header</bridgehead><para><programlisting>
      #include "boost/date_time/gregorian/gregorian.hpp" //include all types plus i/o
      or
      #include "boost/date_time/gregorian/gregorian_types.hpp" //no i/o just types
    </programlisting></para><anchor id="gregcal_functions"/><bridgehead renderas="sect3">Functions</bridgehead><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>static short day_of_week(ymd_type)</entry><entry>Return the day of the week (0==Sunday, 1==Monday, etc)</entry><entry>See also <link linkend="date_time.gregorian.date_class">gregorian::date</link> day_of_week</entry></row><row><entry>static date_int_type day_number(ymd_type)</entry><entry> Convert a ymd_type into a day number. The day number is an absolute number of days since the epoch start.</entry><entry/></row><row><entry>static short end_of_month_day(year_type, month_type)</entry><entry>Given a year and month determine the last day of the month.</entry><entry/></row><row><entry>static ymd_type from_day_number(date_int_type)</entry><entry> Convert a day number to a ymd struct.</entry><entry/></row><row><entry>static bool is_leap_year(year_type)</entry><entry>Returns true if specified year is a leap year.</entry><entry>gregorian_calendar::is_leap_year(2000) --&gt; true</entry></row></tbody></tgroup></informaltable><link linkend="top">top</link></section><section id="date_time.gregorian.day_clock_class" xml:base="../libs/date_time/xmldoc/day_clock_class.xml"><title>Class day_clock</title><link linkend="date_construct_from_clock">Class day_clock</link></section><link linkend="top">top</link></section><section id="date_time.posix_time" xml:base="../libs/date_time/xmldoc/posix_time.xml"><title>Posix Time</title><bridgehead renderas="sect2">Posix Time System</bridgehead><para><link linkend="posix_intro">Introduction</link> -- 
    <link linkend="posix_ex">Usage Examples</link></para><anchor id="posix_intro"/><bridgehead renderas="sect3">Introduction</bridgehead><para>
    Defines a non-adjusted time system with nano-second/micro-second resolution and stable calculation properties.  The nano-second resolution option uses 96 bits of underlying storage for each ptime while the micro-second resolution uses 64 bits per ptime (see <link linkend="date_time.buildinfo">Build Options</link> for details). This time system uses the Gregorian calendar to implement the date portion of the time representation. 
  </para><anchor id="posix_ex"/><bridgehead renderas="sect3">Usage Examples</bridgehead><para><informaltable frame="all"><tgroup cols="2"><thead><row><entry>Example</entry><entry>Description</entry></row></thead><tbody><row><entry><link linkend="date_time.examples.time_math">Time Math</link></entry><entry>A few simple calculations using ptime and time_durations.</entry></row><row><entry><link linkend="date_time.examples.print_hours">Print Hours</link></entry><entry>Retrieve time from clock, use a time_iterator.</entry></row><row><entry><link linkend="date_time.examples.local_utc_conversion">Local to UTC Conversion</link></entry><entry>Demonstrates a couple different ways to convert a local to UTC time including daylight savings rules.</entry></row><row><entry><link linkend="date_time.examples.time_periods">Time Periods</link></entry><entry>Some simple examples of intersection and display of time periods.</entry></row></tbody></tgroup></informaltable></para><section id="date_time.posix_time.ptime_class" xml:base="../libs/date_time/xmldoc/ptime_class.xml"><title>Ptime Class</title><link linkend="ptime_intro">Introduction</link> --
  <link linkend="ptime_header">Header</link> --
  <link linkend="ptime_constr">Construction</link> --
  <link linkend="ptime_from_string">Construct from String</link> --
  <link linkend="ptime_from_clock">Construct from Clock</link> --
  <link linkend="ptime_from_funcs">Construct using Conversion functions</link> --
  <link linkend="ptime_accessors">Accessors</link> --
  <link linkend="ptime_to_string">Conversion To String</link> --
  <link linkend="ptime_operators">Operators</link><anchor id="ptime_intro"/><bridgehead renderas="sect3">Introduction</bridgehead><para>
    The class boost::posix_time::ptime is the primary interface for time point manipulation. In general, the ptime class is immutable once constructed although it does allow assignment. 
  </para><para>
    Class ptime is dependent on <link linkend="date_time.gregorian.date_class">gregorian::date</link> for the interface to the date portion of a time point. 
  </para><para>
    Other techniques for creating times include <link linkend="date_time.posix_time.time_iterators">time iterators</link>. 
  </para><anchor id="ptime_header"/><bridgehead renderas="sect3">Header</bridgehead><para><programlisting>
      #include "boost/date_time/posix_time/posix_time.hpp" //include all types plus i/o
      or
      #include "boost/date_time/posix_time/posix_time_types.hpp" //no i/o just types
    </programlisting></para><anchor id="ptime_constr"/><bridgehead renderas="sect3">Construction</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>ptime(date,time_duration)</entry><entry>Construct from a date and offset</entry><entry>
	      ptime t1(date(2002,Jan,10), time_duration(1,2,3));
	      ptime t2(date(2002,Jan,10), hours(1)+nanosec(5));
	    </entry></row><row><entry>ptime(ptime)</entry><entry>Copy constructor</entry><entry>ptime t3(t1)</entry></row><row><entry>ptime(special_values sv)</entry><entry>Constructor for infinities, not-a-date-time, max_date_time, and min_date_time</entry><entry>
	      ptime d1(neg_infin);
	      ptime d2(pos_infin);
	      ptime d3(not_a_date_time);
	      ptime d4(max_date_time);
	      ptime d5(min_date_time);</entry></row><row><entry>ptime;</entry><entry>Default constructor. Creates a ptime object initialized to not_a_date_time. NOTE: this constructor can be disabled by defining DATE_TIME_NO_DEFAULT_CONSTRUCTOR (see compiler_config.hpp)</entry><entry>ptime p; // p =&gt; not_a_date_time</entry></row></tbody></tgroup></informaltable></para><anchor id="ptime_from_string"/><bridgehead renderas="sect3">Construct from String</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>ptime time_from_string(const std::string&amp;)</entry><entry>From delimited string.</entry><entry>std::string ts("2002-01-20 23:59:59.000");
ptime t(time_from_string(ts))</entry></row><row><entry>ptime from_iso_string(const std::string&amp;)</entry><entry>From non delimited iso form string.</entry><entry>std::string ts("20020131T235959");
ptime t(from_iso_string(ts))</entry></row></tbody></tgroup></informaltable></para><anchor id="ptime_from_clock"/><bridgehead renderas="sect3">Construct from Clock</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>static ptime second_clock::local_time();</entry><entry>Get the local time, second level resolution, based on the time zone settings of the computer.</entry><entry>ptime t(second_clock::local_time())</entry></row><row><entry>static ptime second_clock::universal_time()</entry><entry>Get the UTC time.</entry><entry>ptime t(second_clock::universal_day())</entry></row><row><entry>static ptime microsec_clock::local_time()</entry><entry>Get the local time using a subsecond resolution clock.  On Unix systems this is implemented using GetTimeOfDay.  On most Win32 platforms it is implemented using ftime.  Win32 systems often do not achieve microsecond resolution via this API.  If higher resolution is critical to your application test your platform to see the acheived resolution.</entry><entry>ptime t(microsec_clock::local_time())</entry></row></tbody></tgroup></informaltable></para><anchor id="ptime_from_funcs"/><bridgehead renderas="sect3">Construct using Conversion Functions</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>ptime from_time_t(time_t t);</entry><entry>Converts a time_t into a ptime.</entry><entry>ptime t = from_time_t(tt);</entry></row><row><entry>ptime from_ftime&lt;ptime&gt;(FILETIME ft);</entry><entry>Creates a ptime object from a FILETIME structure.</entry><entry>ptime t = from_ftime&lt;ptime&gt;(ft);</entry></row></tbody></tgroup></informaltable></para><anchor id="ptime_accessors"/><bridgehead renderas="sect3">Accessors</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>date date() const</entry><entry>Get the date part of a time.</entry><entry>
	      date d(2002,Jan,10);
	      ptime t(d, hour(1));
	      t.date() --&gt; 2002-Jan-10;
	    </entry></row><row><entry>time_duration time_of_day() const</entry><entry>Get the time offset in the day.</entry><entry>
	      date d(2002,Jan,10);
	      ptime t(d, hour(1));
	      t.time_of_day() --&gt; 01:00:00;
	    </entry></row></tbody></tgroup></informaltable></para><anchor id="ptime_to_string"/><bridgehead renderas="sect3">Conversion to String</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>std::string to_simple_string(ptime)</entry><entry>To YYYY-mmm-DD HH:MM:SS.fffffffff string where mmm 3 char month name. Fractional seconds only included if non-zero.</entry><entry>2002-Jan-01 10:00:01.123456789</entry></row><row><entry>std::string to_iso_string(ptime)</entry><entry>Convert to form YYYYMMDDTHHMMSS,fffffffff where T is the date-time separator</entry><entry>20020131T100001,123456789</entry></row><row><entry>std::string to_iso_extended_string(ptime)</entry><entry>Convert to form YYYY-MM-DDTHH:MM:SS,fffffffff where T is the date-time separator</entry><entry>2002-01-31T10:00:01,123456789</entry></row></tbody></tgroup></informaltable></para><anchor id="ptime_operators"/><bridgehead renderas="sect3">Operators</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>
	      operator==, operator!=,
	      operator&gt;, operator&lt;
	      operator&gt;=, operator&lt;=
	    </entry><entry>A full complement of comparison operators</entry><entry>t1 == t2, etc</entry></row><row><entry>ptime operator+(date_duration) const</entry><entry>Return a ptime adding a day offset</entry><entry>
	      date d(2002,Jan,1);
	      ptime t(d,minutes(5));
	      date_duration dd(1);
	      ptime t2 = t + dd;
	    </entry></row><row><entry>ptime operator-(date_duration) const</entry><entry>Return a ptime subtracting a day offset</entry><entry>
	      date d(2002,Jan,1);
	      ptime t(d,minutes(5));
	      date_duration dd(1);
	      ptime t2 = t - dd;
	    </entry></row><row><entry>ptime operator+(time_duration) const</entry><entry>Return a ptime adding a time duration</entry><entry>
	      date d(2002,Jan,1);
	      ptime t(d,minutes(5));
	      ptime t2 = t + hours(1) + minutes(2);
	    </entry></row><row><entry>ptime operator-(time_duration) const</entry><entry>Return a ptime subtracting a time duration</entry><entry>
	      date d(2002,Jan,1);
	      ptime t(d,minutes(5));
	      ptime t2 = t - minutes(2);
	    </entry></row><row><entry>time_duration operator-(ptime) const</entry><entry>Take the difference between two times.</entry><entry>
	      date d(2002,Jan,1);
	      ptime t1(d,minutes(5));
	      ptime t2(d,seconds(5));
	      time_duration t3 = t2 - t1;//negative result
	    </entry></row></tbody></tgroup></informaltable></para><link linkend="top">top</link></section><section id="date_time.posix_time.time_duration" xml:base="../libs/date_time/xmldoc/time_duration.xml"><title>Time Duration</title><link linkend="time_duration_intro">Introduction</link> --
  <link linkend="time_duration_header">Header</link> --
  <link linkend="time_duration_constr">Construction</link> --
  <link linkend="time_duration_count_constr">Count Based Construction</link> --
  <link linkend="time_duration_from_string">Construct from String</link> --
  <link linkend="time_duration_accessors">Accessors</link> --
  <link linkend="time_duration_to_string">Conversion To String</link> --
  <link linkend="time_duration_operators">Operators</link><anchor id="time_duration_intro"/><bridgehead renderas="sect3">Introduction</bridgehead><para>
    The class boost::posix_time::time_duration the base type responsible for representing a length of time. A duration can be either positive or negative. The general time_duration class provides a constructor that takes a count of the number of hours, minutes, seconds, and fractional seconds count as shown in the code fragment below. The resolution of the time_duration is configureable at compile time. See <link linkend="date_time.buildinfo">Build-Compiler Information</link> for more information. 
  </para><para><programlisting>
      using namespace boost::posix_time;
      time_duration td(1,2,3,4); //01:02:03.000000004 when resolution is nano seconds
      time_duration td(1,2,3,4); //01:02:03.000004 when resolution is micro seconds
    </programlisting></para><para>
    Several small helper classes that derive from a base time_duration, as shown below, to adjust for different resolutions. These classes can shorten code and make the intent clearer.
  </para><imagedata fileref="../../libs/date_time/doc/time_duration_inherit.png"/><para>
    As an example: 
    <programlisting>  
      using namespace boost::posix_time;
      
      time_duration td = hours(1) + seconds(10); //01:00:01
      td = hours(1) + nanosec(5); //01:00:00.000000005
    </programlisting>
    Note that the existence of the higher resolution classes (eg: nanosec) depends on the installation of the library. See <link linkend="date_time.buildinfo">Build-Compiler Information</link> for more information. 
  </para><anchor id="time_duration_header"/><bridgehead renderas="sect3">Header</bridgehead><para><programlisting>
      #include "boost/date_time/posix_time/posix_time.hpp" //include all types plus i/o
      or
      #include "boost/date_time/posix_time/posix_time_types.hpp" //no i/o just types
    </programlisting></para><anchor id="time_duration_constr"/><bridgehead renderas="sect3">Construction</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>time_duration(hours,minutes,seconds,fractional_seconds)</entry><entry>Construct ad duration from the counts</entry><entry>time_duration td(1,2,3,9); //1 hr 2 min 3 sec 9 nanoseconds</entry></row></tbody></tgroup></informaltable></para><anchor id="time_duration_count_constr"/><bridgehead renderas="sect3">Count Based Construction</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>hours(long)</entry><entry>Number of hours</entry><entry>time_duration td = hours(3);</entry></row><row><entry>minutes(long)</entry><entry>Number of minutes</entry><entry>time_duration td = minutes(3);</entry></row><row><entry>seconds(long)</entry><entry> Number of seconds</entry><entry>time_duration td = seconds(3);</entry></row><row><entry>millisec(long)</entry><entry>Number of milliseconds.</entry><entry>time_duration td = millisec(3);</entry></row><row><entry>microsec(long)</entry><entry>Number of microseconds.</entry><entry>time_duration td = microsec(3);</entry></row><row><entry>nanosec(long)</entry><entry>Number of nanoseconds.</entry><entry>time_duration td = nanosec(3);</entry></row></tbody></tgroup></informaltable></para><anchor id="time_duration_from_string"/><bridgehead renderas="sect3">Construct from String</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>time_duration duration_from_string(const std::string&amp;)</entry><entry>From delimited string.</entry><entry>
	      std::string ts("23:59:59.000");
	      time_duration td(duration_from_string(ts))
	    </entry></row></tbody></tgroup></informaltable></para><anchor id="time_duration_accessors"/><bridgehead renderas="sect3">Accessors</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>long hours() const</entry><entry>Get the number of normalized hours.</entry><entry>time_duration td(1,2,3); td.hours() --&gt; 1</entry></row><row><entry>long minutes() const</entry><entry>Get the number of minutes normalized (0..59).</entry><entry>time_duration td(1,2,3); td.minutes() --&gt; 2</entry></row><row><entry>long seconds() const</entry><entry>Get the normalized number of second (0..59).</entry><entry>time_duration td(1,2,3); td.seconds() --&gt; 3</entry></row><row><entry>long total_seconds() const</entry><entry>Get the total number of seconds truncating any fractional seconds.</entry><entry>
	      time_duration td(1,2,3,10);
	      td.total_seconds() --&gt; (1*3600) + (2*60) + 3 == 3723
	    </entry></row><row><entry>long fractional_seconds() const</entry><entry>Get the number of fractional seconds.</entry><entry>time_duration td(1,2,3, 1000); td.fractional_seconds() --&gt; 1000</entry></row><row><entry>bool is_negative() const</entry><entry>True if duration is negative.</entry><entry>time_duration td(-1,0,0); td.is_negative() --&gt; true</entry></row><row><entry>time_duration invert_sign() const</entry><entry>Generate a new duration with the sign inverted/</entry><entry>time_duration td(-1,0,0); td.invert_sign() --&gt; 01:00:00</entry></row><row><entry>static boost::date_time::time_resolutions resolution()</entry><entry>Describes the resolution capability of the time_duration class. time_resolutions is an enum of resolution possibilities ranging from seconds to nanoseconds.</entry><entry>time_duration::resolution() --&gt; nano</entry></row><row><entry>static time_duration::num_fractional_digits()</entry><entry>Returns an unsigned short holding the number of fractional digits the time resolution has.</entry><entry>time_duration::num_fractional_digits(); // 9 for nano, 6 for micro, etc.</entry></row><row><entry>boost::int64_t ticks()</entry><entry>Return the raw count of the duration type.</entry><entry>time_duration td(0,0,0, 1000); td.ticks() --&gt; 1000</entry></row><row><entry>static time_duration unit()</entry><entry>Return smallest possible unit of duration type (1 nanosecond).</entry><entry>time_duration::unit() --&gt; time_duration(0,0,0,1)</entry></row></tbody></tgroup></informaltable></para><anchor id="time_duration_to_string"/><bridgehead renderas="sect3">Conversion To String</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>std::string to_simple_string(time_duration)</entry><entry>To HH:MM:SS.fffffffff were fff is fractional seconds that are only included if non-zero.</entry><entry>10:00:01.123456789</entry></row><row><entry>std::string to_iso_string(time_duration)</entry><entry>Convert to form HHMMSS,fffffffff.</entry><entry>100001,123456789</entry></row></tbody></tgroup></informaltable></para><anchor id="time_duration_operators"/><bridgehead renderas="sect3">Operators</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>
	      operator==, operator!=,
	      operator&gt;, operator&lt;
	      operator&gt;=, operator&lt;=
	    </entry><entry>A full complement of comparison operators</entry><entry>dd1 == dd2, etc</entry></row><row><entry>time_duration operator+(time_duration) const</entry><entry>Add durations.</entry><entry>
	      time_duration td1(hours(1)+minutes(2));
	      time_duration td2(seconds(10));
	      time_duration td3 = td1 + td2;
	    </entry></row><row><entry>time_duration operator-(time_duration) const</entry><entry>Subtract durations.</entry><entry>
	      time_duration td1(hours(1)+nanosec(2));
	      time_duration td2 = td1 - minutes(1);
	    </entry></row><row><entry>time_duration operator/(int) const</entry><entry>Divide the length of a duration by an integer value. Discards any remainder.</entry><entry>
	      hours(3)/2 == time_duration(1,30,0);
	      nanosec(3)/2 == nanosec(1)
	    </entry></row><row><entry>time_duration operator*(int) const</entry><entry>Multiply the length of a duration by an integer value.</entry><entry>hours(3)*2 == hours(6);</entry></row></tbody></tgroup></informaltable></para><link linkend="top">top</link></section><section id="date_time.posix_time.time_period" xml:base="../libs/date_time/xmldoc/time_period.xml"><title>Time Period</title><link linkend="time_period_intro">Introduction</link> --
  <link linkend="time_period_header">Header</link> --
  <link linkend="time_period_constr">Construction</link> --
  <link linkend="time_period_accessors">Accessors</link> --
  <link linkend="time_period_to_string">Conversion To String</link> --
  <link linkend="time_period_operators">Operators</link><anchor id="time_period_intro"/><bridgehead renderas="sect3">Introduction</bridgehead><para>
    The class boost::posix_time::time_period provides direct representation for ranges between two times. Periods provide the ability to simplify some types of calculations by simplifying the conditional logic of the program. 
  </para><para>
    The <link linkend="date_time.examples.time_periods">time periods example</link> provides an example of using time periods. 
  </para><anchor id="time_period_header"/><bridgehead renderas="sect3">Header</bridgehead><para><programlisting>
      #include "boost/date_time/posix_time/posix_time.hpp" //include all types plus i/o
      or
      #include "boost/date_time/posix_time/posix_time_types.hpp" //no i/o just types
    </programlisting></para><anchor id="time_period_constr"/><bridgehead renderas="sect3">Construction</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>time_period(ptime begin, ptime end)</entry><entry> Create a period as [begin, end). If last is &lt;= begin then the period will be defined as null.</entry><entry>
	      date d(2002,Jan,01);
	      ptime t(d, seconds(10)); //10 sec after midnight
	      time_period tp(t, hours(3));
	    </entry></row><row><entry>time_period(ptime start, time_duration len)</entry><entry> Create a period as [begin, begin+len). If len is &lt;= zero then the period will be defined as null.</entry><entry>
	      date d(2002,Jan,01);
	      ptime t1(d, seconds(10)); //10 sec after midnight
	      ptime t2(d, hours(10)); //10 hours after midnight
	      time_period tp(t1, t2);
	    </entry></row><row><entry>time_period(time_period rhs)</entry><entry> Copy constructor</entry><entry>time_period tp1(tp)</entry></row></tbody></tgroup></informaltable></para><anchor id="time_period_accessors"/><bridgehead renderas="sect3">Accessors</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>ptime begin() const</entry><entry>Return first time of period.</entry><entry>
	      date d(2002,Jan,01);
	      ptime t1(d, seconds(10)); //10 sec after midnight
	      ptime t2(d, hours(10)); //10 hours after midnight
	      time_period tp(t1, t2); tp.begin() --&gt; 2002-Jan-01 00:00:10
	    </entry></row><row><entry>ptime last() const</entry><entry>Return last time in the period</entry><entry>
	      date d(2002,Jan,01);
	      ptime t1(d, seconds(10)); //10 sec after midnight
	      ptime t2(d, hours(10)); //10 hours after midnight
	      time_period tp(t1, t2); tp.last() --&gt; 2002-Jan-01 09:59:59.999999999
	    </entry></row><row><entry>ptime end() const</entry><entry> Return one past the last in period</entry><entry>
	      date d(2002,Jan,01);
	      ptime t1(d, seconds(10)); //10 sec after midnight
	      ptime t2(d, hours(10)); //10 hours after midnight
	      time_period tp(t1, t2); tp.last() --&gt; 2002-Jan-01 10:00:00
	    </entry></row><row><entry>time_duration length() const</entry><entry>Return the length of the time period.</entry><entry>
	      date d(2002,Jan,01);
	      ptime t1(d); //midnight
	      time_period tp(t1, hours(1));
	      tp.length() --&gt; 1 hour
	    </entry></row><row><entry>bool is_null() const</entry><entry>True if period is not well formed. eg: start less than end</entry><entry/></row><row><entry>bool contains(ptime) const</entry><entry>True if ptime is within the period</entry><entry>
	      date d(2002,Jan,01);
	      ptime t1(d, seconds(10)); //10 sec after midnight
	      ptime t2(d, hours(10)); //10 hours after midnight
	      ptime t3(d, hours(2)); //2 hours after midnight
	      time_period tp(t1, t2); tp.contains(t3) --&gt; true
	    </entry></row><row><entry>bool contains(time_period) const</entry><entry>True if period is within the period</entry><entry>
	      time_period tp1(ptime(d,hours(1)), ptime(d,hours(12)));
	      time_period tp2(ptime(d,hours(2)), ptime(d,hours(4)));
	      tp1.contains(tp2) --&gt; true
	      tp2.contains(tp1) --&gt; false
	    </entry></row><row><entry>bool intersects(time_period) const</entry><entry> True if periods overlap</entry><entry>
	      time_period tp1(ptime(d,hours(1)), ptime(d,hours(12)));
	      time_period tp2(ptime(d,hours(2)), ptime(d,hours(4)));
	      tp2.intersects(tp1) --&gt; true
	    </entry></row><row><entry>time_period intersection(time_period) const</entry><entry>Calculate the intersection of 2 periods. Null if no intersection.</entry><entry/></row><row><entry>time_period merge(time_period) const</entry><entry>Returns union of two periods. Null if no intersection.</entry><entry/></row><row><entry>time_period span(time_period) const</entry><entry>Combines two periods and any gap between them such that start = min(p1.start, p2.start) and end = max(p1.end , p2.end).</entry><entry/></row><row><entry>time_period shift(date_duration)</entry><entry>Add duration to both start and end.</entry><entry/></row></tbody></tgroup></informaltable></para><anchor id="time_period_to_string"/><bridgehead renderas="sect3">Conversion To String</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>std::string to_simple_string(time_period dp)</entry><entry>To [YYYY-mmm-DD hh:mm:ss.fffffffff/YYYY-mmm-DD hh:mm:ss.fffffffff] string where mmm is 3 char month name.</entry><entry>[2002-Jan-01 01:25:10.000000001/2002-Jan-31 01:25:10.123456789]</entry></row></tbody></tgroup></informaltable></para><anchor id="time_period_operators"/><bridgehead renderas="sect3">Operators</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>operator&lt;&lt;</entry><entry>Output streaming operator for time duration. Uses facet to output [date time_of_day/date time_of_day]. The default is format is [YYYY-mmm-DD hh:mm:ss.fffffffff/YYYY-mmm-DD hh:mm:ss.fffffffff] string where mmm is 3 char month name.</entry><entry>[2002-Jan-01 01:25:10.000000001/2002-Jan-31 01:25:10.123456789]</entry></row><row><entry>operator==, operator!=</entry><entry>Equality operators. Periods are equal if p1.begin == p2.begin &amp;&amp; p1.last == p2.last</entry><entry>if (tp1 == tp2) {...</entry></row><row><entry>operator&lt;</entry><entry>Ordering with no overlap. True if tp1.end() less than tp2.begin()</entry><entry>if (tp1 &lt; tp2) {...</entry></row><row><entry>operator&gt;</entry><entry>Ordering with no overlap. True if tp1.begin() greater than tp2.end()</entry><entry>if (tp1 &gt; tp2) {... etc</entry></row><row><entry>operator&lt;=, operator&gt;=</entry><entry>Defined in terms of the other operators.</entry><entry/></row></tbody></tgroup></informaltable></para><link linkend="top">top</link></section><section id="date_time.posix_time.time_iterators" xml:base="../libs/date_time/xmldoc/time_iterators.xml"><title>Time Iterators</title><link linkend="time_iter_intro">Introduction</link> --
  <link linkend="time_iter_header">Header</link> --
  <link linkend="time_iter_overview">Overview</link> --
  <link linkend="time_iter_operators">Operators</link><anchor id="time_iter_intro"/><bridgehead renderas="sect3">Introduction</bridgehead><para>
    Time iterators provide a mechanism for iteration through times. Time iterators are similar to <ulink url="http://www.sgi.com/tech/stl/BidirectionalIterator.html">Bidirectional Iterators</ulink>. However, time_iterators are different than standard iterators in that there is no underlying sequence, just a calculation function. In addition, time_iterators are directly comparable against instances of <link linkend="date_time.posix_time.ptime_class">class ptime</link>. Thus a second iterator for the end point of the iteration is not required, but rather a point in time can be used directly. For example, the following code iterates using a 15 minute iteration interval. The <link linkend="date_time.examples.print_hours">print hours</link> example also illustrates the use of the time_iterator. 
  </para><para><programlisting>
      
	#include "boost/date_time/posix_time/posix_time.hpp"
	#include &lt;iostream&gt;


	int
	main()
	{
	  using namespace boost::gregorian;
	  using namespace boost::posix_time;
	  date d(2000,Jan,20);
	  ptime start(d);
	  ptime end = start + hours(1);
	  time_iterator titr(start,minutes(15)); //increment by 15 minutes
	  //produces 00:00:00, 00:15:00, 00:30:00, 00:45:00
	  while (titr &lt; end) {
	    std::cout &lt;&lt; to_simple_string(*titr) &lt;&lt; std::endl;
	    ++titr;
	  }
	  std::cout &lt;&lt; "Now backward" &lt;&lt; std::endl;
	  //produces 01:00:00, 00:45:00, 00:30:00, 00:15:00
	  while (titr &gt; start) {
	    std::cout &lt;&lt; to_simple_string(*titr) &lt;&lt; std::endl;
	    --titr;
	  }
	}
      
    </programlisting></para><anchor id="time_iter_header"/><bridgehead renderas="sect3">Header</bridgehead><para><programlisting>
      #include "boost/date_time/posix_time/posix_time.hpp" //include all types plus i/o
      or
      #include "boost/date_time/posix_time/posix_time_types.hpp" //no i/o just types
    </programlisting></para><anchor id="time_iter_overview"/><bridgehead renderas="sect3">Overview</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Class</entry><entry>Construction Parameters</entry><entry>Description</entry></row></thead><tbody><row><entry>time_iterator</entry><entry>ptime start_time, time_duration increment</entry><entry>Iterate incrementing by the specified duration.</entry></row></tbody></tgroup></informaltable></para><anchor id="time_iter_operators"/><bridgehead renderas="sect3">Operators</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Syntax</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>
	      operator==(const ptime&amp; rhs),
	      operator!=(const ptime&amp; rhs),
	      operator&gt;, operator&lt;
	      operator&gt;=, operator&lt;=
	    </entry><entry>A full complement of comparison operators</entry><entry>
	      date d(2002,Jan,1);
	      ptime start_time(d, hours(1));
	      //increment by 10 minutes
	      time_iterator titr(start_time, minutes(10));
	      ptime end_time = start_time + hours(2);
	      if (titr == end_time) // false
	      if (titr != end_time) // true
	      if (titr &gt;= end_time) // false
	      if (titr &lt;= end_time) // true
	    </entry></row><row><entry>prefix increment</entry><entry>Increment the iterator by the specified duration.</entry><entry>
	      //increment by 10 milli seconds
	      time_iterator titr(start_time, milliseconds(10));
	      ++titr; // == start_time + 10 milliseconds
	    </entry></row><row><entry>prefix decrement</entry><entry>Decrement the iterator by the specified time duration.</entry><entry>Example time_iterator titr(start_time, time_duration(1,2,3));
--titr; // == start_time - 1 hour, 2 minutes, and 3 seconds</entry></row></tbody></tgroup></informaltable></para><link linkend="top">top</link></section><section id="date_time.posix_time.local_time_adjust" xml:base="../libs/date_time/xmldoc/local_time_adjust.xml"><title>Local Time Adjustment</title><link linkend="local_utc_intro">Introduction</link> --
  <link linkend="local_utc_header">Header</link> --
  <link linkend="local_utc_overview">Overview</link><anchor id="local_utc_intro"/><bridgehead renderas="sect3">Introduction</bridgehead><para>
    A frequent problem in time representation is the conversion between various local time systems. In general this is accomplished by using a reference time system. The reference time system is typically UTC. 
  </para><para>
    Since the posix_time system does no internal time adjustment it can be used to represent both local times and UTC times. However, the user is currently left to handle conversions and time zone knowledge explicitly. 
  </para><para>
    The library offers two different ways to perform UTC to local conversions. The first is using the time zone settings of the computer. This is a useful solution for converting a UTC time for a user machine. This approach depends on the ctime API and will provide incorrect results if the environment is set incorrectly. The other approach allows conversion from any zone to UTC and back independent of the settings of the time zone settings of the computer. The <link linkend="date_time.examples.local_utc_conversion">local utc conversion example</link> demonstrates both of these techniques. 
  </para><anchor id="local_utc_header"/><bridgehead renderas="sect3">Header</bridgehead><para><programlisting>
      #include "boost/date_time/gregorian/gregorian.hpp" //include all types plus i/o
      or
      #include "boost/date_time/gregorian/gregorian_types.hpp" //no i/o just types
    </programlisting></para><anchor id="local_utc_overview"/><bridgehead renderas="sect3">Overview</bridgehead><para><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Class</entry><entry>Description</entry><entry>Example</entry></row></thead><tbody><row><entry>date_time::c_local_adjustor&lt;ptime&gt;::utc_to_local(ptime)</entry><entry>Calculate local machine time from a UTC time based on time zone settings and the C API.</entry><entry>
	      typedef boost::date_time::c_local_adjustor&lt;ptime&gt; local_adj;
	      ptime t10(date(2002,Jan,1), hours(7));
	      ptime t11 = local_adj::utc_to_local(t10);
	    </entry></row><row><entry>date_time::local_adjustor&lt;ptime, utc_offset, dst_rules&gt;::utc_to_local(ptime)</entry><entry>Calculate local machine time from a UTC time based daylight savings rules and utc offset</entry><entry><link linkend="date_time.examples.local_utc_conversion">example</link></entry></row><row><entry>date_time::local_adjustor&lt;ptime, utc_offset, dst_rules&gt;::local_to_utc(ptime)</entry><entry>Calculate UTC time based on daylight savings rules and utc offset.</entry><entry><link linkend="date_time.examples.local_utc_conversion">example</link></entry></row></tbody></tgroup></informaltable></para><link linkend="top">top</link></section></section><section id="date_time.details" xml:base="../libs/date_time/xmldoc/details.xml"><title>Details</title><section id="date_time.calculations" xml:base="../libs/date_time/xmldoc/calculations.xml"><title>Calculations</title><para><link linkend="timepoints">Timepoints</link> -- 
    <link linkend="durations">Durations</link> -- 
    <link linkend="intervals">Intervals (Periods)</link> -- 
    <link linkend="special_value_handling">Special Value Handling</link></para><anchor id="timepoints"/><bridgehead renderas="sect3">Timepoints</bridgehead><para>
    This section describes some of basic arithmetic rules that can be performed with timepoints. In general, Timepoints support basic arithmetic in conjunction with Durations as follows:
    <programlisting>
      Timepoint + Duration  --&gt; Timepoint
      Timepoint - Duration  --&gt; Timepoint
      Timepoint - Timepoint --&gt; Duration
    </programlisting>
    Unlike regular numeric types, the following operations are undefined:
    <programlisting>
      Duration + Timepoint  --&gt; Undefined
      Duration - Timepoint  --&gt; Undefined
      Timepoint + Timepoint --&gt; Undefined
    </programlisting></para><anchor id="durations"/><bridgehead renderas="sect3">Durations</bridgehead><para>
    Durations represent a length of time and can have positive and negative values. It is frequently useful to be able to perform calculations with other durations and with simple integral values. The following describes these calculations:
    <programlisting>
      Duration + Duration  --&gt; Duration
      Duration - Duration  --&gt; Duration
      
      Duration * Integer   --&gt; Duration
      Integer  * Duration  --&gt; Duration
      Duration / Integer   --&gt; Duration  (Integer Division rules)
    </programlisting></para><anchor id="intervals"/><bridgehead renderas="sect3">Intervals (Periods)</bridgehead><para>
    Interval logic is extremely useful for simplifying many 'calculations' for dates and times. The following describes the operations provided by periods which are based on half-open range. The following operations calculate new time periods based on two input time periods: 
    <programlisting>
      Timeperiod intersection Timeperiod --&gt; Timeperiod (null interval if no intersection)
      Timeperiod merge Timeperiod        --&gt; Timeperiod (null interval if no intersection)
      Timeperiod shift Duration          --&gt; Timeperiod (shift start and end by duration amount)
    </programlisting>
    In addition, periods support various queries that calculate boolean results. The first set is caluculations with other time periods:
    <programlisting>
      Timeperiod == Timeperiod           --&gt; bool
      Timeperiod &lt; Timeperiod            --&gt; bool (true if lhs.last &lt;= rhs.begin)
      Timeperiod intersects Timeperiod   --&gt; bool
      Timeperiod contains Timeperiod     --&gt; bool
      Timeperiod is_adjacent Timeperiod  --&gt; bool 
    </programlisting>
    The following calculations are performed versus the Timepoint.
    <programlisting>
      Timeperiod contains Timepoint      --&gt; bool
      Timeperiod is_before Timepoint     --&gt; bool
      Timeperiod is_after Timepoint      --&gt; bool 
    </programlisting></para><anchor id="special_value_handling"/><bridgehead renderas="sect3">Special Value Handling</bridgehead><para>
    For many temporal problems it is useful for Duration and Timepoint types to support special values such as Not A Date Time (NADT) and infinity. In general special values such as Not A Date Time (NADT) and infinity should follow rules like floating point values. Note that it should be possible to configure NADT based systems to throw an exception instead of result in NADT. 
    <programlisting>
      Timepoint(NADT) + Duration --&gt; Timepoint(NADT)
      Timepoint(&#x221E;) + Duration    --&gt; Timepoint(&#x221E;)
      Timepoint + Duration(&#x221E;)    --&gt; Timepoint(&#x221E;)
      Timepoint - Duration(&#x221E;)    --&gt; Timepoint(-&#x221E;)
    </programlisting>
    When performing operations on both positive and negative infinities, the library will produce results consistent with the following. 
    <programlisting>
      Timepoint(+&#x221E;) + Duration(-&#x221E;) --&gt; NADT
      Duration(+&#x221E;) + Duration(-&#x221E;)  --&gt; NADT
      Duration(&#xB1;&#x221E;) * Zero          --&gt; NADT
      
      Duration(&#x221E;) * Integer(Not Zero) --&gt; Duration(&#x221E;)
      Duration(+&#x221E;) * -Integer         --&gt; Duration(-&#x221E;)
      Duration(&#x221E;) / Integer           --&gt; Duration(&#x221E;)
    </programlisting></para></section><section id="date_time.design_goals" xml:base="../libs/date_time/xmldoc/design_goals.xml"><title>Design Goals</title><informaltable frame="all"><tgroup cols="3"><thead><row><entry>Category</entry><entry>Description</entry><entry>Functions</entry></row></thead><tbody><row><entry>Interfaces</entry><entry>Provide concrete classes for manipulation of dates and times</entry><entry><itemizedlist mark="bullet"><listitem>
		date, time, date_duration, time_duration, date_period, time_period, etc 
	      </listitem><listitem>
		support for infinity - positive infinity, negative infinity 
	      </listitem><listitem>
		iterators over time and date ranges 
	      </listitem><listitem>
		allow date and time implementations to be separate as much as possible
	      </listitem></itemizedlist></entry></row><row><entry>Calculation</entry><entry>Provide a basis for performing efficient time calculations </entry><entry><itemizedlist mark="bullet"><listitem>days between dates </listitem><listitem>durations of times </listitem><listitem>durations of dates and times together </listitem></itemizedlist></entry></row><row><entry>Representation Flexibility</entry><entry>Provide the maximum possible reusability and flexibility</entry><entry><itemizedlist mark="bullet"><listitem>
		traits based customization of internal
	        representations for size versus resolution control
	      </listitem><listitem>
		Allowing the use of different epochs and resolution
	        (eg: seconds versus microseconds, dates starting at the 
	        year 2000 versus dates starting in 1700)
	      </listitem><listitem>
		Options for configuring unique calendar representations 
		(Gregorian + others)
	      </listitem><listitem>
		the use of Julian Day number and the conversion between 
		this and the Gregorian/Julian calendar date
	      </listitem><listitem>Allow for flexible adjustments including 
		leap seconds
	      </listitem></itemizedlist></entry></row><row><entry>Date Calculations</entry><entry>Provide tools for date calculations</entry><entry><itemizedlist mark="bullet"><listitem>provide basis for calculation of complex event specs like holidays</listitem><listitem>calendar to calendar conversions</listitem><listitem>provide for ability to extend to new calendar systems</listitem></itemizedlist></entry></row><row><entry>Time Calculations</entry><entry>Provide concrete classes for manipulation of time</entry><entry><itemizedlist mark="bullet"><listitem>provide the ability to handle cross time-zone issues</listitem><listitem>provide adjustments for daylight savings time (summer time)</listitem></itemizedlist></entry></row><row><entry>Clock Interfaces</entry><entry>Provide classes for retrieving time current time</entry><entry><itemizedlist mark="bullet"><listitem>access to a network / high resolution time sources </listitem><listitem>retrieving the current date time information to populate classes </listitem></itemizedlist></entry></row><row><entry>I/O Interfaces</entry><entry>Provide input and output for time including</entry><entry><itemizedlist mark="bullet"><listitem>multi-lingual support </listitem><listitem>provide ISO8601 compliant time facet </listitem><listitem>use I/O facets for different local behavior </listitem></itemizedlist></entry></row></tbody></tgroup></informaltable></section><section id="date_time.tradeoffs" xml:base="../libs/date_time/xmldoc/tradeoffs.xml"><title>Tradeoffs: Stability, Predictability, and Approximations</title><bridgehead renderas="sect2">
    Unavoidable Trade-offs
  </bridgehead><para>
    The library does its best to provide everything a user could want, but there are certain inherent constraints that limit what <emphasis>any</emphasis> temporal library can do. Specifically, a user must choose which two of the following three capabilities are desired in any particular application:
    <itemizedlist mark="bullet"><listitem>exact agreement with wall-clock time</listitem><listitem>accurate math, e.g. duration calculations</listitem><listitem>ability to handle timepoints in the future</listitem></itemizedlist>
    Some libraries may implicitly promise to deliver all three, but if you actually put them to the test, only two can be true at once. This limitation is not a deficiency in the design or implementation of any particular library; rather it is a consequence of the way different time systems are defined by international standards. Let's look at each of the three cases:
  </para><para>
    If you want exact agreement with wall-clock time, you must use either UTC or local time. If you compute a duration by subtracting one UTC time from another and you want an answer accurate to the second, the two times must not be too far in the future because leap seconds affect the count but are only determined about 6 months in advance. With local times a future duration calculation could be off by an entire hour, since legislatures can and do change DST rules at will. 
  </para><para>
    If you want to handle wall-clock times in the future, you won't be able (in the general case) to calculate exact durations, for the same reasons described above. 
  </para><para>
    If you want accurate calculations with future times, you will have to use TAI or an equivalent, but the mapping from TAI to UTC or local time depends on leap seconds, so you will not have exact agreement with wall-clock time. 
  </para><bridgehead renderas="sect2">
    Stability, Predictability, and Approximations
  </bridgehead><para>
    Here is some underlying theory that helps to explain what's going on. Remember that a temporal type, like any abstract data type (ADT), is a set of values together with operations on those values. 
  </para><bridgehead renderas="sect3">
    Stability
  </bridgehead><para>
    The representation of a type is <emphasis>stable</emphasis> if the bit pattern associated with a given value does not change over time. A type with an unstable representation is unlikely to be of much use to anyone, so we will insist that any temporal library use only stable representations. 
  </para><para>
    An operation on a type is stable if the result of applying the operation to a particular operand(s) does not change over time. 
  </para><bridgehead renderas="sect3">
    Predictability
  </bridgehead><para>
    Sets are most often classified into two categories: well-defined and ill-defined. Since a type is a set, we can extend these definitions to cover types. For any type T, there must be a predicate <emphasis>is_member( x )</emphasis> which determines whether a value x is a member of type T. This predicate must return <emphasis>true, false,</emphasis> or <emphasis>dont_know</emphasis>. 
  </para><para>
    If for all x, is_member( x ) returns either true or false, we say the set T is <emphasis>well-defined</emphasis>. 
  </para><para>
    If for any x, is_member( x ) returns dont_know, we say the set T is <emphasis>ill-defined</emphasis>. 
  </para><para>
    Those are the rules normally used in math. However, because of the special characteristics of temporal types, it is useful to refine this view and create a third category as follows: 
  </para><para>
    For any temporal type T, there must be a predicate <emphasis>is_member( x, t )</emphasis> which determines whether a value x is a member of T. The parameter t represents the time when the predicate is evaluated. For each x<subscript>i</subscript>, there must be a time t<subscript>i</subscript> and a value v such that: 
    <itemizedlist mark="bullet"><listitem>v = true or v = false, and</listitem><listitem>for all t &lt; t<subscript>i</subscript>, is_member( x<subscript>i</subscript>, t ) returns dont_know, and</listitem><listitem>for all t &gt;= t<subscript>i</subscript>, is_member( x<subscript>i</subscript>, t ) returns v.</listitem></itemizedlist>
    t<subscript>i</subscript> is thus the time when we "find out" whether x<subscript>i</subscript> is a member of T. Now we can define three categories of temporal types:
  </para><para>
    If for all x<subscript>i</subscript>, t<subscript>i</subscript> = negative infinity, we say the type T is <emphasis>predictable</emphasis>. 
  </para><para>
    If for some x<subscript>i</subscript>, t<subscript>i</subscript> = positive infinity, we say the type T is <emphasis>ill-formed</emphasis>. 
  </para><para>
    Otherwise we say the type T is <emphasis>unpredictable</emphasis> (this implies that for some x<subscript>i</subscript>, t<subscript>i</subscript> is finite). 
  </para><para>
    Ill-formed sets are not of much practical use, so we will not discuss them further. In plain english the above simply says that all the values of a predictable type are known ahead of time, but some values of an unpredictable type are not known until some particular time. 
  </para><bridgehead renderas="sect3">
    Stability of Operations
  </bridgehead><para>
    Predictable types have a couple of important properties: 
    <itemizedlist mark="bullet"><listitem>there is an order-preserving mapping from their elements onto a set of consecutive integers, and</listitem><listitem>duration operations on their values are stable</listitem></itemizedlist></para><para>
    The practical effect of this is that duration calculations can be implemented with simple integer subtraction. Examples of predictable types are TAI timepoints and Gregorian dates.
  </para><para>
    Unpredictable types have exactly the opposite properties: 
    <itemizedlist mark="bullet"><listitem>there is no order-preserving mapping from their elements onto a set of consecutive integers, and</listitem><listitem>duration operations on their values are not stable. </listitem></itemizedlist></para><para>
    Examples of unpredictable types are UTC timepoints and Local Time timepoints.
  </para><para>
    We can refine this a little by saying that a range within an unpredicatable type can be predictable, and operations performed entirely on values within that range will be stable. For example, the range of UTC timepoints from 1970-01-01 through the present is predictable, so calculations of durations within that range will be stable. 
  </para><bridgehead renderas="sect3">
    Approximations
  </bridgehead><para>
    These limitations are problematical, because important temporal types like UTC and Local Time are in fact unpredictable, and therefore operations on them are sometimes unstable. Yet as a practical matter we often want to perform this kind of operation, such as computing the duration between two timepoints in the future that are specified in Local Time. 
  </para><para>
    The best the library can do is to provide an approximation, which is generally possible and for most purposes will be good enough. Of course the documentation must specify when an answer will be approximate (and thus unstable) and how big the error may be. In many respects calculating with unpredictable sets is analogous to the use of floating point numbers, for which results are expected to only be approximately correct. Calculating with predictable sets would then be analogous to the user of integers, where results are expected to be exact. 
  </para><para>
    For situations where exact answers are required or instability cannot be tolerated, the user must be able to specify this, and then the library should throw an exception if the user requests a computation for which an exact, stable answer is not possible. 
  </para></section><section id="date_time.serialization" xml:base="../libs/date_time/xmldoc/serialization.xml"><title>Serialization</title><para>
    The boost::date_time library is compatible with the boost::serialization library's text and xml archives. The list of classes that are serializable are:
  </para><bridgehead renderas="sect3">boost::gregorian</bridgehead><informaltable frame="all" pgwide="1"><tgroup cols="3"><tbody><row><entry><link linkend="date_time.gregorian.date_class">date</link></entry><entry><link linkend="date_time.gregorian.date_duration">date_duration</link></entry><entry><link linkend="date_time.gregorian.date_period">date_period</link></entry></row><row><entry><link linkend="date_time.gregorian.date_algorithms">partial_date</link></entry><entry><link linkend="date_time.gregorian.date_algorithms">nth_day_of_week_in_month</link></entry><entry><link linkend="date_time.gregorian.date_algorithms">first_day_of_week_in_month</link></entry></row><row><entry><link linkend="date_time.gregorian.date_algorithms">last_day_of_week_in_month</link></entry><entry><link linkend="date_time.gregorian.date_algorithms">first_day_of_week_before</link></entry><entry><link linkend="date_time.gregorian.date_algorithms">first_day_of_week_after</link></entry></row><row><entry>greg_month</entry><entry>greg_day</entry><entry>greg_weekday</entry></row></tbody></tgroup></informaltable><bridgehead renderas="sect3">boost::posix_time</bridgehead><informaltable frame="all" pgwide="1"><tgroup cols="3"><tbody><row><entry><link linkend="date_time.posix_time.ptime_class">ptime</link></entry><entry><link linkend="date_time.posix_time.time_duration">time_duration</link></entry><entry><link linkend="date_time.posix_time.time_period">time_period</link></entry></row></tbody></tgroup></informaltable><para>
    No extra steps are required to build the date_time library for serialization use.
  </para><para>
    Example text_archive usage:
    <programlisting>
      using namespace boost::posix_time;
      using namespace boost::gregorian;
      ptime pt(date(2002, Feb, 14)), hours(10)), pt2(not_a_date_time);
      std::ofstream ofs("tmp_file");
      archive::test_oarchive oa(ofs);
      oa &lt;&lt; pt;                        // NOTE: no macro
      ofs.close();
      std::ifstream ifs("tmp_file");
      archive::text_iarchive ia(ifs);
      ia &gt;&gt; pt2;                       // NOTE: no macro
      ifs.close();
      pt == pt2; // true</programlisting></para><para>
    Example xml_archive usage:
    <programlisting>
      using namespace boost::gregorian;
      date d(2002, Feb, 14), d2(not_a_date_time);
      std::ofstream ofs("tmp_file");
      archive::xml_oarchive oa(ofs);
      oa &lt;&lt; BOOST_SERIALIZATION_NVP(d); // macro required for xml_archive
      ofs.close();
      std::ifstream ifs("tmp_file");
      archive::xml_iarchive ia(ifs);
      ia &gt;&gt; BOOST_SERIALIZATION_NVP(d2); // macro required for xml_archive
      ifs.close();
      d == d2; // true</programlisting></para><para>
    To use the date_time serialization code, the proper header files must be explicitly included. The header files are:
    <programlisting>
      boost/date_time/gregorian/greg_serialize.hpp</programlisting>
    and
    <programlisting>
      boost/date_time/posix_time/time_serialize.hpp</programlisting></para></section><section id="date_time.terminology" xml:base="../libs/date_time/xmldoc/terminology.xml"><title>Terminology</title><para>
    The following are a number of terms relevant to the date-time domain. 
  </para><para>
    A taxonomy of temporal types:
    <itemizedlist mark="bullet"><listitem>Timepoint -- Specifier for a location in the time continuum. Similar to a number on a ruler.</listitem><listitem>Timelength -- A duration of time unattached to any point on the time continuum.</listitem><listitem>Timeinterval -- A duration of time attached to a specific point in the time continuum.</listitem></itemizedlist></para><para>
    And some other terms: 
    <itemizedlist mark="bullet"><listitem>Accuracy -- A measure of error, the difference between the reading of a clock and the true time.</listitem><listitem>Calendar System -- A system for labeling time points with day level resolution.</listitem><listitem>Clock Device -- A software component (tied to some hardware) that provides the current date or time with respect to a calendar or clock system.</listitem><listitem>Precision -- A measure of repeatability of a clock.</listitem><listitem>Resolution -- A specification of the smallest representable duration (eg: 1 second, 1 century) for a clock/calendar system or temporal type.</listitem><listitem>Stability -- The property of a class which says that the underlying representation (implementation) associated with a particular (abstract) value will never change.</listitem><listitem>Time System -- A system for labeling time points with higher resolution than day-level. </listitem></itemizedlist></para><para>
    Some standard date-time terminology: 
    <itemizedlist mark="bullet"><listitem>Epoch -- Starting time point of a calendar or clock system.</listitem><listitem>DST -- Daylight savings time - a local time adjustment made in some regions during the summer to shift the clock time of the daylight hours</listitem><listitem>Time zone -- A region of the earth that provides for a 'local time' defined by DST rules and UT offset.</listitem><listitem>UTC Time -- Coordinated Universal Time - Civil time system as measured at longitude zero. Kept adjusted to earth rotation by use of leap seconds. Also known as Zulu Time. Replaced the similar system known as Greenwich Mean Time. For more see <ulink url="http://aa.usno.navy.mil/faq/docs/UT.html"/></listitem><listitem>TAI Time -- A high-accuracy monotonic (need better term) time system measured to .1 microsecond resolution by atomic clocks around the world. Not adjusted to earth rotation. For more see <ulink url="http://www.bipm.fr/enus/5_Scientific/c_time/time_server.html"/></listitem></itemizedlist></para><para>
    Some more experimental ones: 
    <itemizedlist mark="bullet"><listitem>Local Time -- A time measured in a specific location of the universe.</listitem><listitem>Time Label -- A tuple that either completely or partially specifies a specific date-time with respect to a calendar or clock system. This is the year-month-day representation.</listitem><listitem>Adjusting Time Length -- A duration that represents varying physical durations depending on the moment in time. For example, a 1 month duration is typically not a fixed number of days and it depends on the date it is measured from to determine the actual length. </listitem></itemizedlist></para><para>
    These are design sorts of terms: 
    <itemizedlist mark="bullet"><listitem>Generation function -- A function that generates a specific set of time points, lengths, or intervals based on one or more parameters. </listitem></itemizedlist></para></section><section id="date_time.references" xml:base="../libs/date_time/xmldoc/references.xml"><title>References</title><para><itemizedlist mark="bullet"><listitem><link linkend="date_ref">Date References</link></listitem><listitem><link linkend="time_ref">Time References</link></listitem><listitem><link linkend="other_c_libs">Other C/C++ Libraries</link></listitem><listitem><link linkend="java_libs">JAVA Date-Time Libraries</link></listitem><listitem><link linkend="script_libs">Scripting Language Libraries</link></listitem><listitem><link linkend="related">Related Commercial and Fanciful Pages</link></listitem><listitem><link linkend="resolution">Resolution, Precision, and Accuracy</link></listitem></itemizedlist></para><anchor id="date_ref"/><bridgehead renderas="sect3">Date Calendar References</bridgehead><para><itemizedlist mark="bullet"><listitem>ISO 8601 date time standard -- <ulink url="http://www.cl.cam.ac.uk/~mgk25/iso-time.html">Summary by Markus Kuhn</ulink></listitem><listitem><ulink url="http://emr.cs.iit.edu/home/reingold/calendar-book/second-edition/">Calendrical Calculations</ulink> book by Reingold &amp; Dershowitz</listitem><listitem><ulink url="http://www.tondering.dk/claus/calendar.html">Calendar FAQ by Claus T&#xF8;ndering</ulink></listitem><listitem>Calendar zone <ulink url="http://www.calendarzone.com"/></listitem><listitem><ulink url="http://www.w3.org/TR/xmlschema-2/#dateTime">XML schema for date time</ulink></listitem><listitem>Will Linden's <ulink url="http://www.ecben.net/calendar.shtml">Calendar Links</ulink></listitem><listitem><ulink url="http://www21.brinkster.com/lonwolve/melt/index.htm">XMAS calendar melt</ulink></listitem></itemizedlist></para><anchor id="time_ref"/><bridgehead renderas="sect3">Time</bridgehead><para><itemizedlist mark="bullet"><listitem>Martin Folwer on time patterns
	<itemizedlist override="opencircle"><listitem><ulink url="http://www.aw.com/cseng/titles/0-201-89542-0/apsupp/events2-1.html">Recurring Events for Calendars</ulink></listitem><listitem>Patterns for things that <ulink url="http://martinfowler.com/ap2/timeNarrative.html">Change with time</ulink></listitem></itemizedlist></listitem><listitem>US National Institute of Standards and Technology <ulink url="http://nist.time.gov/exhibits.html">Time Exhibits</ulink></listitem><listitem>Network Time Protocol at <ulink url="http://www.ntp.org/">NTP.org</ulink></listitem><listitem>US Navy <ulink url="http://tycho.usno.navy.mil/systime.html">Systems of Time</ulink></listitem><listitem><ulink url="http://www.bipm.fr/enus/5_Scientific/c_time/time_1.html">International Atomic Time</ulink></listitem><listitem><ulink url="http://beta.zyprexia.com/docs/pgsql/user/datatype1130.htm">Date-Time type PostgreSQL</ulink> User Guide </listitem></itemizedlist></para><anchor id="other_c_libs"/><bridgehead renderas="sect3">Other C/C++ Libraries</bridgehead><para><itemizedlist mark="bullet"><listitem><ulink url="http://www.cplusplus.com/ref/ctime/index.html">ctime C</ulink> Standard library reference at cplusplus.com</listitem><listitem><ulink url="http://www.cl.cam.ac.uk/~mgk25/c-time/">XTime C extension</ulink> proposal</listitem><listitem><ulink url="http://david.tribble.com/text/c0xcalendar.html#author-info">Another C library extension proposal</ulink> by David Tribble</listitem><listitem><ulink url="http://cr.yp.to/libtai.html">libTAI</ulink> is a C based time library</listitem><listitem><ulink url="http://www.twinsun.com/tz/tz-link.htm">Time Zone Database</ulink> C library for managing timezones/places</listitem><listitem>International Components for Unicode by IBM (open source)
	<itemizedlist override="opencircle"><listitem><ulink url="http://oss.software.ibm.com/icu/userguide/dateCalendar.html">Calendar Class</ulink></listitem><listitem><ulink url="http://oss.software.ibm.com/icu/userguide/dateTime.html">Date Time Services</ulink></listitem><listitem><ulink url="http://oss.software.ibm.com/icu/userguide/dateTimezone.html">Time Zone Class</ulink></listitem><listitem><ulink url="http://oss.software.ibm.com/icu/userguide/formatDateTime.html">Date-Time Formatting</ulink></listitem></itemizedlist></listitem><listitem><ulink url="http://ringside.arc.nasa.gov/www/toolkits/julian_13/aareadme.html">Julian Library in C by Mark Showalter -- NASA</ulink></listitem></itemizedlist></para><anchor id="java_libs"/><bridgehead renderas="sect3">JAVA Date &amp; Time Library Quick Reference</bridgehead><para><itemizedlist mark="bullet"><listitem><ulink url="http://java.sun.com/products/jdk/1.1/docs/api/java.util.Calendar.html#_top_">Calendar class</ulink></listitem><listitem><ulink url="http://java.sun.com/products/jdk/1.1/docs/api/java.util.GregorianCalendar.html#_top_">Gregorian calendar</ulink></listitem><listitem><ulink url="http://java.sun.com/products/jdk/1.1/docs/api/java.util.Date.html">Date class</ulink></listitem><listitem><ulink url="http://java.sun.com/products/jdk/1.1/docs/api/java.sql.Time.html#_top_">sql.time class</ulink></listitem><listitem><ulink url="http://java.sun.com/products/jdk/1.1/docs/api/java.text.DateFormatSymbols.html#_top_">Date format symbols</ulink></listitem><listitem><ulink url="http://java.sun.com/products/jdk/1.1/docs/api/java.text.DateFormat.html#_top_">Date format</ulink></listitem><listitem><ulink url="http://java.sun.com/products/jdk/1.1/docs/api/java.text.SimpleDateFormat.html#_top_">Simple Date Format</ulink></listitem><listitem><ulink url="http://java.sun.com/products/jdk/1.1/docs/api/java.util.SimpleTimeZone.html#_top_">Simple Time Zone</ulink></listitem></itemizedlist></para><anchor id="script_libs"/><bridgehead renderas="sect3">Scripting Language Libraries</bridgehead><para><itemizedlist mark="bullet"><listitem>A python date library <ulink url="http://www.lemburg.com/files/python/mxDateTime.html">MX Date Time</ulink></listitem><listitem>Perl date-time
	<itemizedlist override="opencircle"><listitem><ulink url="http://search.cpan.org/Catalog/Data_and_Data_Type/Date">Date-Time packages at CPAN</ulink></listitem><listitem><ulink url="http://search.cpan.org/doc/TWEGNER/Date-Calc-4.3-bin56Mac/Calc.pm">Date::Calc</ulink> at CPAN</listitem><listitem><ulink url="http://search.cpan.org/doc/MORTY/DateConvert-0.16/Convert.pm">Date::Convert</ulink> calendar conversions at CPAN</listitem></itemizedlist></listitem><listitem>A PHP library <ulink url="http://vlib.activefish.com/docs/vlibDate.html">Vlib Date Library</ulink></listitem></itemizedlist></para><anchor id="related"/><bridgehead renderas="sect3">Related Commercial and Fanciful Pages</bridgehead><para><itemizedlist mark="bullet"><listitem><ulink url="http://www.leapsecond.com/java/gpsclock.htm">Leapsecond.com time</ulink> page</listitem><listitem><ulink url="http://www.worldtimeserver.com">World Time Server / TZ database</ulink></listitem><listitem><ulink url="http://www.longnow.org/10kclock/clock.htm">10000 year clock</ulink> at Long Now Foundation</listitem><listitem><ulink url="http://www.timezonesforpcs.com">Timezones for PCs</ulink></listitem></itemizedlist></para><anchor id="resolution"/><bridgehead renderas="sect3">Resolution, Precision, and Accuracy</bridgehead><para><itemizedlist mark="bullet"><listitem>Definitions with pictures from <ulink url="http://metrologyforum.tm.agilent.com/specs.shtml">Agilent Technologies</ulink></listitem><listitem>Another set of pictures from <ulink url="http://www.teamlabs.com/catalog/performance.asp">Team Labs</ulink></listitem><listitem>Definitions from <ulink url="http://www.solent.ac.uk/hydrography/notes/errorthe/accuracy.htm">Southampton Institute</ulink></listitem><listitem>Definitions from <ulink url="http://www.newport.com/Support/Tutorials/OptoMech/om4a.asp">Newport Corporation</ulink> in the context of instrumentation</listitem></itemizedlist></para></section><section id="date_time.buildinfo" xml:base="../libs/date_time/xmldoc/buildinfo.xml"><title>Build-Compiler Information</title><para><link linkend="overview">Overview</link> --
    <link linkend="compile_options">Compilation Options</link> --
    <link linkend="portability">Compiler/Portability Notes</link> --
    <link linkend="dir_structure">Directory Structure</link> --
    <link linkend="other_boost_libs">Required Boost Libraries</link></para><anchor id="overview"/><bridgehead renderas="sect3">Overview</bridgehead><para>
    The library has several functions that require the creation of a library file. The Jamfile in the build directory will produce a "static" library (libboost_date_time) and a "dynamic/shared" library (boost_date_time) that contains these functions. 
  </para><anchor id="compile_options"/><bridgehead renderas="sect3">Compilation Options</bridgehead><para>
    By default the posix_time system uses a 64 bit integer and a 32 bit integer internally to provide nano-second level resolutions. As an alternative, a single 64 bit integer can be used to provide a microsecond level resolution. This alternative implementation may provide better performance and more compact memory usage for many applications that do not require nano-second resolutions. 
  </para><para>
    To use the alternate resolution (64 bit microsecond) the variable BOOST_DATE_TIME_POSIX_TIME_STD_CONFIG must be defined in the library users project files (ie Makefile, Jamfile, etc). This macro is not used by the Gregorian system and therefore has no effect when building the library.
  </para><anchor id="portability"/><bridgehead renderas="sect3">Compiler/Portability Notes</bridgehead><para>
    The Boost Date-Time library has been built and tested with many compilers. However, some compilers and standard libraries have issues. While some of these issues can be worked around, others are difficult to work around. The following compilers fully support all aspects of the library:
    <itemizedlist mark="bullet"><listitem>GCC 3.2-7 on Linux</listitem><listitem>GCC 2.95.3 with STLport-4.5.3 on Linux</listitem><listitem>GCC 3.1 (cygwin)</listitem><listitem>MSVC 7.1 </listitem></itemizedlist></para><para>
    In particular, a lack of support for standard locales limits the ability of the library to support iostream based input output. For these compilers a set of more limited string based input-output is provided. The compilers/standard libraries with this limitation include: 
    <itemizedlist mark="bullet"><listitem>GCC 2.9x on Linux</listitem><listitem>Borland 5.1.1 and 5.6</listitem><listitem>MSVC 6 SP5 </listitem></itemizedlist></para><para>
    Other compilers such as Comeau and Metroworks have been tested successfully with earlier versions of the library.
  </para><anchor id="dir_structure"/><bridgehead renderas="sect3">Directory Structure</bridgehead><para>
    The directory tree has the following structure:
    <programlisting>
      /boost/date_time                    -- common headers and template code
      /boost/date_time/gregoran           -- Gregorian calendar system header files
      /boost/date_time/posix_time         -- posix time system headers
      /libs/date_time/build               -- build files and output directory
      /libs/date_time/test                -- test battery for generic code
      /libs/date_time/test/gregorian      -- test battery for the Gregorian system
      /libs/date_time/test/posix_time     -- test battery for the posix_time system
      /libs/date_time/examples/posix_time -- time example programs
      /libs/date_time/examples/gregorian  -- nifty example programs
      /libs/date_time/src/gregorian       -- cpp files for libboost_date_time
      /libs/date_time/src/posix_time      -- empty (one file, but no source code...)
    </programlisting></para><anchor id="other_boost_libs"/><bridgehead renderas="sect3">Required Boost Libraries</bridgehead><para>
    The library depends on 
    <itemizedlist mark="bullet"><listitem><ulink url="../../libs/tokenizer/index.html">boost.tokenizer</ulink></listitem><listitem><ulink url="../../libs/integer/cstdint.htm">boost.integer(cstdint)</ulink></listitem><listitem><ulink url="../../libs/utility/operators.htm">boost.operators</ulink></listitem><listitem><ulink url="../../libs/conversion/lexical_cast.htm">boost::lexical_cast </ulink></listitem></itemizedlist>
    so at least these libraries need to be installed. 
  </para></section><section id="date_time.tests" xml:base="../libs/date_time/xmldoc/tests.xml"><title>Tests</title><para>
    The library provides a large number of tests in the 
    <programlisting>
      libs/date_time/test
      libs/date_time/test/gregorian
      libs/date_time/test/posix_time
    </programlisting>
    directories. Building and executing these tests assures that the installation is correct and that the library is functioning correctly. In addition, these tests facilitate the porting to new compilers. Finally, the tests provide examples of many functions not explicitly described in the usage examples. 
  </para></section><section id="date_time.changes" xml:base="../libs/date_time/xmldoc/changes.xml"><title>Change History</title><bridgehead renderas="sect3">Changes from Boost 1.31 to 1.32 (date_time 1.02 to 1.03)</bridgehead><informaltable frame="all"><tgroup cols="2"><thead><row><entry>Type</entry><entry>Description</entry></row></thead><tbody><row><entry>Bug Fix</entry><entry>Snap to end of month behavior corrected for year_functor. Previously, starting 
                 from 2000-Feb-28 (leap year and not end of month) and iterating through the next 
                 leap year would result in 2004-Feb-29 instead of 2004-Feb-28. This behavior has 
                 been corrected to produce the correct result of 2004-Feb-28. Thanks to Bart Garst 
                 for this change.
          </entry></row><row><entry>Feature</entry><entry>Free function for creating a ptime object from a FILETIME struct. This function 
                 is only available on platforms that define BOOST_HAS_FTIME.
          </entry></row><row><entry>Feature</entry><entry>Microsecond time clock is now available on most windows compilers as well as
                 Unix.
          </entry></row><row><entry>Feature</entry><entry>Use of the boost::serialization library is now available with most of the 
                 date_time classes. Classes capable of serialization are: date_generator classes, 
                 date, days, date_period, greg_month, greg_weekday, greg_day, ptime, time_duration,
                 and time_period. Thanks to Bart Garst for this change.
          </entry></row><row><entry>Feature</entry><entry>Functions added to convert date and time classes to wstring. The library now 
                 provides to_*_wstring as well as to_*_string functions for: simple, iso, 
                 iso_extended, and sql for dates and compilers that support wstrings. Thanks to 
                 Bart Garst for this change.
          </entry></row><row><entry>Feature</entry><entry>Period classes now handle zero length and NULL periods correctly. A NULL period 
                 is a period with a negative length. Thanks to Frank Wolf and Bart Garst for this 
                 change.
          </entry></row><row><entry>Feature</entry><entry>Added end_of_month function to gregorian::date to return the last day of
                 the current month represented by the date.  Result is undefined for
                 not_a_date_time or infinities.
          </entry></row><row><entry>Bug Fix</entry><entry>Removed incorrect usage of BOOST_NO_CWCHAR macro throughout library.
          </entry></row><row><entry>Feature</entry><entry>New names added for some date classes. Original names are still valid but may 
                 some day be deprecated. Changes are:
            <simplelist type="horiz" columns="3"><member>date_duration</member><member>is now</member><member>days</member><member>nth_kday_of_month</member><member>is now</member><member>nth_day_of_the_week_in_month</member><member>first_kday_of_month</member><member>is now</member><member>first_day_of_the_week_in_month</member><member>last_kday_of_month</member><member>is now</member><member>last_day_of_the_week_in_month</member><member>first_kday_after</member><member>is now</member><member>first_day_of_the_week_after</member><member>first_kday_before</member><member>is now</member><member>first_day_of_the_week_before</member></simplelist></entry></row><row><entry>Feature</entry><entry>Free functions for date generators added. Functions are: days_until_weekday, days_before_weekday, next_weekday, and previous_weekday.
            <programlisting>
              days days_until_weekday(date, greg_weekday);
              days days_before_weekday(date, greg_weekday);
              date next_weekday(date, greg_weekday);
              date previous_weekday(date, greg_weekday);</programlisting>
	    Thanks to Bart Garst for this change.
          </entry></row><row><entry>Feature</entry><entry>New experimental duration types added for months, years, and weeks. These classes 
                 also provide mathematical operators for use with date and time classes.  Be aware
                 that adding of months or years a time or date past the 28th of a month may show 
                 non-normal mathematical properties.  This is a result of 'end-of-month' 
                 snapping used in the calculation.  The last example below illustrates the    
                 issue.  
           
            <programlisting>
              months m(12);
              years y(1);
              m == y; // true
              days d(7);
              weeks w(1);
              d == w; // true
              ptime t(...);
              t += months(3);
              date d(2004,Jan,30);
              d += months(1); //2004-Feb-29
              d -= months(1); //2004-Jan-29
            </programlisting>
            Input  streaming is not yet implemented for these types.              
	    Thanks to Bart Garst for this change.
          </entry></row><row><entry>Feature</entry><entry>Unifying base class for date_generators brought in to gregorian namespace. See <link linkend="date_time.examples.print_holidays">Print Holidays Example</link>.
          </entry></row><row><entry>Feature</entry><entry>Added constructors for date and ptime that allow for default construction (both) 
                 and special values construction (ptime, both now support this). Default 
                 constructors initialize the objects to not_a_date_time (NADT).
            <programlisting>
              ptime p_nadt(not_a_date_time), p_posinf(pos_infin);
              ptime p; // p == NADT
              date d;  // d == NADT
            </programlisting>
	    Thanks to Bart Garst for this change.
          </entry></row><row><entry>Feature</entry><entry>Output streaming now supports wide stream output on compiler / standard library combinations that support wide streams. This allows code like:
	    <programlisting>
	      std::wstringstream wss;
	      date d(2003,Aug,21);
	      wss &lt;&lt; d;</programlisting>
	    Thanks to Bart Garst for this change.
	  </entry></row><row><entry>Feature</entry><entry>Input streaming for date and time types is now supported on both wide and narrow streams:
	    <programlisting>
	      date d(not_a_date_time);
	      std::stringstream ss("2000-FEB-29");
	      ss &gt;&gt; d; //Feb 29th, 2000
              std::wstringstream ws("2000-FEB-29");
              ws &gt;&gt; d; //Feb 29th, 2000
            </programlisting>
	    Thanks to Bart Garst for this change.
	  </entry></row><row><entry>Bug Fix</entry><entry> Fixed bug in duration_from_string() where a string formatted with
                  less than full amount of fractional digits created an incorrect
                  time_duration.  With microsecond resolution for time durations
                  the string "1:01:01.010" created a time duration of 
                  01:01:01.000010 instead of 01:01:01.010000
          </entry></row><row><entry>Bug Fix</entry><entry>Fixed the special value constructor for gregorian::date and posix_time::ptime 
                 when constructing with min_date_time or max_date_time.  The wrong value was 
                 constructed for these.
          </entry></row></tbody></tgroup></informaltable><bridgehead renderas="sect3">Changes from Boost 1.30 to 1.31 (date_time 1.01 to 1.02)</bridgehead><informaltable frame="all"><tgroup cols="2"><thead><row><entry>Type</entry><entry>Description</entry></row></thead><tbody><row><entry>Bug Fix</entry><entry>Build configuration updated so dll, statically, and dynamically linkable library files are now produced with MSVC compilers. See <link linkend="date_time.buildinfo">Build/Compiler Information</link> for more details.</entry></row><row><entry>Bug Fix</entry><entry>Time_duration from_string is now correctly constructed from a negative value. (ie "-0:39:00.000") Code provided by Bart Garst.</entry></row><row><entry>Bug Fix</entry><entry>Fixed many MSVC compiler warnings when compiled with warning level 4.</entry></row><row><entry>Feature</entry><entry>Added prefix decrement operator (--) for date and time iterators. See <link linkend="date_time.posix_time.time_iterators">Time Iterators</link>  and <link linkend="date_time.gregorian.date_iterators">Date Iterators</link> for more details. Code provided by Bart Garst.</entry></row><row><entry>Feature</entry><entry>Special_values functionality added for date_duration, time_duration and time classes. Code provided by Bart Garst.</entry></row><row><entry>Bug Fix</entry><entry>Fixed time_duration_traits calculation bug which was causing time duration to be limited to 32bit range even when 64 bits were available. Thanks to Joe de Guzman for tracking this down.</entry></row><row><entry>Bug Fix</entry><entry>Provided additional operators for duration types (eg: date_duration, time_duration). This includes dividable by integer and fixes to allow +=, -= operators. Thanks to Bart Garst for writing this code. Also, the documentation of <link linkend="date_time.calculations">Calculations</link> has been improved.</entry></row><row><entry>Bug Fix</entry><entry>Added typedefs to boost::gregorian gregorian_types.hpp various date_generator function classes.</entry></row><row><entry>Feature</entry><entry>Added from_time_t function to convert time_t to a ptime.</entry></row><row><entry>Feature</entry><entry>Added a span function for combining periods. See <link linkend="date_time.gregorian.date_period">date period</link> and <link linkend="date_time.posix_time.time_period">time period</link> docs.</entry></row><row><entry>Feature</entry><entry>Added a function to time_duration to get the total number of seconds in a 
                 duration truncating any fractional seconds. In addition, other resolutions 
                 were added to allow for easy conversions. For example
	    <programlisting>
               seconds(1).total_milliseconds() == 1000
               seconds(1).total_microseconds() == 1000000
               hours(1).total_milliseconds() == 3600*1000 //3600 sec/hour
               seconds(1).total_nanoseconds() == 1000000000
            </programlisting></entry></row><row><entry>Feature</entry><entry>Added output streaming operators for the <link linkend="date_time.gregorian.date_algorithms">date generator</link> classes - partial_date, first_kday_after, first_kday_before, etc. Thanks to Bart Garst for this work.</entry></row><row><entry>Feature</entry><entry>Added unary- operators for durations for reversing the sign of a time duration. For example:
	    <programlisting>
	      time_duration td(5,0,0); //5 hours
	      td = -td; //-5 hours</programlisting>
	  Thanks to Bart Garst for this work.</entry></row><row><entry>Feature</entry><entry>Added support for parsing strings with 'month names'. Thus creating a date object from string now accepts multiple formats ("2003-10-31","2003-Oct-31", and "2003-October-31"). Thus, date d = from_simple_string("2003-Feb-27") is now allowed. A bad month name string ( from_simple_string("2003-SomeBogusMonthName-27")) will cause a bad_month exception. On most compilers the string compare is case insensitive. Thanks to Bart Garst for this work.</entry></row><row><entry>Feature</entry><entry>In addition to support for month names or numbers, functions have been added to create date objects from multi-ordered date strings. Ex: "January-21-2002", "2002-Jan-21", and "21-Jan-2003". See <link linkend="date_time.gregorian.date">Date Class</link> for more details.</entry></row><row><entry>Bug-Fix</entry><entry>Various documentation fixes. Thanks to Bart Garst for updates.</entry></row></tbody></tgroup></informaltable><bridgehead renderas="sect3">Changes from Boost 1.29 to 1.30 (date_time 1.00 to 1.01)</bridgehead><para>
    Notice: The interface to the partial_date class (see <link linkend="date_time.gregorian.algorithms">date_algorithms</link>) was changed. The order of construction parameters was changed which will cause some code to fail execution. This change was made to facilitate more generic local time adjustment code. Thus instead of specifying partial_date pd(Dec,25) the code needs to be changed to partial_date pd(25, Dec); 
  </para><informaltable frame="all"><tgroup cols="2"><thead><row><entry>Type</entry><entry>Description</entry></row></thead><tbody><row><entry>Bug Fix</entry><entry>Added new experimental feature for Daylight Savings Time calculations. This allows traits based specification of dst rules.</entry></row><row><entry>Feature</entry><entry>Added new interfaces to calculate julian day and modified julian day to the gregorian date class. See <link linkend="date_time.gregorian.date">boost::gregorian::date</link>.</entry></row><row><entry>Feature</entry><entry>Add new interface to calculate iso 8601 week number for a date. See <link linkend="date_time.gregorian.date">boost::gregorian::date</link>.</entry></row><row><entry>Feature</entry><entry>Add an iso 8601 time date-time format (eg: YYYYMMDDTHHHMMSS) parsing function. See <link linkend="date_time.posix_time.ptime">Class ptime</link> for more information.</entry></row><row><entry>Feature</entry><entry> Added a length function to the period template so that both date_periods and time_periods will now support this function.</entry></row><row><entry>Bug Fix</entry><entry>Split Jamfiles so that libs/date_time/build/Jamfile only builds library and /libs/date_time/libs/test/Jamfile which runs tests.</entry></row><row><entry>Bug Fix</entry><entry>Fixed many minor documentation issues.</entry></row><row><entry>Bug Fix</entry><entry>Removed the DATE_TIME_INLINE macro which was causing link errors. This macro is no longer needed in projects using the library.</entry></row><row><entry>Bug Fix</entry><entry>Added missing typedef for year_iterator to gregorian_types.hpp</entry></row><row><entry>Bug Fix</entry><entry>Fixed problem with gregorian ostream operators that prevented the use of wide streams.</entry></row><row><entry>Bug-Fix</entry><entry>Tighten error handling for dates so that date(2002, 2, 29) will throw a bad_day_of_month exception. Previously the date would be incorrectly constructed. Reported by sourceforge bug: 628054 among others.</entry></row></tbody></tgroup></informaltable></section><section id="date_time.acknowledgements" xml:base="../libs/date_time/xmldoc/acknowledgements.xml"><title>Acknowledgements</title><para>
    Many people have contributed to the development of this library. In particular Hugo Duncan and Joel de Guzman for help with porting to various compilers. For initial development of concepts and design Corwin Joy and Michael Kenniston deserve special thanks. Also extra thanks to Michael for writing up the theory and tradeoffs part of the documentation. Dave Zumbro for initial inspiration and sage thoughts. Many thanks to boost reviewers and users including: William Seymour, Kjell Elster, Beman Dawes, Gary Powell, Andrew Maclean, William Kempf, Peter Dimov, Chris Little, David Moore, Darin Adler, Gennadiy Rozental, Joachim Achtzehnter, Paul Bristow, Jan Langer, Mark Rodgers, Glen Knowles, Matthew Denman, and George Heintzelman. 
  </para></section></section><section id="date_time.examples" xml:base="../libs/date_time/xmldoc/examples.xml"><title>Examples</title><section id="date_time.examples.general_usage_examples" xml:base="../libs/date_time/xmldoc/usage_examples.xml"><title>General Usage Examples</title><para>
    The following provides some sample usage of dates.
    See <link linkend="date_time.gregorian">Date Programming</link> 
    for more details.

    <programlisting>    
	 using namespace boost::gregorian; 
	 date weekstart(2002,Feb,1);
	 date weekend  = weekstart + week(1);
	 date d2 = d1 + days(5);
	 date today = day_clock::local_day();
	 if (d2 &gt;= today) {} //date comparison operators
	 
	 date_period thisWeek(d1,d2);
	 if (thisWeek.contains(today)) {}//do something
	
	 //iterate and print the week
	 day_iterator itr(weekstart);
	 while (itr &lt;= weekend) {
	   std::cout &lt;&lt; (*itr) &lt;&lt; std::endl;
           ++itr;
	 }  
         //input streaming
         std::stringstream ss("2004-Jan-1");
         ss &gt;&gt; d3;
        
         //localized i/o using facets
         std::locale global;
         std::locale german(global, 
                            new date_facet(de_short_month_names, 
                                           de_long_month_names,
                                           de_special_value_names,
                                           de_long_weekday_names,
                                           de_long_weekday_names,
                                           '.', 
                                           boost::date_time::ymd_order_dmy));
         std::cout.imbue(global2); 
         date d4(2002, Oct, 1);
         std::cout &lt;&lt; d4; //01.Okt.2002

         //date generator functions
         date d5 = next_weekday(d4, Sunday); //calculate sunday following d4

         //define a shorthand for the nth_day_of_the_week_in_month function object
	 typedef nth_day_of_the_week_in_month nth_dow;
         //US labor day is first Monday in Sept
	 nth_dow labor_day(nth_dow::first,Monday, Sep); 
	 date d6 = labor_day.get_date(2004); //calculate a specific date from functor
    </programlisting>    

      The following provides some example code using times.
      See <link linkend="date_time.posix_time">Time Programming</link> 
      for more details.

    <programlisting>    
	 use namespace boost::posix_time; 
	 date d(2002,Feb,1); //an arbitrary date
	 ptime t1(d, hours(5)+nanosec(100)); //date + time of day offset
	 ptime t2 = t1 - minutes(4)+seconds(2);
	 ptime now = second_clock::local_time(); //use the clock
	 date today = now.date(); //Get the date part out of the time
	 date tommorrow = today + date_duration(1);
	 ptime tommorrow_start(tommorrow); //midnight 

         //input streaming
         std::stringstream ss("2004-Jan-1 05:21:33.20");
         ss &gt;&gt; t2;

	 //starting at current time iterator adds by one hour
	 time_iterator titr(now,hours(1)); 
	 for (; titr &lt; tommorrow_start; ++titr) {
	   std::cout &lt;&lt; (*titr) &lt;&lt; std::endl;
	 }

    </programlisting></para><link linkend="top">top</link></section><section id="date_time.examples.dates_as_strings" xml:base="../libs/date_time/xmldoc/ex_dates_as_strings.xml"><title>Dates as Strings</title><para>  
    Various parsing and output of strings.
  </para><programlisting>
    

      /* The following is a simple example that shows conversion of dates 
       * to and from a std::string.
       * 
       * Expected output:
       * 2001-Oct-09
       * 2001-10-09
       * Tuesday October 9, 2001
       * An expected exception is next: 
       * Exception: Month number is out of range 1..12
       */

      #include "boost/date_time/gregorian/gregorian.hpp"
      #include &lt;iostream&gt;
      #include &lt;string&gt;

      int
      main() 
      {

	using namespace boost::gregorian;

	try {
	  // The following date is in ISO 8601 extended format (CCYY-MM-DD)
	  std::string s("2001-10-9"); //2001-October-09
	  date d(from_simple_string(s));
	  std::cout &lt;&lt; to_simple_string(d) &lt;&lt; std::endl;
	  
	  //Read ISO Standard(CCYYMMDD) and output ISO Extended
	  std::string ud("20011009"); //2001-Oct-09
	  date d1(from_undelimited_string(ud));
	  std::cout &lt;&lt; to_iso_extended_string(d1) &lt;&lt; std::endl;
	  
	  //Output the parts of the date - Tuesday October 9, 2001
	  date::ymd_type ymd = d1.year_month_day();
	  greg_weekday wd = d1.day_of_week();
	  std::cout &lt;&lt; wd.as_long_string() &lt;&lt; " "
		    &lt;&lt; ymd.month.as_long_string() &lt;&lt; " "
		    &lt;&lt; ymd.day &lt;&lt; ", " &lt;&lt; ymd.year
		    &lt;&lt; std::endl;

	  //Let's send in month 25 by accident and create an exception
	  std::string bad_date("20012509"); //2001-??-09
	  std::cout &lt;&lt; "An expected exception is next: " &lt;&lt; std::endl;
	  date wont_construct(from_undelimited_string(bad_date));
	  //use wont_construct so compiler doesn't complain, but you wont get here!
	  std::cout &lt;&lt; "oh oh, you shouldn't reach this line: " 
		    &lt;&lt; to_iso_string(wont_construct) &lt;&lt; std::endl;
	}
	catch(std::exception&amp; e) {
	  std::cout &lt;&lt; "  Exception: " &lt;&lt;  e.what() &lt;&lt; std::endl;
	}


	return 0;
      }

    
  </programlisting><para><link linkend="top">top</link></para></section><section id="date_time.examples.days_alive" xml:base="../libs/date_time/xmldoc/ex_days_alive.xml"><title>Days Alive</title><para> 
    Calculate the number of days you have been living using durations and dates.
  </para><programlisting>
    
      /* Short example that calculates the number of days since user was born.
       * Demonstrates comparisons of durations, use of the day_clock,
       * and parsing a date from a string.
       */

      #include "boost/date_time/gregorian/gregorian.hpp"
      #include &lt;iostream&gt;

      int
      main() 
      {
	
	using namespace boost::gregorian;
	std::string s;
	std::cout &lt;&lt; "Enter birth day YYYY-MM-DD (eg: 2002-02-01): ";
	std::cin &gt;&gt; s;
	try {
	  date birthday(from_simple_string(s));
	  date today = day_clock::local_day();
	  days days_alive = today - birthday;
	  days one_day(1);
	  if (days_alive == one_day) {
	    std::cout &lt;&lt; "Born yesterday, very funny" &lt;&lt; std::endl;
	  }
	  else if (days_alive &lt; days(0)) {
	    std::cout &lt;&lt; "Not born yet, hmm: " &lt;&lt; days_alive.days() 
		      &lt;&lt; " days" &lt;&lt;std::endl;
	  }
	  else {
	    std::cout &lt;&lt; "Days alive: " &lt;&lt; days_alive.days() &lt;&lt; std::endl;
	  }

	}
	catch(...) {
	  std::cout &lt;&lt; "Bad date entered: " &lt;&lt; s &lt;&lt; std::endl;
	}
	return 0;
      }
    
  </programlisting><para><link linkend="top">top</link></para></section><section id="date_time.examples.days_between_new_year" xml:base="../libs/date_time/xmldoc/ex_days_between_new_years.xml"><title>Days Between New Years</title><para>  
    Calculate the number of days till new years
  </para><programlisting>
    
      /* Provides a simple example of using a date_generator, and simple
       * mathematical operatorations, to calculate the days since 
       * New Years day of this year, and days until next New Years day.
       *
       * Expected results:
       * Adding together both durations will produce 366 (365 in a leap year).
       */
      #include &lt;iostream&gt;
      #include "boost/date_time/gregorian/gregorian.hpp"

      int
      main() 
      {
	
	using namespace boost::gregorian;

	date today = day_clock::local_day();
	partial_date new_years_day(1,Jan);
	//Subtract two dates to get a duration
	days days_since_year_start = today - new_years_day.get_date(today.year());
	std::cout &lt;&lt; "Days since Jan 1: " &lt;&lt; days_since_year_start.days() 
		  &lt;&lt; std::endl;
	
	days days_until_year_start = new_years_day.get_date(today.year()+1) - today;
	std::cout &lt;&lt; "Days until next Jan 1: " &lt;&lt; days_until_year_start.days() 
		  &lt;&lt; std::endl;
	return 0;
      };

    
  </programlisting><para><link linkend="top">top</link></para></section><section id="date_time.examples.end_of_month_day" xml:base="../libs/date_time/xmldoc/ex_end_of_month_day.xml"><title>End of the Months</title><para>
    Iterates accross the remaining months in a given year, always landing on the last day of the month.
  </para><programlisting>
    
      /* Simple program that uses the gregorian calendar to find the last
       * day of the month and then display the last day of every month left 
       * in the year.
       */

      #include "boost/date_time/gregorian/gregorian.hpp"
      #include &lt;iostream&gt;

      int
      main()
      {
	using namespace boost::gregorian;
	
	std::cout &lt;&lt; "   Enter Year(ex: 2002): ";
	int year, month;
	std::cin &gt;&gt; year;
	std::cout &lt;&lt; "   Enter Month(1..12): ";
	std::cin &gt;&gt; month;
	try {
	  int day = gregorian_calendar::end_of_month_day(year,month);
	  date end_of_month(year,month,day);

	  //Iterate thru by months --
	  month_iterator mitr(end_of_month,1);
	  date start_of_next_year(year+1, Jan, 1);
	  //loop thru the days and print each one
	  while (mitr &lt; start_of_next_year){
	    std::cout &lt;&lt; to_simple_string(*mitr) &lt;&lt; std::endl;
	    ++mitr;
	  }

	}
	catch(...) {
	  std::cout &lt;&lt; "Invalid Date Entered" &lt;&lt; std::endl;
	}
	return 0;

      }

    
  </programlisting><para><link linkend="top">top</link></para></section><section id="date_time.examples.localization" xml:base="../libs/date_time/xmldoc/ex_localization.xml"><title>Localization Demonstration</title><para>
    The boost::date_time library provides the ability to create customized locale facets. Date ordering, language, seperators, and abbreviations can be customized.
  </para><programlisting>
    

      /* The following shows the creation of a facet for the output of 
       * dates in German (please forgive me for any errors in my German --
       * I'm not a native speaker).
       */

      #include "boost/date_time/gregorian/gregorian.hpp"
      #include &lt;iostream&gt;

      /* Define a series of char arrays for short and long name strings to be 
       * associated with date output. */
      const char* const de_short_month_names[] = 
      {
	"Jan", "Feb", "Mar", "Apr", "Mai", "Jun",
	"Jul", "Aug", "Sep", "Okt", "Nov", "Dez", "NAM" 
      };
      const char* const de_long_month_names[] =
      {
	"Januar", "Februar", "Marz", "April", "Mai",
	"Juni", "Juli", "August", "September", "Oktober",
	"November", "Dezember", "NichtDerMonat"
      };
      const char* const de_special_value_names[] =
      {
	"NichtDatumzeit", "-unbegrenztheit", "+unbegrenztheit"
      };
      const char* const de_long_weekday_names[] = 
      {
	"Sonntag", "Montag", "Dienstag", "Mittwoch",
	"Donnerstag", "Freitag", "Samstag"
      };
      const char* const de_short_weekday_names[] =
      {
	"Son", "Mon", "Die","Mit", "Don", "Fre", "Sam"
      };

      const char* const us_short_month_names[] = 
      {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "NAD"
      };
      const char* const us_long_month_names[] =
      {
	"January", "February", "March", "April", "May",
	"June", "July", "August", "September", "October",
	"November", "December", "Not-A-Date"
      };
      const char* const us_special_value_names[] =
      { 
	"Not-A-Date", "-infinity", "+infinity"
      };
      const char* const us_long_weekday_names[] =
      {
	"Sunday", "Monday", "Tuesday", "Wenesday", 
	"Thursday", "Friday", "Saturday"
      };
      const char* const us_short_weekday_names[] =
      {
	"Sun", "Mon", "Tue","Wed", "Thu", "Fri", "Sat"
      };


      int
      main() 
      {

      #ifndef BOOST_DATE_TIME_NO_LOCALE

	using namespace boost::gregorian;
	typedef boost::date_time::all_date_names_put&lt;greg_facet_config&gt; date_facet;
	
	//create a new local
	std::locale default_locale;
	std::locale german_dates1(default_locale, 
				  new date_facet(de_short_month_names, 
						 de_long_month_names,
						 de_special_value_names,
						 de_short_weekday_names,
						 de_long_weekday_names,
						 '.',
						 boost::date_time::ymd_order_dmy,
						 boost::date_time::month_as_integer));
	
	date d1(2002, Oct, 1);
	std::cout.imbue(german_dates1); 
	// output the date in German using short month names
	std::cout &lt;&lt; d1 &lt;&lt; std::endl; //01.10.2002
	
	std::locale german_dates2(default_locale, 
				  new date_facet(de_short_month_names, 
						 de_long_month_names,
						 de_special_value_names,
						 de_short_weekday_names,
						 de_long_weekday_names,
						 '.',
						 boost::date_time::ymd_order_dmy,
						 boost::date_time::month_as_long_string));
	
	std::cout.imbue(german_dates2); 
	greg_month m = d1.month();
	std::cout &lt;&lt; m &lt;&lt; std::endl; //Oktober
	
	greg_weekday wd = d1.day_of_week();
	std::cout &lt;&lt; wd &lt;&lt; std::endl; //Dienstag


	//Numeric date format with US month/day/year ordering
	std::locale usa_dates1(default_locale, 
			       new date_facet(us_short_month_names, 
					      us_long_month_names,
					      us_special_value_names,
					      us_short_weekday_names,
					      us_long_weekday_names,
					      '/',
					      boost::date_time::ymd_order_us,
					      boost::date_time::month_as_integer));
	
	std::cout.imbue(usa_dates1); 
	std::cout &lt;&lt; d1 &lt;&lt; std::endl; //  10/01/2002
	//English names, iso order (year-month-day), '-' separator
	std::locale usa_dates2(default_locale, 
			       new date_facet(us_short_month_names, 
					      us_long_month_names,
					      us_special_value_names,
					      us_short_weekday_names,
					      us_long_weekday_names,
					      '-',
					      boost::date_time::ymd_order_iso,
					      boost::date_time::month_as_short_string));

	std::cout.imbue(usa_dates2); 
	std::cout &lt;&lt; d1 &lt;&lt; std::endl; //  2002-Oct-01
	
	
      #else 
	std::cout &lt;&lt; "Sorry, localization is not supported by this compiler/library" 
		  &lt;&lt; std::endl;
      #endif
	return 0;

      }
    
  </programlisting><para><link linkend="top">top</link></para></section><section id="date_time.examples.date_period_calc" xml:base="../libs/date_time/xmldoc/ex_date_period_calc.xml"><title>Date Period Calculations</title><para>  
    Calculates if a date is in an 'irregular' collection of periods using period calculation functions.
  </para><programlisting>
    
      /*
      This example demonstrates a simple use of periods for the calculation
      of date information.

      The example calculates if a given date is a weekend or holiday
      given an exclusion set.  That is, each weekend or holiday is
      entered into the set as a time interval.  Then if a given date
      is contained within any of the intervals it is considered to
      be within the exclusion set and hence is a offtime.

      Output:
      Number Excluded Periods: 5
      20020202/20020203
      20020209/20020210
      20020212/20020212
      20020216/20020217
      In Exclusion Period: 20020216 --&gt; 20020216/20020217
      20020223/20020224

      */


      #include "boost/date_time/gregorian/gregorian.hpp"
      #include &lt;set&gt;
      #include &lt;algorithm&gt;
      #include &lt;iostream&gt;

      typedef std::set&lt;boost::gregorian::date_period&gt; date_period_set;

      //Simple population of the exclusion set
      date_period_set
      generateExclusion()
      {
	using namespace boost::gregorian;
	date_period periods_array[] = 
	  { date_period(date(2002,Feb,2), date(2002,Feb,4)),//weekend of 2nd-3rd
	    date_period(date(2002,Feb,9), date(2002,Feb,11)),
	    date_period(date(2002,Feb,16), date(2002,Feb,18)),
	    date_period(date(2002,Feb,23), date(2002,Feb,25)),
	    date_period(date(2002,Feb,12), date(2002,Feb,13))//a random holiday 2-12
	  };
	const int num_periods = sizeof(periods_array)/sizeof(date_period);

	date_period_set ps;
	//insert the periods in the set
	std::insert_iterator&lt;date_period_set&gt; itr(ps, ps.begin());
	std::copy(periods_array, periods_array+num_periods, itr );
	return ps;
	
      }


      int main() 
      {
	using namespace boost::gregorian;
	
	date_period_set ps = generateExclusion();
	std::cout &lt;&lt; "Number Excluded Periods: "  &lt;&lt; ps.size() &lt;&lt; std::endl;

	date d(2002,Feb,16);
	date_period_set::const_iterator i = ps.begin();
	//print the periods, check for containment
	for (;i != ps.end(); i++) {
	  std::cout &lt;&lt; to_iso_string(*i) &lt;&lt; std::endl;
	  //if date is in exclusion period then print it
	  if (i-&gt;contains(d)) {
	    std::cout &lt;&lt; "In Exclusion Period: "
		&lt;&lt; to_iso_string(d) &lt;&lt; " --&gt; " &lt;&lt; to_iso_string(*i)
		&lt;&lt; std::endl;
	  }
	}

	return 0;  

      }

    
  </programlisting><para><link linkend="top">top</link></para></section><section id="date_time.examples.print_holidays" xml:base="../libs/date_time/xmldoc/ex_print_holidays.xml"><title>Print Holidays</title><para>  
    This is an example of using functors to define a holiday schedule
  </para><programlisting>
    

      /* Generate a set of dates using a collection of date generators
       * Output looks like:
       * Enter Year: 2002
       * 2002-Jan-01 [Tue]
       * 2002-Jan-21 [Mon]
       * 2002-Feb-12 [Tue]
       * 2002-Jul-04 [Thu]
       * 2002-Sep-02 [Mon]
       * 2002-Nov-28 [Thu]
       * 2002-Dec-25 [Wed]
       * Number Holidays: 7
       */

      #include "boost/date_time/gregorian/gregorian.hpp"
      #include &lt;algorithm&gt;
      #include &lt;functional&gt;
      #include &lt;vector&gt;
      #include &lt;iostream&gt;
      #include &lt;set&gt;

      void
      print_date(boost::gregorian::date d) 
      {
	using namespace boost::gregorian;
      #if defined(BOOST_DATE_TIME_NO_LOCALE)
	std::cout &lt;&lt; to_simple_string(d) &lt;&lt; " [" &lt;&lt; d.day_of_week() &lt;&lt; "]\n";
      #else
	std::cout &lt;&lt; d &lt;&lt; " [" &lt;&lt; d.day_of_week() &lt;&lt; "]\n";
      #endif
      }


      int
      main() {

	std::cout &lt;&lt; "Enter Year: ";
	int year;
	std::cin &gt;&gt; year;

	using namespace boost::gregorian;

	//define a collection of holidays fixed by month and day
	std::vector&lt;year_based_generator*&gt; holidays;
	holidays.push_back(new partial_date(1,Jan)); //Western New Year
	holidays.push_back(new partial_date(4,Jul)); //US Independence Day
	holidays.push_back(new partial_date(25, Dec));//Christmas day


	//define a shorthand for the nth_day_of_the_week_in_month function object
	typedef nth_day_of_the_week_in_month nth_dow;
	
	//US labor day
	holidays.push_back(new nth_dow(nth_dow::first,  Monday,   Sep)); 
	//MLK Day
	holidays.push_back(new nth_dow(nth_dow::third,  Monday,   Jan)); 
	//Pres day
	holidays.push_back(new nth_dow(nth_dow::second, Tuesday,  Feb)); 
	//Thanksgiving
	holidays.push_back(new nth_dow(nth_dow::fourth, Thursday, Nov)); 

	typedef std::set&lt;date&gt; date_set;
	date_set all_holidays;
	
	for(std::vector&lt;year_based_generator*&gt;::iterator it = holidays.begin();
	    it != holidays.end(); ++it)
	{
	  all_holidays.insert((*it)-&gt;get_date(year));
	}

	//print the holidays to the screen
	std::for_each(all_holidays.begin(), all_holidays.end(), print_date);
	std::cout &lt;&lt; "Number Holidays: " &lt;&lt; all_holidays.size() &lt;&lt; std::endl;

	return 0;
      }

    
  </programlisting><para><link linkend="top">top</link></para></section><section id="date_time.examples.print_month" xml:base="../libs/date_time/xmldoc/ex_print_month.xml"><title>Print Month</title><para>  
    Simple utility to print out days of the month with the days of a month. Demontstrates date iteration (date_time::date_itr).
  </para><programlisting>
    
      /* This example prints all the dates in a month. It demonstrates
       * the use of iterators as well as functions of the gregorian_calendar
       * 
       * Output:
       * Enter Year: 2002
       * Enter Month(1..12): 2
       * 2002-Feb-01 [Fri]
       * 2002-Feb-02 [Sat]
       * 2002-Feb-03 [Sun]
       * 2002-Feb-04 [Mon]
       * 2002-Feb-05 [Tue]
       * 2002-Feb-06 [Wed]
       * 2002-Feb-07 [Thu]
       */

      #include "boost/date_time/gregorian/gregorian.hpp"
      #include &lt;iostream&gt;

      int
      main()
      {
	std::cout &lt;&lt; "Enter Year: ";
	int year, month;
	std::cin &gt;&gt; year;
	std::cout &lt;&lt; "Enter Month(1..12): ";
	std::cin &gt;&gt; month;

	using namespace boost::gregorian;
	try {
	  //Use the calendar to get the last day of the month
	  int eom_day = gregorian_calendar::end_of_month_day(year,month);
	  date endOfMonth(year,month,eom_day);

	  //construct an iterator starting with firt day of the month
	  day_iterator ditr(date(year,month,1));
	  //loop thru the days and print each one
	  for (; ditr &lt;= endOfMonth; ++ditr) {
      #if defined(BOOST_DATE_TIME_NO_LOCALE) 
	    std::cout &lt;&lt; to_simple_string(*ditr) &lt;&lt; " ["
      #else
	    std::cout &lt;&lt; *ditr &lt;&lt; " ["
      #endif
		      &lt;&lt; ditr-&gt;day_of_week() &lt;&lt; "]"
		      &lt;&lt; std::endl; 
	  }
	}
	catch(std::exception&amp; e) {

	  std::cout &lt;&lt; "Error bad date, check your entry: \n"
		    &lt;&lt; "  Details: " &lt;&lt; e.what() &lt;&lt; std::endl;
	}
	return 0;
      }

    
  </programlisting><para><link linkend="top">top</link></para></section><section id="date_time.examples.month_add" xml:base="../libs/date_time/xmldoc/ex_month_add.xml"><title>Month Adding</title><para> 
    Adding a month to a day without the use of iterators.
  </para><programlisting>
    
      /* Simple program that uses the gregorian calendar to progress by exactly
       * one month, irregardless of how many days are in that month.
       *
       * This method can be used as an alternative to iterators
       */

      #include "boost/date_time/gregorian/gregorian.hpp"
      #include &lt;iostream&gt;

      int
      main()
      {

	using namespace boost::gregorian;
	typedef boost::date_time::month_functor&lt;date&gt; add_month;

	date d = day_clock::local_day();
	add_month mf(1);
	date d2 = d + mf.get_offset(d);
	std::cout &lt;&lt; "Today is: " &lt;&lt; to_simple_string(d) &lt;&lt; ".\n"
	  &lt;&lt; "One month from today will be: " &lt;&lt; to_simple_string(d2) 
	  &lt;&lt; std::endl;

	return 0;
      }
    
  </programlisting><para><link linkend="top">top</link></para></section><section id="date_time.examples.time_math" xml:base="../libs/date_time/xmldoc/ex_time_math.xml"><title>Time Math</title><para> 
    Various types of calculations with times and time durations.  
  </para><programlisting>
    
      /* Some simple examples of constructing and calculating with times
       * Output:
       * 2002-Feb-01 00:00:00 - 2002-Feb-01 05:04:02.001000000 = -5:04:02.001000000
       */

      #include "boost/date_time/posix_time/posix_time.hpp"
      #include &lt;iostream&gt;

      int
      main() 
      {
	using namespace boost::posix_time;
	using namespace boost::gregorian;

	date d(2002,Feb,1); //an arbitrary date
	//construct a time by adding up some durations durations
	ptime t1(d, hours(5)+minutes(4)+seconds(2)+millisec(1));
	//construct a new time by subtracting some times
	ptime t2 = t1 - hours(5)- minutes(4)- seconds(2)- millisec(1);
	//construct a duration by taking the difference between times
	time_duration td = t2 - t1;
	  
	std::cout &lt;&lt; to_simple_string(t2) &lt;&lt; " - " 
		  &lt;&lt; to_simple_string(t1) &lt;&lt; " = "
		  &lt;&lt; to_simple_string(td) &lt;&lt; std::endl;
	
	return 0;
      }
    
  </programlisting><para><link linkend="top">top</link></para></section><section id="date_time.examples.print_hours" xml:base="../libs/date_time/xmldoc/ex_print_hours.xml"><title>Print Hours</title><para>
    Demonstrate time iteration, clock retrieval, and simple calculation. 
  </para><programlisting>
    
      /* Print the remaining hours of the day
       * Uses the clock to get the local time 
       * Use an iterator to iterate over the remaining hours
       * Retrieve the date part from a time
       *
       * Expected Output something like:
       *
       * 2002-Mar-08 16:30:59
       * 2002-Mar-08 17:30:59
       * 2002-Mar-08 18:30:59
       * 2002-Mar-08 19:30:59
       * 2002-Mar-08 20:30:59
       * 2002-Mar-08 21:30:59
       * 2002-Mar-08 22:30:59
       * 2002-Mar-08 23:30:59
       * Time left till midnight: 07:29:01
       */

      #include "boost/date_time/posix_time/posix_time.hpp"
      #include &lt;iostream&gt;

      int
      main() 
      {
	using namespace boost::posix_time;
	using namespace boost::gregorian;

	//get the current time from the clock -- one second resolution
	ptime now = second_clock::local_time();
	//Get the date part out of the time
	date today = now.date();
	date tommorrow = today + days(1);
	ptime tommorrow_start(tommorrow); //midnight 

	//iterator adds by one hour
	time_iterator titr(now,hours(1)); 
	for (; titr &lt; tommorrow_start; ++titr) {
	  std::cout &lt;&lt; to_simple_string(*titr) &lt;&lt; std::endl;
	}
	
	time_duration remaining = tommorrow_start - now;
	std::cout &lt;&lt; "Time left till midnight: " 
		  &lt;&lt; to_simple_string(remaining) &lt;&lt; std::endl;
	return 0;
      }

    
  </programlisting><para><link linkend="top">top</link></para></section><section id="date_time.examples.local_utc_conversion" xml:base="../libs/date_time/xmldoc/ex_local_utc_conversion.xml"><title>Local to UTC Conversion</title><para>
    Demonstrate utc to local and local to utc calculations including dst.
  </para><programlisting>
    

      /* Demonstrate conversions between a local time and utc
       * Output:
       * 
       * UTC &lt;--&gt; New York while DST is NOT active (5 hours)
       * 2001-Dec-31 19:00:00 in New York is 2002-Jan-01 00:00:00 UTC time 
       * 2002-Jan-01 00:00:00 UTC is 2001-Dec-31 19:00:00 New York time 
       * 
       * UTC &lt;--&gt; New York while DST is active (4 hours)
       * 2002-May-31 20:00:00 in New York is 2002-Jun-01 00:00:00 UTC time 
       * 2002-Jun-01 00:00:00 UTC is 2002-May-31 20:00:00 New York time 
       * 
       * UTC &lt;--&gt; Arizona (7 hours)
       * 2002-May-31 17:00:00 in Arizona is 2002-Jun-01 00:00:00 UTC time 
       */

      #include "boost/date_time/posix_time/posix_time.hpp"
      #include "boost/date_time/local_time_adjustor.hpp"
      #include "boost/date_time/c_local_time_adjustor.hpp"
      #include &lt;iostream&gt;

      int
      main() 
      {
	using namespace boost::posix_time;
	using namespace boost::gregorian;

	//This local adjustor depends on the machine TZ settings-- highly dangerous!
	typedef boost::date_time::c_local_adjustor&lt;ptime&gt; local_adj;
	ptime t10(date(2002,Jan,1), hours(7)); 
	ptime t11 = local_adj::utc_to_local(t10);
	std::cout &lt;&lt; "UTC &lt;--&gt; Zone base on TZ setting" &lt;&lt; std::endl;
	std::cout &lt;&lt; to_simple_string(t11) &lt;&lt; " in your TZ is " 
		  &lt;&lt; to_simple_string(t10) &lt;&lt; " UTC time "
		  &lt;&lt; std::endl;
	time_duration td = t11 - t10;
	std::cout &lt;&lt; "A difference of: " 
		  &lt;&lt; to_simple_string(td) &lt;&lt; std::endl;


	//eastern timezone is utc-5
	typedef boost::date_time::local_adjustor&lt;ptime, -5, us_dst&gt; us_eastern;

	ptime t1(date(2001,Dec,31), hours(19)); //5 hours b/f midnight NY time

	std::cout &lt;&lt; "\nUTC &lt;--&gt; New York while DST is NOT active (5 hours)" 
		  &lt;&lt; std::endl;
	ptime t2 =  us_eastern::local_to_utc(t1);
	std::cout &lt;&lt; to_simple_string(t1) &lt;&lt; " in New York is " 
		  &lt;&lt; to_simple_string(t2) &lt;&lt; " UTC time "
		  &lt;&lt; std::endl;

	ptime t3 = us_eastern::utc_to_local(t2);//back should be the same
	std::cout &lt;&lt; to_simple_string(t2) &lt;&lt; " UTC is " 
		  &lt;&lt; to_simple_string(t3) &lt;&lt; " New York time "
		  &lt;&lt; "\n\n";

	ptime t4(date(2002,May,31), hours(20)); //4 hours b/f midnight NY time
	std::cout &lt;&lt; "UTC &lt;--&gt; New York while DST is active (4 hours)" &lt;&lt; std::endl;
	ptime t5 = us_eastern::local_to_utc(t4);
	std::cout &lt;&lt; to_simple_string(t4) &lt;&lt; " in New York is " 
		  &lt;&lt; to_simple_string(t5) &lt;&lt; " UTC time "
		  &lt;&lt; std::endl;

	ptime t6 = us_eastern::utc_to_local(t5);//back should be the same
	std::cout &lt;&lt; to_simple_string(t5) &lt;&lt; " UTC is " 
		  &lt;&lt; to_simple_string(t6) &lt;&lt; " New York time "
		  &lt;&lt; "\n" &lt;&lt; std::endl;

	  
	//Arizona timezone is utc-7 with no dst
	typedef boost::date_time::local_adjustor&lt;ptime, -7, no_dst&gt; us_arizona;

	ptime t7(date(2002,May,31), hours(17)); 
	std::cout &lt;&lt; "UTC &lt;--&gt; Arizona (7 hours)" &lt;&lt; std::endl;
	ptime t8 = us_arizona::local_to_utc(t7);
	std::cout &lt;&lt; to_simple_string(t7) &lt;&lt; " in Arizona is " 
		  &lt;&lt; to_simple_string(t8) &lt;&lt; " UTC time "
		  &lt;&lt; std::endl;

	return 0;
      }

    
  </programlisting><para><link linkend="top">top</link></para></section><section id="date_time.examples.time_periods" xml:base="../libs/date_time/xmldoc/ex_time_periods.xml"><title>Time Periods</title><para>
    Demonstrate some simple uses of time periods. 
  </para><programlisting>
    

      /* Some simple examples of constructing and calculating with times
       * Returns:
       * [2002-Feb-01 00:00:00/2002-Feb-01 23:59:59.999999999] contains 2002-Feb-01 03:00:05
       * [2002-Feb-01 00:00:00/2002-Feb-01 23:59:59.999999999] intersected with
       * [2002-Feb-01 00:00:00/2002-Feb-01 03:00:04.999999999] is 
       * [2002-Feb-01 00:00:00/2002-Feb-01 03:00:04.999999999]
       */

      #include "boost/date_time/posix_time/posix_time.hpp"
      #include &lt;iostream&gt;

      using namespace boost::posix_time;
      using namespace boost::gregorian;

      //Create a simple period class to contain all the times in a day
      class day_period : public time_period
      {
      public:
	day_period(date d) : time_period(ptime(d),//midnight
					 ptime(d,hours(24)))
	{}

      };

      int
      main() 
      {

	date d(2002,Feb,1); //an arbitrary date
	//a period that represents a day  
	day_period dp(d);
	ptime t(d, hours(3)+seconds(5)); //an arbitray time on that day
	if (dp.contains(t)) {
	  std::cout &lt;&lt; to_simple_string(dp) &lt;&lt; " contains "
		    &lt;&lt; to_simple_string(t)  &lt;&lt; std::endl;
	}
	//a period that represents part of the day
	time_period part_of_day(ptime(d, hours(0)), t);
	//intersect the 2 periods and print the results
	if (part_of_day.intersects(dp)) {
	  time_period result = part_of_day.intersection(dp);
	  std::cout &lt;&lt; to_simple_string(dp) &lt;&lt; " intersected with\n"
		    &lt;&lt; to_simple_string(part_of_day) &lt;&lt; " is \n"
		    &lt;&lt; to_simple_string(result) &lt;&lt; std::endl;
	}
	  
	
	return 0;
      }

    
  </programlisting><para><link linkend="top">top</link></para></section></section><section id="date_time.doxy" xml:base="../libs/date_time/xmldoc/doxy.xml"><title>Library Reference</title><para>
    The following is a detailed reference of the date_time library. A click on any of the reference links will take you to a list of the header files found in that section. Following one of those links will take you to a list of the items declared in that header file. Further sublinks take you to detailed descriptions of each individual item.
  </para><section id="date_time_reference" xml:base="../libs/date_time/xmldoc/date_time_autodoc.boostbook"><title>Date Time Reference</title><section id="id308102"><title>Header &lt;<ulink url="../../boost/date_time/adjust_functors.hpp">boost/date_time/adjust_functors.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="day_functor">day_functor</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="month_functor">month_functor</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="week_functor">week_functor</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="year_functor">year_functor</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="day_functor"><refmeta><refentrytitle>Class template day_functor</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::day_functor</refname><refpurpose><simpara>Functor to iterate a fixed number of days. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> day_functor {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type duration_type;

&#xA0;&#xA0;<emphasis>// <link linkend="day_functorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id313858-bb">day_functor</link>(<emphasis role="bold">int</emphasis>);

&#xA0;&#xA0;<emphasis>// <link linkend="id374751-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id374754-bb">get_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id317426-bb">get_neg_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="day_functorconstruct-copy-destruct"/><computeroutput>day_functor</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id313858-bb"/>day_functor(<emphasis role="bold">int</emphasis> f);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id374751-bb"/><computeroutput>day_functor</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id374754-bb"/>get_offset(<emphasis role="bold">const</emphasis> date_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id317426-bb"/>get_neg_offset(<emphasis role="bold">const</emphasis> date_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="month_functor"><refmeta><refentrytitle>Class template month_functor</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::month_functor</refname><refpurpose><simpara>Provides calculation to find next nth month given a date. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> month_functor {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::calendar_type cal_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> cal_type::ymd_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ymd_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> cal_type::day_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; day_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="month_functorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id439631-bb">month_functor</link>(<emphasis role="bold">int</emphasis>);

&#xA0;&#xA0;<emphasis>// <link linkend="id349946-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id334597-bb">get_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id332389-bb">get_neg_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This adjustment function provides the logic for 'month-based' advancement on a ymd based calendar. The policy it uses to handle the non existant end of month days is to back up to the last day of the month. Also, if the starting date is the last day of a month, this functor will attempt to adjust to the end of the month. </para><refsect2><title><anchor id="month_functorconstruct-copy-destruct"/><computeroutput>month_functor</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id439631-bb"/>month_functor(<emphasis role="bold">int</emphasis> f);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id349946-bb"/><computeroutput>month_functor</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id334597-bb"/>get_offset(<emphasis role="bold">const</emphasis> date_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id332389-bb"/>get_neg_offset(<emphasis role="bold">const</emphasis> date_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns a negative duration_type. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="week_functor"><refmeta><refentrytitle>Class template week_functor</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::week_functor</refname><refpurpose><simpara>Functor to iterate a over weeks. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> week_functor {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::calendar_type calendar_type;

&#xA0;&#xA0;<emphasis>// <link linkend="week_functorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id393715-bb">week_functor</link>(<emphasis role="bold">int</emphasis>);

&#xA0;&#xA0;<emphasis>// <link linkend="id435416-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id397281-bb">get_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id355309-bb">get_neg_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="week_functorconstruct-copy-destruct"/><computeroutput>week_functor</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id393715-bb"/>week_functor(<emphasis role="bold">int</emphasis> f);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id435416-bb"/><computeroutput>week_functor</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id397281-bb"/>get_offset(<emphasis role="bold">const</emphasis> date_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id355309-bb"/>get_neg_offset(<emphasis role="bold">const</emphasis> date_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="year_functor"><refmeta><refentrytitle>Class template year_functor</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::year_functor</refname><refpurpose><simpara>Functor to iterate by a year adjusting for leap years. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> year_functor {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type duration_type;

&#xA0;&#xA0;<emphasis>// <link linkend="year_functorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id300118-bb">year_functor</link>(<emphasis role="bold">int</emphasis>);

&#xA0;&#xA0;<emphasis>// <link linkend="id312559-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id325316-bb">get_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id414188-bb">get_neg_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="year_functorconstruct-copy-destruct"/><computeroutput>year_functor</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id300118-bb"/>year_functor(<emphasis role="bold">int</emphasis> f);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id312559-bb"/><computeroutput>year_functor</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id325316-bb"/>get_offset(<emphasis role="bold">const</emphasis> date_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id414188-bb"/>get_neg_offset(<emphasis role="bold">const</emphasis> date_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id400379"><title>Header &lt;<ulink url="../../boost/date_time/c_local_time_adjustor.hpp">boost/date_time/c_local_time_adjustor.hpp</ulink>&gt;</title><para>Time adjustment calculations based on machine</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type&gt; <emphasis role="bold">class</emphasis> <link linkend="c_local_adjustor">c_local_adjustor</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="c_local_adjustor"><refmeta><refentrytitle>Class template c_local_adjustor</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::c_local_adjustor</refname><refpurpose><simpara>Adjust to / from utc using the C API. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type&gt; 
<emphasis role="bold">class</emphasis> c_local_adjustor {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::time_duration_type time_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::date_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_duration_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id317142-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>time_type</type> <link linkend="id425892-bb">utc_to_local</link>(<emphasis role="bold">const</emphasis> time_type &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Warning!!! This class assumes that timezone settings of the machine are correct. This can be a very dangerous assumption. </para><refsect2><title><anchor id="id317142-bb"/><computeroutput>c_local_adjustor</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id425892-bb"/>utc_to_local(<emphasis role="bold">const</emphasis> time_type &amp; t) ;</literallayout></para><simpara>Convert a utc time to local time. </simpara></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id368278"><title>Header &lt;<ulink url="../../boost/date_time/c_time.hpp">boost/date_time/c_time.hpp</ulink>&gt;</title><para>Provide workarounds related to the ctime header</para><synopsis><emphasis role="bold">namespace</emphasis> std {
}</synopsis></section><section id="id386650"><title>Header &lt;<ulink url="../../boost/date_time/compiler_config.hpp">boost/date_time/compiler_config.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> std {
}</synopsis></section><section id="id304692"><title>Header &lt;<ulink url="../../boost/date_time/constrained_value.hpp">boost/date_time/constrained_value.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> CV {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> value_policies&gt; <emphasis role="bold">class</emphasis> <link linkend="constrained_value">constrained_value</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> rep_type, rep_type min_value, rep_type max_value, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> exception_type&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="simple_exception_policy">simple_exception_policy</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// <simpara>Represent a min or max violation type. </simpara></emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <anchor id="id370701"/>violation_enum { min_violation, max_violation };
&#xA0;&#xA0;}
}</synopsis><refentry id="constrained_value"><refmeta><refentrytitle>Class template constrained_value</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::CV::constrained_value</refname><refpurpose><simpara>A template to specify a constrained basic value type. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> value_policies&gt; 
<emphasis role="bold">class</emphasis> constrained_value {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> value_policies::value_type value_type;

&#xA0;&#xA0;<emphasis>// <link linkend="constrained_valueconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id356804-bb">constrained_value</link>(value_type);
&#xA0;&#xA0;constrained_value&amp; <link linkend="id379704-bb"><emphasis role="bold">operator</emphasis>=</link>(value_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id405391-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<link linkend="id408974-bb"><emphasis role="bold">operator</emphasis> value_type</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id315083-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>value_type max</type> <link linkend="id336420-bb">BOOST_PREVENT_MACRO_SUBSTITUTION</link>() ;
&#xA0;&#xA0;<type>value_type min</type> <link linkend="id332286-bb">BOOST_PREVENT_MACRO_SUBSTITUTION</link>() ;

&#xA0;&#xA0;<emphasis>// <link linkend="id336013-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id321784-bb">assign</link>(value_type) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This template provides a quick way to generate an integer type with a constrained range. The type provides for the ability to specify the min, max, and and error handling policy.</para><para><emphasis role="bold">value policies</emphasis>  A class that provides the range limits via the min and max functions as well as a function on_error that determines how errors are handled. A common strategy would be to assert or throw and exception. The on_error is passed both the current value and the new value that is in error. </para><refsect2><title><anchor id="constrained_valueconstruct-copy-destruct"/><computeroutput>constrained_value</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id356804-bb"/>constrained_value(value_type value);</literallayout></para></listitem><listitem><para><literallayout class="monospaced">constrained_value&amp; <anchor id="id379704-bb"/><emphasis role="bold">operator</emphasis>=(value_type v);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id405391-bb"/><computeroutput>constrained_value</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id408974-bb"/><emphasis role="bold">operator</emphasis> value_type() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Coerce into the representation type. </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id315083-bb"/><computeroutput>constrained_value</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>value_type max</type> <anchor id="id336420-bb"/>BOOST_PREVENT_MACRO_SUBSTITUTION() ;</literallayout></para><simpara>Return the max allowed value (traits method). </simpara></listitem><listitem><para><literallayout class="monospaced"><type>value_type min</type> <anchor id="id332286-bb"/>BOOST_PREVENT_MACRO_SUBSTITUTION() ;</literallayout></para><simpara>Return the min allowed value (traits method). </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id336013-bb"/><computeroutput>constrained_value</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id321784-bb"/>assign(value_type value) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="simple_exception_policy"><refmeta><refentrytitle>Class template simple_exception_policy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::CV::simple_exception_policy</refname><refpurpose><simpara>Template to shortcut the constrained_value policy creation process. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> rep_type, rep_type min_value, rep_type max_value, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> exception_type&gt; 
<emphasis role="bold">class</emphasis> simple_exception_policy {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> rep_type value_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id353157-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>rep_type min</type> <link linkend="id343058-bb">BOOST_PREVENT_MACRO_SUBSTITUTION</link>() ;
&#xA0;&#xA0;<type>rep_type max</type> <link linkend="id342984-bb">BOOST_PREVENT_MACRO_SUBSTITUTION</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id306136-bb">on_error</link>(rep_type, rep_type, violation_enum) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id353157-bb"/><computeroutput>simple_exception_policy</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>rep_type min</type> <anchor id="id343058-bb"/>BOOST_PREVENT_MACRO_SUBSTITUTION() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>rep_type max</type> <anchor id="id342984-bb"/>BOOST_PREVENT_MACRO_SUBSTITUTION() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id306136-bb"/>on_error(rep_type , rep_type , violation_enum ) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id383676"><title>Header &lt;<ulink url="../../boost/date_time/date.hpp">boost/date_time/date.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, <emphasis role="bold">typename</emphasis> calendar, <emphasis role="bold">typename</emphasis> duration_type_&gt; <emphasis role="bold">class</emphasis> <link linkend="boost.date_time.date">date</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="boost.date_time.date"><refmeta><refentrytitle>Class template date</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::date</refname><refpurpose><simpara>Representation of timepoint at the one day level resolution. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, <emphasis role="bold">typename</emphasis> calendar, <emphasis role="bold">typename</emphasis> duration_type_&gt; 
<emphasis role="bold">class</emphasis> date {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; calendar_type;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar::date_traits_type traits_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> duration_type_&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; duration_type;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar::year_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; year_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar::month_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar::day_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; day_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar::ymd_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ymd_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar::date_rep_type&#xA0;&#xA0;&#xA0; date_rep_type;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar::date_int_type&#xA0;&#xA0;&#xA0; date_int_type;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar::day_of_week_type day_of_week_type;

&#xA0;&#xA0;<emphasis>// <link linkend="boost.date_time.dateconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id398749-bb">date</link>(year_type, month_type, day_type);
&#xA0;&#xA0;<link linkend="id342318-bb">date</link>(<emphasis role="bold">const</emphasis> ymd_type &amp;);
&#xA0;&#xA0;<link linkend="id323739-bb">date</link>(date_int_type);
&#xA0;&#xA0;<link linkend="id372396-bb">date</link>(date_rep_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id397241-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>year_type</type> <link linkend="id397245-bb">year</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>month_type</type> <link linkend="id375666-bb">month</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>day_type</type> <link linkend="id355015-bb">day</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>day_of_week_type</type> <link linkend="id305945-bb">day_of_week</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>ymd_type</type> <link linkend="id353902-bb">year_month_day</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id419462-bb"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id305254-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id372630-bb">is_special</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id361215-bb">is_not_a_date</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id281396-bb">is_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id409013-bb">is_pos_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id430174-bb">is_neg_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>special_values</type> <link linkend="id337192-bb">as_special</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id287855-bb"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>date_type</type> <link linkend="id443122-bb"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> duration_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>date_type</type> <link linkend="id380262-bb"><emphasis role="bold">operator</emphasis>-=</link>(<emphasis role="bold">const</emphasis> duration_type &amp;) ;
&#xA0;&#xA0;<type>date_rep_type</type> <link linkend="id299754-bb">day_count</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>date_type</type> <link linkend="id244454-bb"><emphasis role="bold">operator</emphasis>+</link>(<emphasis role="bold">const</emphasis> duration_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>date_type</type> <link linkend="id342556-bb"><emphasis role="bold">operator</emphasis>+=</link>(<emphasis role="bold">const</emphasis> duration_type &amp;) ;

&#xA0;&#xA0;<emphasis>// <link linkend="id401946-bb">protected member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The date template represents an interface shell for a date class that is based on a year-month-day system such as the gregorian or iso systems. It provides basic operations to enable calculation and comparisons.</para><para><emphasis role="bold">Theory</emphasis></para><para>This date representation fundamentally departs from the C tm struct approach. The goal for this type is to provide efficient date operations (add, subtract) and storage (minimize space to represent) in a concrete class. Thus, the date uses a count internally to represent a particular date. The calendar parameter defines the policies for converting the the year-month-day and internal counted form here. Applications that need to perform heavy formatting of the same date repeatedly will perform better by using the year-month-day representation.</para><para>Internally the date uses a day number to represent the date. This is a monotonic time representation. This representation allows for fast comparison as well as simplifying the creation of writing numeric operations. Essentially, the internal day number is like adjusted julian day. The adjustment is determined by the Epoch date which is represented as day 1 of the calendar. Day 0 is reserved for negative infinity so that any actual date is automatically greater than negative infinity. When a date is constructed from a date or formatted for output, the appropriate conversions are applied to create the year, month, day representations. </para><refsect2><title><anchor id="boost.date_time.dateconstruct-copy-destruct"/><computeroutput>date</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id398749-bb"/>date(year_type y, month_type m, day_type d);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id342318-bb"/>date(<emphasis role="bold">const</emphasis> ymd_type &amp; ymd);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id323739-bb"/>date(date_int_type days);</literallayout></para><para>This is a private constructor which allows for the creation of new dates. It is not exposed to users since that would require class users to understand the inner workings of the date class. </para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id372396-bb"/>date(date_rep_type days);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id397241-bb"/><computeroutput>date</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>year_type</type> <anchor id="id397245-bb"/>year() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>month_type</type> <anchor id="id375666-bb"/>month() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>day_type</type> <anchor id="id355015-bb"/>day() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>day_of_week_type</type> <anchor id="id305945-bb"/>day_of_week() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>ymd_type</type> <anchor id="id353902-bb"/>year_month_day() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id419462-bb"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> date_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id305254-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> date_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id372630-bb"/>is_special() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>check to see if date is a special value </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id361215-bb"/>is_not_a_date() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>check to see if date is not a value </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id281396-bb"/>is_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>check to see if date is one of the infinity values </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id409013-bb"/>is_pos_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>check to see if date is greater than all possible dates </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id430174-bb"/>is_neg_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>check to see if date is greater than all possible dates </simpara></listitem><listitem><para><literallayout class="monospaced"><type>special_values</type> <anchor id="id337192-bb"/>as_special() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>return as a special value or a not_special if a normal date </simpara></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id287855-bb"/><emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> date_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id443122-bb"/><emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> duration_type &amp; dd) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id380262-bb"/><emphasis role="bold">operator</emphasis>-=(<emphasis role="bold">const</emphasis> duration_type &amp; dd) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_rep_type</type> <anchor id="id299754-bb"/>day_count() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id244454-bb"/><emphasis role="bold">operator</emphasis>+(<emphasis role="bold">const</emphasis> duration_type &amp; dd) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id342556-bb"/><emphasis role="bold">operator</emphasis>+=(<emphasis role="bold">const</emphasis> duration_type &amp; dd) ;</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id401946-bb"/><computeroutput>date</computeroutput> protected member functions</title><orderedlist/></refsect2></refsect1></refentry></section><section id="id417259"><title>Header &lt;<ulink url="../../boost/date_time/date_clock_device.hpp">boost/date_time/date_clock_device.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="day_clock">day_clock</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="day_clock"><refmeta><refentrytitle>Class template day_clock</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::day_clock</refname><refpurpose><simpara>A clock providing day level services based on C time_t capabilities. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> day_clock {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::ymd_type ymd_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id423222-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>date_type</type> <link linkend="id432375-bb">local_day</link>() ;
&#xA0;&#xA0;<type>date_type::ymd_type</type> <link linkend="id313143-bb">local_day_ymd</link>() ;
&#xA0;&#xA0;<type>date_type::ymd_type</type> <link linkend="id315035-bb">universal_day_ymd</link>() ;
&#xA0;&#xA0;<type>date_type</type> <link linkend="id379622-bb">universal_day</link>() ;

&#xA0;&#xA0;<emphasis>// <link linkend="id329464-bb">private static functions</link></emphasis>
&#xA0;&#xA0;<type>::std::tm *</type> <link linkend="id307920-bb">get_local_time</link>() ;
&#xA0;&#xA0;<type>::std::tm *</type> <link linkend="id396318-bb">get_universal_time</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This clock uses Posix interfaces as its implementation and hence uses the timezone settings of the operating system. Incorrect user settings will result in incorrect results for the calls to local_day. </para><refsect2><title><anchor id="id423222-bb"/><computeroutput>day_clock</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id432375-bb"/>local_day() ;</literallayout></para><simpara>Get the local day as a date type. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>date_type::ymd_type</type> <anchor id="id313143-bb"/>local_day_ymd() ;</literallayout></para><simpara>Get the local day as a ymd_type. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>date_type::ymd_type</type> <anchor id="id315035-bb"/>universal_day_ymd() ;</literallayout></para><simpara>Get the current day in universal date as a ymd_type. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id379622-bb"/>universal_day() ;</literallayout></para><simpara>Get the UTC day as a date type. </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id329464-bb"/><computeroutput>day_clock</computeroutput> private static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>::std::tm *</type> <anchor id="id307920-bb"/>get_local_time() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>::std::tm *</type> <anchor id="id396318-bb"/>get_universal_time() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id354175"><title>Header &lt;<ulink url="../../boost/date_time/date_defs.hpp">boost/date_time/date_defs.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// <simpara>An enumeration of weekday names. </simpara></emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <anchor id="id389709"/>weekdays { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Saturday };

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// <simpara>Simple enum to allow for nice programming with Jan, Feb, etc. </simpara></emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <anchor id="id316500"/>months_of_year { Jan = 1, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Nov, Dec, NotAMonth, NumMonths };
&#xA0;&#xA0;}
}</synopsis></section><section id="id432576"><title>Header &lt;<ulink url="../../boost/date_time/date_duration.hpp">boost/date_time/date_duration.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> duration_rep_traits&gt; <emphasis role="bold">class</emphasis> <link linkend="date_duration">date_duration</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="duration_traits_long">duration_traits_long</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="duration_traits_adapted">duration_traits_adapted</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="date_duration"><refmeta><refentrytitle>Class template date_duration</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::date_duration</refname><refpurpose><simpara>Duration type with date level resolution. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> duration_rep_traits&gt; 
<emphasis role="bold">class</emphasis> date_duration {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> duration_rep_traits::int_type&#xA0; duration_rep_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> duration_rep_traits::impl_type duration_rep;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="date_durationconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id424728-bb">date_duration</link>(duration_rep);
&#xA0;&#xA0;<link linkend="id383990-bb">date_duration</link>(special_values);
&#xA0;&#xA0;<link linkend="id411493-bb">date_duration</link>(<emphasis role="bold">const</emphasis> <link linkend="date_duration">date_duration</link>&lt; duration_rep_traits &gt; &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id423776-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>duration_rep</type> <link linkend="id383623-bb">get_rep</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id321140-bb">is_special</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_rep_type</type> <link linkend="id302579-bb">days</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id410273-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="date_duration">date_duration</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id328694-bb"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> <link linkend="date_duration">date_duration</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="date_duration">date_duration</link></type> <link linkend="id324924-bb"><emphasis role="bold">operator</emphasis>-=</link>(<emphasis role="bold">const</emphasis> <link linkend="date_duration">date_duration</link> &amp;) ;
&#xA0;&#xA0;<type><link linkend="date_duration">date_duration</link></type> <link linkend="id363569-bb"><emphasis role="bold">operator</emphasis>+=</link>(<emphasis role="bold">const</emphasis> <link linkend="date_duration">date_duration</link> &amp;) ;
&#xA0;&#xA0;<type><link linkend="date_duration">date_duration</link></type> <link linkend="id319793-bb"><emphasis role="bold">operator</emphasis>-</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="date_duration">date_duration</link>&lt; duration_rep_traits &gt;</type> <link linkend="id324889-bb"><emphasis role="bold">operator</emphasis>/=</link>(<emphasis role="bold">int</emphasis>) ;
&#xA0;&#xA0;<type><link linkend="date_duration">date_duration</link>&lt; duration_rep_traits &gt;</type> <link linkend="id416013-bb"><emphasis role="bold">operator</emphasis>/</link>(<emphasis role="bold">int</emphasis>) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id244232-bb">is_negative</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id400391-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><link linkend="date_duration">date_duration</link></type> <link linkend="id400394-bb">unit</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="date_durationconstruct-copy-destruct"/><computeroutput>date_duration</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id424728-bb"/>date_duration(duration_rep day_count);</literallayout></para><simpara>Construct from a day count. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id383990-bb"/>date_duration(special_values sv);</literallayout></para><para>construct from special_values - only works when instantiated with duration_traits_adapted </para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id411493-bb"/>date_duration(<emphasis role="bold">const</emphasis> <link linkend="date_duration">date_duration</link>&lt; duration_rep_traits &gt; &amp; other);</literallayout></para><simpara>Construct from another date_duration (Copy Constructor). </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id423776-bb"/><computeroutput>date_duration</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>duration_rep</type> <anchor id="id383623-bb"/>get_rep() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>returns days_ as it's instantiated type - used for streaming </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id321140-bb"/>is_special() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>duration_rep_type</type> <anchor id="id302579-bb"/>days() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>returns days as value, not object. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id410273-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="date_duration">date_duration</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Equality. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id328694-bb"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> <link linkend="date_duration">date_duration</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Less. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="date_duration">date_duration</link></type> <anchor id="id324924-bb"/><emphasis role="bold">operator</emphasis>-=(<emphasis role="bold">const</emphasis> <link linkend="date_duration">date_duration</link> &amp; rhs) ;</literallayout></para><simpara>Subtract another duration -- result is signed. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="date_duration">date_duration</link></type> <anchor id="id363569-bb"/><emphasis role="bold">operator</emphasis>+=(<emphasis role="bold">const</emphasis> <link linkend="date_duration">date_duration</link> &amp; rhs) ;</literallayout></para><simpara>Add a duration -- result is signed. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="date_duration">date_duration</link></type> <anchor id="id319793-bb"/><emphasis role="bold">operator</emphasis>-() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>unary- Allows for dd = -date_duration(2); -&gt; dd == -2 </simpara></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="date_duration">date_duration</link>&lt; duration_rep_traits &gt;</type> <anchor id="id324889-bb"/><emphasis role="bold">operator</emphasis>/=(<emphasis role="bold">int</emphasis> divisor) ;</literallayout></para><simpara>Division operations on a duration with an integer. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="date_duration">date_duration</link>&lt; duration_rep_traits &gt;</type> <anchor id="id416013-bb"/><emphasis role="bold">operator</emphasis>/(<emphasis role="bold">int</emphasis> divisor) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id244232-bb"/>is_negative() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>return sign information </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id400391-bb"/><computeroutput>date_duration</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><link linkend="date_duration">date_duration</link></type> <anchor id="id400394-bb"/>unit() ;</literallayout></para><simpara>Returns the smallest duration -- used by to calculate 'end'. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="duration_traits_long"><refmeta><refentrytitle>Struct duration_traits_long</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::duration_traits_long</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> duration_traits_long {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis role="bold">long</emphasis> int_type;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis role="bold">long</emphasis> impl_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id413989-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>int_type</type> <link linkend="id431286-bb">as_number</link>(impl_type) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Struct for instantiating date_duration with <emphasis role="bold">NO</emphasis>  special values functionality. Allows for transparent implementation of either date_duration&lt;long&gt; or date_duration&lt;int_adapter&lt;long&gt; &gt; </para><refsect2><title><anchor id="id413989-bb"/><computeroutput>duration_traits_long</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id431286-bb"/>as_number(impl_type i) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="duration_traits_adapted"><refmeta><refentrytitle>Struct duration_traits_adapted</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::duration_traits_adapted</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> duration_traits_adapted {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis role="bold">long</emphasis>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int_type;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="int_adapter">boost::date_time::int_adapter</link>&lt; <emphasis role="bold">long</emphasis> &gt; impl_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id360428-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>int_type</type> <link linkend="id360432-bb">as_number</link>(impl_type) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Struct for instantiating date_duration <emphasis role="bold">WITH</emphasis>  special values functionality. Allows for transparent implementation of either date_duration&lt;long&gt; or date_duration&lt;int_adapter&lt;long&gt; &gt; </para><refsect2><title><anchor id="id360428-bb"/><computeroutput>duration_traits_adapted</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id360432-bb"/>as_number(impl_type i) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id381315"><title>Header &lt;<ulink url="../../boost/date_time/date_duration_types.hpp">boost/date_time/date_duration_types.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> duration_config&gt; <emphasis role="bold">class</emphasis> <link linkend="weeks_duration">weeks_duration</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> base_config&gt; <emphasis role="bold">class</emphasis> <link linkend="months_duration">months_duration</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> base_config&gt; <emphasis role="bold">class</emphasis> <link linkend="years_duration">years_duration</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="weeks_duration"><refmeta><refentrytitle>Class template weeks_duration</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::weeks_duration</refname><refpurpose><simpara>Additional duration type that represents a number of n*7 days. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> duration_config&gt; 
<emphasis role="bold">class</emphasis> weeks_duration
  :  : <emphasis role="bold">public</emphasis> boost::date_time::date_duration&lt; duration_config &gt;
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="weeks_durationconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id356008-bb">weeks_duration</link>(<emphasis role="bold">typename</emphasis> duration_config::impl_type);
&#xA0;&#xA0;<link linkend="id394934-bb">weeks_duration</link>(special_values);

&#xA0;&#xA0;<emphasis>// <link linkend="id356004-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="weeks_durationconstruct-copy-destruct"/><computeroutput>weeks_duration</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id356008-bb"/>weeks_duration(<emphasis role="bold">typename</emphasis> duration_config::impl_type w);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id394934-bb"/>weeks_duration(special_values sv);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id356004-bb"/><computeroutput>weeks_duration</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="months_duration"><refmeta><refentrytitle>Class template months_duration</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::months_duration</refname><refpurpose><simpara>additional duration type that represents a logical month </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> base_config&gt; 
<emphasis role="bold">class</emphasis> months_duration {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="months_durationconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id312183-bb">months_duration</link>(int_rep);
&#xA0;&#xA0;<link linkend="id342130-bb">months_duration</link>(special_values);

&#xA0;&#xA0;<emphasis>// <link linkend="id398297-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>int_rep</type> <link linkend="id406291-bb">number_of_months</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id341960-bb">get_neg_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id391285-bb">get_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id302829-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> months_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id335082-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> months_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>months_type</type> <link linkend="id405264-bb"><emphasis role="bold">operator</emphasis>+</link>(<emphasis role="bold">const</emphasis> months_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>months_type &amp;</type> <link linkend="id367744-bb"><emphasis role="bold">operator</emphasis>+=</link>(<emphasis role="bold">const</emphasis> months_type &amp;) ;
&#xA0;&#xA0;<type>months_type</type> <link linkend="id440331-bb"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> months_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>months_type &amp;</type> <link linkend="id354756-bb"><emphasis role="bold">operator</emphasis>-=</link>(<emphasis role="bold">const</emphasis> months_type &amp;) ;
&#xA0;&#xA0;<type>months_type</type> <link linkend="id405284-bb"><emphasis role="bold">operator</emphasis> *</link>(<emphasis role="bold">const</emphasis> int_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>months_type &amp;</type> <link linkend="id430872-bb"><emphasis role="bold">operator</emphasis> *=</link>(<emphasis role="bold">const</emphasis> int_type) ;
&#xA0;&#xA0;<type>months_type</type> <link linkend="id375433-bb"><emphasis role="bold">operator</emphasis>/</link>(<emphasis role="bold">const</emphasis> int_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>months_type &amp;</type> <link linkend="id355279-bb"><emphasis role="bold">operator</emphasis>/=</link>(<emphasis role="bold">const</emphasis> int_type) ;
&#xA0;&#xA0;<type>months_type</type> <link linkend="id394412-bb"><emphasis role="bold">operator</emphasis>+</link>(<emphasis role="bold">const</emphasis> years_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>months_type &amp;</type> <link linkend="id375054-bb"><emphasis role="bold">operator</emphasis>+=</link>(<emphasis role="bold">const</emphasis> years_type &amp;) ;
&#xA0;&#xA0;<type>months_type</type> <link linkend="id371280-bb"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> years_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>months_type &amp;</type> <link linkend="id365338-bb"><emphasis role="bold">operator</emphasis>-=</link>(<emphasis role="bold">const</emphasis> years_type &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>A logical month enables things like: "date(2002,Mar,2) + months(2) -&gt; 2002-May2". If the date is a last day-of-the-month, the result will also be a last-day-of-the-month. </para><refsect2><title><anchor id="months_durationconstruct-copy-destruct"/><computeroutput>months_duration</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id312183-bb"/>months_duration(int_rep num);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id342130-bb"/>months_duration(special_values sv);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id398297-bb"/><computeroutput>months_duration</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>int_rep</type> <anchor id="id406291-bb"/>number_of_months() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id341960-bb"/>get_neg_offset(<emphasis role="bold">const</emphasis> date_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>returns a negative duration </simpara></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id391285-bb"/>get_offset(<emphasis role="bold">const</emphasis> date_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id302829-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> months_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id335082-bb"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> months_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type</type> <anchor id="id405264-bb"/><emphasis role="bold">operator</emphasis>+(<emphasis role="bold">const</emphasis> months_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type &amp;</type> <anchor id="id367744-bb"/><emphasis role="bold">operator</emphasis>+=(<emphasis role="bold">const</emphasis> months_type &amp; rhs) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type</type> <anchor id="id440331-bb"/><emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> months_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type &amp;</type> <anchor id="id354756-bb"/><emphasis role="bold">operator</emphasis>-=(<emphasis role="bold">const</emphasis> months_type &amp; rhs) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type</type> <anchor id="id405284-bb"/><emphasis role="bold">operator</emphasis> *(<emphasis role="bold">const</emphasis> int_type rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type &amp;</type> <anchor id="id430872-bb"/><emphasis role="bold">operator</emphasis> *=(<emphasis role="bold">const</emphasis> int_type rhs) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type</type> <anchor id="id375433-bb"/><emphasis role="bold">operator</emphasis>/(<emphasis role="bold">const</emphasis> int_type rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type &amp;</type> <anchor id="id355279-bb"/><emphasis role="bold">operator</emphasis>/=(<emphasis role="bold">const</emphasis> int_type rhs) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type</type> <anchor id="id394412-bb"/><emphasis role="bold">operator</emphasis>+(<emphasis role="bold">const</emphasis> years_type &amp; y) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type &amp;</type> <anchor id="id375054-bb"/><emphasis role="bold">operator</emphasis>+=(<emphasis role="bold">const</emphasis> years_type &amp; y) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type</type> <anchor id="id371280-bb"/><emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> years_type &amp; y) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type &amp;</type> <anchor id="id365338-bb"/><emphasis role="bold">operator</emphasis>-=(<emphasis role="bold">const</emphasis> years_type &amp; y) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="years_duration"><refmeta><refentrytitle>Class template years_duration</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::years_duration</refname><refpurpose><simpara>additional duration type that represents a logical year </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> base_config&gt; 
<emphasis role="bold">class</emphasis> years_duration {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="years_durationconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id384626-bb">years_duration</link>(int_rep);
&#xA0;&#xA0;<link linkend="id361758-bb">years_duration</link>(special_values);

&#xA0;&#xA0;<emphasis>// <link linkend="id385605-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>int_rep</type> <link linkend="id393985-bb">number_of_years</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id315159-bb">get_neg_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id313879-bb">get_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id384274-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> years_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id309524-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> years_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>years_type</type> <link linkend="id419775-bb"><emphasis role="bold">operator</emphasis>+</link>(<emphasis role="bold">const</emphasis> years_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>years_type &amp;</type> <link linkend="id313907-bb"><emphasis role="bold">operator</emphasis>+=</link>(<emphasis role="bold">const</emphasis> years_type &amp;) ;
&#xA0;&#xA0;<type>years_type</type> <link linkend="id350790-bb"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> years_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>years_type &amp;</type> <link linkend="id364663-bb"><emphasis role="bold">operator</emphasis>-=</link>(<emphasis role="bold">const</emphasis> years_type &amp;) ;
&#xA0;&#xA0;<type>years_type</type> <link linkend="id392331-bb"><emphasis role="bold">operator</emphasis> *</link>(<emphasis role="bold">const</emphasis> int_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>years_type &amp;</type> <link linkend="id377613-bb"><emphasis role="bold">operator</emphasis> *=</link>(<emphasis role="bold">const</emphasis> int_type) ;
&#xA0;&#xA0;<type>years_type</type> <link linkend="id403111-bb"><emphasis role="bold">operator</emphasis>/</link>(<emphasis role="bold">const</emphasis> int_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>years_type &amp;</type> <link linkend="id409630-bb"><emphasis role="bold">operator</emphasis>/=</link>(<emphasis role="bold">const</emphasis> int_type) ;
&#xA0;&#xA0;<type>months_type</type> <link linkend="id434328-bb"><emphasis role="bold">operator</emphasis>+</link>(<emphasis role="bold">const</emphasis> months_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>months_type</type> <link linkend="id341039-bb"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> months_type &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>A logical year enables things like: "date(2002,Mar,2) + years(2) -&gt; 2004-Mar-2". If the date is a last day-of-the-month, the result will also be a last-day-of-the-month (ie date(2001-Feb-28) + years(3) -&gt; 2004-Feb-29). </para><refsect2><title><anchor id="years_durationconstruct-copy-destruct"/><computeroutput>years_duration</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id384626-bb"/>years_duration(int_rep num);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id361758-bb"/>years_duration(special_values sv);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id385605-bb"/><computeroutput>years_duration</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>int_rep</type> <anchor id="id393985-bb"/>number_of_years() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id315159-bb"/>get_neg_offset(<emphasis role="bold">const</emphasis> date_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>returns a negative duration </simpara></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id313879-bb"/>get_offset(<emphasis role="bold">const</emphasis> date_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id384274-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> years_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id309524-bb"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> years_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>years_type</type> <anchor id="id419775-bb"/><emphasis role="bold">operator</emphasis>+(<emphasis role="bold">const</emphasis> years_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>years_type &amp;</type> <anchor id="id313907-bb"/><emphasis role="bold">operator</emphasis>+=(<emphasis role="bold">const</emphasis> years_type &amp; rhs) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>years_type</type> <anchor id="id350790-bb"/><emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> years_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>years_type &amp;</type> <anchor id="id364663-bb"/><emphasis role="bold">operator</emphasis>-=(<emphasis role="bold">const</emphasis> years_type &amp; rhs) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>years_type</type> <anchor id="id392331-bb"/><emphasis role="bold">operator</emphasis> *(<emphasis role="bold">const</emphasis> int_type rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>years_type &amp;</type> <anchor id="id377613-bb"/><emphasis role="bold">operator</emphasis> *=(<emphasis role="bold">const</emphasis> int_type rhs) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>years_type</type> <anchor id="id403111-bb"/><emphasis role="bold">operator</emphasis>/(<emphasis role="bold">const</emphasis> int_type rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>years_type &amp;</type> <anchor id="id409630-bb"/><emphasis role="bold">operator</emphasis>/=(<emphasis role="bold">const</emphasis> int_type rhs) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type</type> <anchor id="id434328-bb"/><emphasis role="bold">operator</emphasis>+(<emphasis role="bold">const</emphasis> months_type &amp; m) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>months_type</type> <anchor id="id341039-bb"/><emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> months_type &amp; m) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id383059"><title>Header &lt;<ulink url="../../boost/date_time/date_format_simple.hpp">boost/date_time/date_format_simple.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; <emphasis role="bold">class</emphasis> <link linkend="simple_format">simple_format</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;&gt; <emphasis role="bold">class</emphasis> <link linkend="id375649-bb">simple_format</link>&lt;<emphasis role="bold">wchar_t</emphasis>&gt;;
&#xA0;&#xA0;}
}</synopsis><refentry id="simple_format"><refmeta><refentrytitle>Class template simple_format</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::simple_format</refname><refpurpose><simpara>Class to provide simple basic formatting rules. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
<emphasis role="bold">class</emphasis> simple_format {
<emphasis role="bold">public</emphasis>:

&#xA0;&#xA0;<emphasis>// <link linkend="id393016-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> charT *</type> <link linkend="id432651-bb">not_a_date</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> charT *</type> <link linkend="id402517-bb">pos_infinity</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> charT *</type> <link linkend="id298242-bb">neg_infinity</link>() ;
&#xA0;&#xA0;<type>month_format_spec</type> <link linkend="id299304-bb">month_format</link>() ;
&#xA0;&#xA0;<type>ymd_order_spec</type> <link linkend="id346525-bb">date_order</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id388108-bb">has_date_sep_chars</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id400586-bb">year_sep_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id340229-bb">month_sep_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id322609-bb">day_sep_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id377034-bb">hour_sep_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id342079-bb">minute_sep_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id314651-bb">second_sep_char</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id393016-bb"/><computeroutput>simple_format</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> charT *</type> <anchor id="id432651-bb"/>not_a_date() ;</literallayout></para><simpara>String used printed is date is invalid. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> charT *</type> <anchor id="id402517-bb"/>pos_infinity() ;</literallayout></para><simpara>String used to for positive infinity value. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> charT *</type> <anchor id="id298242-bb"/>neg_infinity() ;</literallayout></para><simpara>String used to for positive infinity value. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>month_format_spec</type> <anchor id="id299304-bb"/>month_format() ;</literallayout></para><simpara>Describe month format. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>ymd_order_spec</type> <anchor id="id346525-bb"/>date_order() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id388108-bb"/>has_date_sep_chars() ;</literallayout></para><simpara>This format uses '-' to separate date elements. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id400586-bb"/>year_sep_char() ;</literallayout></para><simpara>Char to sep? </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id340229-bb"/>month_sep_char() ;</literallayout></para><simpara>char between year-month </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id322609-bb"/>day_sep_char() ;</literallayout></para><simpara>Char to separate month-day. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id377034-bb"/>hour_sep_char() ;</literallayout></para><simpara>char between date-hours </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id342079-bb"/>minute_sep_char() ;</literallayout></para><simpara>char between hour and minute </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id314651-bb"/>second_sep_char() ;</literallayout></para><simpara>char for second </simpara></listitem></orderedlist></refsect2><refsect2><title>Specializations</title><itemizedlist><listitem><para><link linkend="id375649-bb">Class simple_format&lt;wchar_t&gt;</link></para></listitem></itemizedlist></refsect2></refsect1></refentry><refentry id="id375649-bb"><refmeta><refentrytitle>Class simple_format&lt;wchar_t&gt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::simple_format&lt;wchar_t&gt;</refname><refpurpose><simpara>Specialization of formmating rules for wchar_t. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> simple_format&lt;<emphasis role="bold">wchar_t</emphasis>&gt; {
<emphasis role="bold">public</emphasis>:

&#xA0;&#xA0;<emphasis>// <link linkend="id417252-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <link linkend="id445896-bb">not_a_date</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <link linkend="id336577-bb">pos_infinity</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <link linkend="id298755-bb">neg_infinity</link>() ;
&#xA0;&#xA0;<type>month_format_spec</type> <link linkend="id395190-bb">month_format</link>() ;
&#xA0;&#xA0;<type>ymd_order_spec</type> <link linkend="id367689-bb">date_order</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id425145-bb">has_date_sep_chars</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id285721-bb">year_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id395132-bb">month_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id385336-bb">day_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id320379-bb">hour_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id411507-bb">minute_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id360282-bb">second_sep_char</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id417252-bb"/><computeroutput>simple_format</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <anchor id="id445896-bb"/>not_a_date() ;</literallayout></para><simpara>String used printed is date is invalid. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <anchor id="id336577-bb"/>pos_infinity() ;</literallayout></para><simpara>String used to for positive infinity value. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <anchor id="id298755-bb"/>neg_infinity() ;</literallayout></para><simpara>String used to for positive infinity value. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>month_format_spec</type> <anchor id="id395190-bb"/>month_format() ;</literallayout></para><simpara>Describe month format. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>ymd_order_spec</type> <anchor id="id367689-bb"/>date_order() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id425145-bb"/>has_date_sep_chars() ;</literallayout></para><simpara>This format uses '-' to separate date elements. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id285721-bb"/>year_sep_char() ;</literallayout></para><simpara>Char to sep? </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id395132-bb"/>month_sep_char() ;</literallayout></para><simpara>char between year-month </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id385336-bb"/>day_sep_char() ;</literallayout></para><simpara>Char to separate month-day. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id320379-bb"/>hour_sep_char() ;</literallayout></para><simpara>char between date-hours </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id411507-bb"/>minute_sep_char() ;</literallayout></para><simpara>char between hour and minute </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id360282-bb"/>second_sep_char() ;</literallayout></para><simpara>char for second </simpara></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id382856"><title>Header &lt;<ulink url="../../boost/date_time/date_formatting.hpp">boost/date_time/date_formatting.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> month_type, <emphasis role="bold">typename</emphasis> format_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="month_formatter">month_formatter</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ymd_type, <emphasis role="bold">typename</emphasis> format_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="ymd_formatter">ymd_formatter</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> format_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="date_formatter">date_formatter</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="month_formatter"><refmeta><refentrytitle>Class template month_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::month_formatter</refname><refpurpose><simpara>Formats a month as as string into an ostream. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> month_type, <emphasis role="bold">typename</emphasis> format_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
<emphasis role="bold">class</emphasis> month_formatter {
<emphasis role="bold">public</emphasis>:

&#xA0;&#xA0;<emphasis>// <link linkend="id421978-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>std::basic_ostream&lt; charT &gt; &amp;</type> 
&#xA0;&#xA0;<link linkend="id284106-bb">format_month</link>(<emphasis role="bold">const</emphasis> month_type &amp;, std::basic_ostream&lt; charT &gt; &amp;) ;
&#xA0;&#xA0;<type>std::ostream &amp;</type> <link linkend="id364013-bb">format_month</link>(<emphasis role="bold">const</emphasis> month_type &amp;, std::ostream &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id421978-bb"/><computeroutput>month_formatter</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>std::basic_ostream&lt; charT &gt; &amp;</type> 
<anchor id="id284106-bb"/>format_month(<emphasis role="bold">const</emphasis> month_type &amp; month, std::basic_ostream&lt; charT &gt; &amp; os) ;</literallayout></para><simpara>Formats a month as as string into an ostream. </simpara><para>This function demands that month_type provide functions for converting to short and long strings if that capability is used. </para></listitem><listitem><para><literallayout class="monospaced"><type>std::ostream &amp;</type> <anchor id="id364013-bb"/>format_month(<emphasis role="bold">const</emphasis> month_type &amp; month, std::ostream &amp; os) ;</literallayout></para><simpara>Formats a month as as string into an ostream. </simpara><para>This function demands that month_type provide functions for converting to short and long strings if that capability is used. </para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="ymd_formatter"><refmeta><refentrytitle>Class template ymd_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::ymd_formatter</refname><refpurpose><simpara>Convert ymd to a standard string formatting policies. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ymd_type, <emphasis role="bold">typename</emphasis> format_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
<emphasis role="bold">class</emphasis> ymd_formatter {
<emphasis role="bold">public</emphasis>:

&#xA0;&#xA0;<emphasis>// <link linkend="id403200-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>std::basic_string&lt; charT &gt;</type> <link linkend="id320904-bb">ymd_to_string</link>(ymd_type) ;
&#xA0;&#xA0;<type>std::string</type> <link linkend="id331352-bb">ymd_to_string</link>(ymd_type) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id403200-bb"/><computeroutput>ymd_formatter</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>std::basic_string&lt; charT &gt;</type> <anchor id="id320904-bb"/>ymd_to_string(ymd_type ymd) ;</literallayout></para><simpara>Convert ymd to a standard string formatting policies. </simpara><para>This is standard code for handling date formatting with year-month-day based date information. This function uses the format_type to control whether the string will contain separator characters, and if so what the character will be. In addtion, it can format the month as either an integer or a string as controled by the formatting policy </para></listitem><listitem><para><literallayout class="monospaced"><type>std::string</type> <anchor id="id331352-bb"/>ymd_to_string(ymd_type ymd) ;</literallayout></para><simpara>Convert ymd to a standard string formatting policies. </simpara><para>This is standard code for handling date formatting with year-month-day based date information. This function uses the format_type to control whether the string will contain separator characters, and if so what the character will be. In addtion, it can format the month as either an integer or a string as controled by the formatting policy </para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="date_formatter"><refmeta><refentrytitle>Class template date_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::date_formatter</refname><refpurpose><simpara>Convert a date to string using format policies. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> format_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
<emphasis role="bold">class</emphasis> date_formatter {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::basic_string&lt; charT &gt; string_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id408662-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>string_type</type> <link linkend="id298278-bb">date_to_string</link>(date_type) ;
&#xA0;&#xA0;<type>std::string</type> <link linkend="id392359-bb">date_to_string</link>(date_type) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id408662-bb"/><computeroutput>date_formatter</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>string_type</type> <anchor id="id298278-bb"/>date_to_string(date_type d) ;</literallayout></para><simpara>Convert to a date to standard string using format policies. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>std::string</type> <anchor id="id392359-bb"/>date_to_string(date_type d) ;</literallayout></para><simpara>Convert to a date to standard string using format policies. </simpara></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id297925"><title>Header &lt;<ulink url="../../boost/date_time/date_formatting_limited.hpp">boost/date_time/date_formatting_limited.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;}
}</synopsis></section><section id="id301482"><title>Header &lt;<ulink url="../../boost/date_time/date_formatting_locales.hpp">boost/date_time/date_formatting_locales.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> facet_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="ostream_month_formatter">ostream_month_formatter</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> weekday_type, <emphasis role="bold">typename</emphasis> facet_type, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="ostream_weekday_formatter">ostream_weekday_formatter</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ymd_type, <emphasis role="bold">typename</emphasis> facet_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="ostream_ymd_formatter">ostream_ymd_formatter</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> facet_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="ostream_date_formatter">ostream_date_formatter</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="ostream_month_formatter"><refmeta><refentrytitle>Class template ostream_month_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::ostream_month_formatter</refname><refpurpose><simpara>Formats a month as as string into an ostream. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> facet_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
<emphasis role="bold">class</emphasis> ostream_month_formatter {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> facet_type::month_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_type;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::basic_ostream&lt; charT &gt; ostream_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id419858-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id307465-bb">format_month</link>(<emphasis role="bold">const</emphasis> month_type &amp;, ostream_type &amp;, <emphasis role="bold">const</emphasis> facet_type &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id419858-bb"/><computeroutput>ostream_month_formatter</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id307465-bb"/>format_month(<emphasis role="bold">const</emphasis> month_type &amp; month, ostream_type &amp; os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> facet_type &amp; f) ;</literallayout></para><simpara>Formats a month as as string into an output iterator. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="ostream_weekday_formatter"><refmeta><refentrytitle>Class template ostream_weekday_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::ostream_weekday_formatter</refname><refpurpose><simpara>Formats a weekday. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> weekday_type, <emphasis role="bold">typename</emphasis> facet_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
<emphasis role="bold">class</emphasis> ostream_weekday_formatter {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> facet_type::month_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_type;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::basic_ostream&lt; charT &gt; ostream_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id430414-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id428024-bb">format_weekday</link>(<emphasis role="bold">const</emphasis> weekday_type &amp;, ostream_type &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> facet_type &amp;, <emphasis role="bold">bool</emphasis>) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id430414-bb"/><computeroutput>ostream_weekday_formatter</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id428024-bb"/>format_weekday(<emphasis role="bold">const</emphasis> weekday_type &amp; wd, ostream_type &amp; os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> facet_type &amp; f, <emphasis role="bold">bool</emphasis> as_long_string) ;</literallayout></para><simpara>Formats a month as as string into an output iterator. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="ostream_ymd_formatter"><refmeta><refentrytitle>Class template ostream_ymd_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::ostream_ymd_formatter</refname><refpurpose><simpara>Convert ymd to a standard string formatting policies. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ymd_type, <emphasis role="bold">typename</emphasis> facet_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
<emphasis role="bold">class</emphasis> ostream_ymd_formatter {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> ymd_type::month_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="ostream_month_formatter">ostream_month_formatter</link>&lt; facet_type, charT &gt; month_formatter_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::basic_ostream&lt; charT &gt;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ostream_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::basic_string&lt; charT &gt;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; foo_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id401924-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id376516-bb">ymd_put</link>(ymd_type, ostream_type &amp;, <emphasis role="bold">const</emphasis> facet_type &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id401924-bb"/><computeroutput>ostream_ymd_formatter</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id376516-bb"/>ymd_put(ymd_type ymd, ostream_type &amp; os, <emphasis role="bold">const</emphasis> facet_type &amp; f) ;</literallayout></para><simpara>Convert ymd to a standard string formatting policies. </simpara><para>This is standard code for handling date formatting with year-month-day based date information. This function uses the format_type to control whether the string will contain separator characters, and if so what the character will be. In addtion, it can format the month as either an integer or a string as controled by the formatting policy </para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="ostream_date_formatter"><refmeta><refentrytitle>Class template ostream_date_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::ostream_date_formatter</refname><refpurpose><simpara>Convert a date to string using format policies. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> facet_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
<emphasis role="bold">class</emphasis> ostream_date_formatter {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::basic_ostream&lt; charT &gt; ostream_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::ymd_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ymd_type;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id333524-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id369440-bb">date_put</link>(<emphasis role="bold">const</emphasis> date_type &amp;, ostream_type &amp;, <emphasis role="bold">const</emphasis> facet_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id355202-bb">date_put</link>(<emphasis role="bold">const</emphasis> date_type &amp;, ostream_type &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id333524-bb"/><computeroutput>ostream_date_formatter</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id369440-bb"/>date_put(<emphasis role="bold">const</emphasis> date_type &amp; d, ostream_type &amp; os, <emphasis role="bold">const</emphasis> facet_type &amp; f) ;</literallayout></para><simpara>Put date into an ostream. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id355202-bb"/>date_put(<emphasis role="bold">const</emphasis> date_type &amp; d, ostream_type &amp; os) ;</literallayout></para><simpara>Put date into an ostream. </simpara></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id360638"><title>Header &lt;<ulink url="../../boost/date_time/date_generators.hpp">boost/date_time/date_generators.hpp</ulink>&gt;</title><para>Definition and implementation of date algorithm templates</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="year_based_generator">year_based_generator</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="partial_date">partial_date</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="nth_kday_of_month">nth_kday_of_month</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="first_kday_of_month">first_kday_of_month</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="last_kday_of_month">last_kday_of_month</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="first_kday_after">first_kday_after</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="first_kday_before">first_kday_before</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Returns nth arg as string. 1 -&gt; "first", 2 -&gt; "second", max is 5. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_DATE_TIME_DECL <emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <anchor id="nth_as_str"/>nth_as_str(<emphasis role="bold">int</emphasis> n);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> weekday_type&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>date_type::duration_type</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="days_until_weekday">days_until_weekday</link>(<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">const</emphasis> weekday_type &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> weekday_type&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>date_type::duration_type</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="days_before_weekday">days_before_weekday</link>(<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">const</emphasis> weekday_type &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> weekday_type&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>date_type</type> <link linkend="next_weekday">next_weekday</link>(<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">const</emphasis> weekday_type &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> weekday_type&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>date_type</type> <link linkend="previous_weekday">previous_weekday</link>(<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">const</emphasis> weekday_type &amp;);
&#xA0;&#xA0;}
}</synopsis><refentry id="year_based_generator"><refmeta><refentrytitle>Class template year_based_generator</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::year_based_generator</refname><refpurpose><simpara>Base class for all generators that take a year and produce a date. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> year_based_generator {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::calendar_type calendar_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::year_type year_type;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="year_based_generatorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id370988-bb">year_based_generator</link>();
&#xA0;&#xA0;<link linkend="id370991-bb">~year_based_generator</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id313666-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> date_type</type> <link linkend="id317122-bb">get_date</link>(year_type) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This class is a base class for polymorphic function objects that take a year and produce a concrete date. 
</para><refsect2><title><anchor id="year_based_generatorconstruct-copy-destruct"/><computeroutput>year_based_generator</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id370988-bb"/>year_based_generator();</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id370991-bb"/>~year_based_generator();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id313666-bb"/><computeroutput>year_based_generator</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> date_type</type> <anchor id="id317122-bb"/>get_date(year_type y) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="partial_date"><refmeta><refentrytitle>Class template partial_date</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::partial_date</refname><refpurpose><simpara>Generates a date by applying the year to the given month and day. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> partial_date
  :  : <emphasis role="bold">public</emphasis> boost::date_time::year_based_generator&lt; date_type &gt;
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::calendar_type&#xA0;&#xA0;&#xA0; calendar_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::day_type&#xA0;&#xA0;&#xA0;&#xA0; day_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::month_type&#xA0;&#xA0; month_type;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::year_type&#xA0;&#xA0;&#xA0; year_type;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type&#xA0;&#xA0;&#xA0; duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> duration_type::duration_rep duration_rep;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="partial_dateconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id316311-bb">partial_date</link>(day_type, month_type);
&#xA0;&#xA0;<link linkend="id310209-bb">partial_date</link>(duration_rep);

&#xA0;&#xA0;<emphasis>// <link linkend="id308312-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>date_type</type> <link linkend="id373710-bb">get_date</link>(year_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>date_type</type> <link linkend="id405396-bb"><emphasis role="bold">operator</emphasis>()</link>(year_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id318728-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="partial_date">partial_date</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id395915-bb"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> <link linkend="partial_date">partial_date</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>month_type</type> <link linkend="id383216-bb">month</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>day_type</type> <link linkend="id399080-bb">day</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Example usage: <programlisting>    partial_date pd(1, Jan);
    partial_date pd2(70);
    date d = pd.get_date(2002); //2002-Jan-01
    date d2 = pd2.get_date(2002); //2002-Mar-10
</programlisting></para><refsect2><title><anchor id="partial_dateconstruct-copy-destruct"/><computeroutput>partial_date</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id316311-bb"/>partial_date(day_type d, month_type m);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id310209-bb"/>partial_date(duration_rep days);</literallayout></para><simpara>Partial date created from number of days into year. Range 1-366. </simpara><para>Allowable values range from 1 to 366. 1=Jan1, 366=Dec31. If argument exceeds range, partial_date will be created with closest in-range value. 60 will always be Feb29, if get_date() is called with a non-leap year an exception will be thrown </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id308312-bb"/><computeroutput>partial_date</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id373710-bb"/>get_date(year_type y) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return a concrete date when provided with a year specific year. </simpara><para>Will throw an 'invalid_argument' exception if a partial_date object, instantiated with Feb-29, has get_date called with a non-leap year. Example: <programlisting> partial_date pd(29, Feb);
 pd.get_date(2003); // throws invalid_argument exception
 pg.get_date(2000); // returns 2000-2-29
</programlisting></para></listitem><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id405396-bb"/><emphasis role="bold">operator</emphasis>()(year_type y) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id318728-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="partial_date">partial_date</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id395915-bb"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> <link linkend="partial_date">partial_date</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>month_type</type> <anchor id="id383216-bb"/>month() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>day_type</type> <anchor id="id399080-bb"/>day() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="nth_kday_of_month"><refmeta><refentrytitle>Class template nth_kday_of_month</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::nth_kday_of_month</refname><refpurpose><simpara>Useful generator functor for finding holidays. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> nth_kday_of_month
  :  : <emphasis role="bold">public</emphasis> boost::date_time::year_based_generator&lt; date_type &gt;
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::calendar_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; calendar_type;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::day_of_week_type day_of_week_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::month_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::year_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; year_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; duration_type;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="nth_kday_of_monthconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id356024-bb">nth_kday_of_month</link>(week_num, day_of_week_type, month_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id309002-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>date_type</type> <link linkend="id323169-bb">get_date</link>(year_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>month_type</type> <link linkend="id332788-bb">month</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>week_num</type> <link linkend="id390571-bb">nth_week</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>day_of_week_type</type> <link linkend="id413765-bb">day_of_week</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <link linkend="id428410-bb">nth_week_as_str</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Based on the idea in Cal. Calc. for finding holidays that are the 'first Monday of September'. When instantiated with 'fifth' kday of month, the result will be the last kday of month which can be the fourth or fifth depending on the structure of the month.</para><para>The algorithm here basically guesses for the first day of the month. Then finds the first day of the correct type. That is, if the first of the month is a Tuesday and it needs Wenesday then we simply increment by a day and then we can add the length of a week until we get to the 'nth kday'. There are probably more efficient algorithms based on using a mod 7, but this one works reasonably well for basic applications. </para><refsect2><title><anchor id="nth_kday_of_monthconstruct-copy-destruct"/><computeroutput>nth_kday_of_month</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id356024-bb"/>nth_kday_of_month(week_num week_no, day_of_week_type dow, month_type m);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id309002-bb"/><computeroutput>nth_kday_of_month</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id323169-bb"/>get_date(year_type y) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return a concrete date when provided with a year specific year. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>month_type</type> <anchor id="id332788-bb"/>month() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>week_num</type> <anchor id="id390571-bb"/>nth_week() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>day_of_week_type</type> <anchor id="id413765-bb"/>day_of_week() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <anchor id="id428410-bb"/>nth_week_as_str() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="first_kday_of_month"><refmeta><refentrytitle>Class template first_kday_of_month</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::first_kday_of_month</refname><refpurpose><simpara>Useful generator functor for finding holidays and daylight savings. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> first_kday_of_month
  :  : <emphasis role="bold">public</emphasis> boost::date_time::year_based_generator&lt; date_type &gt;
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::calendar_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; calendar_type;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::day_of_week_type day_of_week_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::month_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::year_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; year_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; duration_type;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="first_kday_of_monthconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id333319-bb">first_kday_of_month</link>(day_of_week_type, month_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id390234-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>date_type</type> <link linkend="id348408-bb">get_date</link>(year_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>month_type</type> <link linkend="id308780-bb">month</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>day_of_week_type</type> <link linkend="id321194-bb">day_of_week</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Similar to nth_kday_of_month, but requires less paramters </para><refsect2><title><anchor id="first_kday_of_monthconstruct-copy-destruct"/><computeroutput>first_kday_of_month</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id333319-bb"/>first_kday_of_month(day_of_week_type dow, month_type m);</literallayout></para><simpara>Specify the first 'Sunday' in 'April' spec. </simpara><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>dow</term><listitem><para>The day of week, eg: Sunday, Monday, etc </para></listitem></varlistentry><varlistentry><term>m</term><listitem><para>The month of the year, eg: Jan, Feb, Mar, etc </para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id390234-bb"/><computeroutput>first_kday_of_month</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id348408-bb"/>get_date(year_type year) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return a concrete date when provided with a year specific year. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>month_type</type> <anchor id="id308780-bb"/>month() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>day_of_week_type</type> <anchor id="id321194-bb"/>day_of_week() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="last_kday_of_month"><refmeta><refentrytitle>Class template last_kday_of_month</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::last_kday_of_month</refname><refpurpose><simpara>Calculate something like Last Sunday of January. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> last_kday_of_month
  :  : <emphasis role="bold">public</emphasis> boost::date_time::year_based_generator&lt; date_type &gt;
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::calendar_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; calendar_type;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::day_of_week_type day_of_week_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::month_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::year_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; year_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; duration_type;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="last_kday_of_monthconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id371752-bb">last_kday_of_month</link>(day_of_week_type, month_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id404786-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>date_type</type> <link linkend="id314847-bb">get_date</link>(year_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>month_type</type> <link linkend="id396820-bb">month</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>day_of_week_type</type> <link linkend="id334752-bb">day_of_week</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Useful generator functor for finding holidays and daylight savings Get the last day of the month and then calculate the difference to the last previous day. 
</para><refsect2><title><anchor id="last_kday_of_monthconstruct-copy-destruct"/><computeroutput>last_kday_of_month</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id371752-bb"/>last_kday_of_month(day_of_week_type dow, month_type m);</literallayout></para><simpara>Specify the date spec like last 'Sunday' in 'April' spec. </simpara><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>dow</term><listitem><para>The day of week, eg: Sunday, Monday, etc </para></listitem></varlistentry><varlistentry><term>m</term><listitem><para>The month of the year, eg: Jan, Feb, Mar, etc </para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id404786-bb"/><computeroutput>last_kday_of_month</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id314847-bb"/>get_date(year_type year) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return a concrete date when provided with a year specific year. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>month_type</type> <anchor id="id396820-bb"/>month() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>day_of_week_type</type> <anchor id="id334752-bb"/>day_of_week() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="first_kday_after"><refmeta><refentrytitle>Class template first_kday_after</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::first_kday_after</refname><refpurpose><simpara>Calculate something like "First Sunday after Jan 1,2002. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> first_kday_after {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::calendar_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; calendar_type;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::day_of_week_type day_of_week_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; duration_type;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="first_kday_afterconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id418486-bb">first_kday_after</link>(day_of_week_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id412058-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>date_type</type> <link linkend="id393889-bb">get_date</link>(date_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>day_of_week_type</type> <link linkend="id300926-bb">day_of_week</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Date generator that takes a date and finds kday after <programlisting>     typedef boost::date_time::first_kday_after&lt;date&gt; firstkdayafter;
     firstkdayafter fkaf(Monday);
     fkaf.get_date(date(2002,Feb,1));
</programlisting></para><refsect2><title><anchor id="first_kday_afterconstruct-copy-destruct"/><computeroutput>first_kday_after</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id418486-bb"/>first_kday_after(day_of_week_type dow);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id412058-bb"/><computeroutput>first_kday_after</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id393889-bb"/>get_date(date_type start_day) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return next kday given. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>day_of_week_type</type> <anchor id="id300926-bb"/>day_of_week() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="first_kday_before"><refmeta><refentrytitle>Class template first_kday_before</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::first_kday_before</refname><refpurpose><simpara>Calculate something like "First Sunday before Jan 1,2002. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> first_kday_before {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::calendar_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; calendar_type;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> calendar_type::day_of_week_type day_of_week_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; duration_type;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="first_kday_beforeconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id398733-bb">first_kday_before</link>(day_of_week_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id391469-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>date_type</type> <link linkend="id364398-bb">get_date</link>(date_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>day_of_week_type</type> <link linkend="id412916-bb">day_of_week</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Date generator that takes a date and finds kday after <programlisting>     typedef boost::date_time::first_kday_before&lt;date&gt; firstkdaybefore;
     firstkdaybefore fkbf(Monday);
     fkbf.get_date(date(2002,Feb,1));
</programlisting></para><refsect2><title><anchor id="first_kday_beforeconstruct-copy-destruct"/><computeroutput>first_kday_before</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id398733-bb"/>first_kday_before(day_of_week_type dow);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id391469-bb"/><computeroutput>first_kday_before</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id364398-bb"/>get_date(date_type start_day) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return next kday given. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>day_of_week_type</type> <anchor id="id412916-bb"/>day_of_week() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="days_until_weekday"><refmeta><refentrytitle>Function template days_until_weekday</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::days_until_weekday</refname><refpurpose><simpara>Calculates the number of days until the next weekday. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> weekday_type&gt; 
&#xA0;&#xA0;<type>date_type::duration_type</type> 
&#xA0;&#xA0;days_until_weekday(<emphasis role="bold">const</emphasis> date_type &amp; d, <emphasis role="bold">const</emphasis> weekday_type &amp; wd);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Calculates the number of days until the next weekday. If the date given falls on a Sunday and the given weekday is Tuesday the result will be 2 days </para></refsect1></refentry><refentry id="days_before_weekday"><refmeta><refentrytitle>Function template days_before_weekday</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::days_before_weekday</refname><refpurpose><simpara>Calculates the number of days since the previous weekday. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> weekday_type&gt; 
&#xA0;&#xA0;<type>date_type::duration_type</type> 
&#xA0;&#xA0;days_before_weekday(<emphasis role="bold">const</emphasis> date_type &amp; d, <emphasis role="bold">const</emphasis> weekday_type &amp; wd);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Calculates the number of days since the previous weekday If the date given falls on a Sunday and the given weekday is Tuesday the result will be 5 days. The answer will be a positive number because Tuesday is 5 days before Sunday, not -5 days before. </para></refsect1></refentry><refentry id="next_weekday"><refmeta><refentrytitle>Function template next_weekday</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::next_weekday</refname><refpurpose><simpara>Generates a date object representing the date of the following weekday from the given date. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> weekday_type&gt; 
&#xA0;&#xA0;<type>date_type</type> next_weekday(<emphasis role="bold">const</emphasis> date_type &amp; d, <emphasis role="bold">const</emphasis> weekday_type &amp; wd);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Generates a date object representing the date of the following weekday from the given date. If the date given is 2004-May-9 (a Sunday) and the given weekday is Tuesday then the resulting date will be 2004-May-11. </para></refsect1></refentry><refentry id="previous_weekday"><refmeta><refentrytitle>Function template previous_weekday</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::previous_weekday</refname><refpurpose><simpara>Generates a date object representing the date of the previous weekday from the given date. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> weekday_type&gt; 
&#xA0;&#xA0;<type>date_type</type> previous_weekday(<emphasis role="bold">const</emphasis> date_type &amp; d, <emphasis role="bold">const</emphasis> weekday_type &amp; wd);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Generates a date object representing the date of the previous weekday from the given date. If the date given is 2004-May-9 (a Sunday) and the given weekday is Tuesday then the resulting date will be 2004-May-4. </para></refsect1></refentry></section><section id="id391588"><title>Header &lt;<ulink url="../../boost/date_time/date_iterator.hpp">boost/date_time/date_iterator.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="date_itr_base">date_itr_base</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> offset_functor, <emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="date_itr">date_itr</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// <simpara>An iterator over dates with varying resolution (day, week, month, year, etc). </simpara></emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <anchor id="id398366"/>date_resolutions { day, week, months, year, decade, century, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;NumDateResolutions };
&#xA0;&#xA0;}
}</synopsis><refentry id="date_itr_base"><refmeta><refentrytitle>Class template date_itr_base</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::date_itr_base</refname><refpurpose><simpara>Base date iterator type. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> date_itr_base {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type duration_type;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; value_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::input_iterator_tag&#xA0; iterator_category;

&#xA0;&#xA0;<emphasis>// <link linkend="date_itr_baseconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id344839-bb">date_itr_base</link>(date_type);
&#xA0;&#xA0;<link linkend="id401221-bb">~date_itr_base</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id405036-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><link linkend="date_itr_base">date_itr_base</link> &amp;</type> <link linkend="id431094-bb"><emphasis role="bold">operator</emphasis>++</link>() ;
&#xA0;&#xA0;<type><link linkend="date_itr_base">date_itr_base</link> &amp;</type> <link linkend="id399629-bb"><emphasis role="bold">operator</emphasis>--</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> duration_type</type> <link linkend="id436185-bb">get_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> duration_type</type> <link linkend="id389701-bb">get_neg_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>date_type</type> <link linkend="id332077-bb"><emphasis role="bold">operator</emphasis> *</link>() ;
&#xA0;&#xA0;<type>date_type *</type> <link linkend="id314140-bb"><emphasis role="bold">operator</emphasis>-&gt;</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id345284-bb"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> date_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id329206-bb"><emphasis role="bold">operator</emphasis>&lt;=</link>(<emphasis role="bold">const</emphasis> date_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id284811-bb"><emphasis role="bold">operator</emphasis>&gt;</link>(<emphasis role="bold">const</emphasis> date_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id424606-bb"><emphasis role="bold">operator</emphasis>&gt;=</link>(<emphasis role="bold">const</emphasis> date_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id437957-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> date_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id327763-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> date_type &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This class provides the skeleton for the creation of iterators. New and interesting interators can be created by plugging in a new function that derives the next value from the current state. generation of various types of -based information.</para><para><emphasis role="bold">Template Parameters</emphasis></para><para><emphasis role="bold">date_type</emphasis></para><para>The date_type is a concrete date_type. The date_type must define a duration_type and a calendar_type. </para><refsect2><title><anchor id="date_itr_baseconstruct-copy-destruct"/><computeroutput>date_itr_base</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id344839-bb"/>date_itr_base(date_type d);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id401221-bb"/>~date_itr_base();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id405036-bb"/><computeroutput>date_itr_base</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><link linkend="date_itr_base">date_itr_base</link> &amp;</type> <anchor id="id431094-bb"/><emphasis role="bold">operator</emphasis>++() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="date_itr_base">date_itr_base</link> &amp;</type> <anchor id="id399629-bb"/><emphasis role="bold">operator</emphasis>--() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> duration_type</type> <anchor id="id436185-bb"/>get_offset(<emphasis role="bold">const</emphasis> date_type &amp; current) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> duration_type</type> <anchor id="id389701-bb"/>get_neg_offset(<emphasis role="bold">const</emphasis> date_type &amp; current) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id332077-bb"/><emphasis role="bold">operator</emphasis> *() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_type *</type> <anchor id="id314140-bb"/><emphasis role="bold">operator</emphasis>-&gt;() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id345284-bb"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> date_type &amp; d) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id329206-bb"/><emphasis role="bold">operator</emphasis>&lt;=(<emphasis role="bold">const</emphasis> date_type &amp; d) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id284811-bb"/><emphasis role="bold">operator</emphasis>&gt;(<emphasis role="bold">const</emphasis> date_type &amp; d) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id424606-bb"/><emphasis role="bold">operator</emphasis>&gt;=(<emphasis role="bold">const</emphasis> date_type &amp; d) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id437957-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> date_type &amp; d) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id327763-bb"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> date_type &amp; d) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="date_itr"><refmeta><refentrytitle>Class template date_itr</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::date_itr</refname><refpurpose><simpara>Overrides the base date iterator providing hook for functors. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> offset_functor, <emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> date_itr : <emphasis role="bold">public</emphasis> boost::date_time::date_itr_base&lt; date_type &gt; {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type duration_type;

&#xA0;&#xA0;<emphasis>// <link linkend="date_itrconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id312028-bb">date_itr</link>(date_type, <emphasis role="bold">int</emphasis> = 1);

&#xA0;&#xA0;<emphasis>// <link linkend="id354910-bb">public member functions</link></emphasis>

&#xA0;&#xA0;<emphasis>// <link linkend="id359787-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> duration_type</type> <link linkend="id352233-bb">get_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> duration_type</type> <link linkend="id332011-bb">get_neg_offset</link>(<emphasis role="bold">const</emphasis> date_type &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="date_itrconstruct-copy-destruct"/><computeroutput>date_itr</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id312028-bb"/>date_itr(date_type d, <emphasis role="bold">int</emphasis> factor = 1);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id354910-bb"/><computeroutput>date_itr</computeroutput> public member functions</title><orderedlist/></refsect2><refsect2><title><anchor id="id359787-bb"/><computeroutput>date_itr</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> duration_type</type> <anchor id="id352233-bb"/>get_offset(<emphasis role="bold">const</emphasis> date_type &amp; current) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> duration_type</type> <anchor id="id332011-bb"/>get_neg_offset(<emphasis role="bold">const</emphasis> date_type &amp; current) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id330778"><title>Header &lt;<ulink url="../../boost/date_time/date_names_put.hpp">boost/date_time/date_names_put.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Config, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> <link linkend="OutputIterator">OutputIterator</link> = std::ostreambuf_iterator&lt;charT&gt; &gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="date_names_put">date_names_put</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Config, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> <link linkend="OutputIterator">OutputIterator</link> = std::ostreambuf_iterator&lt;charT&gt; &gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="all_date_names_put">all_date_names_put</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="date_names_put"><refmeta><refentrytitle>Class template date_names_put</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::date_names_put</refname><refpurpose><simpara>Output facet base class for gregorian dates. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Config, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> <link linkend="OutputIterator">OutputIterator</link> = std::ostreambuf_iterator&lt;charT&gt; &gt; 
<emphasis role="bold">class</emphasis> date_names_put {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> OutputIterator&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; iter_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> Config::month_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> Config::month_enum&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_enum;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> Config::weekday_enum&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; weekday_enum;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> Config::special_value_enum special_value_enum;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::basic_string&lt; charT &gt; string_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="date_names_putconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id304185-bb">date_names_put</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id399644-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id320180-bb">put_special_value</link>(iter_type &amp;, special_value_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id423164-bb">put_month_short</link>(iter_type &amp;, month_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id353438-bb">put_month_long</link>(iter_type &amp;, month_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id383191-bb">put_weekday_short</link>(iter_type &amp;, weekday_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id410122-bb">put_weekday_long</link>(iter_type &amp;, weekday_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id301508-bb">has_date_sep_chars</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id333490-bb">year_sep_char</link>(iter_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id311451-bb">month_sep_char</link>(iter_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id428372-bb">day_sep_char</link>(iter_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>ymd_order_spec</type> <link linkend="id383001-bb">date_order</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>month_format_spec</type> <link linkend="id315215-bb">month_format</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id429109-bb">protected member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id394367-bb">do_put_month_short</link>(iter_type &amp;, month_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id336331-bb">do_put_month_long</link>(iter_type &amp;, month_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id376242-bb">do_put_special_value</link>(iter_type &amp;, special_value_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id355888-bb">do_put_weekday_short</link>(iter_type &amp;, weekday_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id308177-bb">do_put_weekday_long</link>(iter_type &amp;, weekday_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <link linkend="id316680-bb">do_has_date_sep_chars</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id355779-bb">do_year_sep_char</link>(iter_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id427885-bb">do_month_sep_char</link>(iter_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id298886-bb">do_day_sep_char</link>(iter_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> ymd_order_spec</type> <link linkend="id285473-bb">do_date_order</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> month_format_spec</type> <link linkend="id375088-bb">do_month_format</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id363689-bb">put_string</link>(iter_type &amp;, <emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis>) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id411598-bb">put_string</link>(iter_type &amp;, <emphasis role="bold">const</emphasis> string_type &amp;) <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis role="bold">static</emphasis> std::locale::id id;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This class is a base class for date facets used to localize the names of months and the names of days in the week.</para><para>Requirements of Config<itemizedlist><listitem><para>define an enumeration month_enum that enumerates the months. The enumeration should be '1' based eg: Jan==1</para></listitem><listitem><para>define as_short_string and as_long_string</para></listitem></itemizedlist></para><para>(see langer &amp; kreft p334). </para><refsect2><title><anchor id="date_names_putconstruct-copy-destruct"/><computeroutput>date_names_put</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id304185-bb"/>date_names_put();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id399644-bb"/><computeroutput>date_names_put</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id320180-bb"/>put_special_value(iter_type &amp; oitr, special_value_enum sv) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id423164-bb"/>put_month_short(iter_type &amp; oitr, month_enum moy) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id353438-bb"/>put_month_long(iter_type &amp; oitr, month_enum moy) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id383191-bb"/>put_weekday_short(iter_type &amp; oitr, weekday_enum wd) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id410122-bb"/>put_weekday_long(iter_type &amp; oitr, weekday_enum wd) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id301508-bb"/>has_date_sep_chars() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id333490-bb"/>year_sep_char(iter_type &amp; oitr) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id311451-bb"/>month_sep_char(iter_type &amp; oitr) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>char between year-month </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id428372-bb"/>day_sep_char(iter_type &amp; oitr) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Char to separate month-day. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>ymd_order_spec</type> <anchor id="id383001-bb"/>date_order() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Determines the order to put the date elements. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>month_format_spec</type> <anchor id="id315215-bb"/>month_format() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Determines if month is displayed as integer, short or long string. </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id429109-bb"/><computeroutput>date_names_put</computeroutput> protected member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id394367-bb"/>do_put_month_short(iter_type &amp; oitr, month_enum moy) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Default facet implementation uses month_type defaults. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id336331-bb"/>do_put_month_long(iter_type &amp; oitr, month_enum moy) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Default facet implementation uses month_type defaults. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> 
<anchor id="id376242-bb"/>do_put_special_value(iter_type &amp; oitr, special_value_enum sv) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Default facet implementation for special value types. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id355888-bb"/>do_put_weekday_short(iter_type &amp; , weekday_enum ) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id308177-bb"/>do_put_weekday_long(iter_type &amp; , weekday_enum ) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <anchor id="id316680-bb"/>do_has_date_sep_chars() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id355779-bb"/>do_year_sep_char(iter_type &amp; oitr) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id427885-bb"/>do_month_sep_char(iter_type &amp; oitr) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>char between year-month </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id298886-bb"/>do_day_sep_char(iter_type &amp; oitr) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Char to separate month-day. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> ymd_order_spec</type> <anchor id="id285473-bb"/>do_date_order() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Default for date order. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> month_format_spec</type> <anchor id="id375088-bb"/>do_month_format() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Default month format. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id363689-bb"/>put_string(iter_type &amp; oi, <emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> s) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id411598-bb"/>put_string(iter_type &amp; oi, <emphasis role="bold">const</emphasis> string_type &amp; s1) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="all_date_names_put"><refmeta><refentrytitle>Class template all_date_names_put</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::all_date_names_put</refname><refpurpose><simpara>An date name output facet that takes an array of char* to define strings. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Config, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> <link linkend="OutputIterator">OutputIterator</link> = std::ostreambuf_iterator&lt;charT&gt; &gt; 
<emphasis role="bold">class</emphasis> all_date_names_put : <emphasis role="bold">public</emphasis> boost::date_time::date_names_put&lt; Config, charT, OutputIterator &gt;
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> OutputIterator&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; iter_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> Config::month_enum&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_enum;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> Config::weekday_enum&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; weekday_enum;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> Config::special_value_enum special_value_enum;

&#xA0;&#xA0;<emphasis>// <link linkend="all_date_names_putconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id395726-bb">all_date_names_put</link>(<emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis>, <emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis>, <emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis>, charT = '-', 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;ymd_order_spec = ymd_order_iso, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;month_format_spec = month_as_short_string);

&#xA0;&#xA0;<emphasis>// <link linkend="id330609-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> *</type> <link linkend="id432053-bb">get_short_month_names</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> *</type> <link linkend="id340176-bb">get_long_month_names</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> *</type> <link linkend="id333973-bb">get_special_value_names</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> *</type> <link linkend="id349747-bb">get_short_weekday_names</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> *</type> <link linkend="id409782-bb">get_long_weekday_names</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id352064-bb">protected member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id423911-bb">do_put_month_short</link>(iter_type &amp;, month_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id393461-bb">do_put_month_long</link>(iter_type &amp;, month_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id363974-bb">do_put_special_value</link>(iter_type &amp;, special_value_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id407194-bb">do_put_weekday_short</link>(iter_type &amp;, weekday_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id360838-bb">do_put_weekday_long</link>(iter_type &amp;, weekday_enum) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id377493-bb">do_month_sep_char</link>(iter_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id401727-bb">do_day_sep_char</link>(iter_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> ymd_order_spec</type> <link linkend="id345652-bb">do_date_order</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> month_format_spec</type> <link linkend="id290591-bb">do_month_format</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="all_date_names_putconstruct-copy-destruct"/><computeroutput>all_date_names_put</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id395726-bb"/>all_date_names_put(<emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> month_short_names, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> month_long_names, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> special_value_names, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> weekday_short_names, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> weekday_long_names, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;charT separator_char = '-', 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;ymd_order_spec order_spec = ymd_order_iso, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;month_format_spec month_format = month_as_short_string);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id330609-bb"/><computeroutput>all_date_names_put</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> *</type> <anchor id="id432053-bb"/>get_short_month_names() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> *</type> <anchor id="id340176-bb"/>get_long_month_names() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> *</type> <anchor id="id333973-bb"/>get_special_value_names() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> *</type> <anchor id="id349747-bb"/>get_short_weekday_names() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> charT *<emphasis role="bold">const</emphasis> *</type> <anchor id="id409782-bb"/>get_long_weekday_names() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id352064-bb"/><computeroutput>all_date_names_put</computeroutput> protected member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id423911-bb"/>do_put_month_short(iter_type &amp; oitr, month_enum moy) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Generic facet that takes array of chars. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id393461-bb"/>do_put_month_long(iter_type &amp; oitr, month_enum moy) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Long month names. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> 
<anchor id="id363974-bb"/>do_put_special_value(iter_type &amp; oitr, special_value_enum sv) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Special values names. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id407194-bb"/>do_put_weekday_short(iter_type &amp; oitr, weekday_enum wd) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id360838-bb"/>do_put_weekday_long(iter_type &amp; oitr, weekday_enum wd) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id377493-bb"/>do_month_sep_char(iter_type &amp; oitr) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>char between year-month </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id401727-bb"/>do_day_sep_char(iter_type &amp; oitr) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Char to separate month-day. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> ymd_order_spec</type> <anchor id="id345652-bb"/>do_date_order() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Set the date ordering. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> month_format_spec</type> <anchor id="id290591-bb"/>do_month_format() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Set the date ordering. </simpara></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id360230"><title>Header &lt;<ulink url="../../boost/date_time/dst_rules.hpp">boost/date_time/dst_rules.hpp</ulink>&gt;</title><para>Contains template class to provide static dst rule calculations</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type_, <emphasis role="bold">typename</emphasis> time_duration_type_&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="dst_calculator">dst_calculator</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> time_duration_type, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> dst_traits&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="dst_calc_engine">dst_calc_engine</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type_, <emphasis role="bold">typename</emphasis> time_duration_type_, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> dst_start_offset_minutes = , 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">short</emphasis> dst_length_minutes = &gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="us_dst_rules">us_dst_rules</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type_, <emphasis role="bold">typename</emphasis> time_duration_type_&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="null_dst_rules">null_dst_rules</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <anchor id="id407365"/>time_is_dst_result { is_not_in_dst, is_in_dst, ambiguous, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;invalid_time_label };
&#xA0;&#xA0;}
}</synopsis><refentry id="dst_calculator"><refmeta><refentrytitle>Class template dst_calculator</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::dst_calculator</refname><refpurpose><simpara>Dynamic class used to caluclate dst transition information. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type_, <emphasis role="bold">typename</emphasis> time_duration_type_&gt; 
<emphasis role="bold">class</emphasis> dst_calculator {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_duration_type_ time_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type_&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id419715-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>time_is_dst_result</type> 
&#xA0;&#xA0;<link linkend="id364374-bb">process_local_dst_start_day</link>(<emphasis role="bold">const</emphasis> time_duration_type &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, <emphasis role="bold">long</emphasis>) ;
&#xA0;&#xA0;<type>time_is_dst_result</type> 
&#xA0;&#xA0;<link linkend="id381496-bb">process_local_dst_end_day</link>(<emphasis role="bold">const</emphasis> time_duration_type &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, <emphasis role="bold">long</emphasis>) ;
&#xA0;&#xA0;<type>time_is_dst_result</type> 
&#xA0;&#xA0;<link linkend="id420187-bb">local_is_dst</link>(<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">const</emphasis> time_duration_type &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, <emphasis role="bold">const</emphasis> date_type &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, <emphasis role="bold">long</emphasis>) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id419715-bb"/><computeroutput>dst_calculator</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_is_dst_result</type> 
<anchor id="id364374-bb"/>process_local_dst_start_day(<emphasis role="bold">const</emphasis> time_duration_type &amp; time_of_day, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> dst_start_offset_minutes, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">long</emphasis> dst_length_minutes) ;</literallayout></para><simpara>Check the local time offset when on dst start day. </simpara><para>On this dst transition, the time label between the transition boundary and the boudary + the offset are invalid times. If before the boundary then still not in dst. 

</para><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>dst_length_minutes</term><listitem><para>Number of minutes to adjust clock forward </para></listitem></varlistentry><varlistentry><term>dst_start_offset_minutes</term><listitem><para>Local day offset for start of dst </para></listitem></varlistentry><varlistentry><term>time_of_day</term><listitem><para>Time offset in the day for the local time </para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>time_is_dst_result</type> 
<anchor id="id381496-bb"/>process_local_dst_end_day(<emphasis role="bold">const</emphasis> time_duration_type &amp; time_of_day, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> dst_end_offset_minutes, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">long</emphasis> dst_length_minutes) ;</literallayout></para><simpara>Check the local time offset when on the last day of dst. </simpara><para>This is the calculation for the DST end day. On that day times prior to the conversion time - dst_length (1 am in US) are still in dst. Times between the above and the switch time are ambiguous. Times after the start_offset are not in dst. 

</para><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>dst_end_offset_minutes</term><listitem><para>Local time of day for end of dst </para></listitem></varlistentry><varlistentry><term>time_of_day</term><listitem><para>Time offset in the day for the local time </para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>time_is_dst_result</type> 
<anchor id="id420187-bb"/>local_is_dst(<emphasis role="bold">const</emphasis> date_type &amp; current_day, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> time_duration_type &amp; time_of_day, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> date_type &amp; dst_start_day, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> dst_start_offset_minutes, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> date_type &amp; dst_end_day, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> dst_end_offset_minutes, <emphasis role="bold">long</emphasis> dst_length_minutes) ;</literallayout></para><simpara>Calculates if the given local time is dst or not. </simpara><para>Determines if the time is really in DST or not. Also checks for invalid and ambiguous. 

</para><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>current_day</term><listitem><para>The day to check for dst </para></listitem></varlistentry><varlistentry><term>dst_end_day</term><listitem><para>Ending day of dst for the given locality </para></listitem></varlistentry><varlistentry><term>dst_end_offset_minutes</term><listitem><para>Offset within day given in dst for dst boundary (eg 120 for US which is 02:00:00) </para></listitem></varlistentry><varlistentry><term>dst_length_minutes</term><listitem><para>Length of dst adjusment (eg: 60 for US) </para></listitem></varlistentry><varlistentry><term>dst_start_day</term><listitem><para>Starting day of dst for the given locality </para></listitem></varlistentry><varlistentry><term>dst_start_offset_minutes</term><listitem><para>Offset within day for dst boundary (eg 120 for US which is 02:00:00) </para></listitem></varlistentry><varlistentry><term>time_of_day</term><listitem><para>Time offset within the day to check </para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="dst_calc_engine"><refmeta><refentrytitle>Class template dst_calc_engine</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::dst_calc_engine</refname><refpurpose><simpara>Compile-time configurable daylight savings time calculation engine. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> time_duration_type, <emphasis role="bold">typename</emphasis> dst_traits&gt; 
<emphasis role="bold">class</emphasis> dst_calc_engine {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::year_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; year_type;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::calendar_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; calendar_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="dst_calculator">dst_calculator</link>&lt; date_type, time_duration_type &gt; dstcalc;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id389178-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>time_is_dst_result</type> 
&#xA0;&#xA0;<link linkend="id419922-bb">local_is_dst</link>(<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">const</emphasis> time_duration_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id388399-bb">is_dst_boundary_day</link>(date_type) ;
&#xA0;&#xA0;<type>time_duration_type</type> <link linkend="id322866-bb">dst_offset</link>() ;
&#xA0;&#xA0;<type>date_type</type> <link linkend="id404958-bb">local_dst_start_day</link>(year_type) ;
&#xA0;&#xA0;<type>date_type</type> <link linkend="id320630-bb">local_dst_end_day</link>(year_type) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id389178-bb"/><computeroutput>dst_calc_engine</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_is_dst_result</type> 
<anchor id="id419922-bb"/>local_is_dst(<emphasis role="bold">const</emphasis> date_type &amp; d, <emphasis role="bold">const</emphasis> time_duration_type &amp; td) ;</literallayout></para><simpara>Calculates if the given local time is dst or not. </simpara><para>Determines if the time is really in DST or not. Also checks for invalid and ambiguous. 
</para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id388399-bb"/>is_dst_boundary_day(date_type d) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> <anchor id="id322866-bb"/>dst_offset() ;</literallayout></para><simpara>The time of day for the dst transition (eg: typically 01:00:00 or 02:00:00). </simpara></listitem><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id404958-bb"/>local_dst_start_day(year_type year) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id320630-bb"/>local_dst_end_day(year_type year) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="us_dst_rules"><refmeta><refentrytitle>Class template us_dst_rules</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::us_dst_rules</refname><refpurpose><simpara>Depricated: Class to calculate dst boundaries for US time zones. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type_, <emphasis role="bold">typename</emphasis> time_duration_type_, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> dst_start_offset_minutes = , 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">short</emphasis> dst_length_minutes = &gt; 
<emphasis role="bold">class</emphasis> us_dst_rules {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_duration_type_&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type_&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::year_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; year_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::calendar_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; calendar_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="last_kday_of_month">date_time::last_kday_of_month</link>&lt; date_type &gt;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; lkday;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="first_kday_of_month">date_time::first_kday_of_month</link>&lt; date_type &gt;&#xA0;&#xA0;&#xA0;&#xA0; fkday;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="dst_calculator">dst_calculator</link>&lt; date_type, time_duration_type &gt; dstcalc;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id386155-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>time_is_dst_result</type> 
&#xA0;&#xA0;<link linkend="id386160-bb">local_is_dst</link>(<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">const</emphasis> time_duration_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id325846-bb">is_dst_boundary_day</link>(date_type) ;
&#xA0;&#xA0;<type>date_type</type> <link linkend="id376961-bb">local_dst_start_day</link>(year_type) ;
&#xA0;&#xA0;<type>date_type</type> <link linkend="id324575-bb">local_dst_end_day</link>(year_type) ;
&#xA0;&#xA0;<type>time_duration_type</type> <link linkend="id327917-bb">dst_offset</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id386155-bb"/><computeroutput>us_dst_rules</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_is_dst_result</type> 
<anchor id="id386160-bb"/>local_is_dst(<emphasis role="bold">const</emphasis> date_type &amp; d, <emphasis role="bold">const</emphasis> time_duration_type &amp; td) ;</literallayout></para><simpara>Calculates if the given local time is dst or not. </simpara><para>Determines if the time is really in DST or not. Also checks for invalid and ambiguous. 
</para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id325846-bb"/>is_dst_boundary_day(date_type d) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id376961-bb"/>local_dst_start_day(year_type year) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id324575-bb"/>local_dst_end_day(year_type year) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> <anchor id="id327917-bb"/>dst_offset() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="null_dst_rules"><refmeta><refentrytitle>Class template null_dst_rules</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::null_dst_rules</refname><refpurpose><simpara>Used for local time adjustments in places that don't use dst. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type_, <emphasis role="bold">typename</emphasis> time_duration_type_&gt; 
<emphasis role="bold">class</emphasis> null_dst_rules {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_duration_type_ time_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type_&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id300974-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>time_is_dst_result</type> 
&#xA0;&#xA0;<link linkend="id313824-bb">local_is_dst</link>(<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">const</emphasis> time_duration_type &amp;) ;
&#xA0;&#xA0;<type>time_is_dst_result</type> 
&#xA0;&#xA0;<link linkend="id286282-bb">utc_is_dst</link>(<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">const</emphasis> time_duration_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id323313-bb">is_dst_boundary_day</link>(date_type) ;
&#xA0;&#xA0;<type>time_duration_type</type> <link linkend="id312296-bb">dst_offset</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id300974-bb"/><computeroutput>null_dst_rules</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_is_dst_result</type> 
<anchor id="id313824-bb"/>local_is_dst(<emphasis role="bold">const</emphasis> date_type &amp; , <emphasis role="bold">const</emphasis> time_duration_type &amp; ) ;</literallayout></para><simpara>Calculates if the given local time is dst or not. </simpara><para/></listitem><listitem><para><literallayout class="monospaced"><type>time_is_dst_result</type> 
<anchor id="id286282-bb"/>utc_is_dst(<emphasis role="bold">const</emphasis> date_type &amp; , <emphasis role="bold">const</emphasis> time_duration_type &amp; ) ;</literallayout></para><simpara>Calculates if the given utc time is in dst. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id323313-bb"/>is_dst_boundary_day(date_type d) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> <anchor id="id312296-bb"/>dst_offset() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id376648"><title>Header &lt;<ulink url="../../boost/date_time/dst_transition_generators.hpp">boost/date_time/dst_transition_generators.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">class</emphasis> <link linkend="dst_day_calc_rule">dst_day_calc_rule</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> spec&gt; <emphasis role="bold">class</emphasis> <link linkend="day_calc_dst_rule">day_calc_dst_rule</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="dst_day_calc_rule"><refmeta><refentrytitle>Class template dst_day_calc_rule</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::dst_day_calc_rule</refname><refpurpose><simpara>Defines base interface for calculating start and end date of daylight savings. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">class</emphasis> dst_day_calc_rule {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::year_type year_type;

&#xA0;&#xA0;<emphasis>// <link linkend="dst_day_calc_ruleconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id302065-bb">~dst_day_calc_rule</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id425419-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> date_type</type> <link linkend="id284615-bb">start_day</link>(year_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> date_type</type> <link linkend="id435955-bb">end_day</link>(year_type) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="dst_day_calc_ruleconstruct-copy-destruct"/><computeroutput>dst_day_calc_rule</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id302065-bb"/>~dst_day_calc_rule();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id425419-bb"/><computeroutput>dst_day_calc_rule</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> date_type</type> <anchor id="id284615-bb"/>start_day(year_type y) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> date_type</type> <anchor id="id435955-bb"/>end_day(year_type y) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="day_calc_dst_rule"><refmeta><refentrytitle>Class template day_calc_dst_rule</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::day_calc_dst_rule</refname><refpurpose><simpara>Canonical form for a class that provides day rule calculation. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> spec&gt; 
<emphasis role="bold">class</emphasis> day_calc_dst_rule
  :  : <emphasis role="bold">public</emphasis> boost::date_time::dst_day_calc_rule&lt; spec::date_type &gt;
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> spec::date_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::year_type year_type;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> spec::start_rule&#xA0;&#xA0;&#xA0;&#xA0; start_rule;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> spec::end_rule&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; end_rule;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="day_calc_dst_ruleconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id382829-bb">day_calc_dst_rule</link>(start_rule, end_rule);

&#xA0;&#xA0;<emphasis>// <link linkend="id396452-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> date_type</type> <link linkend="id418477-bb">start_day</link>(year_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> date_type</type> <link linkend="id360393-bb">end_day</link>(year_type) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This class is used to generate specific sets of dst rules</para><para/><refsect2><title><anchor id="day_calc_dst_ruleconstruct-copy-destruct"/><computeroutput>day_calc_dst_rule</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id382829-bb"/>day_calc_dst_rule(start_rule dst_start, end_rule dst_end);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id396452-bb"/><computeroutput>day_calc_dst_rule</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> date_type</type> <anchor id="id418477-bb"/>start_day(year_type y) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> date_type</type> <anchor id="id360393-bb"/>end_day(year_type y) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id356584"><title>Header &lt;<ulink url="../../boost/date_time/filetime_functions.hpp">boost/date_time/filetime_functions.hpp</ulink>&gt;</title><para>Function(s) for converting between a FILETIME structure and a time object. This file is only available on systems that have BOOST_HAS_FTIME defined.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type&gt; <type>time_type</type> <link linkend="time_from_ftime">time_from_ftime</link>(<emphasis role="bold">const</emphasis> FILETIME &amp;);
&#xA0;&#xA0;}
}</synopsis><refentry id="time_from_ftime"><refmeta><refentrytitle>Function template time_from_ftime</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::time_from_ftime</refname><refpurpose><simpara>Create a time object from an initialized FILETIME struct. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type&gt; <type>time_type</type> time_from_ftime(<emphasis role="bold">const</emphasis> FILETIME &amp; ft);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Create a time object from an initialized FILETIME struct. A FILETIME struct holds 100-nanosecond units (0.0000001). When built with microsecond resolution the FILETIME's sub second value will be truncated. Nanosecond resolution has no truncation. </para></refsect1></refentry></section><section id="id338206"><title>Header &lt;<ulink url="../../boost/date_time/gregorian_calendar.hpp">boost/date_time/gregorian_calendar.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ymd_type_, <emphasis role="bold">typename</emphasis> date_int_type_&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="gregorian_calendar_base">gregorian_calendar_base</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="gregorian_calendar_base"><refmeta><refentrytitle>Class template gregorian_calendar_base</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::gregorian_calendar_base</refname><refpurpose><simpara>An implementation of the Gregorian calendar. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ymd_type_, <emphasis role="bold">typename</emphasis> date_int_type_&gt; 
<emphasis role="bold">class</emphasis> gregorian_calendar_base {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> ymd_type_&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ymd_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// define a type a date split into components </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> ymd_type::month_type month_type;&#xA0;&#xA0;&#xA0;  <emphasis>// define a type for representing months </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> ymd_type::day_type&#xA0;&#xA0; day_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// define a type for representing days </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> ymd_type::year_type&#xA0; year_type;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// Type to hold a stand alone year value (eg: 2002). </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_int_type_&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_int_type;  <emphasis>// Define the integer type to use for internal calculations. </emphasis>

&#xA0;&#xA0;<emphasis>// <link linkend="id423726-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <link linkend="id426651-bb">day_of_week</link>(<emphasis role="bold">const</emphasis> ymd_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id395028-bb">week_number</link>(<emphasis role="bold">const</emphasis> ymd_type &amp;) ;
&#xA0;&#xA0;<type>date_int_type</type> <link linkend="id367991-bb">day_number</link>(<emphasis role="bold">const</emphasis> ymd_type &amp;) ;
&#xA0;&#xA0;<type>date_int_type</type> <link linkend="id351364-bb">julian_day_number</link>(<emphasis role="bold">const</emphasis> ymd_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">long</emphasis></type> <link linkend="id407932-bb">modjulian_day_number</link>(<emphasis role="bold">const</emphasis> ymd_type &amp;) ;
&#xA0;&#xA0;<type>ymd_type</type> <link linkend="id342753-bb">from_day_number</link>(date_int_type) ;
&#xA0;&#xA0;<type>ymd_type</type> <link linkend="id324808-bb">from_julian_day_number</link>(date_int_type) ;
&#xA0;&#xA0;<type>ymd_type</type> <link linkend="id428393-bb">from_modjulian_day_number</link>(<emphasis role="bold">long</emphasis>) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id430334-bb">is_leap_year</link>(year_type) ;
&#xA0;&#xA0;<type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <link linkend="id400720-bb">end_of_month_day</link>(year_type, month_type) ;
&#xA0;&#xA0;<type>ymd_type</type> <link linkend="id359989-bb">epoch</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <link linkend="id362731-bb">days_in_week</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This is a parameterized implementation of a proleptic Gregorian Calendar that can be used in the creation of date systems or just to perform calculations. All the methods of this class are static functions, so the intent is to never create instances of this class. 
</para><refsect2><title><anchor id="id423726-bb"/><computeroutput>gregorian_calendar_base</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <anchor id="id426651-bb"/>day_of_week(<emphasis role="bold">const</emphasis> ymd_type &amp; ymd) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id395028-bb"/>week_number(<emphasis role="bold">const</emphasis> ymd_type &amp; ymd) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_int_type</type> <anchor id="id367991-bb"/>day_number(<emphasis role="bold">const</emphasis> ymd_type &amp; ymd) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_int_type</type> <anchor id="id351364-bb"/>julian_day_number(<emphasis role="bold">const</emphasis> ymd_type &amp; ymd) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">long</emphasis></type> <anchor id="id407932-bb"/>modjulian_day_number(<emphasis role="bold">const</emphasis> ymd_type &amp; ymd) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>ymd_type</type> <anchor id="id342753-bb"/>from_day_number(date_int_type ) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>ymd_type</type> <anchor id="id324808-bb"/>from_julian_day_number(date_int_type ) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>ymd_type</type> <anchor id="id428393-bb"/>from_modjulian_day_number(<emphasis role="bold">long</emphasis> ) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id430334-bb"/>is_leap_year(year_type ) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <anchor id="id400720-bb"/>end_of_month_day(year_type y, month_type m) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>ymd_type</type> <anchor id="id359989-bb"/>epoch() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <anchor id="id362731-bb"/>days_in_week() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id386642"><title>Header &lt;<ulink url="../../boost/date_time/int_adapter.hpp">boost/date_time/int_adapter.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> int_type_&gt; <emphasis role="bold">class</emphasis> <link linkend="int_adapter">int_adapter</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits, <emphasis role="bold">typename</emphasis> int_type&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id384987"><emphasis role="bold">operator</emphasis>&lt;&lt;</link>(std::basic_ostream&lt; charT, traits &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link>&lt; int_type &gt; &amp;);
&#xA0;&#xA0;}
}</synopsis><refentry id="int_adapter"><refmeta><refentrytitle>Class template int_adapter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::int_adapter</refname><refpurpose><simpara>Adapter to create integer types with +-infinity, and not a value. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> int_type_&gt; 
<emphasis role="bold">class</emphasis> int_adapter {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> int_type_ int_type;

&#xA0;&#xA0;<emphasis>// <link linkend="int_adapterconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id300108-bb">int_adapter</link>(int_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id323624-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id323630-bb">is_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id326407-bb">is_pos_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id322782-bb">is_neg_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id320435-bb">is_nan</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id379638-bb">is_special</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id408572-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id343967-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id326766-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id369714-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id324744-bb"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id284117-bb"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id412479-bb"><emphasis role="bold">operator</emphasis>&gt;</link>(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>int_type</type> <link linkend="id428285-bb">as_number</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>special_values</type> <link linkend="id445295-bb">as_special</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> rhs_type&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <link linkend="id305809-bb"><emphasis role="bold">operator</emphasis>+</link>(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link>&lt; rhs_type &gt; &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <link linkend="id407125-bb"><emphasis role="bold">operator</emphasis>+</link>(<emphasis role="bold">const</emphasis> int_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> rhs_type&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <link linkend="id425794-bb"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link>&lt; rhs_type &gt; &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <link linkend="id351970-bb"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> int_type) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <link linkend="id414307-bb"><emphasis role="bold">operator</emphasis> *</link>(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <link linkend="id372409-bb"><emphasis role="bold">operator</emphasis> *</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis>) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <link linkend="id405581-bb"><emphasis role="bold">operator</emphasis>/</link>(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <link linkend="id334601-bb"><emphasis role="bold">operator</emphasis>/</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis>) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <link linkend="id383665-bb"><emphasis role="bold">operator</emphasis>%</link>(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <link linkend="id325167-bb"><emphasis role="bold">operator</emphasis>%</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis>) <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id321702-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id321707-bb">has_infinity</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link></type> <link linkend="id373839-bb">pos_infinity</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link></type> <link linkend="id386524-bb">neg_infinity</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link></type> <link linkend="id319189-bb">not_a_number</link>() ;
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link> max</type> <link linkend="id372032-bb">BOOST_PREVENT_MACRO_SUBSTITUTION</link>() ;
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link> min</type> <link linkend="id432084-bb">BOOST_PREVENT_MACRO_SUBSTITUTION</link>() ;
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <link linkend="id316024-bb">from_special</link>(special_values) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id400234-bb">is_inf</link>(int_type) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id401368-bb">is_neg_inf</link>(int_type) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id411120-bb">is_pos_inf</link>(int_type) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id349153-bb">is_not_a_number</link>(int_type) ;
&#xA0;&#xA0;<type>special_values</type> <link linkend="id373477-bb">to_special</link>(int_type) ;
&#xA0;&#xA0;<type>int_type</type> <link linkend="id360032-bb">maxcount</link>() ;

&#xA0;&#xA0;<emphasis>// <link linkend="id346826-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id298312-bb">compare</link>(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <link linkend="id377088-bb">mult_div_specials</link>(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <link linkend="id377674-bb">mult_div_specials</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This class is used internally in counted date/time representations. It adds the floating point like features of infinities and not a number. It also provides mathmatical operations with consideration to special values following these rules: <programlisting>  +infinity  -  infinity  == Not A Number (NAN)
   infinity  *  non-zero  == infinity
   infinity  *  zero      == NAN
  +infinity  * -integer   == -infinity
   infinity  /  infinity  == NAN
   infinity  *  infinity  == infinity 
 *
</programlisting></para><refsect2><title><anchor id="int_adapterconstruct-copy-destruct"/><computeroutput>int_adapter</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id300108-bb"/>int_adapter(int_type v);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id323624-bb"/><computeroutput>int_adapter</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id323630-bb"/>is_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id326407-bb"/>is_pos_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id322782-bb"/>is_neg_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id320435-bb"/>is_nan() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id379638-bb"/>is_special() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id408572-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id343967-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id326766-bb"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id369714-bb"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id324744-bb"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id284117-bb"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id412479-bb"/><emphasis role="bold">operator</emphasis>&gt;(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id428285-bb"/>as_number() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>special_values</type> <anchor id="id445295-bb"/>as_special() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns either special value type or is_not_special. </simpara></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> rhs_type&gt; 
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <anchor id="id305809-bb"/><emphasis role="bold">operator</emphasis>+(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link>&lt; rhs_type &gt; &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Operator allows for adding dissimilar int_adapter types. The return type will match that of the the calling object's type </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="int_adapter">int_adapter</link></type> <anchor id="id407125-bb"/><emphasis role="bold">operator</emphasis>+(<emphasis role="bold">const</emphasis> int_type rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> rhs_type&gt; 
&#xA0;&#xA0;<type><link linkend="int_adapter">int_adapter</link></type> <anchor id="id425794-bb"/><emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link>&lt; rhs_type &gt; &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Operator allows for subtracting dissimilar int_adapter types. The return type will match that of the the calling object's type </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="int_adapter">int_adapter</link></type> <anchor id="id351970-bb"/><emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> int_type rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="int_adapter">int_adapter</link></type> <anchor id="id414307-bb"/><emphasis role="bold">operator</emphasis> *(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="int_adapter">int_adapter</link></type> <anchor id="id372409-bb"/><emphasis role="bold">operator</emphasis> *(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Provided for cases when automatic conversion from 'int' to 'int_adapter' causes incorrect results. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="int_adapter">int_adapter</link></type> <anchor id="id405581-bb"/><emphasis role="bold">operator</emphasis>/(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="int_adapter">int_adapter</link></type> <anchor id="id334601-bb"/><emphasis role="bold">operator</emphasis>/(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Provided for cases when automatic conversion from 'int' to 'int_adapter' causes incorrect results. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="int_adapter">int_adapter</link></type> <anchor id="id383665-bb"/><emphasis role="bold">operator</emphasis>%(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="int_adapter">int_adapter</link></type> <anchor id="id325167-bb"/><emphasis role="bold">operator</emphasis>%(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Provided for cases when automatic conversion from 'int' to 'int_adapter' causes incorrect results. </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id321702-bb"/><computeroutput>int_adapter</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id321707-bb"/>has_infinity() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link></type> <anchor id="id373839-bb"/>pos_infinity() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link></type> <anchor id="id386524-bb"/>neg_infinity() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link></type> <anchor id="id319189-bb"/>not_a_number() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="int_adapter">int_adapter</link> max</type> <anchor id="id372032-bb"/>BOOST_PREVENT_MACRO_SUBSTITUTION() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="int_adapter">int_adapter</link> min</type> <anchor id="id432084-bb"/>BOOST_PREVENT_MACRO_SUBSTITUTION() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="int_adapter">int_adapter</link></type> <anchor id="id316024-bb"/>from_special(special_values sv) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id400234-bb"/>is_inf(int_type v) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id401368-bb"/>is_neg_inf(int_type v) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id411120-bb"/>is_pos_inf(int_type v) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id349153-bb"/>is_not_a_number(int_type v) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>special_values</type> <anchor id="id373477-bb"/>to_special(int_type v) ;</literallayout></para><simpara>Returns either special value type or is_not_special. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id360032-bb"/>maxcount() ;</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id346826-bb"/><computeroutput>int_adapter</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id298312-bb"/>compare(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>returns -1, 0, 1, or 2 if 'this' is &lt;, ==, &gt;, or 'nan comparison' rhs </simpara></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="int_adapter">int_adapter</link></type> <anchor id="id377088-bb"/>mult_div_specials(<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Assumes at least 'this' or 'rhs' is a special value. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="int_adapter">int_adapter</link></type> <anchor id="id377674-bb"/>mult_div_specials(<emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Assumes 'this' is a special value. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id384987"><refmeta><refentrytitle>Function template operator&lt;&lt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::operator&lt;&lt;</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits, <emphasis role="bold">typename</emphasis> int_type&gt; 
&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;<emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="int_adapter">int_adapter</link>&lt; int_type &gt; &amp; ia);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Expected output is either a numeric representation or a special values representation.
 Ex. "12", "+infinity", "not-a-number", etc. </para></refsect1></refentry></section><section id="id387443"><title>Header &lt;<ulink url="../../boost/date_time/iso_format.hpp">boost/date_time/iso_format.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; <emphasis role="bold">class</emphasis> <link linkend="iso_format_base">iso_format_base</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;&gt; <emphasis role="bold">class</emphasis> <link linkend="id301674-bb">iso_format_base</link>&lt;<emphasis role="bold">wchar_t</emphasis>&gt;;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; <emphasis role="bold">class</emphasis> <link linkend="iso_format">iso_format</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; <emphasis role="bold">class</emphasis> <link linkend="iso_extended_format">iso_extended_format</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="iso_format_base"><refmeta><refentrytitle>Class template iso_format_base</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::iso_format_base</refname><refpurpose><simpara>Class to provide common iso formatting spec. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
<emphasis role="bold">class</emphasis> iso_format_base {
<emphasis role="bold">public</emphasis>:

&#xA0;&#xA0;<emphasis>// <link linkend="id285752-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>month_format_spec</type> <link linkend="id423503-bb">month_format</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> charT *</type> <link linkend="id313806-bb">not_a_date</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> charT *</type> <link linkend="id387091-bb">pos_infinity</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> charT *</type> <link linkend="id435399-bb">neg_infinity</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id375757-bb">year_sep_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id396391-bb">month_sep_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id366361-bb">day_sep_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id398109-bb">hour_sep_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id312872-bb">minute_sep_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id347104-bb">second_sep_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id372481-bb">period_start_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id422169-bb">time_start_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id425211-bb">week_start_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id352864-bb">period_sep_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id412722-bb">time_sep_char</link>() ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id382708-bb">fractional_time_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id353866-bb">is_component_sep</link>(charT) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id322883-bb">is_fractional_time_sep</link>(charT) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id306355-bb">is_timezone_sep</link>(charT) ;
&#xA0;&#xA0;<type>charT</type> <link linkend="id334743-bb">element_sep_char</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id285752-bb"/><computeroutput>iso_format_base</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>month_format_spec</type> <anchor id="id423503-bb"/>month_format() ;</literallayout></para><simpara>Describe month format -- its an integer in iso format. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> charT *</type> <anchor id="id313806-bb"/>not_a_date() ;</literallayout></para><simpara>String used printed is date is invalid. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> charT *</type> <anchor id="id387091-bb"/>pos_infinity() ;</literallayout></para><simpara>String used to for positive infinity value. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> charT *</type> <anchor id="id435399-bb"/>neg_infinity() ;</literallayout></para><simpara>String used to for positive infinity value. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id375757-bb"/>year_sep_char() ;</literallayout></para><simpara>ISO char for a year -- used in durations. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id396391-bb"/>month_sep_char() ;</literallayout></para><simpara>ISO char for a month. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id366361-bb"/>day_sep_char() ;</literallayout></para><simpara>ISO char for a day. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id398109-bb"/>hour_sep_char() ;</literallayout></para><simpara>char for minute </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id312872-bb"/>minute_sep_char() ;</literallayout></para><simpara>char for minute </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id347104-bb"/>second_sep_char() ;</literallayout></para><simpara>char for second </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id372481-bb"/>period_start_char() ;</literallayout></para><simpara>ISO char for a period. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id422169-bb"/>time_start_char() ;</literallayout></para><simpara>Used in time in mixed strings to set start of time. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id425211-bb"/>week_start_char() ;</literallayout></para><simpara>Used in mixed strings to identify start of a week number. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id352864-bb"/>period_sep_char() ;</literallayout></para><simpara>Separators for periods. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id412722-bb"/>time_sep_char() ;</literallayout></para><simpara>Separator for hh:mm:ss. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id382708-bb"/>fractional_time_sep_char() ;</literallayout></para><simpara>Preferred Separator for hh:mm:ss,decimal_fraction. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id353866-bb"/>is_component_sep(charT sep) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id322883-bb"/>is_fractional_time_sep(charT sep) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id306355-bb"/>is_timezone_sep(charT sep) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>charT</type> <anchor id="id334743-bb"/>element_sep_char() ;</literallayout></para></listitem></orderedlist></refsect2><refsect2><title>Specializations</title><itemizedlist><listitem><para><link linkend="id301674-bb">Class iso_format_base&lt;wchar_t&gt;</link></para></listitem></itemizedlist></refsect2></refsect1></refentry><refentry id="id301674-bb"><refmeta><refentrytitle>Class iso_format_base&lt;wchar_t&gt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::iso_format_base&lt;wchar_t&gt;</refname><refpurpose><simpara>Class to provide common iso formatting spec. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> iso_format_base&lt;<emphasis role="bold">wchar_t</emphasis>&gt; {
<emphasis role="bold">public</emphasis>:

&#xA0;&#xA0;<emphasis>// <link linkend="id401187-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>month_format_spec</type> <link linkend="id401193-bb">month_format</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <link linkend="id362065-bb">not_a_date</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <link linkend="id344660-bb">pos_infinity</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <link linkend="id341918-bb">neg_infinity</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id402263-bb">year_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id395904-bb">month_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id385232-bb">day_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id445030-bb">hour_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id381725-bb">minute_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id368495-bb">second_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id351640-bb">period_start_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id403182-bb">time_start_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id335068-bb">week_start_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id417633-bb">period_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id361957-bb">time_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id322821-bb">fractional_time_sep_char</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id362689-bb">is_component_sep</link>(<emphasis role="bold">wchar_t</emphasis>) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id410074-bb">is_fractional_time_sep</link>(<emphasis role="bold">wchar_t</emphasis>) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id374388-bb">is_timezone_sep</link>(<emphasis role="bold">wchar_t</emphasis>) ;
&#xA0;&#xA0;<type><emphasis role="bold">wchar_t</emphasis></type> <link linkend="id387938-bb">element_sep_char</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id401187-bb"/><computeroutput>iso_format_base</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>month_format_spec</type> <anchor id="id401193-bb"/>month_format() ;</literallayout></para><simpara>Describe month format -- its an integer in iso format. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <anchor id="id362065-bb"/>not_a_date() ;</literallayout></para><simpara>String used printed is date is invalid. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <anchor id="id344660-bb"/>pos_infinity() ;</literallayout></para><simpara>String used to for positive infinity value. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <anchor id="id341918-bb"/>neg_infinity() ;</literallayout></para><simpara>String used to for positive infinity value. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id402263-bb"/>year_sep_char() ;</literallayout></para><simpara>ISO char for a year -- used in durations. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id395904-bb"/>month_sep_char() ;</literallayout></para><simpara>ISO char for a month. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id385232-bb"/>day_sep_char() ;</literallayout></para><simpara>ISO char for a day. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id445030-bb"/>hour_sep_char() ;</literallayout></para><simpara>char for minute </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id381725-bb"/>minute_sep_char() ;</literallayout></para><simpara>char for minute </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id368495-bb"/>second_sep_char() ;</literallayout></para><simpara>char for second </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id351640-bb"/>period_start_char() ;</literallayout></para><simpara>ISO char for a period. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id403182-bb"/>time_start_char() ;</literallayout></para><simpara>Used in time in mixed strings to set start of time. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id335068-bb"/>week_start_char() ;</literallayout></para><simpara>Used in mixed strings to identify start of a week number. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id417633-bb"/>period_sep_char() ;</literallayout></para><simpara>Separators for periods. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id361957-bb"/>time_sep_char() ;</literallayout></para><simpara>Separator for hh:mm:ss. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id322821-bb"/>fractional_time_sep_char() ;</literallayout></para><simpara>Preferred Separator for hh:mm:ss,decimal_fraction. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id362689-bb"/>is_component_sep(<emphasis role="bold">wchar_t</emphasis> sep) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id410074-bb"/>is_fractional_time_sep(<emphasis role="bold">wchar_t</emphasis> sep) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id374388-bb"/>is_timezone_sep(<emphasis role="bold">wchar_t</emphasis> sep) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">wchar_t</emphasis></type> <anchor id="id387938-bb"/>element_sep_char() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="iso_format"><refmeta><refentrytitle>Class template iso_format</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::iso_format</refname><refpurpose><simpara>Format description for iso normal YYYYMMDD. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
<emphasis role="bold">class</emphasis> iso_format : <emphasis role="bold">public</emphasis> boost::date_time::iso_format_base&lt; charT &gt; {
<emphasis role="bold">public</emphasis>:

&#xA0;&#xA0;<emphasis>// <link linkend="id289015-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id289020-bb">has_date_sep_chars</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id289015-bb"/><computeroutput>iso_format</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id289020-bb"/>has_date_sep_chars() ;</literallayout></para><simpara>The ios standard format doesn't use char separators. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="iso_extended_format"><refmeta><refentrytitle>Class template iso_extended_format</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::iso_extended_format</refname><refpurpose><simpara>Extended format uses seperators YYYY-MM-DD. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
<emphasis role="bold">class</emphasis> iso_extended_format
  :  : <emphasis role="bold">public</emphasis> boost::date_time::iso_format_base&lt; charT &gt;
{
<emphasis role="bold">public</emphasis>:

&#xA0;&#xA0;<emphasis>// <link linkend="id323920-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id377392-bb">has_date_sep_chars</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id323920-bb"/><computeroutput>iso_extended_format</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id377392-bb"/>has_date_sep_chars() ;</literallayout></para><simpara>Extended format needs char separators. </simpara></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id399454"><title>Header &lt;<ulink url="../../boost/date_time/local_time_adjustor.hpp">boost/date_time/local_time_adjustor.hpp</ulink>&gt;</title><para>Time adjustment calculations for local times</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_duration_type, <emphasis role="bold">short</emphasis> hours, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis> minutes = &gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="utc_adjustment">utc_adjustment</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type, <emphasis role="bold">typename</emphasis> dst_rules&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="id418394">dynamic_local_time_adjustor</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type, <emphasis role="bold">typename</emphasis> dst_rules, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> utc_offset_rules&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="static_local_time_adjustor">static_local_time_adjustor</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type, <emphasis role="bold">short</emphasis> utc_offset, <emphasis role="bold">typename</emphasis> dst_rule&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="local_adjustor">local_adjustor</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <anchor id="dummy_to_prevent_msvc6_ice"/>dummy_to_prevent_msvc6_ice();
&#xA0;&#xA0;}
}</synopsis><refentry id="utc_adjustment"><refmeta><refentrytitle>Class template utc_adjustment</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::utc_adjustment</refname><refpurpose><simpara>Provides a base offset adjustment from utc. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_duration_type, <emphasis role="bold">short</emphasis> hours, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis> minutes = &gt; 
<emphasis role="bold">class</emphasis> utc_adjustment {
<emphasis role="bold">public</emphasis>:

&#xA0;&#xA0;<emphasis>// <link linkend="id302720-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>time_duration_type</type> <link linkend="id331890-bb">local_to_utc_base_offset</link>() ;
&#xA0;&#xA0;<type>time_duration_type</type> <link linkend="id386568-bb">utc_to_local_base_offset</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id302720-bb"/><computeroutput>utc_adjustment</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> <anchor id="id331890-bb"/>local_to_utc_base_offset() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> <anchor id="id386568-bb"/>utc_to_local_base_offset() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id418394"><refmeta><refentrytitle>Class template dynamic_local_time_adjustor</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::dynamic_local_time_adjustor</refname><refpurpose><simpara>Allow sliding utc adjustment with fixed dst rules. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type, <emphasis role="bold">typename</emphasis> dst_rules&gt; 
<emphasis role="bold">class</emphasis> dynamic_local_time_adjustor {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::time_duration_type time_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::date_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id418394construct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id322307-bb">dynamic_local_time_adjustor</link>(time_duration_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id391590-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>time_duration_type</type> <link linkend="id391596-bb">utc_offset</link>(<emphasis role="bold">bool</emphasis>) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id418394construct-copy-destruct"/><computeroutput>dynamic_local_time_adjustor</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id322307-bb"/>dynamic_local_time_adjustor(time_duration_type utc_offset);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id391590-bb"/><computeroutput>dynamic_local_time_adjustor</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> <anchor id="id391596-bb"/>utc_offset(<emphasis role="bold">bool</emphasis> is_dst) ;</literallayout></para><simpara>Presumes local time. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="static_local_time_adjustor"><refmeta><refentrytitle>Class template static_local_time_adjustor</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::static_local_time_adjustor</refname><refpurpose><simpara>Embed the rules for local time adjustments at compile time. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type, <emphasis role="bold">typename</emphasis> dst_rules, <emphasis role="bold">typename</emphasis> utc_offset_rules&gt; 
<emphasis role="bold">class</emphasis> static_local_time_adjustor {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::time_duration_type time_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::date_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id329177-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>time_duration_type</type> <link linkend="id366953-bb">utc_to_local_offset</link>(<emphasis role="bold">const</emphasis> time_type &amp;) ;
&#xA0;&#xA0;<type>time_duration_type</type> 
&#xA0;&#xA0;<link linkend="id344362-bb">local_to_utc_offset</link>(<emphasis role="bold">const</emphasis> time_type &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;date_time::dst_flags = date_time::calculate) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id329177-bb"/><computeroutput>static_local_time_adjustor</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> <anchor id="id366953-bb"/>utc_to_local_offset(<emphasis role="bold">const</emphasis> time_type &amp; t) ;</literallayout></para><simpara>Calculates the offset from a utc time to local based on dst and utc offset. </simpara><para>
The logic is as follows. Starting with UTC time use the offset to create a label for an non-dst adjusted local time. Then call dst_rules::local_is_dst with the non adjust local time. The results of this function will either unabiguously decide that the initial local time is in dst or return an illegal or ambiguous result. An illegal result only occurs at the end of dst (where labels are skipped) and indicates that dst has ended. An ambiguous result means that we need to recheck by making a dst adjustment and then rechecking. If the dst offset is added to the utc time and the recheck proves non-ambiguous then we are past the boundary. If it is still ambiguous then we are ahead of the boundary and dst is still in effect.</para><para>TODO -- check if all dst offsets are positive. If not then the algorithm needs to check for this and reverse the illegal/ambiguous logic. </para><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>t</term><listitem><para>UTC time to calculate offset to local time This adjustment depends on the following observations about the workings of the DST boundary offset. Since UTC time labels are monotonically increasing we can determine if a given local time is in DST or not and therefore adjust the offset appropriately.</para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> 
<anchor id="id344362-bb"/>local_to_utc_offset(<emphasis role="bold">const</emphasis> time_type &amp; t, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;date_time::dst_flags dst = date_time::calculate) ;</literallayout></para><simpara>Get the offset to UTC given a local time. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="local_adjustor"><refmeta><refentrytitle>Class template local_adjustor</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::local_adjustor</refname><refpurpose><simpara>Template that simplifies the creation of local time calculator. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type, <emphasis role="bold">short</emphasis> utc_offset, <emphasis role="bold">typename</emphasis> dst_rule&gt; 
<emphasis role="bold">class</emphasis> local_adjustor {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::time_duration_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::date_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="static_local_time_adjustor">static_local_time_adjustor</link>&lt; time_type, dst_rule, <link linkend="utc_adjustment">utc_adjustment</link>&lt; time_duration_type, utc_offset &gt; &gt; dst_adjustor;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id412017-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>time_type</type> <link linkend="id360605-bb">utc_to_local</link>(<emphasis role="bold">const</emphasis> time_type &amp;) ;
&#xA0;&#xA0;<type>time_type</type> <link linkend="id424108-bb">local_to_utc</link>(<emphasis role="bold">const</emphasis> time_type &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;date_time::dst_flags = date_time::calculate) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Use this template to create the timezone to utc convertors as required.</para><para>This class will also work for other regions that don't use dst and have a utc offset which is an integral number of hours.</para><para><emphasis role="bold">Template Parameters</emphasis>  -time_type -- Time class to use -utc_offset -- Number hours local time is adjust from utc -use_dst -- true (default) if region uses dst, false otherwise For example: <programlisting>  //eastern timezone is utc-5
     typedef date_time::local_adjustor&lt;ptime, -5, us_dst&gt; us_eastern;
     typedef date_time::local_adjustor&lt;ptime, -6, us_dst&gt; us_central;
     typedef date_time::local_adjustor&lt;ptime, -7, us_dst&gt; us_mountain;
     typedef date_time::local_adjustor&lt;ptime, -8, us_dst&gt; us_pacific;
     typedef date_time::local_adjustor&lt;ptime, -7, no_dst&gt; us_arizona;
</programlisting></para><refsect2><title><anchor id="id412017-bb"/><computeroutput>local_adjustor</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id360605-bb"/>utc_to_local(<emphasis role="bold">const</emphasis> time_type &amp; t) ;</literallayout></para><simpara>Convert a utc time to local time. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id424108-bb"/>local_to_utc(<emphasis role="bold">const</emphasis> time_type &amp; t, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;date_time::dst_flags dst = date_time::calculate) ;</literallayout></para><simpara>Convert a local time to utc. </simpara></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id379829"><title>Header &lt;<ulink url="../../boost/date_time/local_timezone_defs.hpp">boost/date_time/local_timezone_defs.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">struct</emphasis> <link linkend="us_dst_trait">us_dst_trait</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">struct</emphasis> <link linkend="eu_dst_trait">eu_dst_trait</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">struct</emphasis> <link linkend="uk_dst_trait">uk_dst_trait</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; <emphasis role="bold">struct</emphasis> <link linkend="acst_dst_trait">acst_dst_trait</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="us_dst_trait"><refmeta><refentrytitle>Struct template us_dst_trait</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::us_dst_trait</refname><refpurpose><simpara>Specification for daylight savings start rules in US. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">struct</emphasis> us_dst_trait {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::day_of_week_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; day_of_week_type;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::month_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="first_kday_of_month">date_time::first_kday_of_month</link>&lt; date_type &gt; start_rule_functor;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="last_kday_of_month">date_time::last_kday_of_month</link>&lt; date_type &gt;&#xA0; end_rule_functor;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id425487-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>day_of_week_type</type> <link linkend="id425493-bb">start_day</link>() ;
&#xA0;&#xA0;<type>month_type</type> <link linkend="id425805-bb">start_month</link>() ;
&#xA0;&#xA0;<type>day_of_week_type</type> <link linkend="id445060-bb">end_day</link>() ;
&#xA0;&#xA0;<type>month_type</type> <link linkend="id368659-bb">end_month</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id354964-bb">dst_start_offset_minutes</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id327678-bb">dst_end_offset_minutes</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id285738-bb">dst_shift_length_minutes</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This class is used to configure dst_calc_engine template typically as follows: <programlisting>          using namespace boost::gregorian;
          using namespace boost::posix_time;
          typedef us_dst_trait&lt;date&gt; us_dst_traits;
          typedef boost::date_time::dst_calc_engine&lt;date, time_duration, 
                                                    us_dst_traits&gt;  
                                                    us_dst_calc;
          //calculate the 2002 transition day of USA April 7 2002
          date dst_start = us_dst_calc::local_dst_start_day(2002); 

          //calculate the 2002 transition day of USA Oct 27 2002
          date dst_end = us_dst_calc::local_dst_end_day(2002); 
                                                    
          //check if a local time is in dst or not -- posible answers
          //are yes, no, invalid time label, ambiguous
          ptime t(...some time...);  
          if (us_dst::local_is_dst(t.date(), t.time_of_day()) 
              == boost::date_time::is_not_in_dst) 
          {

          }
</programlisting>This generates a type suitable for the calculation of dst transitions for the United States. Of course other templates can be used for other locales. </para><refsect2><title><anchor id="id425487-bb"/><computeroutput>us_dst_trait</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>day_of_week_type</type> <anchor id="id425493-bb"/>start_day() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>month_type</type> <anchor id="id425805-bb"/>start_month() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>day_of_week_type</type> <anchor id="id445060-bb"/>end_day() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>month_type</type> <anchor id="id368659-bb"/>end_month() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id354964-bb"/>dst_start_offset_minutes() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id327678-bb"/>dst_end_offset_minutes() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id285738-bb"/>dst_shift_length_minutes() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="eu_dst_trait"><refmeta><refentrytitle>Struct template eu_dst_trait</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::eu_dst_trait</refname><refpurpose><simpara>Rules for daylight savings start in the EU (Last Sun in Mar). </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">struct</emphasis> eu_dst_trait {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::day_of_week_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; day_of_week_type;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::month_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="last_kday_of_month">date_time::last_kday_of_month</link>&lt; date_type &gt; start_rule_functor;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="last_kday_of_month">date_time::last_kday_of_month</link>&lt; date_type &gt; end_rule_functor;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id320813-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>day_of_week_type</type> <link linkend="id320819-bb">start_day</link>() ;
&#xA0;&#xA0;<type>month_type</type> <link linkend="id408652-bb">start_month</link>() ;
&#xA0;&#xA0;<type>day_of_week_type</type> <link linkend="id313956-bb">end_day</link>() ;
&#xA0;&#xA0;<type>month_type</type> <link linkend="id306446-bb">end_month</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id378606-bb">dst_start_offset_minutes</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id367972-bb">dst_end_offset_minutes</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id427325-bb">dst_shift_length_minutes</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>These amount to the following:<itemizedlist><listitem><para>Start of dst day is last Sunday in March</para></listitem><listitem><para>End day of dst is last Sunday in Oct</para></listitem><listitem><para>Going forward switch time is 2:00 am (offset 120 minutes)</para></listitem><listitem><para>Going back switch time is 3:00 am (off set 180 minutes)</para></listitem><listitem><para>Shift duration is one hour (60 minutes) </para></listitem></itemizedlist></para><refsect2><title><anchor id="id320813-bb"/><computeroutput>eu_dst_trait</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>day_of_week_type</type> <anchor id="id320819-bb"/>start_day() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>month_type</type> <anchor id="id408652-bb"/>start_month() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>day_of_week_type</type> <anchor id="id313956-bb"/>end_day() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>month_type</type> <anchor id="id306446-bb"/>end_month() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id378606-bb"/>dst_start_offset_minutes() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id367972-bb"/>dst_end_offset_minutes() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id427325-bb"/>dst_shift_length_minutes() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="uk_dst_trait"><refmeta><refentrytitle>Struct template uk_dst_trait</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::uk_dst_trait</refname><refpurpose><simpara>Alternative dst traits for some parts of the United Kingdom. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">struct</emphasis> uk_dst_trait : <emphasis role="bold">public</emphasis> boost::date_time::eu_dst_trait&lt; date_type &gt; {

&#xA0;&#xA0;<emphasis>// <link linkend="id299024-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id299030-bb">dst_start_offset_minutes</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id428011-bb">dst_end_offset_minutes</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id319696-bb">dst_shift_length_minutes</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id299024-bb"/><computeroutput>uk_dst_trait</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id299030-bb"/>dst_start_offset_minutes() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id428011-bb"/>dst_end_offset_minutes() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id319696-bb"/>dst_shift_length_minutes() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="acst_dst_trait"><refmeta><refentrytitle>Struct template acst_dst_trait</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::acst_dst_trait</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type&gt; 
<emphasis role="bold">struct</emphasis> acst_dst_trait {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::day_of_week_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; day_of_week_type;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::month_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="last_kday_of_month">date_time::last_kday_of_month</link>&lt; date_type &gt; start_rule_functor;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="last_kday_of_month">date_time::last_kday_of_month</link>&lt; date_type &gt; end_rule_functor;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id344507-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>day_of_week_type</type> <link linkend="id380227-bb">start_day</link>() ;
&#xA0;&#xA0;<type>month_type</type> <link linkend="id401679-bb">start_month</link>() ;
&#xA0;&#xA0;<type>day_of_week_type</type> <link linkend="id312115-bb">end_day</link>() ;
&#xA0;&#xA0;<type>month_type</type> <link linkend="id303015-bb">end_month</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id298176-bb">dst_start_offset_minutes</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id392768-bb">dst_end_offset_minutes</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id400912-bb">dst_shift_length_minutes</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id344507-bb"/><computeroutput>acst_dst_trait</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>day_of_week_type</type> <anchor id="id380227-bb"/>start_day() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>month_type</type> <anchor id="id401679-bb"/>start_month() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>day_of_week_type</type> <anchor id="id312115-bb"/>end_day() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>month_type</type> <anchor id="id303015-bb"/>end_month() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id298176-bb"/>dst_start_offset_minutes() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id392768-bb"/>dst_end_offset_minutes() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id400912-bb"/>dst_shift_length_minutes() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id331390"><title>Header &lt;<ulink url="../../boost/date_time/microsec_time_clock.hpp">boost/date_time/microsec_time_clock.hpp</ulink>&gt;</title><para>This file contains a high resolution time clock implementation.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type&gt; <emphasis role="bold">class</emphasis> <link linkend="microsec_clock">microsec_clock</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="microsec_clock"><refmeta><refentrytitle>Class template microsec_clock</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::microsec_clock</refname><refpurpose><simpara>A clock providing microsecond level resolution. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type&gt; 
<emphasis role="bold">class</emphasis> microsec_clock {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::date_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::time_duration_type time_duration_type;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_duration_type::rep_type&#xA0; resolution_traits_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id430932-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>time_type</type> <link linkend="id310198-bb">local_time</link>() ;

&#xA0;&#xA0;<emphasis>// <link linkend="id427143-bb">private static functions</link></emphasis>
&#xA0;&#xA0;<type>time_type</type> <link linkend="id427149-bb">create_time</link>(timeval *) ;
&#xA0;&#xA0;<type>time_type</type> <link linkend="id405249-bb">local_time</link>() ;
&#xA0;&#xA0;<type>time_type</type> <link linkend="id439095-bb">create_time</link>(FILETIME &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>A high precision clock that measures the local time at a resolution up to microseconds and adjusts to the resolution of the time system. For example, for the a library configuration with nano second resolution, the last 3 places of the fractional seconds will always be 000 since there are 1000 nano-seconds in a micro second. </para><refsect2><title><anchor id="id430932-bb"/><computeroutput>microsec_clock</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id310198-bb"/>local_time() ;</literallayout></para><simpara>Return the local time based on computer clock settings. </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id427143-bb"/><computeroutput>microsec_clock</computeroutput> private static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id427149-bb"/>create_time(timeval * tv) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id405249-bb"/>local_time() ;</literallayout></para><simpara>Return the local time based on computer clock settings. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id439095-bb"/>create_time(FILETIME &amp; ft) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id376408"><title>Header &lt;<ulink url="../../boost/date_time/parse_format_base.hpp">boost/date_time/parse_format_base.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// <simpara>Enum for distinguishing parsing and formatting options. </simpara></emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <anchor id="id405073"/>month_format_spec { month_as_integer, month_as_short_string, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;month_as_long_string };
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <link linkend="id417225">ymd_order_spec</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="id417225"><refmeta><refentrytitle>Type ymd_order_spec</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::ymd_order_spec</refname><refpurpose><simpara>Enum for distinguishing the order of Month, Day, &amp; Year. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>

<emphasis role="bold">enum</emphasis> ymd_order_spec { ymd_order_iso, ymd_order_dmy, ymd_order_us };</synopsis></refsynopsisdiv></refentry></section><section id="id341416"><title>Header &lt;<ulink url="../../boost/date_time/period.hpp">boost/date_time/period.hpp</ulink>&gt;</title><para>This file contain the implementation of the period abstraction. This is basically the same idea as a range. Although this class is intended for use in the time library, it is pretty close to general enough for other numeric uses.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> point_rep, <emphasis role="bold">typename</emphasis> duration_rep&gt; <emphasis role="bold">class</emphasis> <link linkend="period">period</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="period"><refmeta><refentrytitle>Class template period</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::period</refname><refpurpose><simpara>Provides generalized period type useful in date-time systems. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> point_rep, <emphasis role="bold">typename</emphasis> duration_rep&gt; 
<emphasis role="bold">class</emphasis> period {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> point_rep&#xA0;&#xA0;&#xA0; point_type;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> duration_rep duration_type;

&#xA0;&#xA0;<emphasis>// <link linkend="periodconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id331915-bb">period</link>(point_rep, point_rep);
&#xA0;&#xA0;<link linkend="id374831-bb">period</link>(point_rep, duration_rep);

&#xA0;&#xA0;<emphasis>// <link linkend="id342658-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>point_rep</type> <link linkend="id388709-bb">begin</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>point_rep</type> <link linkend="id328284-bb">end</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>point_rep</type> <link linkend="id309120-bb">last</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_rep</type> <link linkend="id368078-bb">length</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id301322-bb">is_null</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id431225-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id367574-bb"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id334269-bb">shift</link>(<emphasis role="bold">const</emphasis> duration_rep &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id371031-bb">contains</link>(<emphasis role="bold">const</emphasis> point_rep &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id414868-bb">contains</link>(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id439120-bb">intersects</link>(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id367980-bb">is_adjacent</link>(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id311046-bb">is_before</link>(<emphasis role="bold">const</emphasis> point_rep &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id410254-bb">is_after</link>(<emphasis role="bold">const</emphasis> point_rep &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="period">period</link></type> <link linkend="id318377-bb">intersection</link>(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="period">period</link></type> <link linkend="id410989-bb">merge</link>(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><link linkend="period">period</link></type> <link linkend="id304882-bb">span</link>(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This template uses a class to represent a time point within the period and another class to represent a duration. As a result, this class is not appropriate for use when the number and duration representation are the same (eg: in the regular number domain).</para><para>A period can be specified by providing either the starting point and a duration or the starting point and the end point( end is NOT part of the period but 1 unit past it. A period will be "invalid" if either start_point &gt;= end_point or the given duration is &lt; 0. Any valid period will return false for is_null().</para><para>Zero length periods are considered valid. In this case the start point is exactly 1 unit less than the end point, in other words start is equal to last.</para><para>In the case that the begin and last are the same, the period has a length of zero units. For example, suppose this is a period of days. That is, each time-point represents a single day. If the start and the last is the same day then the period is zero length.</para><para>The best way to handle periods is usually to provide a start point and a duration. So, day1 + 7 days is a week period which includes all of the first day and 6 more days (eg: Sun to Sat). </para><refsect2><title><anchor id="periodconstruct-copy-destruct"/><computeroutput>period</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id331915-bb"/>period(point_rep first_point, point_rep end_point);</literallayout></para><simpara>create a period from begin to last eg: [begin,end) </simpara><para>If end &lt;= begin then the period will be invalid </para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id374831-bb"/>period(point_rep first_point, duration_rep len);</literallayout></para><simpara>create a period as [begin, begin+len) </simpara><para>If len is &lt; 0 then the period will be invalid </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id342658-bb"/><computeroutput>period</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>point_rep</type> <anchor id="id388709-bb"/>begin() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return the first element in the period. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>point_rep</type> <anchor id="id328284-bb"/>end() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return one past the last element. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>point_rep</type> <anchor id="id309120-bb"/>last() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return the last item in the period. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>duration_rep</type> <anchor id="id368078-bb"/>length() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return the length of the period. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id301322-bb"/>is_null() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>True if period is ill formed (length less than zero). </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id431225-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Equality operator. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id367574-bb"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Strict as defined by rhs.last &lt;= lhs.last. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id334269-bb"/>shift(<emphasis role="bold">const</emphasis> duration_rep &amp; d) ;</literallayout></para><simpara>Shift the start and end by the specified amount. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id371031-bb"/>contains(<emphasis role="bold">const</emphasis> point_rep &amp; point) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>True if the point is inside the period. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id414868-bb"/>contains(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp; other) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>True if this period fully contains (or equals) the other period. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id439120-bb"/>intersects(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp; other) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>True if the periods overlap in any way. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id367980-bb"/>is_adjacent(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp; other) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>True if periods are next to each other without a gap. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id311046-bb"/>is_before(<emphasis role="bold">const</emphasis> point_rep &amp; point) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>True if all of the period is prior to the passed point or end &lt;= t. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id410254-bb"/>is_after(<emphasis role="bold">const</emphasis> point_rep &amp; point) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>True if all of the period is prior or t &lt; start. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="period">period</link></type> <anchor id="id318377-bb"/>intersection(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp; other) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns the period of intersection or invalid range no intersection. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="period">period</link></type> <anchor id="id410989-bb"/>merge(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp; other) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns the union of intersecting periods -- or null period. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="period">period</link></type> <anchor id="id304882-bb"/>span(<emphasis role="bold">const</emphasis> <link linkend="period">period</link> &amp; other) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Combine two periods with earliest start and latest end. </simpara><para>Combines two periods and any gap between them such that start = min(p1.start, p2.start) end = max(p1.end , p2.end) <programlisting>        [---p1---)
                       [---p2---)
 result:
        [-----------p3----------) 
   *
</programlisting></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id404576"><title>Header &lt;<ulink url="../../boost/date_time/special_defs.hpp">boost/date_time/special_defs.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <anchor id="id407341"/>special_values { not_a_date_time, neg_infin, pos_infin, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;min_date_time, max_date_time, not_special, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;NumSpecialValues };
&#xA0;&#xA0;}
}</synopsis></section><section id="id373457"><title>Header &lt;<ulink url="../../boost/date_time/time.hpp">boost/date_time/time.hpp</ulink>&gt;</title><para>This file contains the interface for the time associated classes.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, <emphasis role="bold">typename</emphasis> time_system&gt; <emphasis role="bold">class</emphasis> <link linkend="base_time">base_time</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="base_time"><refmeta><refentrytitle>Class template base_time</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::base_time</refname><refpurpose><simpara>Representation of a precise moment in time, including the date. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, <emphasis role="bold">typename</emphasis> time_system&gt; 
<emphasis role="bold">class</emphasis> base_time {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_system::time_rep_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_rep_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_system::date_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_system::date_duration_type date_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_system::time_duration_type time_duration_type;

&#xA0;&#xA0;<emphasis>// <link linkend="base_timeconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id423414-bb">base_time</link>(<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">const</emphasis> time_duration_type &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;dst_flags = not_dst);
&#xA0;&#xA0;<link linkend="id323093-bb">base_time</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id366790-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>date_type</type> <link linkend="id297973-bb">date</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>time_duration_type</type> <link linkend="id365480-bb">time_of_day</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>std::string</type> <link linkend="id370440-bb">zone_name</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id413641-bb">is_not_a_date_time</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id345886-bb">is_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id334767-bb">is_pos_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id299035-bb">is_neg_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id418938-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> time_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id377164-bb"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> time_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>time_duration_type</type> <link linkend="id405816-bb"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> time_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>time_type</type> <link linkend="id340986-bb"><emphasis role="bold">operator</emphasis>+</link>(<emphasis role="bold">const</emphasis> date_duration_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>time_type</type> <link linkend="id327884-bb"><emphasis role="bold">operator</emphasis>+=</link>(<emphasis role="bold">const</emphasis> date_duration_type &amp;) ;
&#xA0;&#xA0;<type>time_type</type> <link linkend="id333494-bb"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> date_duration_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>time_type</type> <link linkend="id413628-bb"><emphasis role="bold">operator</emphasis>-=</link>(<emphasis role="bold">const</emphasis> date_duration_type &amp;) ;
&#xA0;&#xA0;<type>time_type</type> <link linkend="id381629-bb"><emphasis role="bold">operator</emphasis>+</link>(<emphasis role="bold">const</emphasis> time_duration_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>time_type</type> <link linkend="id306414-bb"><emphasis role="bold">operator</emphasis>+=</link>(<emphasis role="bold">const</emphasis> time_duration_type &amp;) ;
&#xA0;&#xA0;<type>time_type</type> <link linkend="id322540-bb"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> time_duration_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>time_type</type> <link linkend="id349634-bb"><emphasis role="bold">operator</emphasis>-=</link>(<emphasis role="bold">const</emphasis> time_duration_type &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This class is a skeleton for the interface of a temporal type with a resolution that is higher than a day. It is intended that this class be the base class and that the actual time class be derived using the BN pattern. In this way, the derived class can make decisions such as 'should there be a default constructor' and what should it set its value to, should there be optional constructors say allowing only an time_durations that generate a time from a clock,etc. So, in fact multiple time types can be created for a time_system with different construction policies, and all of them can perform basic operations by only writing a copy constructor. Finally, compiler errors are also shorter.</para><para>The real behavior of the time class is provided by the time_system template parameter. This class must provide all the logic for addition, subtraction, as well as define all the interface types. </para><refsect2><title><anchor id="base_timeconstruct-copy-destruct"/><computeroutput>base_time</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id423414-bb"/>base_time(<emphasis role="bold">const</emphasis> date_type &amp; day, <emphasis role="bold">const</emphasis> time_duration_type &amp; td, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;dst_flags dst = not_dst);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id323093-bb"/>base_time(<emphasis role="bold">const</emphasis> time_rep_type &amp; rhs);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id366790-bb"/><computeroutput>base_time</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id297973-bb"/>date() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> <anchor id="id365480-bb"/>time_of_day() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>std::string</type> <anchor id="id370440-bb"/>zone_name() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id413641-bb"/>is_not_a_date_time() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>check to see if date is not a value </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id345886-bb"/>is_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>check to see if date is one of the infinity values </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id334767-bb"/>is_pos_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>check to see if date is greater than all possible dates </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id299035-bb"/>is_neg_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>check to see if date is greater than all possible dates </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id418938-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> time_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Equality operator -- others generated by boost::equality_comparable. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id377164-bb"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> time_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Equality operator -- others generated by boost::less_than_comparable. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> <anchor id="id405816-bb"/><emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> time_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>difference between two times </simpara></listitem><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id340986-bb"/><emphasis role="bold">operator</emphasis>+(<emphasis role="bold">const</emphasis> date_duration_type &amp; dd) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>add date durations </simpara></listitem><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id327884-bb"/><emphasis role="bold">operator</emphasis>+=(<emphasis role="bold">const</emphasis> date_duration_type &amp; dd) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id333494-bb"/><emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> date_duration_type &amp; dd) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>subtract date durations </simpara></listitem><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id413628-bb"/><emphasis role="bold">operator</emphasis>-=(<emphasis role="bold">const</emphasis> date_duration_type &amp; dd) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id381629-bb"/><emphasis role="bold">operator</emphasis>+(<emphasis role="bold">const</emphasis> time_duration_type &amp; td) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>add time durations </simpara></listitem><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id306414-bb"/><emphasis role="bold">operator</emphasis>+=(<emphasis role="bold">const</emphasis> time_duration_type &amp; td) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id322540-bb"/><emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> time_duration_type &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>subtract time durations </simpara></listitem><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id349634-bb"/><emphasis role="bold">operator</emphasis>-=(<emphasis role="bold">const</emphasis> time_duration_type &amp; td) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id347523"><title>Header &lt;<ulink url="../../boost/date_time/time_clock.hpp">boost/date_time/time_clock.hpp</ulink>&gt;</title><para>This file contains the interface for clock devices.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> time_type&gt; <emphasis role="bold">class</emphasis> <link linkend="second_clock">second_clock</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="second_clock"><refmeta><refentrytitle>Class template second_clock</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::second_clock</refname><refpurpose><simpara>A clock providing time level services based on C time_t capabilities. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> date_type, <emphasis role="bold">typename</emphasis> time_type&gt; 
<emphasis role="bold">class</emphasis> second_clock {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::time_duration_type time_duration_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id428262-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>time_type</type> <link linkend="id421481-bb">local_time</link>() ;
&#xA0;&#xA0;<type>time_type</type> <link linkend="id367700-bb">universal_time</link>() ;

&#xA0;&#xA0;<emphasis>// <link linkend="id337896-bb">private static functions</link></emphasis>
&#xA0;&#xA0;<type>time_type</type> <link linkend="id348710-bb">create_time</link>(::std::tm *) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This clock provides resolution to the 1 second level </para><refsect2><title><anchor id="id428262-bb"/><computeroutput>second_clock</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id421481-bb"/>local_time() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id367700-bb"/>universal_time() ;</literallayout></para><simpara>Get the current day in universal date as a ymd_type. </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id337896-bb"/><computeroutput>second_clock</computeroutput> private static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id348710-bb"/>create_time(::std::tm * current) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id390099"><title>Header &lt;<ulink url="../../boost/date_time/time_defs.hpp">boost/date_time/time_defs.hpp</ulink>&gt;</title><para>This file contains nice definitions for handling the resoluion of various time reprsentations.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// <simpara>Defines some nice types for handling time level resolutions. </simpara></emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <anchor id="id339358"/>time_resolutions { sec, tenth, hundreth, milli, ten_thousandth, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;micro, nano, NumResolutions };

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// <simpara>Flags for daylight savings or summer time. </simpara></emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <anchor id="id418358"/>dst_flags { not_dst, is_dst, calculate };
&#xA0;&#xA0;}
}</synopsis></section><section id="id404841"><title>Header &lt;<ulink url="../../boost/date_time/time_duration.hpp">boost/date_time/time_duration.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, <emphasis role="bold">typename</emphasis> rep_type&gt; <emphasis role="bold">class</emphasis> <link linkend="id351182">time_duration</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> base_duration, <emphasis role="bold">long</emphasis> frac_of_second&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="subsecond_duration">subsecond_duration</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="id351182"><refmeta><refentrytitle>Class template time_duration</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::time_duration</refname><refpurpose><simpara>Represents some amount of elapsed time measure to a given resolution. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, <emphasis role="bold">typename</emphasis> rep_type&gt; 
<emphasis role="bold">class</emphasis> time_duration {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; duration_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> rep_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; traits_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> rep_type::day_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; day_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> rep_type::hour_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; hour_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> rep_type::min_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; min_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> rep_type::sec_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; sec_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> rep_type::fractional_seconds_type fractional_seconds_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> rep_type::tick_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; tick_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> rep_type::impl_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; impl_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id351182construct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id328523-bb">time_duration</link>();
&#xA0;&#xA0;<link linkend="id328526-bb">time_duration</link>(hour_type, min_type, sec_type = 0, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;fractional_seconds_type = 0);
&#xA0;&#xA0;<link linkend="id356831-bb">time_duration</link>(<emphasis role="bold">const</emphasis> <link linkend="id351182">time_duration</link>&lt; T, rep_type &gt; &amp;);
&#xA0;&#xA0;<link linkend="id409998-bb">time_duration</link>(special_values);
&#xA0;&#xA0;<link linkend="id415264-bb">time_duration</link>(impl_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id389063-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>hour_type</type> <link linkend="id352370-bb">hours</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>min_type</type> <link linkend="id420513-bb">minutes</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>sec_type</type> <link linkend="id426406-bb">seconds</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>sec_type</type> <link linkend="id344583-bb">total_seconds</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>tick_type</type> <link linkend="id398744-bb">total_milliseconds</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>tick_type</type> <link linkend="id396261-bb">total_nanoseconds</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>tick_type</type> <link linkend="id353188-bb">total_microseconds</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>fractional_seconds_type</type> <link linkend="id393123-bb">fractional_seconds</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id378900-bb">invert_sign</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id306343-bb">is_negative</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id324939-bb"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> <link linkend="id351182">time_duration</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id419986-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="id351182">time_duration</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id381887-bb"><emphasis role="bold">operator</emphasis>-</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id436164-bb"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> duration_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id384923-bb"><emphasis role="bold">operator</emphasis>+</link>(<emphasis role="bold">const</emphasis> duration_type &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id420140-bb"><emphasis role="bold">operator</emphasis>/</link>(<emphasis role="bold">int</emphasis>) ;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id426320-bb"><emphasis role="bold">operator</emphasis>-=</link>(<emphasis role="bold">const</emphasis> duration_type &amp;) ;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id335015-bb"><emphasis role="bold">operator</emphasis>+=</link>(<emphasis role="bold">const</emphasis> duration_type &amp;) ;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id396433-bb"><emphasis role="bold">operator</emphasis>/=</link>(<emphasis role="bold">int</emphasis>) ;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id397252-bb"><emphasis role="bold">operator</emphasis> *</link>(<emphasis role="bold">int</emphasis>) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id394738-bb"><emphasis role="bold">operator</emphasis> *=</link>(<emphasis role="bold">int</emphasis>) ;
&#xA0;&#xA0;<type>tick_type</type> <link linkend="id421383-bb">ticks</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id387277-bb">is_special</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id313944-bb">is_pos_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id413314-bb">is_neg_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id285380-bb">is_not_a_date_time</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>impl_type</type> <link linkend="id385828-bb">get_rep</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id414557-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>duration_type</type> <link linkend="id414563-bb">unit</link>() ;
&#xA0;&#xA0;<type>tick_type</type> <link linkend="id428982-bb">ticks_per_second</link>() ;
&#xA0;&#xA0;<type>time_resolutions</type> <link linkend="id378100-bb">resolution</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <link linkend="id364666-bb">num_fractional_digits</link>() ;

&#xA0;&#xA0;<emphasis>// <link linkend="id312040-bb">protected member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This class represents a standard set of capabilities for all counted time durations. Time duration implementations should derive from this class passing their type as the first template parameter. This design allows the subclass duration types to provide custom construction policies or other custom features not provided here.</para><para/><refsect2><title><anchor id="id351182construct-copy-destruct"/><computeroutput>time_duration</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id328523-bb"/>time_duration();</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id328526-bb"/>time_duration(hour_type hours, min_type minutes, sec_type seconds = 0, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;fractional_seconds_type frac_sec = 0);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id356831-bb"/>time_duration(<emphasis role="bold">const</emphasis> <link linkend="id351182">time_duration</link>&lt; T, rep_type &gt; &amp; other);</literallayout></para><simpara>Construct from another time_duration (Copy constructor). </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id409998-bb"/>time_duration(special_values sv);</literallayout></para><simpara>Construct from special_values. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id415264-bb"/>time_duration(impl_type in);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id389063-bb"/><computeroutput>time_duration</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>hour_type</type> <anchor id="id352370-bb"/>hours() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns number of hours in the duration. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>min_type</type> <anchor id="id420513-bb"/>minutes() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns normalized number of minutes. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>sec_type</type> <anchor id="id426406-bb"/>seconds() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns normalized number of seconds (0..60). </simpara></listitem><listitem><para><literallayout class="monospaced"><type>sec_type</type> <anchor id="id344583-bb"/>total_seconds() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns total number of seconds truncating any fractional seconds. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>tick_type</type> <anchor id="id398744-bb"/>total_milliseconds() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns total number of milliseconds truncating any fractional seconds. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>tick_type</type> <anchor id="id396261-bb"/>total_nanoseconds() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns total number of nanoseconds truncating any sub millisecond values. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>tick_type</type> <anchor id="id353188-bb"/>total_microseconds() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns total number of microseconds truncating any sub microsecond values. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>fractional_seconds_type</type> <anchor id="id393123-bb"/>fractional_seconds() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns count of fractional seconds at given resolution. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id378900-bb"/>invert_sign() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id306343-bb"/>is_negative() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id324939-bb"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> <link linkend="id351182">time_duration</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id419986-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="id351182">time_duration</link> &amp; rhs) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id381887-bb"/><emphasis role="bold">operator</emphasis>-() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>unary- Allows for time_duration td = -td1 </simpara></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id436164-bb"/><emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> duration_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id384923-bb"/><emphasis role="bold">operator</emphasis>+(<emphasis role="bold">const</emphasis> duration_type &amp; d) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id420140-bb"/><emphasis role="bold">operator</emphasis>/(<emphasis role="bold">int</emphasis> divisor) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id426320-bb"/><emphasis role="bold">operator</emphasis>-=(<emphasis role="bold">const</emphasis> duration_type &amp; d) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id335015-bb"/><emphasis role="bold">operator</emphasis>+=(<emphasis role="bold">const</emphasis> duration_type &amp; d) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id396433-bb"/><emphasis role="bold">operator</emphasis>/=(<emphasis role="bold">int</emphasis> divisor) ;</literallayout></para><simpara>Division operations on a duration with an integer. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id397252-bb"/><emphasis role="bold">operator</emphasis> *(<emphasis role="bold">int</emphasis> rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Multiplication operations an a duration with an integer. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id394738-bb"/><emphasis role="bold">operator</emphasis> *=(<emphasis role="bold">int</emphasis> divisor) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>tick_type</type> <anchor id="id421383-bb"/>ticks() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id387277-bb"/>is_special() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Is ticks_ a special value? </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id313944-bb"/>is_pos_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Is duration pos-infinity. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id413314-bb"/>is_neg_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Is duration neg-infinity. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id285380-bb"/>is_not_a_date_time() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Is duration not-a-date-time. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>impl_type</type> <anchor id="id385828-bb"/>get_rep() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Used for special_values output. </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id414557-bb"/><computeroutput>time_duration</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>duration_type</type> <anchor id="id414563-bb"/>unit() ;</literallayout></para><simpara>Returns smallest representable duration. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>tick_type</type> <anchor id="id428982-bb"/>ticks_per_second() ;</literallayout></para><simpara>Return the number of ticks in a second. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>time_resolutions</type> <anchor id="id378100-bb"/>resolution() ;</literallayout></para><simpara>Provide the resolution of this duration type. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <anchor id="id364666-bb"/>num_fractional_digits() ;</literallayout></para><simpara>Returns number of possible digits in fractional seconds. </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id312040-bb"/><computeroutput>time_duration</computeroutput> protected member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="subsecond_duration"><refmeta><refentrytitle>Class template subsecond_duration</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::subsecond_duration</refname><refpurpose><simpara>Template for instantiating derived adjusting durations. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> base_duration, <emphasis role="bold">long</emphasis> frac_of_second&gt; 
<emphasis role="bold">class</emphasis> subsecond_duration {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> base_duration::traits_type traits_type;

&#xA0;&#xA0;<emphasis>// <link linkend="subsecond_durationconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id417384-bb">subsecond_duration</link>(<emphasis role="bold">long</emphasis>);

&#xA0;&#xA0;<emphasis>// <link linkend="id400729-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="subsecond_durationconstruct-copy-destruct"/><computeroutput>subsecond_duration</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id417384-bb"/>subsecond_duration(<emphasis role="bold">long</emphasis> ss);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id400729-bb"/><computeroutput>subsecond_duration</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry></section><section id="id435250"><title>Header &lt;<ulink url="../../boost/date_time/time_formatting_streams.hpp">boost/date_time/time_formatting_streams.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_duration_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="id401643">ostream_time_duration_formatter</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="ostream_time_formatter">ostream_time_formatter</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_period_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="id379036">ostream_time_period_formatter</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="id401643"><refmeta><refentrytitle>Class template ostream_time_duration_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::ostream_time_duration_formatter</refname><refpurpose><simpara>Put a time type into a stream using appropriate facets. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_duration_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
<emphasis role="bold">class</emphasis> ostream_time_duration_formatter {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::basic_ostream&lt; charT &gt;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ostream_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_duration_type::fractional_seconds_type fractional_seconds_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id325896-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id319677-bb">duration_put</link>(<emphasis role="bold">const</emphasis> time_duration_type &amp;, ostream_type &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id325896-bb"/><computeroutput>ostream_time_duration_formatter</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id319677-bb"/>duration_put(<emphasis role="bold">const</emphasis> time_duration_type &amp; td, ostream_type &amp; os) ;</literallayout></para><simpara>Put time into an ostream. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="ostream_time_formatter"><refmeta><refentrytitle>Class template ostream_time_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::ostream_time_formatter</refname><refpurpose><simpara>Put a time type into a stream using appropriate facets. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
<emphasis role="bold">class</emphasis> ostream_time_formatter {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::basic_ostream&lt; charT &gt;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ostream_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::date_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::time_duration_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="id401643">ostream_time_duration_formatter</link>&lt; time_duration_type, charT &gt; duration_formatter;

&#xA0;&#xA0;<emphasis>// <link linkend="id303032-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id315961-bb">time_put</link>(<emphasis role="bold">const</emphasis> time_type &amp;, ostream_type &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id303032-bb"/><computeroutput>ostream_time_formatter</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id315961-bb"/>time_put(<emphasis role="bold">const</emphasis> time_type &amp; t, ostream_type &amp; os) ;</literallayout></para><simpara>Put time into an ostream. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id379036"><refmeta><refentrytitle>Class template ostream_time_period_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::ostream_time_period_formatter</refname><refpurpose><simpara>Put a time period into a stream using appropriate facets. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_period_type, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
<emphasis role="bold">class</emphasis> ostream_time_period_formatter {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::basic_ostream&lt; charT &gt;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ostream_type;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_period_type::point_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="ostream_time_formatter">ostream_time_formatter</link>&lt; time_type, charT &gt; time_formatter;

&#xA0;&#xA0;<emphasis>// <link linkend="id423339-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id423345-bb">period_put</link>(<emphasis role="bold">const</emphasis> time_period_type &amp;, ostream_type &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id423339-bb"/><computeroutput>ostream_time_period_formatter</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id423345-bb"/>period_put(<emphasis role="bold">const</emphasis> time_period_type &amp; tp, ostream_type &amp; os) ;</literallayout></para><simpara>Put time into an ostream. </simpara></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id322749"><title>Header &lt;<ulink url="../../boost/date_time/time_iterator.hpp">boost/date_time/time_iterator.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type&gt; <emphasis role="bold">class</emphasis> <link linkend="time_itr">time_itr</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="time_itr"><refmeta><refentrytitle>Class template time_itr</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::time_itr</refname><refpurpose><simpara>Simple time iterator skeleton class. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type&gt; 
<emphasis role="bold">class</emphasis> time_itr {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_type::time_duration_type time_duration_type;

&#xA0;&#xA0;<emphasis>// <link linkend="time_itrconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id331817-bb">time_itr</link>(time_type, time_duration_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id404130-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><link linkend="time_itr">time_itr</link> &amp;</type> <link linkend="id404136-bb"><emphasis role="bold">operator</emphasis>++</link>() ;
&#xA0;&#xA0;<type><link linkend="time_itr">time_itr</link> &amp;</type> <link linkend="id414005-bb"><emphasis role="bold">operator</emphasis>--</link>() ;
&#xA0;&#xA0;<type>time_type</type> <link linkend="id320162-bb"><emphasis role="bold">operator</emphasis> *</link>() ;
&#xA0;&#xA0;<type>time_type *</type> <link linkend="id413457-bb"><emphasis role="bold">operator</emphasis>-&gt;</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id354252-bb"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> time_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id323801-bb"><emphasis role="bold">operator</emphasis>&lt;=</link>(<emphasis role="bold">const</emphasis> time_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id373646-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> time_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id321068-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> time_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id304236-bb"><emphasis role="bold">operator</emphasis>&gt;</link>(<emphasis role="bold">const</emphasis> time_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id316222-bb"><emphasis role="bold">operator</emphasis>&gt;=</link>(<emphasis role="bold">const</emphasis> time_type &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="time_itrconstruct-copy-destruct"/><computeroutput>time_itr</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id331817-bb"/>time_itr(time_type t, time_duration_type d);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id404130-bb"/><computeroutput>time_itr</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><link linkend="time_itr">time_itr</link> &amp;</type> <anchor id="id404136-bb"/><emphasis role="bold">operator</emphasis>++() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="time_itr">time_itr</link> &amp;</type> <anchor id="id414005-bb"/><emphasis role="bold">operator</emphasis>--() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_type</type> <anchor id="id320162-bb"/><emphasis role="bold">operator</emphasis> *() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_type *</type> <anchor id="id413457-bb"/><emphasis role="bold">operator</emphasis>-&gt;() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id354252-bb"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> time_type &amp; t) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id323801-bb"/><emphasis role="bold">operator</emphasis>&lt;=(<emphasis role="bold">const</emphasis> time_type &amp; t) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id373646-bb"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> time_type &amp; t) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id321068-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> time_type &amp; t) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id304236-bb"/><emphasis role="bold">operator</emphasis>&gt;(<emphasis role="bold">const</emphasis> time_type &amp; t) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id316222-bb"/><emphasis role="bold">operator</emphasis>&gt;=(<emphasis role="bold">const</emphasis> time_type &amp; t) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id364961"><title>Header &lt;<ulink url="../../boost/date_time/time_parsing.hpp">boost/date_time/time_parsing.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_duration&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="id351182">time_duration</link></type> <link linkend="id367349">parse_delimited_time_duration</link>(<emphasis role="bold">const</emphasis> std::string &amp;);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Utility function to split appart string. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id332099"/>split(<emphasis role="bold">const</emphasis> std::string &amp; s, <emphasis role="bold">char</emphasis> sep, std::string &amp; first, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;std::string &amp; second);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>time_type</type> <anchor id="parse_delimited_time"/>parse_delimited_time(<emphasis role="bold">const</emphasis> std::string &amp; s, <emphasis role="bold">char</emphasis> sep);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Parse time duration part of an iso time of form: [-]hhmmss (eg: 120259 is 12 hours 2 min 59 seconds). </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_duration&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="id351182">time_duration</link></type> <anchor id="id422876"/>parse_undelimited_time_duration(<emphasis role="bold">const</emphasis> std::string &amp; s);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Parse time string of form YYYYMMDDThhmmss where T is delimeter between date and time. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>time_type</type> <anchor id="parse_iso_time"/>parse_iso_time(<emphasis role="bold">const</emphasis> std::string &amp; s, <emphasis role="bold">char</emphasis> sep);
&#xA0;&#xA0;}
}</synopsis><refentry id="id367349"><refmeta><refentrytitle>Function template parse_delimited_time_duration</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::parse_delimited_time_duration</refname><refpurpose><simpara>Creates a time_duration object from a delimited string. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_duration&gt; 
&#xA0;&#xA0;<type><link linkend="id351182">time_duration</link></type> parse_delimited_time_duration(<emphasis role="bold">const</emphasis> std::string &amp; s);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Expected format for string is "[-]h[h][:mm][:ss][.fff]". A negative duration will be created if the first character in string is a '-', all other '-' will be treated as delimiters. Accepted delimiters are "-:,.". </para></refsect1></refentry></section><section id="id316460"><title>Header &lt;<ulink url="../../boost/date_time/time_resolution_traits.hpp">boost/date_time/time_resolution_traits.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="id329534">time_resolution_traits_bi32_impl</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="id361126">time_resolution_traits_adapted32_impl</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="id434902">time_resolution_traits_bi64_impl</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="id430258">time_resolution_traits_adapted64_impl</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> frac_sec_type, time_resolutions res, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;#<emphasis role="bold">if</emphasis>(defined(BOOST_MSVC)&amp;&amp;(_MSC_VER&lt;=1200)) boost::int64_t resolution_adjust, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;#<emphasis role="bold">else</emphasis> <emphasis role="bold">typename</emphasis> frac_sec_type::int_type resolution_adjust, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;#endif <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis> frac_digits, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> v_type = boost::int32_t&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="time_resolution_traits">time_resolution_traits</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_resolution_traits&lt; <link linkend="id361126">time_resolution_traits_adapted32_impl</link>, milli, 1000, 3 &gt; milli_res;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_resolution_traits&lt; <link linkend="id430258">time_resolution_traits_adapted64_impl</link>, micro, 1000000, 6 &gt; micro_res;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_resolution_traits&lt; <link linkend="id430258">time_resolution_traits_adapted64_impl</link>, nano, 1000000000, 9 &gt; nano_res;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Simple function to calculate absolute value of a numeric type. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type>T</type> <anchor id="absolute_value"/>absolute_value(T x);
&#xA0;&#xA0;}
}</synopsis><refentry id="id329534"><refmeta><refentrytitle>Struct time_resolution_traits_bi32_impl</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::time_resolution_traits_bi32_impl</refname><refpurpose><simpara>traits struct for time_resolution_traits implementation type </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> time_resolution_traits_bi32_impl {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::int32_t int_type;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::int32_t impl_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id409641-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>int_type</type> <link linkend="id420146-bb">as_number</link>(impl_type) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id328099-bb">is_adapted</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id409641-bb"/><computeroutput>time_resolution_traits_bi32_impl</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id420146-bb"/>as_number(impl_type i) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id328099-bb"/>is_adapted() ;</literallayout></para><simpara>Used to determine if implemented type is int_adapter or int. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id361126"><refmeta><refentrytitle>Struct time_resolution_traits_adapted32_impl</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::time_resolution_traits_adapted32_impl</refname><refpurpose><simpara>traits struct for time_resolution_traits implementation type </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> time_resolution_traits_adapted32_impl {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::int32_t&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int_type;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="int_adapter">boost::date_time::int_adapter</link>&lt; boost::int32_t &gt; impl_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id341072-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>int_type</type> <link linkend="id341079-bb">as_number</link>(impl_type) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id425167-bb">is_adapted</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id341072-bb"/><computeroutput>time_resolution_traits_adapted32_impl</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id341079-bb"/>as_number(impl_type i) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id425167-bb"/>is_adapted() ;</literallayout></para><simpara>Used to determine if implemented type is int_adapter or int. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id434902"><refmeta><refentrytitle>Struct time_resolution_traits_bi64_impl</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::time_resolution_traits_bi64_impl</refname><refpurpose><simpara>traits struct for time_resolution_traits implementation type </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> time_resolution_traits_bi64_impl {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::int64_t int_type;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::int64_t impl_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id407000-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>int_type</type> <link linkend="id407006-bb">as_number</link>(impl_type) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id394548-bb">is_adapted</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id407000-bb"/><computeroutput>time_resolution_traits_bi64_impl</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id407006-bb"/>as_number(impl_type i) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id394548-bb"/>is_adapted() ;</literallayout></para><simpara>Used to determine if implemented type is int_adapter or int. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id430258"><refmeta><refentrytitle>Struct time_resolution_traits_adapted64_impl</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::time_resolution_traits_adapted64_impl</refname><refpurpose><simpara>traits struct for time_resolution_traits implementation type </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> time_resolution_traits_adapted64_impl {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::int64_t&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int_type;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="int_adapter">boost::date_time::int_adapter</link>&lt; boost::int64_t &gt; impl_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id408463-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>int_type</type> <link linkend="id305399-bb">as_number</link>(impl_type) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id370669-bb">is_adapted</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id408463-bb"/><computeroutput>time_resolution_traits_adapted64_impl</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id305399-bb"/>as_number(impl_type i) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id370669-bb"/>is_adapted() ;</literallayout></para><simpara>Used to determine if implemented type is int_adapter or int. </simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="time_resolution_traits"><refmeta><refentrytitle>Class template time_resolution_traits</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::time_resolution_traits</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> frac_sec_type, time_resolutions res, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;#<emphasis role="bold">if</emphasis>(defined(BOOST_MSVC)&amp;&amp;(_MSC_VER&lt;=1200)) boost::int64_t resolution_adjust, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;#<emphasis role="bold">else</emphasis> <emphasis role="bold">typename</emphasis> frac_sec_type::int_type resolution_adjust, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;#endif <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis> frac_digits, <emphasis role="bold">typename</emphasis> v_type = boost::int32_t&gt; 
<emphasis role="bold">class</emphasis> time_resolution_traits {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> frac_sec_type::int_type&#xA0; fractional_seconds_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> frac_sec_type::int_type&#xA0; tick_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> frac_sec_type::impl_type impl_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> v_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; day_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> v_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; hour_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> v_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; min_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> v_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; sec_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id405643-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type/> <link linkend="id405648-bb">BOOST_STATIC_CONSTANT</link>(<emphasis role="bold">int</emphasis>, ticks_per_second = resolution_adjust) ;

&#xA0;&#xA0;<emphasis>// <link linkend="id372701-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>frac_sec_type::int_type</type> <link linkend="id376258-bb">as_number</link>(<emphasis role="bold">typename</emphasis> frac_sec_type::impl_type) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id393613-bb">is_adapted</link>() ;
&#xA0;&#xA0;<type>time_resolutions</type> <link linkend="id392830-bb">resolution</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <link linkend="id338041-bb">num_fractional_digits</link>() ;
&#xA0;&#xA0;<type>fractional_seconds_type</type> <link linkend="id302892-bb">res_adjust</link>() ;
&#xA0;&#xA0;<type>tick_type</type> <link linkend="id428380-bb">to_tick_count</link>(hour_type, min_type, sec_type, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;fractional_seconds_type) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id405643-bb"/><computeroutput>time_resolution_traits</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type/> <anchor id="id405648-bb"/>BOOST_STATIC_CONSTANT(<emphasis role="bold">int</emphasis> , ticks_per_second  = resolution_adjust) ;</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id372701-bb"/><computeroutput>time_resolution_traits</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>frac_sec_type::int_type</type> <anchor id="id376258-bb"/>as_number(<emphasis role="bold">typename</emphasis> frac_sec_type::impl_type i) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id393613-bb"/>is_adapted() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_resolutions</type> <anchor id="id392830-bb"/>resolution() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <anchor id="id338041-bb"/>num_fractional_digits() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>fractional_seconds_type</type> <anchor id="id302892-bb"/>res_adjust() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>tick_type</type> <anchor id="id428380-bb"/>to_tick_count(hour_type hours, min_type minutes, sec_type seconds, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;fractional_seconds_type fs) ;</literallayout></para><simpara>Any negative argument results in a negative tick_count. </simpara></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id340438"><title>Header &lt;<ulink url="../../boost/date_time/time_system_counted.hpp">boost/date_time/time_system_counted.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> config&gt; <emphasis role="bold">struct</emphasis> <link linkend="counted_time_rep">counted_time_rep</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_rep&gt; <emphasis role="bold">class</emphasis> <link linkend="counted_time_system">counted_time_system</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="counted_time_rep"><refmeta><refentrytitle>Struct template counted_time_rep</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::counted_time_rep</refname><refpurpose><simpara>Time representation that uses a single integer count. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> config&gt; 
<emphasis role="bold">struct</emphasis> counted_time_rep {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> config::int_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> config::date_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> config::impl_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; impl_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::duration_type&#xA0;&#xA0; date_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::calendar_type&#xA0;&#xA0; calendar_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_type::ymd_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ymd_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> config::time_duration_type time_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> config::resolution_traits&#xA0; resolution_traits;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="counted_time_repconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id328765-bb">counted_time_rep</link>(<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">const</emphasis> time_duration_type &amp;);
&#xA0;&#xA0;<link linkend="id436918-bb">counted_time_rep</link>(int_type);
&#xA0;&#xA0;<link linkend="id315203-bb">counted_time_rep</link>(impl_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id427696-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>date_type</type> <link linkend="id345360-bb">date</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>int_type</type> <link linkend="id409169-bb">day_count</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>int_type</type> <link linkend="id376069-bb">time_count</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>int_type</type> <link linkend="id385014-bb">tod</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id371292-bb">is_pos_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id364071-bb">is_neg_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id322139-bb">is_not_a_date_time</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id306976-bb">is_special</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>impl_type</type> <link linkend="id343329-bb">get_rep</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id353151-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>int_type</type> <link linkend="id417030-bb">frac_sec_per_day</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="counted_time_repconstruct-copy-destruct"/><computeroutput>counted_time_rep</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id328765-bb"/>counted_time_rep(<emphasis role="bold">const</emphasis> date_type &amp; d, <emphasis role="bold">const</emphasis> time_duration_type &amp; tod);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id436918-bb"/>counted_time_rep(int_type count);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id315203-bb"/>counted_time_rep(impl_type count);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id427696-bb"/><computeroutput>counted_time_rep</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id345360-bb"/>date() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id409169-bb"/>day_count() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id376069-bb"/>time_count() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id385014-bb"/>tod() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id371292-bb"/>is_pos_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id364071-bb"/>is_neg_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id322139-bb"/>is_not_a_date_time() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id306976-bb"/>is_special() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>impl_type</type> <anchor id="id343329-bb"/>get_rep() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id353151-bb"/><computeroutput>counted_time_rep</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id417030-bb"/>frac_sec_per_day() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="counted_time_system"><refmeta><refentrytitle>Class template counted_time_system</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::counted_time_system</refname><refpurpose><simpara>An unadjusted time system implementation. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_rep&gt; 
<emphasis role="bold">class</emphasis> counted_time_system {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_rep&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_rep_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_rep_type::impl_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; impl_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_rep_type::time_duration_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_duration_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_duration_type::fractional_seconds_type fractional_seconds_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_rep_type::date_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_rep_type::date_duration_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_duration_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id426276-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type><emphasis role="bold">void</emphasis></type> <link linkend="id347039-bb">unused_var</link>(<emphasis role="bold">const</emphasis> T &amp;) ;
&#xA0;&#xA0;<type>time_rep_type</type> 
&#xA0;&#xA0;<link linkend="id318744-bb">get_time_rep</link>(<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">const</emphasis> time_duration_type &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;date_time::dst_flags = not_dst) ;
&#xA0;&#xA0;<type>date_type</type> <link linkend="id422850-bb">get_date</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;) ;
&#xA0;&#xA0;<type>time_duration_type</type> <link linkend="id432729-bb">get_time_of_day</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;) ;
&#xA0;&#xA0;<type>std::string</type> <link linkend="id306662-bb">zone_name</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id338270-bb">is_equal</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, <emphasis role="bold">const</emphasis> time_rep_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id394315-bb">is_less</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, <emphasis role="bold">const</emphasis> time_rep_type &amp;) ;
&#xA0;&#xA0;<type>time_rep_type</type> <link linkend="id413478-bb">add_days</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, <emphasis role="bold">const</emphasis> date_duration_type &amp;) ;
&#xA0;&#xA0;<type>time_rep_type</type> 
&#xA0;&#xA0;<link linkend="id422191-bb">subtract_days</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, <emphasis role="bold">const</emphasis> date_duration_type &amp;) ;
&#xA0;&#xA0;<type>time_rep_type</type> 
&#xA0;&#xA0;<link linkend="id329240-bb">subtract_time_duration</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, <emphasis role="bold">const</emphasis> time_duration_type &amp;) ;
&#xA0;&#xA0;<type>time_rep_type</type> <link linkend="id339102-bb">add_time_duration</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, time_duration_type) ;
&#xA0;&#xA0;<type>time_duration_type</type> 
&#xA0;&#xA0;<link linkend="id285446-bb">subtract_times</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, <emphasis role="bold">const</emphasis> time_rep_type &amp;) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id426276-bb"/><computeroutput>counted_time_system</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type><emphasis role="bold">void</emphasis></type> <anchor id="id347039-bb"/>unused_var(<emphasis role="bold">const</emphasis> T &amp; ) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_rep_type</type> 
<anchor id="id318744-bb"/>get_time_rep(<emphasis role="bold">const</emphasis> date_type &amp; day, <emphasis role="bold">const</emphasis> time_duration_type &amp; tod, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;date_time::dst_flags dst = not_dst) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id422850-bb"/>get_date(<emphasis role="bold">const</emphasis> time_rep_type &amp; val) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> <anchor id="id432729-bb"/>get_time_of_day(<emphasis role="bold">const</emphasis> time_rep_type &amp; val) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>std::string</type> <anchor id="id306662-bb"/>zone_name(<emphasis role="bold">const</emphasis> time_rep_type &amp; ) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id338270-bb"/>is_equal(<emphasis role="bold">const</emphasis> time_rep_type &amp; lhs, <emphasis role="bold">const</emphasis> time_rep_type &amp; rhs) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id394315-bb"/>is_less(<emphasis role="bold">const</emphasis> time_rep_type &amp; lhs, <emphasis role="bold">const</emphasis> time_rep_type &amp; rhs) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_rep_type</type> 
<anchor id="id413478-bb"/>add_days(<emphasis role="bold">const</emphasis> time_rep_type &amp; base, <emphasis role="bold">const</emphasis> date_duration_type &amp; dd) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_rep_type</type> 
<anchor id="id422191-bb"/>subtract_days(<emphasis role="bold">const</emphasis> time_rep_type &amp; base, <emphasis role="bold">const</emphasis> date_duration_type &amp; dd) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_rep_type</type> 
<anchor id="id329240-bb"/>subtract_time_duration(<emphasis role="bold">const</emphasis> time_rep_type &amp; base, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> time_duration_type &amp; td) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_rep_type</type> 
<anchor id="id339102-bb"/>add_time_duration(<emphasis role="bold">const</emphasis> time_rep_type &amp; base, time_duration_type td) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> 
<anchor id="id285446-bb"/>subtract_times(<emphasis role="bold">const</emphasis> time_rep_type &amp; lhs, <emphasis role="bold">const</emphasis> time_rep_type &amp; rhs) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id354130"><title>Header &lt;<ulink url="../../boost/date_time/time_system_split.hpp">boost/date_time/time_system_split.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> config, boost::int32_t ticks_per_second&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="split_timedate_system">split_timedate_system</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="split_timedate_system"><refmeta><refentrytitle>Class template split_timedate_system</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::split_timedate_system</refname><refpurpose><simpara>An unadjusted time system implementation. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> config, boost::int32_t ticks_per_second&gt; 
<emphasis role="bold">class</emphasis> split_timedate_system {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> config::time_rep_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_rep_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> config::date_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> config::time_duration_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> config::date_duration_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> config::int_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> config::resolution_traits&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; resolution_traits;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="wrapping_int">date_time::wrapping_int</link>&lt; int_type, INT64_C(86400)*ticks_per_second wrap_int_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="wrapping_int">date_time::wrapping_int</link>&lt; int_type, ticks_per_day &gt;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; wrap_int_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id309506-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>time_rep_type</type> 
&#xA0;&#xA0;<link linkend="id302000-bb">get_time_rep</link>(<emphasis role="bold">const</emphasis> date_type &amp;, <emphasis role="bold">const</emphasis> time_duration_type &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;date_time::dst_flags = not_dst) ;
&#xA0;&#xA0;<type>date_type</type> <link linkend="id366478-bb">get_date</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;) ;
&#xA0;&#xA0;<type>time_duration_type</type> <link linkend="id436153-bb">get_time_of_day</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;) ;
&#xA0;&#xA0;<type>std::string</type> <link linkend="id427464-bb">zone_name</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id361895-bb">is_equal</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, <emphasis role="bold">const</emphasis> time_rep_type &amp;) ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id363003-bb">is_less</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, <emphasis role="bold">const</emphasis> time_rep_type &amp;) ;
&#xA0;&#xA0;<type>time_rep_type</type> <link linkend="id308532-bb">add_days</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, <emphasis role="bold">const</emphasis> date_duration_type &amp;) ;
&#xA0;&#xA0;<type>time_rep_type</type> 
&#xA0;&#xA0;<link linkend="id394837-bb">subtract_days</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, <emphasis role="bold">const</emphasis> date_duration_type &amp;) ;
&#xA0;&#xA0;<type>time_rep_type</type> 
&#xA0;&#xA0;<link linkend="id414253-bb">subtract_time_duration</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, <emphasis role="bold">const</emphasis> time_duration_type &amp;) ;
&#xA0;&#xA0;<type>time_rep_type</type> <link linkend="id322360-bb">add_time_duration</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, time_duration_type) ;
&#xA0;&#xA0;<type>time_duration_type</type> 
&#xA0;&#xA0;<link linkend="id383508-bb">subtract_times</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;, <emphasis role="bold">const</emphasis> time_rep_type &amp;) ;

&#xA0;&#xA0;<emphasis>// <link linkend="id352903-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type/> <link linkend="id321227-bb">BOOST_STATIC_CONSTANT</link>(int_type, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;ticks_per_day = INT64_C(86400)*config::tick_per_second) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id309506-bb"/><computeroutput>split_timedate_system</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>time_rep_type</type> 
<anchor id="id302000-bb"/>get_time_rep(<emphasis role="bold">const</emphasis> date_type &amp; day, <emphasis role="bold">const</emphasis> time_duration_type &amp; tod, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;date_time::dst_flags dst = not_dst) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>date_type</type> <anchor id="id366478-bb"/>get_date(<emphasis role="bold">const</emphasis> time_rep_type &amp; val) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> <anchor id="id436153-bb"/>get_time_of_day(<emphasis role="bold">const</emphasis> time_rep_type &amp; val) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>std::string</type> <anchor id="id427464-bb"/>zone_name(<emphasis role="bold">const</emphasis> time_rep_type &amp; ) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id361895-bb"/>is_equal(<emphasis role="bold">const</emphasis> time_rep_type &amp; lhs, <emphasis role="bold">const</emphasis> time_rep_type &amp; rhs) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id363003-bb"/>is_less(<emphasis role="bold">const</emphasis> time_rep_type &amp; lhs, <emphasis role="bold">const</emphasis> time_rep_type &amp; rhs) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_rep_type</type> 
<anchor id="id308532-bb"/>add_days(<emphasis role="bold">const</emphasis> time_rep_type &amp; base, <emphasis role="bold">const</emphasis> date_duration_type &amp; dd) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_rep_type</type> 
<anchor id="id394837-bb"/>subtract_days(<emphasis role="bold">const</emphasis> time_rep_type &amp; base, <emphasis role="bold">const</emphasis> date_duration_type &amp; dd) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_rep_type</type> 
<anchor id="id414253-bb"/>subtract_time_duration(<emphasis role="bold">const</emphasis> time_rep_type &amp; base, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> time_duration_type &amp; td) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_rep_type</type> 
<anchor id="id322360-bb"/>add_time_duration(<emphasis role="bold">const</emphasis> time_rep_type &amp; base, time_duration_type td) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>time_duration_type</type> 
<anchor id="id383508-bb"/>subtract_times(<emphasis role="bold">const</emphasis> time_rep_type &amp; lhs, <emphasis role="bold">const</emphasis> time_rep_type &amp; rhs) ;</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id352903-bb"/><computeroutput>split_timedate_system</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type/> <anchor id="id321227-bb"/>BOOST_STATIC_CONSTANT(int_type , 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;ticks_per_day  = INT64_C(86400)*config::tick_per_second) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id418251"><title>Header &lt;<ulink url="../../boost/date_time/wrapping_int.hpp">boost/date_time/wrapping_int.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> int_type_, int_type_ wrap_val&gt; <emphasis role="bold">class</emphasis> <link linkend="wrapping_int">wrapping_int</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> int_type_, int_type_ wrap_min, int_type_ wrap_max&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="wrapping_int2">wrapping_int2</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="wrapping_int"><refmeta><refentrytitle>Class template wrapping_int</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::wrapping_int</refname><refpurpose><simpara>A wrapping integer used to support time durations. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> int_type_, int_type_ wrap_val&gt; 
<emphasis role="bold">class</emphasis> wrapping_int {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> int_type_ int_type;

&#xA0;&#xA0;<emphasis>// <link linkend="wrapping_intconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id298216-bb">wrapping_int</link>(int_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id318942-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>int_type</type> <link linkend="id307476-bb">as_int</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<link linkend="id432438-bb"><emphasis role="bold">operator</emphasis> int_type</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>int_type</type> <link linkend="id335280-bb">add</link>(int_type) ;
&#xA0;&#xA0;<type>int_type</type> <link linkend="id408502-bb">subtract</link>(int_type) ;

&#xA0;&#xA0;<emphasis>// <link linkend="id433467-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>int_type</type> <link linkend="id433473-bb">wrap_value</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>In composite date and time types this type is used to wrap at the day boundary. </para><refsect2><title><anchor id="wrapping_intconstruct-copy-destruct"/><computeroutput>wrapping_int</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id298216-bb"/>wrapping_int(int_type v);</literallayout></para><simpara>Add, return true if wrapped. </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id318942-bb"/><computeroutput>wrapping_int</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id307476-bb"/>as_int() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Explicit converion method. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id432438-bb"/><emphasis role="bold">operator</emphasis> int_type() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id335280-bb"/>add(int_type v) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id408502-bb"/>subtract(int_type v) ;</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id433467-bb"/><computeroutput>wrapping_int</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id433473-bb"/>wrap_value() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="wrapping_int2"><refmeta><refentrytitle>Class template wrapping_int2</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::wrapping_int2</refname><refpurpose><simpara>A wrapping integer used to wrap around at the top. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> int_type_, int_type_ wrap_min, int_type_ wrap_max&gt; 
<emphasis role="bold">class</emphasis> wrapping_int2 {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> int_type_ int_type;

&#xA0;&#xA0;<emphasis>// <link linkend="wrapping_int2construct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id343611-bb">wrapping_int2</link>(int_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id374620-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>int_type</type> <link linkend="id374626-bb">as_int</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<link linkend="id308624-bb"><emphasis role="bold">operator</emphasis> int_type</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>int_type</type> <link linkend="id378045-bb">add</link>(int_type) ;
&#xA0;&#xA0;<type>int_type</type> <link linkend="id309833-bb">subtract</link>(int_type) ;

&#xA0;&#xA0;<emphasis>// <link linkend="id392564-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">long</emphasis></type> <link linkend="id429151-bb">wrap_value</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">long</emphasis></type> <link linkend="id318951-bb">min_value</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Bad name, quick impl to fix a bug -- fix later!! This allows the wrap to restart at a value other than 0. Currently this only works if wrap_min == 1 </para><refsect2><title><anchor id="wrapping_int2construct-copy-destruct"/><computeroutput>wrapping_int2</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id343611-bb"/>wrapping_int2(int_type v);</literallayout></para><para>If initializing value is out of range of [wrap_min, wrap_max], value will be initialized to closest of min or max </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id374620-bb"/><computeroutput>wrapping_int2</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id374626-bb"/>as_int() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Explicit converion method. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id308624-bb"/><emphasis role="bold">operator</emphasis> int_type() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id378045-bb"/>add(int_type v) ;</literallayout></para><simpara>Add, return number of wraps performed. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>int_type</type> <anchor id="id309833-bb"/>subtract(int_type v) ;</literallayout></para><simpara>Subtract will return '-d' if wrapping took place ('d' is the number of wraps). </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id392564-bb"/><computeroutput>wrapping_int2</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">long</emphasis></type> <anchor id="id429151-bb"/>wrap_value() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">long</emphasis></type> <anchor id="id318951-bb"/>min_value() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id395548"><title>Header &lt;<ulink url="../../boost/date_time/year_month_day.hpp">boost/date_time/year_month_day.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> date_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> YearType, <emphasis role="bold">typename</emphasis> MonthType, <emphasis role="bold">typename</emphasis> DayType&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="year_month_day_base">year_month_day_base</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="year_month_day_base"><refmeta><refentrytitle>Struct template year_month_day_base</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::date_time::year_month_day_base</refname><refpurpose><simpara>Allow rapid creation of ymd triples of different types. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> YearType, <emphasis role="bold">typename</emphasis> MonthType, <emphasis role="bold">typename</emphasis> DayType&gt; 
<emphasis role="bold">struct</emphasis> year_month_day_base {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> YearType&#xA0; year_type;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> MonthType month_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> DayType&#xA0;&#xA0; day_type;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="year_month_day_baseconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id383915-bb">year_month_day_base</link>(YearType, MonthType, DayType);

&#xA0;&#xA0;<emphasis>// <link linkend="id288033-bb">public member functions</link></emphasis>

&#xA0;&#xA0;YearType year;
&#xA0;&#xA0;MonthType month;
&#xA0;&#xA0;DayType day;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="year_month_day_baseconstruct-copy-destruct"/><computeroutput>year_month_day_base</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id383915-bb"/>year_month_day_base(YearType year, MonthType month, DayType day);</literallayout></para><simpara>A basic constructor. </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id288033-bb"/><computeroutput>year_month_day_base</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry></section></section><section id="gregorian_reference" xml:base="../libs/date_time/xmldoc/gregorian_autodoc.boostbook"><title>Gregorian Reference</title><section id="id329645"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/formatters.hpp">boost/date_time/gregorian/formatters.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; charT &gt;</type> <anchor id="id426633"/>to_simple_string_type(<emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp; d);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// To YYYY-mmm-DD string where mmm 3 char month name. Example: 2002-Jan-01. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::string</type> <anchor id="id385495"/>to_simple_string(<emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp; d);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; charT &gt;</type> <anchor id="id368232"/>to_simple_string_type(<emphasis role="bold">const</emphasis> date_period &amp; d);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Convert date period to simple string. Example: [2002-Jan-01/2002-Jan-02]. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::string</type> <anchor id="id323685"/>to_simple_string(<emphasis role="bold">const</emphasis> date_period &amp; d);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; charT &gt;</type> <anchor id="id311252"/>to_iso_string_type(<emphasis role="bold">const</emphasis> date_period &amp; d);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Date period to iso standard format CCYYMMDD/CCYYMMDD. Example: 20021225/20021231. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::string</type> <anchor id="id355817"/>to_iso_string(<emphasis role="bold">const</emphasis> date_period &amp; d);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; charT &gt;</type> <anchor id="id326452"/>to_iso_extended_string_type(<emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp; d);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Convert to iso extended format string CCYY-MM-DD. Example 2002-12-31. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::string</type> <anchor id="id410513"/>to_iso_extended_string(<emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp; d);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; charT &gt;</type> <anchor id="id412291"/>to_iso_string_type(<emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp; d);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Convert to iso standard string YYYYMMDD. Example: 20021231. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::string</type> <anchor id="id384580"/>to_iso_string(<emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp; d);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; charT &gt;</type> <anchor id="to_sql_string_type"/>to_sql_string_type(<emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp; d);
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::string</type> <anchor id="to_sql_string"/>to_sql_string(<emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp; d);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Convert date period to simple string. Example: [2002-Jan-01/2002-Jan-02]. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::wstring</type> <anchor id="id382900"/>to_simple_wstring(<emphasis role="bold">const</emphasis> date_period &amp; d);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// To YYYY-mmm-DD string where mmm 3 char month name. Example: 2002-Jan-01. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::wstring</type> <anchor id="id402727"/>to_simple_wstring(<emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp; d);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Date period to iso standard format CCYYMMDD/CCYYMMDD. Example: 20021225/20021231. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::wstring</type> <anchor id="id423403"/>to_iso_wstring(<emphasis role="bold">const</emphasis> date_period &amp; d);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Convert to iso extended format string CCYY-MM-DD. Example 2002-12-31. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::wstring</type> <anchor id="id377059"/>to_iso_extended_wstring(<emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp; d);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Convert to iso standard string YYYYMMDD. Example: 20021231. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::wstring</type> <anchor id="id418427"/>to_iso_wstring(<emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp; d);
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::wstring</type> <anchor id="to_sql_wstring"/>to_sql_wstring(<emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp; d);
&#xA0;&#xA0;}
}</synopsis></section><section id="id395520"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/formatters_limited.hpp">boost/date_time/gregorian/formatters_limited.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;}
}</synopsis></section><section id="id331975"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/greg_calendar.hpp">boost/date_time/gregorian/greg_calendar.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="gregorian_calendar">gregorian_calendar</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::int_adapter&lt; <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">long</emphasis> &gt; fancy_date_rep;  <emphasis>// An internal date representation that includes infinities, not a date. </emphasis>
&#xA0;&#xA0;}
}</synopsis><refentry id="gregorian_calendar"><refmeta><refentrytitle>Class gregorian_calendar</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::gregorian_calendar</refname><refpurpose><simpara>Gregorian calendar for this implementation, hard work in the base. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> gregorian_calendar {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="greg_weekday">greg_weekday</link>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; day_of_week_type;  <emphasis>// Type to hold a weekday (eg: Sunday, Monday,...). </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> greg_day_of_year_rep day_of_year_type;  <emphasis>// Counter type from 1 to 366 for gregorian dates. </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> fancy_date_rep&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_rep_type;&#xA0;&#xA0;&#xA0;  <emphasis>// Internal date representation that handles infinity, not a date. </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> fancy_date_rep&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_traits_type;  <emphasis>// Date rep implements the traits stuff as well. </emphasis>
};</synopsis></refsynopsisdiv></refentry></section><section id="id337478"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/greg_date.hpp">boost/date_time/gregorian/greg_date.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="boost.gregorian.date">date</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="boost.gregorian.date"><refmeta><refentrytitle>Class date</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::date</refname><refpurpose><simpara>A date type based on gregorian_calendar. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> date {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> gregorian_calendar::year_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; year_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> gregorian_calendar::month_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> gregorian_calendar::day_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; day_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> gregorian_calendar::day_of_year_type day_of_year_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> gregorian_calendar::ymd_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ymd_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> gregorian_calendar::date_rep_type&#xA0;&#xA0;&#xA0; date_rep_type;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> gregorian_calendar::date_int_type&#xA0;&#xA0;&#xA0; date_int_type;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_duration&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; duration_type;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="boost.gregorian.dateconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id422918-bb">date</link>();
&#xA0;&#xA0;<link linkend="id319339-bb">date</link>(year_type, month_type, day_type);
&#xA0;&#xA0;<link linkend="id386267-bb">date</link>(<emphasis role="bold">const</emphasis> ymd_type &amp;);
&#xA0;&#xA0;<link linkend="id414393-bb">date</link>(<emphasis role="bold">const</emphasis> date_int_type &amp;);
&#xA0;&#xA0;<link linkend="id398481-bb">date</link>(date_rep_type);
&#xA0;&#xA0;<link linkend="id432644-bb">date</link>(special_values);

&#xA0;&#xA0;<emphasis>// <link linkend="id383784-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>date_int_type</type> <link linkend="id383790-bb">julian_day</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>day_of_year_type</type> <link linkend="id300029-bb">day_of_year</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">long</emphasis></type> <link linkend="id319289-bb">modjulian_day</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id431571-bb">week_number</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>date_int_type</type> <link linkend="id380917-bb">day_number</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This class is the primary interface for programming with greogorian dates. The is a lightweight type that can be freely passed by value. All comparison operators are supported. </para><refsect2><title><anchor id="boost.gregorian.dateconstruct-copy-destruct"/><computeroutput>date</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id422918-bb"/>date();</literallayout></para><simpara>Default constructor constructs with not_a_date_time. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id319339-bb"/>date(year_type y, month_type m, day_type d);</literallayout></para><simpara>Main constructor with year, month, day. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id386267-bb"/>date(<emphasis role="bold">const</emphasis> ymd_type &amp; ymd);</literallayout></para><simpara>Constructor from a ymd_type structure. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id414393-bb"/>date(<emphasis role="bold">const</emphasis> date_int_type &amp; rhs);</literallayout></para><simpara>Needed copy constructor. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id398481-bb"/>date(date_rep_type rhs);</literallayout></para><simpara>Needed copy constructor. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id432644-bb"/>date(special_values sv);</literallayout></para><simpara>Constructor for infinities, not a date, max and min date. </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id383784-bb"/><computeroutput>date</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>date_int_type</type> <anchor id="id383790-bb"/>julian_day() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return the Julian Day number for the date. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>day_of_year_type</type> <anchor id="id300029-bb"/>day_of_year() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return the day of year 1..365 or 1..366 (for leap year). </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">long</emphasis></type> <anchor id="id319289-bb"/>modjulian_day() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return the Modified Julian Day number for the date. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id431571-bb"/>week_number() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return the iso 8601 week number 1..53. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>date_int_type</type> <anchor id="id380917-bb"/>day_number() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Return the day number from the calendar. </simpara></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id317225"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/greg_day.hpp">boost/date_time/gregorian/greg_day.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="bad_day_of_month">bad_day_of_month</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="greg_day">greg_day</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> CV::simple_exception_policy&lt; <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis>, 1, 31, <link linkend="bad_day_of_month">bad_day_of_month</link> &gt; greg_day_policies;  <emphasis>// Policy class that declares error handling and day of month ranges. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> CV::constrained_value&lt; greg_day_policies &gt; greg_day_rep;  <emphasis>// Generated represetation for gregorian day of month. </emphasis>
&#xA0;&#xA0;}
}</synopsis><refentry id="bad_day_of_month"><refmeta><refentrytitle>Struct bad_day_of_month</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::bad_day_of_month</refname><refpurpose><simpara>Exception type for gregorian day of month (1..31). </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> bad_day_of_month {
&#xA0;&#xA0;<emphasis>// <link linkend="bad_day_of_monthconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id324144-bb">bad_day_of_month</link>();
&#xA0;&#xA0;<link linkend="id324148-bb">bad_day_of_month</link>(<emphasis role="bold">const</emphasis> std::string &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id324139-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="bad_day_of_monthconstruct-copy-destruct"/><computeroutput>bad_day_of_month</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id324144-bb"/>bad_day_of_month();</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id324148-bb"/>bad_day_of_month(<emphasis role="bold">const</emphasis> std::string &amp; s);</literallayout></para><simpara>Allow other classes to throw with unique string for bad day like Feb 29. </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id324139-bb"/><computeroutput>bad_day_of_month</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="greg_day"><refmeta><refentrytitle>Class greg_day</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::greg_day</refname><refpurpose><simpara>Represent a day of the month (range 1 - 31). </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> greg_day {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="greg_dayconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id371063-bb">greg_day</link>(<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis>);

&#xA0;&#xA0;<emphasis>// <link linkend="id382216-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <link linkend="id382222-bb">as_number</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<link linkend="id437342-bb"><emphasis role="bold">operator</emphasis> <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This small class allows for simple conversion an integer value into a day of the month for a standard gregorian calendar. The type is automatically range checked so values outside of the range 1-31 will cause a bad_day_of_month exception </para><refsect2><title><anchor id="greg_dayconstruct-copy-destruct"/><computeroutput>greg_day</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id371063-bb"/>greg_day(<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis> day_of_month);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id382216-bb"/><computeroutput>greg_day</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <anchor id="id382222-bb"/>as_number() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id437342-bb"/><emphasis role="bold">operator</emphasis> <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis>() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id347220"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/greg_day_of_year.hpp">boost/date_time/gregorian/greg_day_of_year.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="bad_day_of_year">bad_day_of_year</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> CV::simple_exception_policy&lt; <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis>, 1, 366, <link linkend="bad_day_of_year">bad_day_of_year</link> &gt; greg_day_of_year_policies;  <emphasis>// A day of the year range (1..366). </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> CV::constrained_value&lt; greg_day_of_year_policies &gt; greg_day_of_year_rep;  <emphasis>// Define a range representation type for the day of the year 1..366. </emphasis>
&#xA0;&#xA0;}
}</synopsis><refentry id="bad_day_of_year"><refmeta><refentrytitle>Struct bad_day_of_year</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::bad_day_of_year</refname><refpurpose><simpara>Exception type for day of year (1..366). </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> bad_day_of_year {
&#xA0;&#xA0;<emphasis>// <link linkend="bad_day_of_yearconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id425183-bb">bad_day_of_year</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id425177-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="bad_day_of_yearconstruct-copy-destruct"/><computeroutput>bad_day_of_year</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id425183-bb"/>bad_day_of_year();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id425177-bb"/><computeroutput>bad_day_of_year</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry></section><section id="id313866"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/greg_duration.hpp">boost/date_time/gregorian/greg_duration.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::date_time::duration_traits_adapted date_duration_rep;  <emphasis>// An internal date representation that includes infinities, not a date. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::date_duration&lt; date_duration_rep &gt; date_duration;  <emphasis>// Durations in days for gregorian system. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_duration days;  <emphasis>// Shorthand for date_duration. </emphasis>
&#xA0;&#xA0;}
}</synopsis></section><section id="id391110"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/greg_duration_types.hpp">boost/date_time/gregorian/greg_duration_types.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="greg_durations_config">greg_durations_config</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::months_duration&lt; <link linkend="greg_durations_config">greg_durations_config</link> &gt; months;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::years_duration&lt; <link linkend="greg_durations_config">greg_durations_config</link> &gt; years;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::weeks_duration&lt; date_time::duration_traits_adapted &gt; weeks;
&#xA0;&#xA0;}
}</synopsis><refentry id="greg_durations_config"><refmeta><refentrytitle>Struct greg_durations_config</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::greg_durations_config</refname><refpurpose><simpara>config struct for additional duration types (ie months_duration&lt;&gt; &amp; years_duration&lt;&gt;) </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> greg_durations_config {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="boost.gregorian.date">date</link>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::int_adapter&lt; <emphasis role="bold">int</emphasis> &gt;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int_rep;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::month_functor&lt; date_type &gt; month_adjustor_type;
};</synopsis></refsynopsisdiv></refentry></section><section id="id388664"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/greg_facet.hpp">boost/date_time/gregorian/greg_facet.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="greg_facet_config">greg_facet_config</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::date_time::date_names_put&lt; <link linkend="greg_facet_config">greg_facet_config</link> &gt; greg_base_facet;  <emphasis>// Create the base facet type for gregorian::date. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id307366"><emphasis role="bold">operator</emphasis>&lt;&lt;</link>(std::basic_ostream&lt; charT, traits &gt; &amp;, <emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id382673"><emphasis role="bold">operator</emphasis>&lt;&lt;</link>(std::basic_ostream&lt; charT, traits &gt; &amp;, <emphasis role="bold">const</emphasis> <link linkend="greg_month">greg_month</link> &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id285910"><emphasis role="bold">operator</emphasis>&lt;&lt;</link>(std::basic_ostream&lt; charT, traits &gt; &amp;, <emphasis role="bold">const</emphasis> <link linkend="greg_weekday">greg_weekday</link> &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id287707"><emphasis role="bold">operator</emphasis>&lt;&lt;</link>(std::basic_ostream&lt; charT, traits &gt; &amp;, <emphasis role="bold">const</emphasis> date_period &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id244161"/><emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> date_duration &amp; dd);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// operator&lt;&lt; for gregorian::partial_date. Output: "Jan 1" </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id415652"/><emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> partial_date &amp; pd);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// operator&lt;&lt; for gregorian::nth_kday_of_month. Output: "first Mon of Jun" </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id369898"/><emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> nth_kday_of_month &amp; nkd);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// operator&lt;&lt; for gregorian::first_kday_of_month. Output: "first Mon of Jun" </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id398025"/><emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> first_kday_of_month &amp; fkd);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// operator&lt;&lt; for gregorian::last_kday_of_month. Output: "last Mon of Jun" </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id318258"/><emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> last_kday_of_month &amp; lkd);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// operator&lt;&lt; for gregorian::first_kday_after. Output: "first Mon after" </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id320731"/><emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> first_kday_after &amp; fka);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// operator&lt;&lt; for gregorian::first_kday_before. Output: "first Mon before" </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id368716"/><emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> first_kday_before &amp; fkb);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// operator&gt;&gt; for gregorian::date </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_istream&lt; charT &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id373081"/><emphasis role="bold">operator</emphasis>&gt;&gt;(std::basic_istream&lt; charT &gt; &amp; is, <link linkend="boost.gregorian.date">date</link> &amp; d);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// operator&gt;&gt; for gregorian::date_duration </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_istream&lt; charT &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id365562"/><emphasis role="bold">operator</emphasis>&gt;&gt;(std::basic_istream&lt; charT &gt; &amp; is, date_duration &amp; dd);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// operator&gt;&gt; for gregorian::date_period </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_istream&lt; charT &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id303191"/><emphasis role="bold">operator</emphasis>&gt;&gt;(std::basic_istream&lt; charT &gt; &amp; is, date_period &amp; dp);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// generates a locale with the set of gregorian name-strings of type char* </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_DATE_TIME_DECL std::locale</type> 
&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id381517"/>generate_locale(std::locale &amp; loc, <emphasis role="bold">char</emphasis> type);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Returns a pointer to a facet with a default set of names (English). </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_DATE_TIME_DECL boost::date_time::all_date_names_put&lt; <link linkend="greg_facet_config">greg_facet_config</link>, <emphasis role="bold">char</emphasis> &gt; *</type> 
&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id327304"/>create_facet_def(<emphasis role="bold">char</emphasis> type);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// generates a locale with the set of gregorian name-strings of type wchar_t* </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_DATE_TIME_DECL std::locale</type> 
&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id302635"/>generate_locale(std::locale &amp; loc, <emphasis role="bold">wchar_t</emphasis> type);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Returns a pointer to a facet with a default set of names (English). </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_DATE_TIME_DECL boost::date_time::all_date_names_put&lt; <link linkend="greg_facet_config">greg_facet_config</link>, <emphasis role="bold">wchar_t</emphasis> &gt; *</type> 
&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id338902"/>create_facet_def(<emphasis role="bold">wchar_t</emphasis> type);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// operator&gt;&gt; for gregorian::greg_month - throws exception if invalid month given </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_istream&lt; charT &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id332432"/><emphasis role="bold">operator</emphasis>&gt;&gt;(std::basic_istream&lt; charT &gt; &amp; is, <link linkend="greg_month">greg_month</link> &amp; m);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// operator&gt;&gt; for gregorian::greg_weekday - throws exception if invalid weekday given </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_istream&lt; charT &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id407303"/><emphasis role="bold">operator</emphasis>&gt;&gt;(std::basic_istream&lt; charT &gt; &amp; is, <link linkend="greg_weekday">greg_weekday</link> &amp; wd);
&#xA0;&#xA0;}
}</synopsis><refentry id="greg_facet_config"><refmeta><refentrytitle>Struct greg_facet_config</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::greg_facet_config</refname><refpurpose><simpara>Configuration of the output facet template. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> greg_facet_config {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="greg_month">boost::gregorian::greg_month</link>&#xA0;&#xA0;&#xA0;&#xA0; month_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::date_time::special_values special_value_enum;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::gregorian::months_of_year month_enum;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::date_time::weekdays&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; weekday_enum;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
};</synopsis></refsynopsisdiv></refentry><refentry id="id307366"><refmeta><refentrytitle>Function template operator&lt;&lt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::operator&lt;&lt;</refname><refpurpose><simpara>ostream operator for gregorian::date </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;<emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, <emphasis role="bold">const</emphasis> <link linkend="boost.gregorian.date">date</link> &amp; d);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Uses the date facet to determine various output parameters including:<itemizedlist><listitem><para>string values for the month (eg: Jan, Feb, Mar) (default: English)</para></listitem><listitem><para>string values for special values (eg: not-a-date-time) (default: English)</para></listitem><listitem><para>selection of long, short strings, or numerical month representation (default: short string)</para></listitem><listitem><para>month day year order (default yyyy-mmm-dd) </para></listitem></itemizedlist></para></refsect1></refentry><refentry id="id382673"><refmeta><refentrytitle>Function template operator&lt;&lt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::operator&lt;&lt;</refname><refpurpose><simpara>operator&lt;&lt; for gregorian::greg_month typically streaming: Jan, Feb, Mar... </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;<emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, <emphasis role="bold">const</emphasis> <link linkend="greg_month">greg_month</link> &amp; m);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Uses the date facet to determine output string as well as selection of long or short strings. Default if no facet is installed is to output a 2 wide numeric value for the month eg: 01 == Jan, 02 == Feb, ... 12 == Dec. </para></refsect1></refentry><refentry id="id285910"><refmeta><refentrytitle>Function template operator&lt;&lt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::operator&lt;&lt;</refname><refpurpose><simpara>operator&lt;&lt; for gregorian::greg_weekday typically streaming: Sun, Mon, Tue, ... </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;<emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="greg_weekday">greg_weekday</link> &amp; wd);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Uses the date facet to determine output string as well as selection of long or short string. Default if no facet is installed is to output a 3 char english string for the day of the week. </para></refsect1></refentry><refentry id="id287707"><refmeta><refentrytitle>Function template operator&lt;&lt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::operator&lt;&lt;</refname><refpurpose><simpara>operator&lt;&lt; for gregorian::date_period typical output: [2002-Jan-01/2002-Jan-31] </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;<emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, <emphasis role="bold">const</emphasis> date_period &amp; dp);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Uses the date facet to determine output string as well as selection of long or short string fr dates. Default if no facet is installed is to output a 3 char english string for the day of the week. </para></refsect1></refentry></section><section id="id347825"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/greg_month.hpp">boost/date_time/gregorian/greg_month.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="bad_month">bad_month</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="greg_month">greg_month</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::months_of_year months_of_year;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> CV::simple_exception_policy&lt; <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis>, 1, 12, <link linkend="bad_month">bad_month</link> &gt; greg_month_policies;  <emphasis>// Build a policy class for the greg_month_rep. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> CV::constrained_value&lt; greg_month_policies &gt; greg_month_rep;  <emphasis>// A constrained range that implements the gregorian_month rules. </emphasis>
&#xA0;&#xA0;}
}</synopsis><refentry id="bad_month"><refmeta><refentrytitle>Struct bad_month</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::bad_month</refname><refpurpose><simpara>Exception thrown if a greg_month is constructed with a value out of range. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> bad_month {
&#xA0;&#xA0;<emphasis>// <link linkend="bad_monthconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id363946-bb">bad_month</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id363940-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="bad_monthconstruct-copy-destruct"/><computeroutput>bad_month</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id363946-bb"/>bad_month();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id363940-bb"/><computeroutput>bad_month</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="greg_month"><refmeta><refentrytitle>Class greg_month</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::greg_month</refname><refpurpose><simpara>Wrapper class to represent months in gregorian based calendar. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> greg_month {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::months_of_year&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; month_enum;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::map&lt; std::string, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis> &gt; month_map_type;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::shared_ptr&lt; month_map_type &gt;&#xA0;&#xA0;&#xA0;&#xA0; month_map_ptr_type;

&#xA0;&#xA0;<emphasis>// <link linkend="greg_monthconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id365011-bb">greg_month</link>(month_enum);
&#xA0;&#xA0;<link linkend="id307329-bb">greg_month</link>(<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis>);

&#xA0;&#xA0;<emphasis>// <link linkend="id309901-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<link linkend="id309906-bb"><emphasis role="bold">operator</emphasis> <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <link linkend="id419702-bb">as_number</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>month_enum</type> <link linkend="id428268-bb">as_enum</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <link linkend="id423136-bb">as_short_string</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <link linkend="id422578-bb">as_long_string</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <link linkend="id365194-bb">as_short_wstring</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <link linkend="id422282-bb">as_long_wstring</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <link linkend="id348754-bb">as_short_string</link>(<emphasis role="bold">char</emphasis>) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <link linkend="id347279-bb">as_long_string</link>(<emphasis role="bold">char</emphasis>) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <link linkend="id428550-bb">as_short_string</link>(<emphasis role="bold">wchar_t</emphasis>) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <link linkend="id370181-bb">as_long_string</link>(<emphasis role="bold">wchar_t</emphasis>) <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id229966-bb">public static functions</link></emphasis>
&#xA0;&#xA0;<type>month_map_ptr_type</type> <link linkend="id229972-bb">get_month_map_ptr</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="greg_monthconstruct-copy-destruct"/><computeroutput>greg_month</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id365011-bb"/>greg_month(month_enum theMonth);</literallayout></para><simpara>Construct a month from the months_of_year enumeration. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id307329-bb"/>greg_month(<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis> theMonth);</literallayout></para><simpara>Construct from a short value. </simpara></listitem></orderedlist></refsect2><refsect2><title><anchor id="id309901-bb"/><computeroutput>greg_month</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id309906-bb"/><emphasis role="bold">operator</emphasis> <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis>() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Convert the value back to a short. </simpara></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <anchor id="id419702-bb"/>as_number() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns month as number from 1 to 12. </simpara></listitem><listitem><para><literallayout class="monospaced"><type>month_enum</type> <anchor id="id428268-bb"/>as_enum() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <anchor id="id423136-bb"/>as_short_string() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <anchor id="id422578-bb"/>as_long_string() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <anchor id="id365194-bb"/>as_short_wstring() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <anchor id="id422282-bb"/>as_long_wstring() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <anchor id="id348754-bb"/>as_short_string(<emphasis role="bold">char</emphasis> ) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <anchor id="id347279-bb"/>as_long_string(<emphasis role="bold">char</emphasis> ) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <anchor id="id428550-bb"/>as_short_string(<emphasis role="bold">wchar_t</emphasis> ) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <anchor id="id370181-bb"/>as_long_string(<emphasis role="bold">wchar_t</emphasis> ) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id229966-bb"/><computeroutput>greg_month</computeroutput> public static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>month_map_ptr_type</type> <anchor id="id229972-bb"/>get_month_map_ptr() ;</literallayout></para><simpara>Shared pointer to a map of Month strings (Names &amp; Abbrev) &amp; numbers. </simpara></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id308611"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/greg_weekday.hpp">boost/date_time/gregorian/greg_weekday.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="bad_weekday">bad_weekday</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="greg_weekday">greg_weekday</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> CV::simple_exception_policy&lt; <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis>, 0, 6, <link linkend="bad_weekday">bad_weekday</link> &gt; greg_weekday_policies;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> CV::constrained_value&lt; greg_weekday_policies &gt; greg_weekday_rep;
&#xA0;&#xA0;}
}</synopsis><refentry id="bad_weekday"><refmeta><refentrytitle>Struct bad_weekday</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::bad_weekday</refname><refpurpose><simpara>Exception that flags that a weekday number is incorrect. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> bad_weekday {
&#xA0;&#xA0;<emphasis>// <link linkend="bad_weekdayconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id389091-bb">bad_weekday</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id389085-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="bad_weekdayconstruct-copy-destruct"/><computeroutput>bad_weekday</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id389091-bb"/>bad_weekday();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id389085-bb"/><computeroutput>bad_weekday</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="greg_weekday"><refmeta><refentrytitle>Class greg_weekday</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::greg_weekday</refname><refpurpose><simpara>Represent a day within a week (range 0==Sun to 6==Sat). </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> greg_weekday {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::date_time::weekdays weekday_enum;

&#xA0;&#xA0;<emphasis>// <link linkend="greg_weekdayconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id323704-bb">greg_weekday</link>(<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis>);

&#xA0;&#xA0;<emphasis>// <link linkend="id368644-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <link linkend="id368651-bb">as_number</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <link linkend="id360472-bb">as_short_string</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <link linkend="id366587-bb">as_long_string</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <link linkend="id320224-bb">as_short_wstring</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <link linkend="id287919-bb">as_long_wstring</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>weekday_enum</type> <link linkend="id351414-bb">as_enum</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="greg_weekdayconstruct-copy-destruct"/><computeroutput>greg_weekday</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id323704-bb"/>greg_weekday(<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis> day_of_week_num);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id368644-bb"/><computeroutput>greg_weekday</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></type> <anchor id="id368651-bb"/>as_number() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <anchor id="id360472-bb"/>as_short_string() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <anchor id="id366587-bb"/>as_long_string() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <anchor id="id320224-bb"/>as_short_wstring() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">wchar_t</emphasis> *</type> <anchor id="id287919-bb"/>as_long_wstring() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>weekday_enum</type> <anchor id="id351414-bb"/>as_enum() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id351055"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/greg_year.hpp">boost/date_time/gregorian/greg_year.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="bad_year">bad_year</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="greg_year">greg_year</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> CV::simple_exception_policy&lt; <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis>, 1400, 10000, <link linkend="bad_year">bad_year</link> &gt; greg_year_policies;  <emphasis>// Policy class that declares error handling gregorian year type. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> CV::constrained_value&lt; greg_year_policies &gt; greg_year_rep;  <emphasis>// Generated representation for gregorian year. </emphasis>
&#xA0;&#xA0;}
}</synopsis><refentry id="bad_year"><refmeta><refentrytitle>Struct bad_year</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::bad_year</refname><refpurpose><simpara>Exception type for gregorian year. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> bad_year {
&#xA0;&#xA0;<emphasis>// <link linkend="bad_yearconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id300168-bb">bad_year</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id398137-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="bad_yearconstruct-copy-destruct"/><computeroutput>bad_year</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id300168-bb"/>bad_year();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id398137-bb"/><computeroutput>bad_year</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="greg_year"><refmeta><refentrytitle>Class greg_year</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::gregorian::greg_year</refname><refpurpose><simpara>Represent a day of the month (range 1900 - 10000). </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> greg_year {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="greg_yearconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id354736-bb">greg_year</link>(<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis>);

&#xA0;&#xA0;<emphasis>// <link linkend="id325863-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<link linkend="id427974-bb"><emphasis role="bold">operator</emphasis> <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis></link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This small class allows for simple conversion an integer value into a year for the gregorian calendar. This currently only allows a range of 1900 to 10000. Both ends of the range are a bit arbitrary at the moment, but they are the limits of current testing of the library. As such they may be increased in the future. </para><refsect2><title><anchor id="greg_yearconstruct-copy-destruct"/><computeroutput>greg_year</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id354736-bb"/>greg_year(<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis> year);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id325863-bb"/><computeroutput>greg_year</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id427974-bb"/><emphasis role="bold">operator</emphasis> <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">short</emphasis>() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id331597"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/greg_ymd.hpp">boost/date_time/gregorian/greg_ymd.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::year_month_day_base&lt; <link linkend="greg_year">greg_year</link>, <link linkend="greg_month">greg_month</link>, <link linkend="greg_day">greg_day</link> &gt; greg_year_month_day;
&#xA0;&#xA0;}
}</synopsis></section><section id="id405081"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/gregorian.hpp">boost/date_time/gregorian/gregorian.hpp</ulink>&gt;</title><para>Single file header that provides overall include for all elements of the gregorian date-time system. This includes the various types defined, but also other functions for formatting and parsing.</para></section><section id="id369276"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/gregorian_types.hpp">boost/date_time/gregorian/gregorian_types.hpp</ulink>&gt;</title><para>Single file header that defines most of the types for the gregorian date-time system.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::period&lt; <link linkend="boost.gregorian.date">date</link>, date_duration &gt; date_period;  <emphasis>// Date periods for the gregorian system. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::year_based_generator&lt; <link linkend="boost.gregorian.date">date</link> &gt; year_based_generator;  <emphasis>// A unifying date_generator base type. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::partial_date&lt; <link linkend="boost.gregorian.date">date</link> &gt; partial_date;  <emphasis>// A date generation object type. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::nth_kday_of_month&lt; <link linkend="boost.gregorian.date">date</link> &gt; nth_kday_of_month;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> nth_kday_of_month nth_day_of_the_week_in_month;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::first_kday_of_month&lt; <link linkend="boost.gregorian.date">date</link> &gt; first_kday_of_month;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> first_kday_of_month first_day_of_the_week_in_month;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::last_kday_of_month&lt; <link linkend="boost.gregorian.date">date</link> &gt; last_kday_of_month;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> last_kday_of_month last_day_of_the_week_in_month;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::first_kday_after&lt; <link linkend="boost.gregorian.date">date</link> &gt; first_kday_after;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> first_kday_after first_day_of_the_week_after;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::first_kday_before&lt; <link linkend="boost.gregorian.date">date</link> &gt; first_kday_before;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> first_kday_before first_day_of_the_week_before;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::day_clock&lt; <link linkend="boost.gregorian.date">date</link> &gt; day_clock;  <emphasis>// A clock to get the current day from the local computer. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::date_itr_base&lt; <link linkend="boost.gregorian.date">date</link> &gt; date_iterator;  <emphasis>// Base date_iterator type for gregorian types. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::date_itr&lt; date_time::day_functor&lt; <link linkend="boost.gregorian.date">date</link> &gt;, <link linkend="boost.gregorian.date">date</link> &gt; day_iterator;  <emphasis>// A day level iterator. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::date_itr&lt; date_time::week_functor&lt; <link linkend="boost.gregorian.date">date</link> &gt;, <link linkend="boost.gregorian.date">date</link> &gt; week_iterator;  <emphasis>// A week level iterator. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::date_itr&lt; date_time::month_functor&lt; <link linkend="boost.gregorian.date">date</link> &gt;, <link linkend="boost.gregorian.date">date</link> &gt; month_iterator;  <emphasis>// A month level iterator. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::date_itr&lt; date_time::year_functor&lt; <link linkend="boost.gregorian.date">date</link> &gt;, <link linkend="boost.gregorian.date">date</link> &gt; year_iterator;  <emphasis>// A year level iterator. </emphasis>
&#xA0;&#xA0;}
}</synopsis></section><section id="id345616"><title>Header &lt;<ulink url="../../boost/date_time/gregorian/parsers.hpp">boost/date_time/gregorian/parsers.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> gregorian {

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Deprecated: Use from_simple_string. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.gregorian.date">date</link></type> <anchor id="from_string"/>from_string(std::string s);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// From delimited date string where with order year-month-day eg: 2002-1-25 or 2003-Jan-25 (full month name is also accepted). </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.gregorian.date">date</link></type> <anchor id="from_simple_string"/>from_simple_string(std::string s);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// From delimited date string where with order year-month-day eg: 1-25-2003 or Jan-25-2003 (full month name is also accepted). </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.gregorian.date">date</link></type> <anchor id="from_us_string"/>from_us_string(std::string s);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// From delimited date string where with order day-month-year eg: 25-1-2002 or 25-Jan-2003 (full month name is also accepted). </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.gregorian.date">date</link></type> <anchor id="from_uk_string"/>from_uk_string(std::string s);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// From iso type date string where with order year-month-day eg: 20020125. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.gregorian.date">date</link></type> <anchor id="from_undelimited_string"/>from_undelimited_string(std::string s);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// From iso type date string where with order year-month-day eg: 20020125. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.gregorian.date">date</link></type> <anchor id="date_from_iso_string"/>date_from_iso_string(<emphasis role="bold">const</emphasis> std::string &amp; s);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Stream should hold a date in the form of: 2002-1-25. Month number, abbrev, or name are accepted. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> iterator_type&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.gregorian.date">date</link></type> <anchor id="from_stream"/>from_stream(iterator_type beg, iterator_type end);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Function to parse a date_period from a string (eg: [2003-Oct-31/2003-Dec-25]). </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>date_period</type> <anchor id="date_period_from_string"/>date_period_from_string(<emphasis role="bold">const</emphasis> std::string &amp; s);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Function to parse a date_period from a wstring (eg: [2003-Oct-31/2003-Dec-25]). </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>date_period</type> <anchor id="date_period_from_wstring"/>date_period_from_wstring(<emphasis role="bold">const</emphasis> std::wstring &amp; s);
&#xA0;&#xA0;}
}</synopsis></section></section><section id="posix_time_reference" xml:base="../libs/date_time/xmldoc/posix_time_autodoc.boostbook"><title>Posix Time Reference</title><section id="id367327"><title>Header &lt;<ulink url="../../boost/date_time/posix_time/conversion.hpp">boost/date_time/posix_time/conversion.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> posix_time {

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Function that converts a time_t into a ptime. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="ptime">ptime</link></type> <anchor id="from_time_t"/>from_time_t(std::time_t t);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type&gt; <type>time_type</type> <link linkend="from_ftime">from_ftime</link>(<emphasis role="bold">const</emphasis> FILETIME &amp;);
&#xA0;&#xA0;}
}</synopsis><refentry id="from_ftime"><refmeta><refentrytitle>Function template from_ftime</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::from_ftime</refname><refpurpose><simpara>Function to create a time object from an initialized FILETIME struct. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> time_type&gt; <type>time_type</type> from_ftime(<emphasis role="bold">const</emphasis> FILETIME &amp; ft);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Function to create a time object from an initialized FILETIME struct. A FILETIME struct holds 100-nanosecond units (0.0000001). When built with microsecond resolution the FILETIME's sub second value will be truncated. Nanosecond resolution has no truncation.</para><para>Note ftime is part of the Win32 API, so it is not portable to non-windows platforms. </para></refsect1></refentry></section><section id="id376463"><title>Header &lt;<ulink url="../../boost/date_time/posix_time/date_duration_operators.hpp">boost/date_time/posix_time/date_duration_operators.hpp</ulink>&gt;</title><para>Operators for ptime and optional gregorian types. Operators use snap-to-end-of-month behavior. Further details on this behavior can be found in reference for date_time/date_duration_types.hpp and documentation for month and year iterators.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> posix_time {
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="ptime">ptime</link></type> <link linkend="id317131"><emphasis role="bold">operator</emphasis>+</link>(<emphasis role="bold">const</emphasis> <link linkend="ptime">ptime</link> &amp;, <emphasis role="bold">const</emphasis> boost::gregorian::months &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="ptime">ptime</link></type> <link linkend="id427352"><emphasis role="bold">operator</emphasis>+=</link>(<link linkend="ptime">ptime</link> &amp;, <emphasis role="bold">const</emphasis> boost::gregorian::months &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="ptime">ptime</link></type> <link linkend="id419875"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> <link linkend="ptime">ptime</link> &amp;, <emphasis role="bold">const</emphasis> boost::gregorian::months &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="ptime">ptime</link></type> <link linkend="id412521"><emphasis role="bold">operator</emphasis>-=</link>(<link linkend="ptime">ptime</link> &amp;, <emphasis role="bold">const</emphasis> boost::gregorian::months &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="ptime">ptime</link></type> <link linkend="id322621"><emphasis role="bold">operator</emphasis>+</link>(<emphasis role="bold">const</emphasis> <link linkend="ptime">ptime</link> &amp;, <emphasis role="bold">const</emphasis> boost::gregorian::years &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="ptime">ptime</link></type> <link linkend="id327656"><emphasis role="bold">operator</emphasis>+=</link>(<link linkend="ptime">ptime</link> &amp;, <emphasis role="bold">const</emphasis> boost::gregorian::years &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="ptime">ptime</link></type> <link linkend="id320262"><emphasis role="bold">operator</emphasis>-</link>(<emphasis role="bold">const</emphasis> <link linkend="ptime">ptime</link> &amp;, <emphasis role="bold">const</emphasis> boost::gregorian::years &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="ptime">ptime</link></type> <link linkend="id319945"><emphasis role="bold">operator</emphasis>-=</link>(<link linkend="ptime">ptime</link> &amp;, <emphasis role="bold">const</emphasis> boost::gregorian::years &amp;);
&#xA0;&#xA0;}
}</synopsis><refentry id="id317131"><refmeta><refentrytitle>Function operator+</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::operator+</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="ptime">ptime</link></type> <emphasis role="bold">operator</emphasis>+(<emphasis role="bold">const</emphasis> <link linkend="ptime">ptime</link> &amp; t, <emphasis role="bold">const</emphasis> boost::gregorian::months &amp; m);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Adds a months object and a ptime. Result will be same day-of-month as ptime unless original day was the last day of month. see date_time::months_duration for more details </para></refsect1></refentry><refentry id="id427352"><refmeta><refentrytitle>Function operator+=</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::operator+=</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="ptime">ptime</link></type> <emphasis role="bold">operator</emphasis>+=(<link linkend="ptime">ptime</link> &amp; t, <emphasis role="bold">const</emphasis> boost::gregorian::months &amp; m);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Adds a months object to a ptime. Result will be same day-of-month as ptime unless original day was the last day of month. see date_time::months_duration for more details </para></refsect1></refentry><refentry id="id419875"><refmeta><refentrytitle>Function operator-</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::operator-</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="ptime">ptime</link></type> <emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> <link linkend="ptime">ptime</link> &amp; t, <emphasis role="bold">const</emphasis> boost::gregorian::months &amp; m);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Subtracts a months object and a ptime. Result will be same day-of-month as ptime unless original day was the last day of month. see date_time::months_duration for more details </para></refsect1></refentry><refentry id="id412521"><refmeta><refentrytitle>Function operator-=</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::operator-=</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="ptime">ptime</link></type> <emphasis role="bold">operator</emphasis>-=(<link linkend="ptime">ptime</link> &amp; t, <emphasis role="bold">const</emphasis> boost::gregorian::months &amp; m);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Subtracts a months object from a ptime. Result will be same day-of-month as ptime unless original day was the last day of month. see date_time::months_duration for more details </para></refsect1></refentry><refentry id="id322621"><refmeta><refentrytitle>Function operator+</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::operator+</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="ptime">ptime</link></type> <emphasis role="bold">operator</emphasis>+(<emphasis role="bold">const</emphasis> <link linkend="ptime">ptime</link> &amp; t, <emphasis role="bold">const</emphasis> boost::gregorian::years &amp; y);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Adds a years object and a ptime. Result will be same month and day-of-month as ptime unless original day was the last day of month. see date_time::years_duration for more details </para></refsect1></refentry><refentry id="id327656"><refmeta><refentrytitle>Function operator+=</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::operator+=</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="ptime">ptime</link></type> <emphasis role="bold">operator</emphasis>+=(<link linkend="ptime">ptime</link> &amp; t, <emphasis role="bold">const</emphasis> boost::gregorian::years &amp; y);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Adds a years object to a ptime. Result will be same month and day-of-month as ptime unless original day was the last day of month. see date_time::years_duration for more details </para></refsect1></refentry><refentry id="id320262"><refmeta><refentrytitle>Function operator-</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::operator-</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="ptime">ptime</link></type> <emphasis role="bold">operator</emphasis>-(<emphasis role="bold">const</emphasis> <link linkend="ptime">ptime</link> &amp; t, <emphasis role="bold">const</emphasis> boost::gregorian::years &amp; y);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Subtracts a years object and a ptime. Result will be same month and day-of-month as ptime unless original day was the last day of month. see date_time::years_duration for more details </para></refsect1></refentry><refentry id="id319945"><refmeta><refentrytitle>Function operator-=</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::operator-=</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="ptime">ptime</link></type> <emphasis role="bold">operator</emphasis>-=(<link linkend="ptime">ptime</link> &amp; t, <emphasis role="bold">const</emphasis> boost::gregorian::years &amp; y);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Subtracts a years object from a ptime. Result will be same month and day-of-month as ptime unless original day was the last day of month. see date_time::years_duration for more details </para></refsect1></refentry></section><section id="id310460"><title>Header &lt;<ulink url="../../boost/date_time/posix_time/posix_time.hpp">boost/date_time/posix_time/posix_time.hpp</ulink>&gt;</title><para>Global header file to get all of posix time types</para></section><section id="id444833"><title>Header &lt;<ulink url="../../boost/date_time/posix_time/posix_time_config.hpp">boost/date_time/posix_time/posix_time_config.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> posix_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="id344570">time_duration</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="simple_time_rep">simple_time_rep</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="posix_time_system_config">posix_time_system_config</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="id381340">millisec_posix_time_system_config</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::time_resolution_traits&lt; boost::date_time::time_resolution_traits_adapted64_impl, boost::date_time::nano, 1000000000, 9 &gt; time_res_traits;
&#xA0;&#xA0;}
}</synopsis><refentry id="id344570"><refmeta><refentrytitle>Class time_duration</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::time_duration</refname><refpurpose><simpara>Base time duration type. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> time_duration {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_res_traits&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; rep_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_res_traits::day_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; day_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_res_traits::hour_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; hour_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_res_traits::min_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; min_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_res_traits::sec_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; sec_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_res_traits::fractional_seconds_type fractional_seconds_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_res_traits::tick_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; tick_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_res_traits::impl_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; impl_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id344570construct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id439326-bb">time_duration</link>(hour_type, min_type, sec_type, fractional_seconds_type = 0);
&#xA0;&#xA0;<link linkend="id327776-bb">time_duration</link>();
&#xA0;&#xA0;<link linkend="id327779-bb">time_duration</link>(boost::date_time::special_values);
&#xA0;&#xA0;<link linkend="id403560-bb">time_duration</link>(impl_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id318917-bb">public member functions</link></emphasis>

&#xA0;&#xA0;<emphasis>// <link linkend="id394655-bb">private member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id344570construct-copy-destruct"/><computeroutput>time_duration</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id439326-bb"/>time_duration(hour_type hour, min_type min, sec_type sec, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;fractional_seconds_type fs = 0);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id327776-bb"/>time_duration();</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id327779-bb"/>time_duration(boost::date_time::special_values sv);</literallayout></para><simpara>Construct from special_values. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id403560-bb"/>time_duration(impl_type ticks);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id318917-bb"/><computeroutput>time_duration</computeroutput> public member functions</title><orderedlist/></refsect2><refsect2><title><anchor id="id394655-bb"/><computeroutput>time_duration</computeroutput> private member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="simple_time_rep"><refmeta><refentrytitle>Struct simple_time_rep</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::simple_time_rep</refname><refpurpose><simpara>Simple implementation for the time rep. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> simple_time_rep {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> gregorian::date date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="id344570">time_duration</link>&#xA0;&#xA0; time_duration_type;

&#xA0;&#xA0;<emphasis>// <link linkend="simple_time_repconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id333473-bb">simple_time_rep</link>(date_type, time_duration_type);

&#xA0;&#xA0;<emphasis>// <link linkend="id396812-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id336338-bb">is_special</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id419814-bb">is_pos_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id368096-bb">is_neg_infinity</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id383574-bb">is_not_a_date_time</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;date_type day;
&#xA0;&#xA0;time_duration_type time_of_day;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="simple_time_repconstruct-copy-destruct"/><computeroutput>simple_time_rep</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id333473-bb"/>simple_time_rep(date_type d, time_duration_type tod);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id396812-bb"/><computeroutput>simple_time_rep</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id336338-bb"/>is_special() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id419814-bb"/>is_pos_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id368096-bb"/>is_neg_infinity() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id383574-bb"/>is_not_a_date_time() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="posix_time_system_config"><refmeta><refentrytitle>Class posix_time_system_config</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::posix_time_system_config</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> posix_time_system_config {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="simple_time_rep">simple_time_rep</link>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_rep_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> gregorian::date&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> gregorian::date_duration&#xA0;&#xA0; date_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="id344570">time_duration</link>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_res_traits::tick_type int_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_res_traits&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; resolution_traits;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id322936-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type/> <link linkend="id322942-bb">BOOST_STATIC_CONSTANT</link>(boost::int64_t, tick_per_second = 1000000000) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id322936-bb"/><computeroutput>posix_time_system_config</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type/> <anchor id="id322942-bb"/>BOOST_STATIC_CONSTANT(boost::int64_t , tick_per_second  = 1000000000) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id381340"><refmeta><refentrytitle>Class millisec_posix_time_system_config</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::millisec_posix_time_system_config</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> millisec_posix_time_system_config {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> boost::int64_t&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_rep_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> gregorian::date&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; date_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> gregorian::date_duration&#xA0;&#xA0; date_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="id344570">time_duration</link>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_res_traits::tick_type int_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_res_traits::impl_type impl_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_res_traits&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; resolution_traits;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="id301094-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type/> <link linkend="id372681-bb">BOOST_STATIC_CONSTANT</link>(boost::int64_t, tick_per_second = 1000000) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id301094-bb"/><computeroutput>millisec_posix_time_system_config</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type/> <anchor id="id372681-bb"/>BOOST_STATIC_CONSTANT(boost::int64_t , tick_per_second  = 1000000) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id300614"><title>Header &lt;<ulink url="../../boost/date_time/posix_time/posix_time_duration.hpp">boost/date_time/posix_time/posix_time_duration.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> posix_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="hours">hours</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="minutes">minutes</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="seconds">seconds</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::subsecond_duration&lt; <link linkend="id344570">time_duration</link>, 1000 &gt; millisec;  <emphasis>// Allows expression of durations as milli seconds. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::subsecond_duration&lt; <link linkend="id344570">time_duration</link>, 1000 &gt; milliseconds;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::subsecond_duration&lt; <link linkend="id344570">time_duration</link>, 1000000 &gt; microsec;  <emphasis>// Allows expression of durations as micro seconds. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::subsecond_duration&lt; <link linkend="id344570">time_duration</link>, 1000000 &gt; microseconds;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::subsecond_duration&lt; <link linkend="id344570">time_duration</link>, 1000000000 &gt; nanosec;  <emphasis>// Allows expression of durations as nano seconds. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::subsecond_duration&lt; <link linkend="id344570">time_duration</link>, 1000000000 &gt; nanoseconds;
&#xA0;&#xA0;}
}</synopsis><refentry id="hours"><refmeta><refentrytitle>Class hours</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::hours</refname><refpurpose><simpara>Allows expression of durations as an hour count. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> hours : <emphasis role="bold">public</emphasis> boost::posix_time::time_duration {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="hoursconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id368009-bb">hours</link>(<emphasis role="bold">long</emphasis>);

&#xA0;&#xA0;<emphasis>// <link linkend="id368002-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="hoursconstruct-copy-destruct"/><computeroutput>hours</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id368009-bb"/>hours(<emphasis role="bold">long</emphasis> h);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id368002-bb"/><computeroutput>hours</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="minutes"><refmeta><refentrytitle>Class minutes</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::minutes</refname><refpurpose><simpara>Allows expression of durations as a minute count. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> minutes : <emphasis role="bold">public</emphasis> boost::posix_time::time_duration {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="minutesconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id314042-bb">minutes</link>(<emphasis role="bold">long</emphasis>);

&#xA0;&#xA0;<emphasis>// <link linkend="id314036-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="minutesconstruct-copy-destruct"/><computeroutput>minutes</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id314042-bb"/>minutes(<emphasis role="bold">long</emphasis> m);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id314036-bb"/><computeroutput>minutes</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="seconds"><refmeta><refentrytitle>Class seconds</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::seconds</refname><refpurpose><simpara>Allows expression of durations as a seconds count. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> seconds : <emphasis role="bold">public</emphasis> boost::posix_time::time_duration {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="secondsconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id368870-bb">seconds</link>(<emphasis role="bold">long</emphasis>);

&#xA0;&#xA0;<emphasis>// <link linkend="id407627-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="secondsconstruct-copy-destruct"/><computeroutput>seconds</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id368870-bb"/>seconds(<emphasis role="bold">long</emphasis> s);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id407627-bb"/><computeroutput>seconds</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry></section><section id="id330577"><title>Header &lt;<ulink url="../../boost/date_time/posix_time/posix_time_system.hpp">boost/date_time/posix_time/posix_time_system.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> posix_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::split_timedate_system&lt; posix_time_system_config, 1000000000 &gt; posix_time_system;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::counted_time_rep&lt; millisec_posix_time_system_config &gt; int64_time_rep;
&#xA0;&#xA0;}
}</synopsis></section><section id="id391049"><title>Header &lt;<ulink url="../../boost/date_time/posix_time/posix_time_types.hpp">boost/date_time/posix_time/posix_time_types.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> posix_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::time_itr&lt; <link linkend="ptime">ptime</link> &gt; time_iterator;  <emphasis>// Iterator over a defined time duration. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::second_clock&lt; ptime::date_type, <link linkend="ptime">ptime</link> &gt; second_clock;  <emphasis>// A time clock that has a resolution of one second. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::microsec_clock&lt; <link linkend="ptime">ptime</link> &gt; microsec_clock;  <emphasis>// A time clock that has a resolution of one microsecond. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::null_dst_rules&lt; ptime::date_type, <link linkend="id344570">time_duration</link> &gt; no_dst;  <emphasis>// Define a dst null dst rule for the posix_time system. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::us_dst_rules&lt; ptime::date_type, <link linkend="id344570">time_duration</link> &gt; us_dst;  <emphasis>// Define US dst rule calculator for the posix_time system. </emphasis>
&#xA0;&#xA0;}
}</synopsis></section><section id="id408599"><title>Header &lt;<ulink url="../../boost/date_time/posix_time/ptime.hpp">boost/date_time/posix_time/ptime.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> posix_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="ptime">ptime</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="ptime"><refmeta><refentrytitle>Class ptime</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::ptime</refname><refpurpose><simpara>Time type with no timezone or other adjustments. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> ptime {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> posix_time_system&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_system_type;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_system_type::time_rep_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_rep_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> time_system_type::time_duration_type time_duration_type;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="ptime">ptime</link>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; time_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="ptimeconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id373926-bb">ptime</link>(gregorian::date, time_duration_type);
&#xA0;&#xA0;<link linkend="id420093-bb">ptime</link>(gregorian::date);
&#xA0;&#xA0;<link linkend="id342248-bb">ptime</link>(<emphasis role="bold">const</emphasis> time_rep_type &amp;);
&#xA0;&#xA0;<link linkend="id430161-bb">ptime</link>(<emphasis role="bold">const</emphasis> special_values);
&#xA0;&#xA0;<link linkend="id356296-bb">ptime</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id394759-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="ptimeconstruct-copy-destruct"/><computeroutput>ptime</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id373926-bb"/>ptime(gregorian::date d, time_duration_type td);</literallayout></para><simpara>Construct with date and offset in day. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id420093-bb"/>ptime(gregorian::date d);</literallayout></para><simpara>Construct a time at start of the given day (midnight). </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id342248-bb"/>ptime(<emphasis role="bold">const</emphasis> time_rep_type &amp; rhs);</literallayout></para><simpara>Copy from time_rep. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id430161-bb"/>ptime(<emphasis role="bold">const</emphasis> special_values sv);</literallayout></para><simpara>Construct from special value. </simpara></listitem><listitem><para><literallayout class="monospaced"><anchor id="id356296-bb"/>ptime();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id394759-bb"/><computeroutput>ptime</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry></section><section id="id356305"><title>Header &lt;<ulink url="../../boost/date_time/posix_time/time_formatters.hpp">boost/date_time/posix_time/time_formatters.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> posix_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; charT &gt;</type> <anchor id="id418825"/>to_simple_string_type(<link linkend="id344570">time_duration</link> td);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; charT &gt;</type> <anchor id="id423544"/>to_iso_string_type(<link linkend="id344570">time_duration</link> td);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Time to simple format CCYY-mmm-dd hh:mm:ss.fffffff. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; charT &gt;</type> <anchor id="id381736"/>to_simple_string_type(<link linkend="ptime">ptime</link> t);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; charT &gt;</type> <anchor id="id316012"/>to_simple_string_type(time_period tp);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; charT &gt;</type> <anchor id="id244053"/>to_iso_string_type(<link linkend="ptime">ptime</link> t);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; charT &gt;</type> <anchor id="id363548"/>to_iso_extended_string_type(<link linkend="ptime">ptime</link> t);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Time duration to wstring -hh::mm::ss.fffffff. Example: 10:09:03.0123456. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::wstring</type> <anchor id="id320202"/>to_simple_wstring(<link linkend="id344570">time_duration</link> td);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Time duration in iso format -hhmmss,fffffff Example: 10:09:03,0123456. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::wstring</type> <anchor id="id399363"/>to_iso_wstring(<link linkend="id344570">time_duration</link> td);
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::wstring</type> <anchor id="id352792"/>to_simple_wstring(<link linkend="ptime">ptime</link> t);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Convert to wstring of form [YYYY-mmm-DD HH:MM::SS.ffffff/YYYY-mmm-DD HH:MM::SS.fffffff]. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::wstring</type> <anchor id="id305907"/>to_simple_wstring(time_period tp);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Convert iso short form YYYYMMDDTHHMMSS where T is the date-time separator. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::wstring</type> <anchor id="id424904"/>to_iso_wstring(<link linkend="ptime">ptime</link> t);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Convert to form YYYY-MM-DDTHH:MM:SS where T is the date-time separator. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::wstring</type> <anchor id="id368354"/>to_iso_extended_wstring(<link linkend="ptime">ptime</link> t);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_istream&lt; charT &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id381911"/><emphasis role="bold">operator</emphasis>&gt;&gt;(std::basic_istream&lt; charT &gt; &amp; is, <link linkend="id344570">time_duration</link> &amp; td);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_istream&lt; charT &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id328259"/><emphasis role="bold">operator</emphasis>&gt;&gt;(std::basic_istream&lt; charT &gt; &amp; is, <link linkend="ptime">ptime</link> &amp; pt);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_istream&lt; charT &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id425116"><emphasis role="bold">operator</emphasis>&gt;&gt;</link>(std::basic_istream&lt; charT &gt; &amp;, time_period &amp;);
&#xA0;&#xA0;}
}</synopsis><refentry id="id425116"><refmeta><refentrytitle>Function template operator&gt;&gt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::operator&gt;&gt;</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;<type>std::basic_istream&lt; charT &gt; &amp;</type> 
&#xA0;&#xA0;<emphasis role="bold">operator</emphasis>&gt;&gt;(std::basic_istream&lt; charT &gt; &amp; is, time_period &amp; tp);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>operator&gt;&gt; for time_period. time_period must be in "[date time_duration/date time_duration]" format. </para></refsect1></refentry></section><section id="id431429"><title>Header &lt;<ulink url="../../boost/date_time/posix_time/time_formatters_limited.hpp">boost/date_time/posix_time/time_formatters_limited.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> posix_time {

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Time duration to string -hh::mm::ss.fffffff. Example: 10:09:03.0123456. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::string</type> <anchor id="id327343"/>to_simple_string(<link linkend="id344570">time_duration</link> td);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Time duration in iso format -hhmmss,fffffff Example: 10:09:03,0123456. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::string</type> <anchor id="id375502"/>to_iso_string(<link linkend="id344570">time_duration</link> td);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Time to simple format CCYY-mmm-dd hh:mm:ss.fffffff. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::string</type> <anchor id="id304753"/>to_simple_string(<link linkend="ptime">ptime</link> t);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Convert to string of form [YYYY-mmm-DD HH:MM::SS.ffffff/YYYY-mmm-DD HH:MM::SS.fffffff]. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::string</type> <anchor id="id354901"/>to_simple_string(time_period tp);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Convert iso short form YYYYMMDDTHHMMSS where T is the date-time separator. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::string</type> <anchor id="id343584"/>to_iso_string(<link linkend="ptime">ptime</link> t);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Convert to form YYYY-MM-DDTHH:MM:SS where T is the date-time separator. </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::string</type> <anchor id="id426569"/>to_iso_extended_string(<link linkend="ptime">ptime</link> t);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// ostream operator for posix_time::time_duration </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id400016"/><emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="id344570">time_duration</link> &amp; td);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// ostream operator for posix_time::ptime </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id431835"/><emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, <emphasis role="bold">const</emphasis> <link linkend="ptime">ptime</link> &amp; t);

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// ostream operator for posix_time::time_period </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT, <emphasis role="bold">typename</emphasis> traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; charT, traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<anchor id="id286003"/><emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; charT, traits &gt; &amp; os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> time_period &amp; tp);
&#xA0;&#xA0;}
}</synopsis></section><section id="id303750"><title>Header &lt;<ulink url="../../boost/date_time/posix_time/time_parsers.hpp">boost/date_time/posix_time/time_parsers.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> posix_time {
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="id344570">time_duration</link></type> <link linkend="duration_from_string">duration_from_string</link>(<emphasis role="bold">const</emphasis> std::string &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="ptime">ptime</link></type> <anchor id="time_from_string"/>time_from_string(<emphasis role="bold">const</emphasis> std::string &amp; s);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="ptime">ptime</link></type> <anchor id="from_iso_string"/>from_iso_string(<emphasis role="bold">const</emphasis> std::string &amp; s);
&#xA0;&#xA0;}
}</synopsis><refentry id="duration_from_string"><refmeta><refentrytitle>Function duration_from_string</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::posix_time::duration_from_string</refname><refpurpose><simpara>Creates a time_duration object from a delimited string. </simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="id344570">time_duration</link></type> duration_from_string(<emphasis role="bold">const</emphasis> std::string &amp; s);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Expected format for string is "[-]h[h][:mm][:ss][.fff]". A negative duration will be created if the first character in string is a '-', all other '-' will be treated as delimiters. Accepted delimiters are "-:,.". </para></refsect1></refentry></section><section id="id405012"><title>Header &lt;<ulink url="../../boost/date_time/posix_time/time_period.hpp">boost/date_time/posix_time/time_period.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> posix_time {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> date_time::period&lt; <link linkend="ptime">ptime</link>, <link linkend="id344570">time_duration</link> &gt; time_period;  <emphasis>// Time period type. </emphasis>
&#xA0;&#xA0;}
}</synopsis></section></section></section></chapter><chapter xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="function" rev:last-revision="$Date: 2004/07/25 02:51:51 $"><chapterinfo><author><firstname>Douglas</firstname><surname>Gregor</surname><email>dgregor -at- cs.indiana.edu</email></author><copyright><year>2001</year><year>2002</year><year>2003</year><year>2004</year><holder>Douglas Gregor</holder></copyright><legalnotice><para>Use, modification and distribution is subject to the Boost
    Software License, Version 1.0. (See accompanying file
    <filename>LICENSE_1_0.txt</filename> or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)</para></legalnotice></chapterinfo><title>Boost.Function</title><section id="function.intro"><title>Introduction</title><para>The Boost.Function library contains a family of class templates
that are function object wrappers. The notion is similar to a
generalized callback. It shares features with function pointers in
that both define a call interface (e.g., a function taking two integer
arguments and returning a floating-point value) through which some
implementation can be called, and the implementation that is invoked
may change throughout the course of the program.</para><para> Generally, any place in which a function pointer would be used
to defer a call or make a callback, Boost.Function can be used instead
to allow the user greater flexibility in the implementation of the
target. Targets can be any 'compatible' function object (or function
pointer), meaning that the arguments to the interface designated by
Boost.Function can be converted to the arguments of the target
function object.</para></section><section id="function.history" rev:last-revision="$Date: 2003/03/12 23:27:22 $" xml:base="../libs/function/doc/history.xml"><title>History &amp; Compatibility Notes</title><itemizedlist spacing="compact"><listitem><para><emphasis role="bold">Version 1.30.0</emphasis>: </para><itemizedlist spacing="compact"><listitem><para>All features deprecated in version 1.29.0 have
      been removed from Boost.Function.</para></listitem><listitem><para><computeroutput><link linkend="boost.function">boost::function</link></computeroutput>
      and <computeroutput><link linkend="functionN">boost::functionN</link></computeroutput> objects
      can be assigned to 0 (semantically equivalent to calling
      <computeroutput><link linkend="id377153-bb">clear</link>()</computeroutput>) and
      compared against 0 (semantically equivalent to calling
      <computeroutput><link linkend="id393241-bb">empty</link>()</computeroutput>).</para></listitem><listitem><para>The Boost.Function code is now generated
      entirely by the <ulink url="../../libs/preprocessor/index.html">Preprocessor</ulink> library,
      so it is now possible to generate
      <computeroutput><link linkend="boost.function">boost::function</link></computeroutput> and
      <computeroutput><link linkend="functionN">boost::functionN</link></computeroutput> class
      templates for any number of arguments.</para></listitem><listitem><para>The
      <link linkend="bad_function_call">boost::bad_function_call</link> exception class
      was introduced.</para></listitem></itemizedlist></listitem><listitem><para><emphasis role="bold">Version 1.29.0</emphasis>:
  Boost.Function has been partially redesigned to minimize the
  interface and make it cleaner. Several seldom- or never-used
  features of the older Boost.Function have been deprecated and will
  be removed in the near future. Here is a list of features that have
  been deprecated, the likely impact of the deprecations, and how to
  adjust your code:

<itemizedlist spacing="compact"><listitem><para>The <computeroutput>boost::function</computeroutput> class template syntax has
  changed. The old syntax, e.g., <computeroutput>boost::function&lt;int, float,
  double, std::string&gt;</computeroutput>, has been changed to a more natural
  syntax <computeroutput>boost::function&lt;int (float, double,
  std::string)&gt;</computeroutput>, where all return and argument types are
  encoded in a single function type parameter. Any other template
  parameters (e.g., the <computeroutput>Allocator</computeroutput>) follow this single
  parameter.</para><para> The resolution to this change depends on the
  abilities of your compiler: if your compiler supports template
  partial specialization and can parse function types (most do), modify 
  your code to use the newer
  syntax (preferable) or directly use one of the
  <computeroutput>functionN</computeroutput> classes whose syntax has not
  changed. If your compiler does not support template partial
  specialization or function types, you must take the latter option and 
  use the numbered Boost.Function classes. This option merely requires 
  changing types such as <computeroutput>boost::function&lt;void, int, int&gt;</computeroutput>
  to <computeroutput>boost::function2&lt;void, int, int&gt;</computeroutput> (adding the number of
  function arguments to the end of the class name).</para><para> Support for the old syntax with the
  <computeroutput>boost::function</computeroutput> class template will persist for a short
  while, but will eventually be removed so that we can provide better
  error messages and link compatibility. </para></listitem><listitem><para>The invocation
  policy template parameter (<computeroutput>Policy</computeroutput>) has been deprecated
  and will be removed. There is no direct equivalent to this rarely
  used feature.</para></listitem><listitem><para>The mixin template parameter
  (<computeroutput>Mixin</computeroutput>) has been deprecated and will be removed. There
  is not direct equivalent to this rarely used feature.</para></listitem><listitem><para>The
  <computeroutput>set</computeroutput> methods have been deprecated and will be
  removed. Use the assignment operator instead.</para></listitem></itemizedlist></para></listitem></itemizedlist></section><section id="function.tutorial" rev:last-revision="$Date: 2004/01/25 01:17:35 $" xml:base="../libs/function/doc/tutorial.xml"><title>Tutorial</title><para> Boost.Function has two syntactical forms: the preferred form
and the portable form. The preferred form fits more closely with the
C++ language and reduces the number of separate template parameters
that need to be considered, often improving readability; however, the
preferred form is not supported on all platforms due to compiler
bugs. The compatible form will work on all compilers supported by
Boost.Function. Consult the table below to determine which syntactic
form to use for your compiler.

  <informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><itemizedlist spacing="compact"><listitem><simpara>GNU C++ 2.95.x, 3.0.x, 3.1.x</simpara></listitem><listitem><simpara>Comeau C++ 4.2.45.2</simpara></listitem><listitem><simpara>SGI MIPSpro 7.3.0</simpara></listitem><listitem><simpara>Intel C++ 5.0, 6.0</simpara></listitem><listitem><simpara>Compaq's cxx 6.2</simpara></listitem><listitem><simpara>Microsoft Visual C++ 7.1</simpara></listitem></itemizedlist></entry><entry><itemizedlist spacing="compact"><listitem><simpara><emphasis>Any compiler supporting the preferred syntax</emphasis></simpara></listitem><listitem><simpara>Microsoft Visual C++ 6.0, 7.0</simpara></listitem><listitem><simpara>Borland C++ 5.5.1</simpara></listitem><listitem><simpara>Sun WorkShop 6 update 2 C++ 5.3</simpara></listitem><listitem><simpara>Metrowerks CodeWarrior 8.1</simpara></listitem></itemizedlist></entry></row></tbody></tgroup></informaltable></para><para> If your compiler does not appear in this list, please try the preferred syntax and report your results to the Boost list so that we can keep this table up-to-date.</para><section><title>Basic Usage</title><para> A function wrapper is defined simply
by instantiating the <computeroutput>function</computeroutput> class
template with the desired return type and argument types, formulated
as a C++ function type. Any number of arguments may be supplied, up to
some implementation-defined limit (10 is the default maximum). The
following declares a function object wrapper
<computeroutput>f</computeroutput> that takes two
<computeroutput>int</computeroutput> parameters and returns a
<computeroutput>float</computeroutput>:

  <informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting><link linkend="boost.function">boost::function</link>&lt;float (int x, int y)&gt; f;</programlisting></entry><entry><programlisting><link linkend="functionN">boost::function2</link>&lt;float, int, int&gt; f;</programlisting></entry></row></tbody></tgroup></informaltable></para><para> By default, function object wrappers are empty, so we can create a 
function object to assign to <computeroutput>f</computeroutput>:

<programlisting>struct int_div { 
  float operator()(int x, int y) const { return ((float)x)/y; }; 
};</programlisting><programlisting>f = int_div();</programlisting></para><para> Now we can use <computeroutput>f</computeroutput> to execute
the underlying function object
<computeroutput>int_div</computeroutput>:

<programlisting>std::cout &lt;&lt; f(5, 3) &lt;&lt; std::endl;</programlisting></para><para> We are free to assign any compatible function object to
<computeroutput>f</computeroutput>. If
<computeroutput>int_div</computeroutput> had been declared to take two
<computeroutput>long</computeroutput> operands, the implicit
conversions would have been applied to the arguments without any user
interference. The only limit on the types of arguments is that they be
CopyConstructible, so we can even use references and arrays:

  <informaltable><tgroup cols="1" align="left"><thead><row><entry>Preferred syntax</entry></row></thead><tbody><row><entry><programlisting><link linkend="boost.function">boost::function</link>&lt;void (int values[], int n, int&amp; sum, float&amp; avg)&gt; sum_avg;</programlisting></entry></row></tbody></tgroup></informaltable><informaltable><tgroup cols="1" align="left"><thead><row><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting><link linkend="functionN">boost::function4</link>&lt;void, int*, int, int&amp;, float&amp;&gt; sum_avg;</programlisting></entry></row></tbody></tgroup></informaltable><programlisting>void do_sum_avg(int values[], int n, int&amp; sum, float&amp; avg)
{
  sum = 0;
  for (int i = 0; i &lt; n; i++)
    sum += values[i];
  avg = (float)sum / n;
}</programlisting><programlisting>sum_avg = &amp;do_sum_avg;</programlisting></para><para> Invoking a function object wrapper that does not actually
contain a function object is a precondition violation, much like
trying to call through a null function pointer, and will throw a <link linkend="bad_function_call">bad_function_call</link> exception). We can check for an
empty function object wrapper by using it in a boolean context (it evaluates <computeroutput>true</computeroutput> if the wrapper is not empty) or compare it against <computeroutput>0</computeroutput>. For instance:
<programlisting>if (f)
  std::cout &lt;&lt; f(5, 3) &lt;&lt; std::endl;
else
  std::cout &lt;&lt; "f has no target, so it is unsafe to call" &lt;&lt; std::endl;</programlisting></para><para> Alternatively,
<computeroutput><link linkend="id393241-bb">empty</link>()</computeroutput>
method will return whether or not the wrapper is empty.  </para><para> Finally, we can clear out a function target by assigning it to <computeroutput>0</computeroutput> or by calling the <computeroutput><link linkend="id377153-bb">clear</link>()</computeroutput> member function, e.g., 
<programlisting>f = 0;</programlisting></para></section><section><title>Free functions</title><para> Free function pointers can be considered singleton function objects with const function call operators, and can therefore be directly used with the function object wrappers: 
<programlisting>float mul_ints(int x, int y) { return ((float)x) * y; }</programlisting><programlisting>f = &amp;mul_ints;</programlisting></para><para> Note that the <computeroutput>&amp;</computeroutput> isn't really necessary unless you happen to be using Microsoft Visual C++ version 6. </para></section><section><title>Member functions</title><para> In many systems, callbacks often call to member functions of a
particular object. This is often referred to as "argument binding",
and is beyond the scope of Boost.Function. The use of member functions
directly, however, is supported, so the following code is valid:

<programlisting>struct X {
  int foo(int);
};</programlisting><informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting><link linkend="boost.function">boost::function</link>&lt;int (X*, int)&gt; f;

f = &amp;X::foo;
  
X x;
f(&amp;x, 5);</programlisting></entry><entry><programlisting><link linkend="functionN">boost::function2</link>&lt;int, X*, int&gt; f;

f = &amp;X::foo;
  
X x;
f(&amp;x, 5);</programlisting></entry></row></tbody></tgroup></informaltable></para><para> Several libraries exist that support argument binding. Three such libraries are summarized below:
<itemizedlist><listitem><para><ulink url="../../libs/bind/index.html">Bind</ulink>. This library allows binding of
  arguments for any function object. It is lightweight and very
  portable.</para></listitem><listitem><para>The C++ Standard library. Using
  <computeroutput>std::bind1st</computeroutput> and
  <computeroutput>std::mem_fun</computeroutput> together one can bind
  the object of a pointer-to-member function for use with
  Boost.Function:

  <informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting><link linkend="boost.function">boost::function</link>&lt;int (int)&gt; f;
X x;
f = std::bind1st(
      std::mem_fun(&amp;X::foo), &amp;x);
f(5); // Call x.foo(5)</programlisting></entry><entry><programlisting><link linkend="functionN">boost::function1</link>&lt;int, int&gt; f;
X x;
f = std::bind1st(
      std::mem_fun(&amp;X::foo), &amp;x);
f(5); // Call x.foo(5)</programlisting></entry></row></tbody></tgroup></informaltable></para></listitem><listitem><para>The <link linkend="lambda">Lambda</link> library. This library provides a powerful composition mechanism to construct function objects that uses very natural C++ syntax. Lambda requires a compiler that is reasonably conformant to the C++ standard. </para></listitem></itemizedlist></para></section><section><title>References to Function Objects</title><para> In some cases it is
  expensive (or semantically incorrect) to have Boost.Function clone a
  function object. In such cases, it is possible to request that
  Boost.Function keep only a reference to the actual function
  object. This is done using the <computeroutput>ref</computeroutput>
  and <computeroutput>cref</computeroutput> functions to wrap a
  reference to a function object:

  <informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting>stateful_type a_function_object;
<link linkend="boost.function">boost::function</link>&lt;int (int)&gt; f;
f = <link linkend="id376299">boost::ref</link>(a_function_object);

<link linkend="boost.function">boost::function</link>&lt;int (int)&gt; f2(f);</programlisting></entry><entry><programlisting>stateful_type a_function_object;
<link linkend="functionN">boost::function1</link>&lt;int, int&gt; f;
f = <link linkend="id376299">boost::ref</link>(a_function_object);

<link linkend="functionN">boost::function1</link>&lt;int, int&gt; f2(f);</programlisting></entry></row></tbody></tgroup></informaltable></para><para> Here, <computeroutput>f</computeroutput> will not make a copy
of <computeroutput>a_function_object</computeroutput>, nor will
<computeroutput>f2</computeroutput> when it is targeted to
<computeroutput>f</computeroutput>'s reference to
<computeroutput>a_function_object</computeroutput>. Additionally, when
using references to function objects, Boost.Function will not throw
exceptions during assignment or construction.
</para></section><section><title>Comparing Boost.Function function objects</title><para>Function object wrappers can be compared via <computeroutput>==</computeroutput>
  or <computeroutput>!=</computeroutput> against any function object that can be stored
  within the wrapper. If the function object wrapper contains a
  function object of that type, it will be compared against the given
  function object (which must be
  <link linkend="EqualityComparable">EqualityComparable</link>). For instance:</para><programlisting>int compute_with_X(X*, int);

f = &amp;X::foo;
assert(f == &amp;X::foo);
assert(&amp;compute_with_X != f);</programlisting><para>When comparing against an instance of
   <computeroutput><link linkend="reference_wrapper">reference_wrapper</link></computeroutput>, the address
   of the object in the
   <computeroutput><link linkend="reference_wrapper">reference_wrapper</link></computeroutput> is compared
   against the address of the object stored by the function object
   wrapper:</para><programlisting>a_stateful_object so1, so2;
f = <link linkend="id376299">boost::ref</link>(so1);
assert(f == <link linkend="id376299">boost::ref</link>(so1));
assert(f == so1); <emphasis>// Only if a_stateful_object is <link linkend="EqualityComparable">EqualityComparable</link></emphasis>
assert(f != <link linkend="id376299">boost::ref</link>(so2));</programlisting></section></section><section id="function.reference"><title>Reference</title><section id="function.definitions"><title>Definitions</title><para><itemizedlist><listitem><para>A function object <computeroutput>f</computeroutput> is
      <emphasis>compatible</emphasis> if for the given set of argument
      types <computeroutput>Arg1</computeroutput>,
      <computeroutput>Arg2</computeroutput>, ...,
      <computeroutput>ArgN</computeroutput> and a
      return type <computeroutput>ResultType</computeroutput>, the
      appropriate following function is well-formed:
<programlisting><emphasis>// if ResultType is not <emphasis role="bold">void</emphasis></emphasis>
  ResultType foo(Arg1 arg1, Arg2 arg2, ..., Arg<emphasis>N</emphasis> arg<emphasis>N</emphasis>)
  {
    <emphasis role="bold">return</emphasis> f(arg1, arg2, ..., arg<emphasis>N</emphasis>);
  }

  <emphasis>// if ResultType is <emphasis role="bold">void</emphasis></emphasis>
  ResultType foo(Arg1 arg1, Arg2 arg2, ..., Arg<emphasis>N</emphasis> arg<emphasis>N</emphasis>)
  {
    f(arg1, arg2, ..., arg<emphasis>N</emphasis>);
  }
</programlisting></para><para> A special provision is made for pointers to member
      functions. Though they are not function objects, Boost.Function
      will adapt them internally to function objects. This requires
      that a pointer to member function of the form <computeroutput>R
      (X::*mf)(Arg1, Arg2, ..., ArgN)
      cv-quals</computeroutput> be adapted to a
      function object with the following function call operator
      overloads:
<programlisting><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename P</emphasis>&gt;
  R <emphasis role="bold">operator</emphasis>()(<emphasis>cv-quals</emphasis> P&amp; x, Arg1 arg1, Arg2 arg2, ..., Arg<emphasis>N</emphasis> arg<emphasis>N</emphasis>) <emphasis role="bold">const</emphasis>
  {
    <emphasis role="bold">return</emphasis> (*x).*mf(arg1, arg2, ..., arg<emphasis>N</emphasis>);
  }
</programlisting></para></listitem><listitem><para>A function object <computeroutput>f</computeroutput> of
      type <computeroutput>F</computeroutput> is
      <emphasis>stateless</emphasis> if it is a function pointer or if
      <computeroutput>boost::is_stateless&lt;T&gt;</computeroutput>
      is true. The construction of or copy to a Boost.Function object
      from a stateless function object will not cause exceptions to be
      thrown and will not allocate any storage.
      </para></listitem></itemizedlist></para></section><section id="header.boost.function.hpp"><title>Header &lt;<ulink url="../../boost/function.hpp">boost/function.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="bad_function_call">bad_function_call</link>;
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="function_base">function_base</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> R, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Allocator = std::allocator&lt;<emphasis role="bold">void</emphasis>&gt; &gt; 
  &#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="functionN">functionN</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id243473">swap</link>(<link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id367263-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;, Functor);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id304156-bb"><emphasis role="bold">operator</emphasis>==</link>(Functor, <emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id307683-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id418996-bb"><emphasis role="bold">operator</emphasis>==</link>(<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> U1, <emphasis role="bold">typename</emphasis> U2, ..., <emphasis role="bold">typename</emphasis> UN, <emphasis role="bold">typename</emphasis> Allocator2&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id340873-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator1&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;U1, U2, ..., UN, Allocator2&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id273475-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;, Functor);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id345580-bb"><emphasis role="bold">operator</emphasis>!=</link>(Functor, <emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id393309-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id403770-bb"><emphasis role="bold">operator</emphasis>!=</link>(<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> U1, <emphasis role="bold">typename</emphasis> U2, ..., <emphasis role="bold">typename</emphasis> UN, <emphasis role="bold">typename</emphasis> Allocator2&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id372280-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator1&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;U1, U2, ..., UN, Allocator2&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator = std::allocator&lt;<emphasis role="bold">void</emphasis>&gt; &gt; 
  &#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="boost.function">function</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id354066">swap</link>(<link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id235870-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;, Functor);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id318513-bb"><emphasis role="bold">operator</emphasis>==</link>(Functor, <emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id262984-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id349308-bb"><emphasis role="bold">operator</emphasis>==</link>(<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature1, <emphasis role="bold">typename</emphasis> Allocator1, <emphasis role="bold">typename</emphasis> Signature2, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Allocator2&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id242840-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature1, Allocator1&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature2, Allocator2&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id256291-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;, Functor);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id428210-bb"><emphasis role="bold">operator</emphasis>!=</link>(Functor, <emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id425558-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id409074-bb"><emphasis role="bold">operator</emphasis>!=</link>(<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature1, <emphasis role="bold">typename</emphasis> Allocator1, <emphasis role="bold">typename</emphasis> Signature2, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Allocator2&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id316198-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature1, Allocator1&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature2, Allocator2&gt;&amp;);
}</synopsis><refentry id="bad_function_call"><refmeta><refentrytitle>Class bad_function_call</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::bad_function_call</refname><refpurpose>An exception type thrown when an instance of a <computeroutput>function</computeroutput> object is empty when invoked.</refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> bad_function_call : <emphasis role="bold">public</emphasis> std::runtime_error {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="bad_function_callconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id365072-bb">bad_function_call</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="bad_function_callconstruct-copy-destruct"/><computeroutput>bad_function_call</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id365072-bb"/>bad_function_call();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Constructs a <computeroutput><link linkend="bad_function_call">bad_function_call</link></computeroutput> exception object.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="function_base"><refmeta><refentrytitle>Class function_base</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::function_base</refname><refpurpose>The common base class for all Boost.Function
    objects. Objects of type function_base may not be created
    directly.</refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> function_base {
<emphasis role="bold">public</emphasis>:

&#xA0;&#xA0;<emphasis>// <link linkend="id429695-bb">capacity</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id346441-bb">empty</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id363180-bb">target access</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type>Functor*</type> <link linkend="id362089-bb">target</link>();
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type><emphasis role="bold">const</emphasis> Functor*</type> <link linkend="id252115-bb">target</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type><emphasis role="bold">bool</emphasis></type> <link linkend="id236630-bb">contains</link>(<emphasis role="bold">const</emphasis> Functor&amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id429695-bb"/><computeroutput>function_base</computeroutput> capacity</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id346441-bb"/>empty() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>false</computeroutput> if <computeroutput>this</computeroutput> has a target, and <computeroutput>true</computeroutput> otherwise.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id363180-bb"/><computeroutput>function_base</computeroutput> target access</title><orderedlist><listitem><para id="id360366-bb"><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type>Functor*</type> <anchor id="id362089-bb"/>target();
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type><emphasis role="bold">const</emphasis> Functor*</type> <anchor id="id252115-bb"/>target() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>If <computeroutput>this</computeroutput> stores a target of type
        <computeroutput>Functor</computeroutput>, returns the address of the
        target. Otherwise, returns the NULL
        pointer.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type><emphasis role="bold">bool</emphasis></type> <anchor id="id236630-bb"/>contains(<emphasis role="bold">const</emphasis> Functor&amp; f) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>true</computeroutput> if <computeroutput>this-&gt;<link linkend="id360366-bb">target</link>&lt;Functor&gt;()</computeroutput> is non-NULL and <computeroutput><link linkend="function_equal">function_equal</link>(*(this-&gt;target&lt;Functor&gt;()), f)</computeroutput></simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="functionN"><refmeta><refentrytitle>Class template functionN</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::functionN</refname><refpurpose>A set of generalized function pointers that can be used for callbacks or wrapping function objects.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> R, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Allocator = std::allocator&lt;<emphasis role="bold">void</emphasis>&gt; &gt; 
<emphasis role="bold">class</emphasis> functionN : <emphasis role="bold">public</emphasis> <link linkend="function_base">function_base</link> {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> R&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; result_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> Allocator allocator_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; argument_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// If N == 1</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; first_argument_type;&#xA0;  <emphasis>// If N == 2</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; second_argument_type;  <emphasis>// If N == 2</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; arg1_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; arg2_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;.
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;.
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;.
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> TN&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; argN_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// static constants</emphasis>
&#xA0;&#xA0;<emphasis role="bold">static</emphasis> <emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> arity = N;

&#xA0;&#xA0;<emphasis>// <link linkend="lambda">Lambda</link> library support</emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Args&gt; 
&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> sig {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> result_type type;
&#xA0;&#xA0;};

&#xA0;&#xA0;<emphasis>// <link linkend="functionNconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id383122-bb">functionN</link>();
&#xA0;&#xA0;<link linkend="id319466-bb">functionN</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> F&gt; <link linkend="id325943-bb">functionN</link>(F);
&#xA0;&#xA0;functionN&amp; <link linkend="id243506-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&amp;);
&#xA0;&#xA0;<link linkend="id433349-bb">~functionN</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id363207-bb">modifiers</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id264499-bb">swap</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&amp;);
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id356064-bb">clear</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id218197-bb">capacity</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id363748-bb">empty</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<link linkend="id405855-bb"><emphasis role="bold">operator</emphasis> safe_bool</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id235240-bb"><emphasis role="bold">operator</emphasis>!</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id311150-bb">target access</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type>Functor*</type> <link linkend="id307750-bb">target</link>();
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type><emphasis role="bold">const</emphasis> Functor*</type> <link linkend="id308769-bb">target</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type><emphasis role="bold">bool</emphasis></type> <link linkend="id355447-bb">contains</link>(<emphasis role="bold">const</emphasis> Functor&amp;) <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id399301-bb">invocation</link></emphasis>
&#xA0;&#xA0;<type>result_type</type> <link linkend="id316822-bb"><emphasis role="bold">operator</emphasis>()</link>(arg1_type, arg2_type, ..., argN_type) <emphasis role="bold">const</emphasis>;
};

<emphasis>// <link linkend="id253632-bb">specialized algorithms</link></emphasis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id243473">swap</link>(<link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;);

<emphasis>// <link linkend="id443814-bb">comparison operators</link></emphasis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id367263-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;, Functor);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id304156-bb"><emphasis role="bold">operator</emphasis>==</link>(Functor, <emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id307683-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id418996-bb"><emphasis role="bold">operator</emphasis>==</link>(<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> U1, <emphasis role="bold">typename</emphasis> U2, ..., <emphasis role="bold">typename</emphasis> UN, <emphasis role="bold">typename</emphasis> Allocator2&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id340873-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator1&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;U1, U2, ..., UN, Allocator2&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id273475-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;, Functor);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id345580-bb"><emphasis role="bold">operator</emphasis>!=</link>(Functor, <emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id393309-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id403770-bb"><emphasis role="bold">operator</emphasis>!=</link>(<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> U1, <emphasis role="bold">typename</emphasis> U2, ..., <emphasis role="bold">typename</emphasis> UN, <emphasis role="bold">typename</emphasis> Allocator2&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id372280-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator1&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;U1, U2, ..., UN, Allocator2&gt;&amp;);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class template <link linkend="functionN">functionN</link> is
      actually a family of related classes <link linkend="functionN">function0</link>, <link linkend="functionN">function1</link>, etc., up to some
      implementation-defined maximum. In this context, <computeroutput>N</computeroutput>
      refers to the number of parameters.</para><refsect2><title><anchor id="functionNconstruct-copy-destruct"/><computeroutput>functionN</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id383122-bb"/>functionN();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><simpara><computeroutput>this-&gt;<link linkend="id363748-bb">empty</link>()</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id319466-bb"/>functionN(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&amp; f);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><simpara>Contains a copy of the <computeroutput>f</computeroutput>'s target, if it has one, or is empty if <computeroutput>f.<link linkend="id363748-bb">empty</link>()</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw unless copying the target of <computeroutput>f</computeroutput> throws.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> F&gt; <anchor id="id325943-bb"/>functionN(F f);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara>F is a function object Callable from <computeroutput>this</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><simpara><computeroutput>*this</computeroutput> targets a copy of <computeroutput>f</computeroutput> if <computeroutput>f</computeroutput> is nonempty, or <computeroutput>this-&gt;<link linkend="id363748-bb">empty</link>()</computeroutput> if <computeroutput>f</computeroutput> is empty.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw when <computeroutput>f</computeroutput> is a stateless function object.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced">functionN&amp; <anchor id="id243506-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&amp; f);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><simpara><computeroutput>*this</computeroutput> targets a copy of <computeroutput>f</computeroutput>'s target, if it has one, or is empty if <computeroutput>f.<link linkend="id363748-bb">empty</link>()</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw when the target of <computeroutput>f</computeroutput> is a stateless function object or a reference to the function object.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id433349-bb"/>~functionN();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>If <computeroutput>!this-&gt;<link linkend="id363748-bb">empty</link>()</computeroutput>, destroys the target of this.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id363207-bb"/><computeroutput>functionN</computeroutput> modifiers</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id264499-bb"/>swap(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&amp; f);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Interchanges the targets of <computeroutput>*this</computeroutput> and <computeroutput>f</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id356064-bb"/>clear();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><simpara>this-&gt;<link linkend="id363748-bb">empty</link>()</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id218197-bb"/><computeroutput>functionN</computeroutput> capacity</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id363748-bb"/>empty() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>false</computeroutput> if <computeroutput>this</computeroutput> has a target, and <computeroutput>true</computeroutput> otherwise.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id405855-bb"/><emphasis role="bold">operator</emphasis> safe_bool() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>A <computeroutput>safe_bool</computeroutput> that evaluates <computeroutput>false</computeroutput> in a boolean context when <computeroutput>this-&gt;<link linkend="id363748-bb">empty</link>()</computeroutput>, and <computeroutput>true</computeroutput> otherwise.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id235240-bb"/><emphasis role="bold">operator</emphasis>!() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>this-&gt;<link linkend="id363748-bb">empty</link>()</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id311150-bb"/><computeroutput>functionN</computeroutput> target access</title><orderedlist><listitem><para id="id245934-bb"><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type>Functor*</type> <anchor id="id307750-bb"/>target();
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type><emphasis role="bold">const</emphasis> Functor*</type> <anchor id="id308769-bb"/>target() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>If <computeroutput>this</computeroutput> stores a target of type
        <computeroutput>Functor</computeroutput>, returns the address of the
        target. Otherwise, returns the NULL
        pointer.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type><emphasis role="bold">bool</emphasis></type> <anchor id="id355447-bb"/>contains(<emphasis role="bold">const</emphasis> Functor&amp; f) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>true</computeroutput> if <computeroutput>this-&gt;<link linkend="id245934-bb">target</link>&lt;Functor&gt;()</computeroutput> is non-NULL and <computeroutput><link linkend="function_equal">function_equal</link>(*(this-&gt;target&lt;Functor&gt;()), f)</computeroutput></simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id399301-bb"/><computeroutput>functionN</computeroutput> invocation</title><orderedlist><listitem><para><literallayout class="monospaced"><type>result_type</type> <anchor id="id316822-bb"/><emphasis role="bold">operator</emphasis>()(arg1_type a1, arg2_type a2, ... , argN_type aN) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara><computeroutput>f(a1, a2, ..., aN)</computeroutput>, where <computeroutput>f</computeroutput> is the target of <computeroutput>*this</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara>if <computeroutput>R</computeroutput> is <computeroutput>void</computeroutput>, nothing is returned; otherwise, the return value of the call to <computeroutput>f</computeroutput> is returned.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara><computeroutput><link linkend="bad_function_call">bad_function_call</link></computeroutput> if <computeroutput>!this-&gt;<link linkend="id363748-bb">empty</link>()</computeroutput>. Otherwise, may through any exception thrown by the target function <computeroutput>f</computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id253632-bb"/><computeroutput>functionN</computeroutput> specialized algorithms</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <anchor id="id243473"/>swap(<link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp; f1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp; f2);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara><computeroutput>f1.<link linkend="id264499-bb">swap</link>(f2)</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id443814-bb"/><computeroutput>functionN</computeroutput> comparison operators</title><orderedlist><listitem><para id="id364475"><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id367263-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp; f, Functor g);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id304156-bb"/><emphasis role="bold">operator</emphasis>==(Functor g, <emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp; f);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id307683-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp; f, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt; g);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id418996-bb"/><emphasis role="bold">operator</emphasis>==(<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt; g, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp; f);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> U1, <emphasis role="bold">typename</emphasis> U2, ..., <emphasis role="bold">typename</emphasis> UN, <emphasis role="bold">typename</emphasis> Allocator2&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <anchor id="id340873-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator1&gt;&amp; f1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;U1, U2, ..., UN, Allocator2&gt;&amp; f2);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>True when <computeroutput>f</computeroutput> stores an object of
        type <computeroutput>Functor</computeroutput> and one of the following conditions applies:
          <itemizedlist><listitem><simpara><computeroutput>g</computeroutput> is of type
            <computeroutput><link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;</computeroutput>
            and <computeroutput>f.target&lt;Functor&gt;() == g.<link linkend="id231874-bb">get_pointer</link>()</computeroutput>.</simpara></listitem><listitem><simpara><computeroutput>g</computeroutput> is not of type
            <computeroutput><link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;</computeroutput>
            and
            <computeroutput><link linkend="function_equal">function_equal</link>(*(f.target&lt;Functor&gt;()),
            g)</computeroutput>.</simpara></listitem></itemizedlist></simpara></listitem></varlistentry><varlistentry><term>Notes</term><listitem><simpara><computeroutput><link linkend="functionN">functionN</link></computeroutput>
        objects are not
        <link linkend="EqualityComparable">EqualityComparable</link>.</simpara></listitem></varlistentry><varlistentry><term>Rationale</term><listitem><simpara>The <computeroutput>safe_bool</computeroutput> conversion
        opens a loophole whereby two <computeroutput>functionN</computeroutput>
        instances can be compared via <computeroutput>==</computeroutput>, although this
        is not feasible to implement. The undefined <computeroutput>void
        operator==</computeroutput> closes the loophole and ensures a
        compile-time or link-time error.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para id="id370415"><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id273475-bb"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp; f, Functor g);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id345580-bb"/><emphasis role="bold">operator</emphasis>!=(Functor g, <emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp; f);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id393309-bb"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp; f, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt; g);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id403770-bb"/><emphasis role="bold">operator</emphasis>!=(<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt; g, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator&gt;&amp; f);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, <emphasis role="bold">typename</emphasis> Allocator1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> U1, <emphasis role="bold">typename</emphasis> U2, ..., <emphasis role="bold">typename</emphasis> UN, <emphasis role="bold">typename</emphasis> Allocator2&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <anchor id="id372280-bb"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;T1, T2, ..., TN, Allocator1&gt;&amp; f1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&lt;U1, U2, ..., UN, Allocator2&gt;&amp; f2);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>True when <computeroutput>f</computeroutput> does not store an
        object of type <computeroutput>Functor</computeroutput> or it stores an object of
        type <computeroutput>Functor</computeroutput> and one of the following conditions
        applies:
          <itemizedlist><listitem><simpara><computeroutput>g</computeroutput> is of type
            <computeroutput><link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;</computeroutput>
            and <computeroutput>f.target&lt;Functor&gt;() != g.<link linkend="id231874-bb">get_pointer</link>()</computeroutput>.</simpara></listitem><listitem><simpara><computeroutput>g</computeroutput> is not of type
            <computeroutput><link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;</computeroutput>
            and <computeroutput>!<link linkend="function_equal">function_equal</link>(*(f.target&lt;Functor&gt;()), g)</computeroutput>.</simpara></listitem></itemizedlist></simpara></listitem></varlistentry><varlistentry><term>Notes</term><listitem><simpara><computeroutput><link linkend="functionN">functionN</link></computeroutput>
        objects are not
        <link linkend="EqualityComparable">EqualityComparable</link>.</simpara></listitem></varlistentry><varlistentry><term>Rationale</term><listitem><simpara>The <computeroutput>safe_bool</computeroutput> conversion
        opens a loophole whereby two <computeroutput>functionN</computeroutput>
        instances can be compared via <computeroutput>!=</computeroutput>, although this
        is not feasible to implement. The undefined <computeroutput>void
        operator!=</computeroutput> closes the loophole and ensures a
        compile-time or link-time error.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="boost.function"><refmeta><refentrytitle>Class template function</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::function</refname><refpurpose>A generalized function pointer that can be used for
    callbacks or wrapping function objects.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis>  // Function type R (T1, T2, ..., TN)</emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Allocator = std::allocator&lt;<emphasis role="bold">void</emphasis>&gt; &gt; 
<emphasis role="bold">class</emphasis> function : <emphasis role="bold">public</emphasis> <link linkend="functionN">functionN</link>&lt;R, T1, T2, ..., TN, Allocator&gt; {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> R&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; result_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> Allocator allocator_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; argument_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// If N == 1</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; first_argument_type;&#xA0;  <emphasis>// If N == 2</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; second_argument_type;  <emphasis>// If N == 2</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; arg1_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; arg2_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;.
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;.
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;.
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> TN&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; argN_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// static constants</emphasis>
&#xA0;&#xA0;<emphasis role="bold">static</emphasis> <emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> arity = N;

&#xA0;&#xA0;<emphasis>// <link linkend="lambda">Lambda</link> library support</emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Args&gt; 
&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> sig {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> result_type type;
&#xA0;&#xA0;};

&#xA0;&#xA0;<emphasis>// <link linkend="boost.functionconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id318295-bb">function</link>();
&#xA0;&#xA0;<link linkend="id235217-bb">function</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&amp;);
&#xA0;&#xA0;<link linkend="id370932-bb">function</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> F&gt; <link linkend="id243601-bb">function</link>(F);
&#xA0;&#xA0;function&amp; <link linkend="id439716-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&amp;);
&#xA0;&#xA0;function&amp; <link linkend="id429940-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&amp;);
&#xA0;&#xA0;<link linkend="id262990-bb">~function</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id273706-bb">modifiers</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id270465-bb">swap</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&amp;);
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id377153-bb">clear</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id401776-bb">capacity</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id393241-bb">empty</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<link linkend="id392406-bb"><emphasis role="bold">operator</emphasis> safe_bool</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id323901-bb"><emphasis role="bold">operator</emphasis>!</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id407989-bb">target access</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type>Functor*</type> <link linkend="id252399-bb">target</link>();
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type><emphasis role="bold">const</emphasis> Functor*</type> <link linkend="id447916-bb">target</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type><emphasis role="bold">bool</emphasis></type> <link linkend="id323481-bb">contains</link>(<emphasis role="bold">const</emphasis> Functor&amp;) <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id355827-bb">invocation</link></emphasis>
&#xA0;&#xA0;<type>result_type</type> <link linkend="id308652-bb"><emphasis role="bold">operator</emphasis>()</link>(arg1_type, arg2_type, ..., argN_type) <emphasis role="bold">const</emphasis>;
};

<emphasis>// <link linkend="id372143-bb">specialized algorithms</link></emphasis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id354066">swap</link>(<link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;, <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;);

<emphasis>// <link linkend="id284910-bb">comparison operators</link></emphasis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id235870-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;, Functor);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id318513-bb"><emphasis role="bold">operator</emphasis>==</link>(Functor, <emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id262984-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id349308-bb"><emphasis role="bold">operator</emphasis>==</link>(<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature1, <emphasis role="bold">typename</emphasis> Allocator1, <emphasis role="bold">typename</emphasis> Signature2, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Allocator2&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id242840-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature1, Allocator1&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature2, Allocator2&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id256291-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;, Functor);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id428210-bb"><emphasis role="bold">operator</emphasis>!=</link>(Functor, <emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id425558-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id409074-bb"><emphasis role="bold">operator</emphasis>!=</link>(<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp;);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature1, <emphasis role="bold">typename</emphasis> Allocator1, <emphasis role="bold">typename</emphasis> Signature2, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Allocator2&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id316198-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature1, Allocator1&gt;&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature2, Allocator2&gt;&amp;);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class template <link linkend="boost.function">function</link> is a thin
      wrapper around the numbered class templates <link linkend="functionN">function0</link>, <link linkend="functionN">function1</link>, etc. It accepts a
      function type with N arguments and will will derive from
      <link linkend="functionN">functionN</link> instantiated with the arguments
      it receives.</para><para>The semantics of all operations in class template
      <link linkend="boost.function">function</link> are equivalent to that of the
      underlying <link linkend="functionN">functionN</link> object, although
      additional member functions are required to allow proper copy
      construction and copy assignment of function objects.</para><refsect2><title><anchor id="boost.functionconstruct-copy-destruct"/><computeroutput>function</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id318295-bb"/>function();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><simpara><computeroutput>this-&gt;<link linkend="id393241-bb">empty</link>()</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id235217-bb"/>function(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&amp; f);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><simpara>Contains a copy of the <computeroutput>f</computeroutput>'s target, if it has one, or is empty if <computeroutput>f.<link linkend="id393241-bb">empty</link>()</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw unless copying the target of <computeroutput>f</computeroutput> throws.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id370932-bb"/>function(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&amp; f);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><simpara>Contains a copy of the <computeroutput>f</computeroutput>'s target, if it has one, or is empty if <computeroutput>f.<link linkend="id393241-bb">empty</link>()</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw unless copying the target of <computeroutput>f</computeroutput> throws.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> F&gt; <anchor id="id243601-bb"/>function(F f);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara>F is a function object Callable from <computeroutput>this</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><simpara><computeroutput>*this</computeroutput> targets a copy of <computeroutput>f</computeroutput> if <computeroutput>f</computeroutput> is nonempty, or <computeroutput>this-&gt;<link linkend="id393241-bb">empty</link>()</computeroutput> if <computeroutput>f</computeroutput> is empty.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw when <computeroutput>f</computeroutput> is a stateless function object.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced">function&amp; <anchor id="id439716-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> <link linkend="functionN">functionN</link>&amp; f);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><simpara><computeroutput>*this</computeroutput> targets a copy of <computeroutput>f</computeroutput>'s target, if it has one, or is empty if <computeroutput>f.<link linkend="id393241-bb">empty</link>()</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw when the target of <computeroutput>f</computeroutput> is a stateless function object or a reference to the function object.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced">function&amp; <anchor id="id429940-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&amp; f);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><simpara><computeroutput>*this</computeroutput> targets a copy of <computeroutput>f</computeroutput>'s target, if it has one, or is empty if <computeroutput>f.<link linkend="id393241-bb">empty</link>()</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw when the target of <computeroutput>f</computeroutput> is a stateless function object or a reference to the function object.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id262990-bb"/>~function();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>If <computeroutput>!this-&gt;<link linkend="id393241-bb">empty</link>()</computeroutput>, destroys the target of <computeroutput>this</computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id273706-bb"/><computeroutput>function</computeroutput> modifiers</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id270465-bb"/>swap(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&amp; f);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Interchanges the targets of <computeroutput>*this</computeroutput> and <computeroutput>f</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id377153-bb"/>clear();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><simpara><computeroutput>this-&gt;<link linkend="id393241-bb">empty</link>()</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id401776-bb"/><computeroutput>function</computeroutput> capacity</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id393241-bb"/>empty() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>false</computeroutput> if <computeroutput>this</computeroutput> has a target, and <computeroutput>true</computeroutput> otherwise.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id392406-bb"/><emphasis role="bold">operator</emphasis> safe_bool() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>A <computeroutput>safe_bool</computeroutput> that evaluates <computeroutput>false</computeroutput> in a boolean context when <computeroutput>this-&gt;<link linkend="id393241-bb">empty</link>()</computeroutput>, and <computeroutput>true</computeroutput> otherwise.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id323901-bb"/><emphasis role="bold">operator</emphasis>!() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>this-&gt;<link linkend="id393241-bb">empty</link>()</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id407989-bb"/><computeroutput>function</computeroutput> target access</title><orderedlist><listitem><para id="id324276-bb"><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type>Functor*</type> <anchor id="id252399-bb"/>target();
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type><emphasis role="bold">const</emphasis> Functor*</type> <anchor id="id447916-bb"/>target() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>If <computeroutput>this</computeroutput> stores a target of type
        <computeroutput>Functor</computeroutput>, returns the address of the
        target. Otherwise, returns the NULL
        pointer.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Functor&gt; <type><emphasis role="bold">bool</emphasis></type> <anchor id="id323481-bb"/>contains(<emphasis role="bold">const</emphasis> Functor&amp; f) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>true</computeroutput> if <computeroutput>this-&gt;<link linkend="id324276-bb">target</link>&lt;Functor&gt;()</computeroutput> is non-NULL and <computeroutput><link linkend="function_equal">function_equal</link>(*(this-&gt;target&lt;Functor&gt;()), f)</computeroutput></simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id355827-bb"/><computeroutput>function</computeroutput> invocation</title><orderedlist><listitem><para><literallayout class="monospaced"><type>result_type</type> <anchor id="id308652-bb"/><emphasis role="bold">operator</emphasis>()(arg1_type a1, arg2_type a2, ... , argN_type aN) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara><computeroutput>f(a1, a2, ..., aN)</computeroutput>, where <computeroutput>f</computeroutput> is the target of <computeroutput>*this</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara>if <computeroutput>R</computeroutput> is <computeroutput>void</computeroutput>, nothing is returned; otherwise, the return value of the call to <computeroutput>f</computeroutput> is returned.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara><computeroutput><link linkend="bad_function_call">bad_function_call</link></computeroutput> if <computeroutput>!this-&gt;<link linkend="id393241-bb">empty</link>()</computeroutput>. Otherwise, may through any exception thrown by the target function <computeroutput>f</computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id372143-bb"/><computeroutput>function</computeroutput> specialized algorithms</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <anchor id="id354066"/>swap(<link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp; f1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp; f2);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara><computeroutput>f1.<link linkend="id270465-bb">swap</link>(f2)</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id284910-bb"/><computeroutput>function</computeroutput> comparison operators</title><orderedlist><listitem><para id="id346448"><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id235870-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp; f, Functor g);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id318513-bb"/><emphasis role="bold">operator</emphasis>==(Functor g, <emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp; f);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id262984-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp; f, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt; g);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id349308-bb"/><emphasis role="bold">operator</emphasis>==(<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt; g, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp; f);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature1, <emphasis role="bold">typename</emphasis> Allocator1, <emphasis role="bold">typename</emphasis> Signature2, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Allocator2&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <anchor id="id242840-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature1, Allocator1&gt;&amp; f1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature2, Allocator2&gt;&amp; f2);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>True when <computeroutput>f</computeroutput> stores an object of
        type <computeroutput>Functor</computeroutput> and one of the following conditions applies:
          <itemizedlist><listitem><simpara><computeroutput>g</computeroutput> is of type
            <computeroutput><link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;</computeroutput>
            and <computeroutput>f.target&lt;Functor&gt;() == g.<link linkend="id231874-bb">get_pointer</link>()</computeroutput>.</simpara></listitem><listitem><simpara><computeroutput>g</computeroutput> is not of type
            <computeroutput><link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;</computeroutput>
            and <computeroutput>function_equals(*(f.target&lt;Functor&gt;()), g)</computeroutput>.</simpara></listitem></itemizedlist></simpara></listitem></varlistentry><varlistentry><term>Notes</term><listitem><simpara><computeroutput><link linkend="boost.function">function</link></computeroutput>
        objects are not
        <link linkend="EqualityComparable">EqualityComparable</link>.</simpara></listitem></varlistentry><varlistentry><term>Rationale</term><listitem><simpara>The <computeroutput>safe_bool</computeroutput> conversion
        opens a loophole whereby two <computeroutput>function</computeroutput>
        instances can be compared via <computeroutput>==</computeroutput>, although this
        is not feasible to implement. The undefined <computeroutput>void
        operator==</computeroutput> closes the loophole and ensures a
        compile-time or link-time error.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para id="id370730"><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id256291-bb"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp; f, Functor g);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id428210-bb"/><emphasis role="bold">operator</emphasis>!=(Functor g, <emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp; f);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id425558-bb"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp; f, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt; g);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Allocator, <emphasis role="bold">typename</emphasis> Functor&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id409074-bb"/><emphasis role="bold">operator</emphasis>!=(<link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt; g, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature, Allocator&gt;&amp; f);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature1, <emphasis role="bold">typename</emphasis> Allocator1, <emphasis role="bold">typename</emphasis> Signature2, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Allocator2&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <anchor id="id316198-bb"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature1, Allocator1&gt;&amp; f1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.function">function</link>&lt;Signature2, Allocator2&gt;&amp; f2);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>True when <computeroutput>f</computeroutput> does not store an
        object of type <computeroutput>Functor</computeroutput> or it stores an object of
        type <computeroutput>Functor</computeroutput> and one of the following conditions
        applies:
          <itemizedlist><listitem><simpara><computeroutput>g</computeroutput> is of type
            <computeroutput><link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;</computeroutput>
            and <computeroutput>f.target&lt;Functor&gt;() != g.<link linkend="id231874-bb">get_pointer</link>()</computeroutput>.</simpara></listitem><listitem><simpara><computeroutput>g</computeroutput> is not of type
            <computeroutput><link linkend="reference_wrapper">reference_wrapper</link>&lt;Functor&gt;</computeroutput>
            and <computeroutput>!function_equals(*(f.target&lt;Functor&gt;()), g)</computeroutput>.</simpara></listitem></itemizedlist></simpara></listitem></varlistentry><varlistentry><term>Notes</term><listitem><simpara><computeroutput><link linkend="boost.function">function</link></computeroutput>
        objects are not
        <link linkend="EqualityComparable">EqualityComparable</link>.</simpara></listitem></varlistentry><varlistentry><term>Rationale</term><listitem><simpara>The <computeroutput>safe_bool</computeroutput> conversion
        opens a loophole whereby two <computeroutput>function</computeroutput>
        instances can be compared via <computeroutput>!=</computeroutput>, although this
        is not feasible to implement. The undefined <computeroutput>void
        operator!=</computeroutput> closes the loophole and ensures a
        compile-time or link-time error.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id330862"><title>Header &lt;<ulink url="../../boost/function_equal.hpp">boost/function_equal.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> F, <emphasis role="bold">typename</emphasis> G&gt; <type><emphasis role="bold">bool</emphasis></type> <link linkend="function_equal">function_equal</link>(<emphasis role="bold">const</emphasis> F&amp;, <emphasis role="bold">const</emphasis> G&amp;);
}</synopsis><refentry id="function_equal"><refmeta><refentrytitle>Function template function_equal</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::function_equal</refname><refpurpose><simpara>Compare two function objects for equality.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> F, <emphasis role="bold">typename</emphasis> G&gt; <type><emphasis role="bold">bool</emphasis></type> function_equal(<emphasis role="bold">const</emphasis> F&amp; f, <emphasis role="bold">const</emphasis> G&amp; g);</synopsis></refsynopsisdiv><refsect1><title>Description</title><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>f == g</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Only if <computeroutput>f == g</computeroutput> throws.</simpara></listitem></varlistentry></variablelist></refsect1></refentry></section></section><section id="function.faq" rev:last-revision="$Date: 2004/02/18 06:37:13 $" xml:base="../libs/function/doc/faq.xml"><title>Frequently Asked Questions</title><qandaset><qandaentry><question><para>Why can't I compare
    <link linkend="boost.function">boost::function</link> objects with
    <computeroutput>operator==</computeroutput> or
    <computeroutput>operator!=</computeroutput>?</para></question><answer><para>Comparison between <link linkend="boost.function">boost::function</link>
      objects cannot be implemented "well", and therefore will not be
      implemented. The typical semantics requested for <computeroutput>f ==
      g</computeroutput> given <link linkend="boost.function">boost::function</link> objects
      <computeroutput>f</computeroutput> and <computeroutput>g</computeroutput> are:</para><itemizedlist><listitem><simpara>If <computeroutput>f</computeroutput> and <computeroutput>g</computeroutput>
          store function objects of the same type, use that type's
          <computeroutput>operator==</computeroutput> to compare
          them.</simpara></listitem><listitem><simpara>If <computeroutput>f</computeroutput> and <computeroutput>g</computeroutput>
          store function objects of different types, return
          <computeroutput>false</computeroutput>.</simpara></listitem></itemizedlist><para>The problem occurs when the type of the function objects
      stored by both <computeroutput>f</computeroutput> and <computeroutput>g</computeroutput> doesn't have an
      <computeroutput>operator==</computeroutput>: we would like the expression <computeroutput>f ==
      g</computeroutput> to fail to compile, as occurs with, e.g., the standard
      containers. However, this is not implementable for
      <link linkend="boost.function">boost::function</link> because it necessarily
      "erases" some type information after it has been assigned a
      function object, so it cannot try to call
      <computeroutput>operator==</computeroutput> later: it must either find a way to call
      <computeroutput>operator==</computeroutput> now, or it will never be able to call it
      later. Note, for instance, what happens if you try to put a
      <computeroutput>float</computeroutput> value into a
      <link linkend="boost.function">boost::function</link> object: you will get an
      error at the assignment operator or constructor, not in
      <computeroutput>operator()</computeroutput>, because the function-call expression
      must be bound in the constructor or assignment operator.</para><para>The most promising approach is to find a method of
      determining if <computeroutput>operator==</computeroutput> can be called for a
      particular type, and then supporting it only when it is
      available; in other situations, an exception would be
      thrown. However, to date there is no known way to detect if an
      arbitrary operator expression <computeroutput>f == g</computeroutput> is suitably
      defined. The best solution known has the following undesirable
      qualities:</para><orderedlist><listitem><simpara>Fails at compile-time for objects where
        <computeroutput>operator==</computeroutput> is not accessible (e.g., because it is
        <computeroutput>private</computeroutput>).</simpara></listitem><listitem><simpara>Fails at compile-time if calling
        <computeroutput>operator==</computeroutput> is ambiguous.</simpara></listitem><listitem><simpara>Appears to be correct if the
        <computeroutput>operator==</computeroutput> declaration is correct, even though
        <computeroutput>operator==</computeroutput> may not compile.</simpara></listitem></orderedlist><para>All of these problems translate into failures in the
      <link linkend="boost.function">boost::function</link> constructors or
      assignment operator, <emphasis>even if the user never invokes
      operator==</emphasis>. We can't do that to users.</para><para>The other option is to place the burden on users that want
      to use <computeroutput>operator==</computeroutput>, e.g., by providing an
      <computeroutput>is_equality_comparable</computeroutput> trait they may
      specialize. This is a workable solution, but is dangerous in
      practice, because forgetting to specialize the trait will result
      in unexpected exceptions being thrown from
      <link linkend="boost.function">boost::function</link>'s
      <computeroutput>operator==</computeroutput>. This essentially negates the usefulness
      of <computeroutput>operator==</computeroutput> in the context in which it is most
      desired: multitarget callbacks. The
      <link linkend="signals">Signals</link> library has a way around
      this.</para></answer></qandaentry><qandaentry><question><para>I see void pointers; is this [mess] type safe?</para></question><answer><para>Yes, <computeroutput>boost::function</computeroutput> is type
safe even though it uses void pointers and pointers to functions
returning void and taking no arguments. Essentially, all type
information is encoded in the functions that manage and invoke
function pointers and function objects. Only these functions are
instantiated with the exact type that is pointed to by the void
pointer or pointer to void function. The reason that both are required
is that one may cast between void pointers and object pointers safely
or between different types of function pointers (provided you don't
invoke a function pointer with the wrong type).  </para></answer></qandaentry><qandaentry><question><para>Why are there workarounds for void returns? C++ allows them!</para></question><answer><para>Void returns are permitted by the C++ standard, as in this code snippet:
<programlisting>void f();
void g() { return f(); }</programlisting></para><para> This is a valid usage of <computeroutput>boost::function</computeroutput> because void returns are not used. With void returns, we would attempting to compile ill-formed code similar to:
<programlisting>int f();
void g() { return f(); }</programlisting></para><para> In essence, not using void returns allows
<computeroutput>boost::function</computeroutput> to swallow a return value. This is
consistent with allowing the user to assign and invoke functions and
function objects with parameters that don't exactly match.</para></answer></qandaentry><qandaentry><question><para>Why (function) cloning?</para></question><answer><para>In November and December of 2000, the issue of cloning
      vs. reference counting was debated at length and it was decided
      that cloning gave more predictable semantics. I won't rehash the
      discussion here, but if it cloning is incorrect for a particular
      application a reference-counting allocator could be used.</para></answer></qandaentry><qandaentry><question><para>How much overhead does a call through <computeroutput><link linkend="boost.function">boost::function</link></computeroutput> incur?</para></question><answer><para>The cost of <computeroutput>boost::function</computeroutput> can be reasonably
      consistently measured at around 20ns +/- 10 ns on a modern &gt;2GHz
      platform versus directly inlining the code.</para><para>However, the performance of your application may benefit
      from or be disadvantaged by <computeroutput>boost::function</computeroutput>
      depending on how your C++ optimiser optimises.  Similar to a
      standard function pointer, differences of order of 10% have been
      noted to the benefit or disadvantage of using
      <computeroutput>boost::function</computeroutput> to call a function that contains a
      tight loop depending on your compilation circumstances.</para><para>[Answer provided by Matt Hurd. See <ulink url="http://article.gmane.org/gmane.comp.lib.boost.devel/33278"/>]</para></answer></qandaentry></qandaset></section><section id="function.misc" rev:last-revision="$Date: 2003/03/12 23:27:22 $" xml:base="../libs/function/doc/misc.xml"><title>Miscellaneous Notes</title><section><title>Boost.Function vs. Function Pointers</title><para>Boost.Function has several advantages over function pointers, namely:

<itemizedlist spacing="compact"><listitem><para>Boost.Function allows arbitrary compatible function objects to be targets (instead of requiring an exact function signature).</para></listitem><listitem><para>Boost.Function may be used with argument-binding and other function object construction libraries.</para></listitem><listitem><para>Boost.Function has predictible behavior when an empty function object is called. </para></listitem></itemizedlist></para><para> And, of course, function pointers have several advantages over Boost.Function:

<itemizedlist spacing="compact"><listitem><para> Function pointers are smaller (the size of one pointer instead of three) </para></listitem><listitem><para> Function pointers are faster (Boost.Function may require two calls through function pointers) </para></listitem><listitem><para> Function pointers are backward-compatible with C libraries.</para></listitem><listitem><para> More readable error messages. </para></listitem></itemizedlist></para></section><section><title>Performance</title><section><title>Function object wrapper size</title><para> Function object wrappers will be the size of two function pointers plus one function pointer or data pointer (whichever is larger). On common 32-bit platforms, this amounts to 12 bytes per wrapper. Additionally, the function object target will be allocated on the heap.</para></section><section><title>Copying efficiency</title><para> Copying function object wrappers may require allocating memory for a copy of the function object target. The default allocator may be replaced with a faster custom allocator or one may choose to allow the function object wrappers to only store function object targets by reference (using <computeroutput>ref</computeroutput>) if the cost of this cloning becomes prohibitive.</para></section><section><title>Invocation efficiency</title><para> With a properly inlining compiler, an invocation of a function object requires one call through a function pointer. If the call is to a free function pointer, an additional call must be made to that function pointer (unless the compiler has very powerful interprocedural analysis).</para></section></section><section><title>Combatting virtual function "bloat"</title><para> The use of virtual functions tends to cause 'code bloat' on many compilers. When a class contains a virtual function, it is necessary to emit an additional function that classifies the type of the object. It has been our experience that these auxiliary functions increase the size of the executable significantly when many <computeroutput>boost::function</computeroutput> objects are used. </para><para> In Boost.Function, an alternative but equivalent approach was taken using free functions instead of virtual functions. The Boost.Function object essentially holds two pointers to make a valid target call: a void pointer to the function object it contains and a void pointer to an "invoker" that can call the function object, given the function pointer. This invoker function performs the argument and return value conversions Boost.Function provides. A third pointer points to a free function called the "manager", which handles the cloning and destruction of function objects. The scheme is typesafe because the only functions that actually handle the function object, the invoker and the manager, are instantiated given the type of the function object, so they can safely cast the incoming void pointer (the function object pointer) to the appropriate type.</para></section><section><title>Acknowledgements</title><para> Many people were involved in the construction of this
    library. William Kempf, Jesse Jones and Karl Nelson were all
    extremely helpful in isolating an interface and scope for the
    library. John Maddock managed the formal review, and many
    reviewers gave excellent comments on interface, implementation,
    and documentation. Peter Dimov led us to the function
    declarator-based syntax.</para></section></section><section id="function.testsuite"><title>Testsuite</title><section id="function.testsuite.acceptance"><title>Acceptance tests</title><informaltable><tgroup cols="3"><colspec colnum="2" colwidth="1in"/><thead><row><entry>Test</entry><entry>Type</entry><entry>Description</entry><entry>If failing...</entry></row></thead><tbody><row><entry><simpara><ulink url="../../libs/function/test/function_test.cpp">function_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test the capabilities of the <link linkend="boost.function">boost::function</link> class template.</para></entry><entry><para>The <link linkend="boost.function">boost::function</link> class template may not be usable on your compiler. However, the library may still be usable via the <link linkend="functionN">boost::functionN</link> class templates.</para></entry></row><row><entry><simpara><ulink url="../../libs/function/test/function_n_test.cpp">function_n_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test the capabilities of the <link linkend="functionN">boost::functionN</link> class templates.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/function/test/allocator_test.cpp">allocator_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test the use of custom allocators.</para></entry><entry><para>Allocators are ignored by the implementation.</para></entry></row><row><entry><simpara><ulink url="../../libs/function/test/stateless_test.cpp">stateless_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test the optimization of stateless function objects in the Boost.Function library.</para></entry><entry><para>The exception-safety and performance guarantees given for stateless function objects may not be met by the implementation.</para></entry></row><row><entry><simpara><ulink url="../../libs/function/test/lambda_test.cpp">lambda_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test the interaction between Boost.Function and Boost.Lambda.</para></entry><entry><para>Either Boost.Lambda does not work on the platform, or Boost.Function cannot safely be applied without the use of boost::unlambda.</para></entry></row><row><entry><simpara><ulink url="../../libs/function/test/contains_test.cpp">contains_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test the operation of the
    <computeroutput>target</computeroutput> member function and the
    equality operators.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/function/test/function_30.cpp">function_30.cpp</ulink></simpara></entry><entry><simpara>compile</simpara></entry><entry><para>Test the generation of a Boost.Function function object adaptor accepting 30 arguments.</para></entry><entry><para>The Boost.Function library may work for function object adaptors of up to 10 parameters, but will be unable to generate adaptors for an arbitrary number of parameters. Failure often indicates an error in the compiler's preprocessor.</para></entry></row><row><entry><simpara><ulink url="../../libs/function/test/function_arith_cxx98.cpp">function_arith_cxx98.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test the first tutorial example.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/function/test/function_arith_portable.cpp">function_arith_portable.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test the first tutorial example.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/function/test/sum_avg_cxx98.cpp">sum_avg_cxx98.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test the second tutorial example.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/function/test/sum_avg_portable.cpp">sum_avg_portable.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test the second tutorial example.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/function/test/mem_fun_cxx98.cpp">mem_fun_cxx98.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test member function example from tutorial.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/function/test/mem_fun_portable.cpp">mem_fun_portable.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test member function example from tutorial.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/function/test/std_bind_cxx98.cpp">std_bind_cxx98.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test standard binders example from tutorial.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/function/test/std_bind_portable.cpp">std_bind_portable.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test standard binders example from tutorial.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/function/test/function_ref_cxx98.cpp">function_ref_cxx98.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test <link linkend="id376299">boost::ref</link> example from tutorial.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/function/test/function_ref_portable.cpp">function_ref_portable.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test <link linkend="id376299">boost::ref</link> example from tutorial.</para></entry><entry/></row></tbody></tgroup></informaltable></section><section id="function.testsuite.negative"><title>Negative tests</title><informaltable><tgroup cols="3"><colspec colnum="2" colwidth="1in"/><thead><row><entry>Test</entry><entry>Type</entry><entry>Description</entry><entry>If failing...</entry></row></thead><tbody><row><entry><simpara><ulink url="../../libs/function/test/function_test_fail1.cpp">function_test_fail1.cpp</ulink></simpara></entry><entry><simpara>compile-fail</simpara></entry><entry><para>Test the (incorrect!) use of comparisons between Boost.Function function objects.</para></entry><entry><para>Intuitive (but incorrect!) code may compile and will give meaningless results.</para></entry></row><row><entry><simpara><ulink url="../../libs/function/test/function_test_fail2.cpp">function_test_fail2.cpp</ulink></simpara></entry><entry><simpara>compile-fail</simpara></entry><entry><para>Test the use of an incompatible function object with Boost.Function</para></entry><entry><para>Incorrect code may compile (with potentially unexpected results).</para></entry></row></tbody></tgroup></informaltable></section></section></chapter><chapter xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="lambda" rev:last-revision="$Date: 2004/11/02 05:19:02 $"><chapterinfo><author><firstname>Jaakko</firstname><surname>J&#xE4;rvi</surname><email>jarvi at cs tamu edu</email></author><copyright><year>1999</year><year>2000</year><year>2001</year><year>2002</year><year>2003</year><year>2004</year><holder>Jaakko J&#xE4;rvi</holder><holder>Gary Powell</holder></copyright><legalnotice><para>Use, modification and distribution is subject to the Boost
    Software License, Version 1.0. (See accompanying file
    <filename>LICENSE_1_0.txt</filename> or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)</para></legalnotice></chapterinfo><title>Boost.Lambda</title><section id="introduction"><title>In a nutshell</title><para>

      The Boost Lambda Library (BLL in the sequel) is a C++ template
      library, which implements form of <emphasis>lambda abstractions</emphasis> for C++.
The term originates from functional programming and lambda calculus, where a lambda abstraction defines an unnamed function.
      The primary motivation for the BLL is to provide flexible and
      convenient means to define unnamed function objects for STL algorithms.
In explaining what the library is about, a line of code says more than a thousand words; the
      following line outputs the elements of some STL container
      <literal>a</literal> separated by spaces:

      <programlisting>for_each(a.begin(), a.end(), std::cout &lt;&lt; _1 &lt;&lt; ' ');</programlisting>

      The expression <literal>std::cout &lt;&lt; _1 &lt;&lt; ' '</literal> defines a unary function object. 
      The variable <literal>_1</literal> is the parameter of this function, a <emphasis>placeholder</emphasis> for the actual argument. 
      Within each iteration of <literal>for_each</literal>, the function is
      called with an element of <literal>a</literal> as the actual argument.
      This actual argument is substituted for the placeholder, and the <quote>body</quote> of the function is evaluated.
    </para><para>The essence of BLL is letting you define small unnamed function objects, such as the one above, directly on the call site of an STL algorithm.
    </para></section><section id="lambda.getting_started"><title>Getting Started</title><section><title>Installing the library</title><para>
	The library consists of include files only, hence there is no
	installation procedure. The <literal>boost</literal> include directory
	must be on the include path.
	There are a number of include files that give different functionality:

	<itemizedlist><listitem><para><filename>lambda/lambda.hpp</filename> defines lambda expressions for different C++
	      operators, see <xref linkend="lambda.operator_expressions"/>.
	    </para></listitem><listitem><para><filename>lambda/bind.hpp</filename> defines <literal>bind</literal> functions for up to 9 arguments, see <xref linkend="lambda.bind_expressions"/>.</para></listitem><listitem><para><filename>lambda/if.hpp</filename> defines lambda function equivalents for if statements and the conditional operator, see <xref linkend="lambda.lambda_expressions_for_control_structures"/> (includes <filename>lambda.hpp</filename>).
	    </para></listitem><listitem><para><filename>lambda/loops.hpp</filename> defines lambda function equivalent for looping constructs, see <xref linkend="lambda.lambda_expressions_for_control_structures"/>.
	    </para></listitem><listitem><para><filename>lambda/switch.hpp</filename> defines lambda function equivalent for the switch statement, see <xref linkend="lambda.lambda_expressions_for_control_structures"/>.
	    </para></listitem><listitem><para><filename>lambda/construct.hpp</filename> provides tools for writing lambda expressions with constructor, destructor, new and delete invocations, see <xref linkend="lambda.construction_and_destruction"/> (includes <filename>lambda.hpp</filename>).
	    </para></listitem><listitem><para><filename>lambda/casts.hpp</filename> provides lambda versions of different casts, as well as <literal>sizeof</literal> and <literal>typeid</literal>, see <xref linkend="lambda.cast_expressions"/>.
	    </para></listitem><listitem><para><filename>lambda/exceptions.hpp</filename> gives tools for throwing and catching
	      exceptions within lambda functions, <xref linkend="lambda.exceptions"/> (includes
	      <filename>lambda.hpp</filename>).
	    </para></listitem><listitem><para><filename>lambda/algorithm.hpp</filename> and <filename>lambda/numeric.hpp</filename> (cf. standard <filename>algortihm</filename> and <filename>numeric</filename> headers) allow nested STL algorithm invocations, see <xref linkend="lambda.nested_stl_algorithms"/>.
	    </para></listitem></itemizedlist>

	Any other header files in the package are for internal use.
	Additionally, the library depends on two other Boost Libraries, the
	<emphasis>Tuple</emphasis><xref linkend="cit:boost::tuple"/> and the <emphasis>type_traits</emphasis><xref linkend="cit:boost::type_traits"/> libraries, and on the <filename>boost/ref.hpp</filename> header.
      </para><para>
	All definitions are placed in the namespace <literal>boost::lambda</literal> and its subnamespaces.
      </para></section><section><title>Conventions used in this document</title><para>In most code examples, we omit the namespace prefixes for names in the <literal moreinfo="none">std</literal> and <literal moreinfo="none">boost::lambda</literal> namespaces.
Implicit using declarations
<programlisting>
using namespace std;
using namespace boost::lambda;
</programlisting>
are assumed to be in effect.
</para></section></section><section><title>Introduction</title><section><title>Motivation</title><para>The Standard Template Library (STL)
	<xref role="citation" linkend="cit:stepanov:94"/>, now part of the C++ Standard Library <xref role="citation" linkend="cit:c++:98"/>, is a generic container and algorithm library.
Typically STL algorithms operate on container elements via <emphasis>function objects</emphasis>. These function objects are passed as arguments to the algorithms.
</para><para>
Any C++ construct that can be called with the function call syntax
is a function object. 
The STL contains predefined function objects for some common cases (such as <literal>plus</literal>, <literal>less</literal> and <literal>not1</literal>). 
As an example, one possible implementation for the standard <literal>plus</literal> template is:

<programlisting>
template &lt;class T&gt; : public binary_function&lt;T, T, T&gt;
struct plus {
  T operator()(const T&amp; i, const T&amp; j) const {
    return i + j; 
  }
};
</programlisting>

The base class <literal>binary_function&lt;T, T, T&gt;</literal> contains typedefs for the argument and return types of the function object, which are needed to make the function object <emphasis>adaptable</emphasis>.
</para><para>
In addition to the basic function object classes, such as the one above,
the STL contains <emphasis>binder</emphasis> templates for creating a unary function object from an adaptable binary function object by fixing one of the arguments to a constant value.
For example, instead of having to explicitly write a function object class like:

<programlisting>
class plus_1 {
  int _i;
public:
  plus_1(const int&amp; i) : _i(i) {}
  int operator()(const int&amp; j) { return _i + j; }
};
</programlisting>

the equivalent functionality can be achieved with the <literal moreinfo="none">plus</literal> template and one of the binder templates (<literal moreinfo="none">bind1st</literal>).
E.g., the following two expressions create function objects with identical functionalities; 
when invoked, both return the result of adding <literal moreinfo="none">1</literal> to the argument of the function object:

<programlisting>
plus_1(1)
bind1st(plus&lt;int&gt;(), 1)
</programlisting>

The subexpression <literal>plus&lt;int&gt;()</literal> in the latter line is a binary function object which computes the sum of two integers, and <literal>bind1st</literal> invokes this function object partially binding the first argument to <literal>1</literal>.
As an example of using the above function object, the following code adds <literal>1</literal> to each element of some container <literal>a</literal> and outputs the results into the standard output stream <literal>cout</literal>.

<programlisting>
transform(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout),
          bind1st(plus&lt;int&gt;(), 1));
</programlisting></para><para>
To make the binder templates more generally applicable, the STL contains <emphasis>adaptors</emphasis> for making 
pointers or references to functions, and pointers to member functions, 
adaptable.

Finally, some STL implementations contain function composition operations as
extensions to the standard <xref linkend="cit:sgi:02"/>.
      </para><para>
All these tools aim at one goal: to make it possible to specify 
<emphasis>unnamed functions</emphasis> in a call of an STL algorithm, 
in other words, to pass code fragments as an argument to a function. 

However, this goal is attained only partially.
The simple example above shows that the definition of unnamed functions 
with the standard tools is cumbersome.

Complex expressions involving functors, adaptors, binders and 
function composition operations tend to be difficult to comprehend.

In addition to this, there are significant restrictions in applying 
the standard tools. E.g. the standard binders allow only one argument 
of a binary function to be bound; there are no binders for 
3-ary, 4-ary etc. functions. 
</para><para>
The Boost Lambda Library provides solutions for the problems described above:

<itemizedlist><listitem><para>
Unnamed functions can be created easily with an intuitive syntax. 

The above example can be written as:

<programlisting>
transform(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout), 
          1 + _1);
</programlisting>

or even more intuitively:

<programlisting>
for_each(a.begin(), a.end(), cout &lt;&lt; (1 + _1));
</programlisting></para></listitem><listitem><para>
Most of the restrictions in argument binding are removed, 
arbitrary arguments of practically any C++ function can be bound.
</para></listitem><listitem><para>
Separate function composition operations are not needed, 
as function composition is supported implicitly.

</para></listitem></itemizedlist></para></section><section><title>Introduction to lambda expressions</title><para>
	Lambda expression are common in functional programming languages. 
	Their syntax varies between languages (and between different forms of lambda calculus), but the basic form of a lambda expressions is:


<programlisting>
lambda x<subscript>1</subscript> ... x<subscript>n</subscript>.e
</programlisting>

	A lambda expression defines an unnamed function and consists of:
	<itemizedlist><listitem><para>
	      the parameters of this function: <literal>x<subscript>1</subscript> ... x<subscript>n</subscript></literal>.
	      </para></listitem><listitem><para>the expression e which computes the value of the function in terms of the parameters <literal>x<subscript>1</subscript> ... x<subscript>n</subscript></literal>.
	    </para></listitem></itemizedlist>

	A simple example of a lambda expression is 
<programlisting>
lambda x y.x+y
</programlisting>
Applying the lambda function means substituting the formal parameters with the actual arguments:
<programlisting>
(lambda x y.x+y) 2 3 = 2 + 3 = 5 
</programlisting></para><para>
In the C++ version of lambda expressions the <literal>lambda x<subscript>1</subscript> ... x<subscript>n</subscript></literal> part is missing and the formal parameters have predefined names.
In the current version of the library, 
there are three such predefined formal parameters, 
called <emphasis>placeholders</emphasis>: 
<literal>_1</literal>, <literal>_2</literal> and <literal>_3</literal>. 
They refer to the first, second and third argument of the function defined 
by the lambda expression.
	
For example, the C++ version of the definition
<programlisting>lambda x y.x+y</programlisting>
is 
<programlisting>_1 + _2</programlisting></para><para>
Hence, there is no syntactic keyword for C++ lambda expressions. 
	The use of a placeholder as an operand implies that the operator invocation is a lambda expression.
	However, this is true only for operator invocations.
	Lambda expressions containing function calls, control structures, casts etc. require special syntactic constructs. 
	Most importantly, function calls need to be wrapped inside a <literal>bind</literal> function. 

	As an example, consider the lambda expression:

	<programlisting>lambda x y.foo(x,y)</programlisting>

	Rather than <literal>foo(_1, _2)</literal>, the C++ counterpart for this expression is:

	<programlisting>bind(foo, _1, _2)</programlisting>

	We refer to this type of C++ lambda expressions as <emphasis>bind expressions</emphasis>. 
      </para><para>A lambda expression defines a C++ function object, hence function application syntax is like calling any other function object, for instance: <literal>(_1 + _2)(i, j)</literal>.


      </para><section id="lambda.partial_function_application"><title>Partial function application</title><para>
A bind expression is in effect a <emphasis>partial function application</emphasis>.
In partial function application, some of the arguments of a function are bound to fixed values. 
	  The result is another function, with possibly fewer arguments. 
	  When called with the unbound arguments, this new function invokes the original function with the merged argument list of bound and unbound arguments.
	</para></section><section id="lambda.terminology"><title>Terminology</title><para>
	  A lambda expression defines a function. A C++ lambda expression concretely constructs a function object, <emphasis>a functor</emphasis>, when evaluated. We use the name <emphasis>lambda functor</emphasis> to refer to such a function object. 
	  Hence, in the terminology adopted here, the result of evaluating a lambda expression is a lambda functor.
	</para></section></section></section><section id="lambda.using_library"><title>Using the library</title><para>
The purpose of this section is to introduce the basic functionality of the library.
There are quite a lot of exceptions and special cases, but discussion of them is postponed until later sections.


    </para><section id="lambda.introductory_examples"><title>Introductory Examples</title><para>
	In this section we give basic examples of using BLL lambda expressions in STL algorithm invocations. 
	We start with some simple expressions and work up. 
	First, we initialize the elements of a container, say, a <literal>list</literal>, to the value <literal>1</literal>:


	<programlisting>
list&lt;int&gt; v(10);
for_each(v.begin(), v.end(), _1 = 1);</programlisting>

	The expression <literal>_1 = 1</literal> creates a lambda functor which assigns the value <literal>1</literal> to every element in <literal>v</literal>.<footnote><para>
Strictly taken, the C++ standard defines <literal>for_each</literal> as a <emphasis>non-modifying sequence operation</emphasis>, and the function object passed to <literal moreinfo="none">for_each</literal> should not modify its argument. 
The requirements for the arguments of <literal>for_each</literal> are unnecessary strict, since as long as the iterators are <emphasis>mutable</emphasis>, <literal>for_each</literal> accepts a function object that can have side-effects on their argument.
Nevertheless, it is straightforward to provide another function template with the functionality of<literal>std::for_each</literal> but more fine-grained requirements for its arguments.
</para></footnote></para><para>
	Next, we create a container of pointers and make them point to the elements in the first container <literal>v</literal>:

	<programlisting>
vector&lt;int*&gt; vp(10); 
transform(v.begin(), v.end(), vp.begin(), &amp;_1);</programlisting>

The expression <literal>&amp;_1</literal> creates a function object for getting the address of each element in <literal>v</literal>.
The addresses get assigned to the corresponding elements in <literal>vp</literal>.
      </para><para>
	The next code fragment changes the values in <literal>v</literal>. 
	For each element, the function <literal>foo</literal> is called. 
The original value of the element is passed as an argument to <literal>foo</literal>.
The result of <literal>foo</literal> is assigned back to the element:


	<programlisting>
int foo(int);
for_each(v.begin(), v.end(), _1 = bind(foo, _1));</programlisting></para><para>
	The next step is to sort the elements of <literal>vp</literal>:
	
	<programlisting>sort(vp.begin(), vp.end(), *_1 &gt; *_2);</programlisting>

	In this call to <literal>sort</literal>, we are sorting the elements by their contents in descending order. 
      </para><para>
	Finally, the following <literal>for_each</literal> call outputs the sorted content of <literal>vp</literal> separated by line breaks:

<programlisting>
for_each(vp.begin(), vp.end(), cout &lt;&lt; *_1 &lt;&lt; '\n');
</programlisting>

Note that a normal (non-lambda) expression as subexpression of a lambda expression is evaluated immediately.  
This may cause surprises. 
For instance, if the previous example is rewritten as
<programlisting>
for_each(vp.begin(), vp.end(), cout &lt;&lt; '\n' &lt;&lt; *_1);
</programlisting>
the subexpression <literal>cout &lt;&lt; '\n'</literal> is evaluated immediately and the effect is to output a single line break, followed by the elements of <literal>vp</literal>.
The BLL provides functions <literal>constant</literal> and <literal>var</literal> to turn constants and, respectively, variables into lambda expressions, and can be used to prevent the immediate evaluation of subexpressions:
<programlisting>
for_each(vp.begin(), vp.end(), cout &lt;&lt; constant('\n') &lt;&lt; *_1);
</programlisting>
These functions are described more thoroughly in <xref linkend="lambda.delaying_constants_and_variables"/></para></section><section id="lambda.parameter_and_return_types"><title>Parameter and return types of lambda functors</title><para>
	During the invocation of a lambda functor, the actual arguments are substituted for the placeholders. 
	The placeholders do not dictate the type of these actual arguments.
	The basic rule is that a lambda function can be called with arguments of any types, as long as the lambda expression with substitutions performed is a valid C++ expression. 
	As an example, the expression
	<literal>_1 + _2</literal> creates a binary lambda functor. 
	It can be called with two objects of any types <literal>A</literal> and <literal>B</literal> for which <literal>operator+(A,B)</literal> is defined (and for which BLL knows the return type of the operator, see below).
      </para><para>
	C++ lacks a mechanism to query a type of an expression. 
	However, this precise mechanism is crucial for the implementation of C++ lambda expressions.
	Consequently, BLL includes a somewhat complex type deduction system which uses a set of traits classes for deducing the resulting type of lambda functions.
	It handles expressions where the operands are of built-in types and many of the expressions with operands of standard library types.
	Many of the user defined types are covered as well, particularly if the user defined operators obey normal conventions in defining the return types. 
      </para><para>
	There are, however, cases when the return type cannot be deduced. For example, suppose you have defined:

	<programlisting>C operator+(A, B);</programlisting>

	The following lambda function invocation fails, since the return type cannot be deduced:

	<programlisting>A a; B b; (_1 + _2)(a, b);</programlisting></para><para>
	There are two alternative solutions to this. 
	The first is to extend the BLL type deduction system to cover your own types (see <xref linkend="lambda.extending"/>). 
	The second is to use a special lambda expression (<literal>ret</literal>) which defines the return type in place (see <xref linkend="lambda.overriding_deduced_return_type"/>):

	<programlisting>A a; B b; ret&lt;C&gt;(_1 + _2)(a, b);</programlisting></para><para>
	For bind expressions, the return type can be defined as a template argument of the bind function as well: 
	<programlisting>bind&lt;int&gt;(foo, _1, _2);</programlisting></para></section><section id="lambda.actual_arguments_to_lambda_functors"><title>About actual arguments to lambda functors</title><para>A general restriction for the actual arguments is that they cannot be non-const rvalues. 
	For example:

<programlisting>
int i = 1; int j = 2; 
(_1 + _2)(i, j); // ok
(_1 + _2)(1, 2); // error (!)
</programlisting>

	This restriction is not as bad as it may look. 
	Since the lambda functors are most often called inside STL-algorithms, 
	the arguments originate from dereferencing iterators and the dereferencing operators seldom return rvalues.
	And for the cases where they do, there are workarounds discussed in 
<xref linkend="lambda.rvalues_as_actual_arguments"/>.


      </para></section><section id="lambda.storing_bound_arguments"><title>Storing bound arguments in lambda functions</title><para>

By default, temporary const copies of the bound arguments are stored 
in the lambda functor.

This means that the value of a bound argument is fixed at the time of the 
creation of the lambda function and remains constant during the lifetime 
of the lambda function object.
For example:
<programlisting>
int i = 1;
(_1 = 2, _1 + i)(i);
</programlisting>
The comma operator is overloaded to combine lambda expressions into a sequence;
the resulting unary lambda functor first assigns 2 to its argument, 
then adds the value of <literal>i</literal> to it.
The value of the expression in the last line is 3, not 4. 
In other words, the lambda expression that is created is
<literal>lambda x.(x = 2, x + 1)</literal> rather than
<literal>lambda x.(x = 2, x + i)</literal>.
      
</para><para>

As said, this is the default behavior for which there are exceptions.
The exact rules are as follows:

<itemizedlist><listitem><para>

The programmer can control the storing mechanism with <literal>ref</literal> 
and <literal>cref</literal> wrappers <xref linkend="cit:boost::ref"/>.

Wrapping an argument with <literal>ref</literal>, or <literal>cref</literal>, 
instructs the library to store the argument as a reference, 
or as a reference to const respectively.

For example, if we rewrite the previous example and wrap the variable 
<literal>i</literal> with <literal>ref</literal>, 
we are creating the lambda expression <literal>lambda x.(x = 2, x + i)</literal> 
and the value of the expression in the last line will be 4:

<programlisting>
i = 1;
(_1 = 2, _1 + ref(i))(i);
</programlisting>

Note that <literal>ref</literal> and <literal>cref</literal> are different
from <literal>var</literal> and <literal>constant</literal>.

While the latter ones create lambda functors, the former do not. 
For example:

<programlisting>
int i; 
var(i) = 1; // ok
ref(i) = 1; // not ok, ref(i) is not a lambda functor
</programlisting>

The functions <literal>ref</literal> and <literal>cref</literal> mostly 
exist for historical reasons,
and <literal>ref</literal> can always
be replaced with <literal>var</literal>, and <literal>cref</literal> with
<literal>constant_ref</literal>. 
See <xref linkend="lambda.delaying_constants_and_variables"/> for details.
The <literal>ref</literal> and <literal>cref</literal> functions are
general purpose utility functions in Boost, and hence defined directly
in the <literal moreinfo="none">boost</literal> namespace.

</para></listitem><listitem><para>
Array types cannot be copied, they are thus stored as const reference by default.
</para></listitem><listitem><para> 
For some expressions it makes more sense to store the arguments as references. 

For example, the obvious intention of the lambda expression 
<literal>i += _1</literal> is that calls to the lambda functor affect the 
value of the variable <literal>i</literal>, 
rather than some temporary copy of it. 

As another example, the streaming operators take their leftmost argument 
as non-const references. 

The exact rules are:

<itemizedlist><listitem><para>The left argument of compound assignment operators (<literal>+=</literal>, <literal>*=</literal>, etc.) are stored as references to non-const.</para></listitem><listitem><para>If the left argument of <literal>&lt;&lt;</literal> or <literal>&gt;&gt;</literal>  operator is derived from an instantiation of <literal>basic_ostream</literal> or respectively from <literal>basic_istream</literal>, the argument is stored as a reference to non-const. 
For all other types, the argument is stored as a copy.
</para></listitem><listitem><para>
In pointer arithmetic expressions, non-const array types are stored as non-const references.
This is to prevent pointer arithmetic making non-const arrays const. 

</para></listitem></itemizedlist></para></listitem></itemizedlist></para></section></section><section id="lambda.le_in_details"><title>Lambda expressions in details</title><para>
This section describes different categories of lambda expressions in details.
We devote a separate section for each of the possible forms of a lambda expression.


</para><section id="lambda.placeholders"><title>Placeholders</title><para>
The BLL defines three placeholder types: <literal>placeholder1_type</literal>, <literal>placeholder2_type</literal> and <literal>placeholder3_type</literal>. 
BLL has a predefined placeholder variable for each placeholder type: <literal>_1</literal>, <literal>_2</literal> and <literal>_3</literal>. 
However, the user is not forced to use these placeholders. 
It is easy to define placeholders with alternative names.
This is done by defining new variables of placeholder types. 
For example:

<programlisting>boost::lambda::placeholder1_type X;
boost::lambda::placeholder2_type Y;
boost::lambda::placeholder3_type Z;
</programlisting>

With these variables defined, <literal>X += Y * Z</literal> is equivalent to <literal>_1 += _2 * _3</literal>.
</para><para>
The use of placeholders in the lambda expression determines whether the resulting function is nullary, unary, binary or 3-ary. 
The highest placeholder index is decisive. For example:

<programlisting>
_1 + 5              // unary
_1 * _1 + _1        // unary
_1 + _2             // binary
bind(f, _1, _2, _3) // 3-ary
_3 + 10             // 3-ary
</programlisting>

Note that the last line creates a 3-ary function, which adds <literal>10</literal> to its <emphasis>third</emphasis> argument. 
The first two arguments are discarded.
Furthermore, lambda functors only have a minimum arity.
One can always provide more arguments (up the number of supported placeholders)
that is really needed.
The remaining arguments are just discarded.
For example:

<programlisting>
int i, j, k; 
_1(i, j, k)        // returns i, discards j and k
(_2 + _2)(i, j, k) // returns j+j, discards i and k
</programlisting>

See
<xref linkend="lambda.why_weak_arity"/> for the design rationale behind this
functionality.

</para><para>
In addition to these three placeholder types, there is also a fourth placeholder type <literal>placeholderE_type</literal>.
The use of this placeholder is defined in <xref linkend="lambda.exceptions"/> describing exception handling in lambda expressions. 
</para><para>When an actual argument is supplied for a placeholder, the parameter passing mode is always by reference. 
This means that any side-effects to the placeholder are reflected to the actual argument. 
For example:


<programlisting>
int i = 1; 
(_1 += 2)(i);         // i is now 3
(++_1, cout &lt;&lt; _1)(i) // i is now 4, outputs 4
</programlisting></para></section><section id="lambda.operator_expressions"><title>Operator expressions</title><para>
The basic rule is that any C++ operator invocation with at least one argument being a lambda expression is itself a lambda expression.
Almost all overloadable operators are supported. 
For example, the following is a valid lambda expression:

<programlisting>cout &lt;&lt; _1, _2[_3] = _1 &amp;&amp; false</programlisting></para><para>
However, there are some restrictions that originate from the C++ operator overloading rules, and some special cases.
</para><section><title>Operators that cannot be overloaded</title><para>
Some operators cannot be overloaded at all (<literal>::</literal>, <literal>.</literal>, <literal>.*</literal>).
For some operators, the requirements on return types prevent them to be overloaded to create lambda functors.
These operators are <literal>-&gt;.</literal>, <literal>-&gt;</literal>, <literal>new</literal>, <literal>new[]</literal>, <literal>delete</literal>, <literal>delete[]</literal> and <literal>?:</literal> (the conditional operator).
</para></section><section id="lambda.assignment_and_subscript"><title>Assignment and subscript operators</title><para>
These operators must be implemented as class members. 
Consequently, the left operand must be a lambda expression. For example:

<programlisting>
int i; 
_1 = i;      // ok
i = _1;      // not ok. i is not a lambda expression
</programlisting>

There is a simple solution around this limitation, described in <xref linkend="lambda.delaying_constants_and_variables"/>.
In short, 
the left hand argument can be explicitly turned into a lambda functor by wrapping it with a special <literal>var</literal> function:
<programlisting>
var(i) = _1; // ok
</programlisting></para></section><section id="lambda.logical_operators"><title>Logical operators</title><para>
Logical operators obey the short-circuiting evaluation rules. For example, in the following code, <literal>i</literal> is never incremented:
<programlisting>
bool flag = true; int i = 0;
(_1 || ++_2)(flag, i);
</programlisting></para></section><section id="lambda.comma_operator"><title>Comma operator</title><para>
Comma operator is the <quote>statement separator</quote> in lambda expressions. 
Since comma is also the separator between arguments in a function call, extra parenthesis are sometimes needed:

<programlisting>
for_each(a.begin(), a.end(), (++_1, cout &lt;&lt; _1));
</programlisting>

Without the extra parenthesis around <literal>++_1, cout &lt;&lt; _1</literal>, the code would be interpreted as an attempt to call <literal>for_each</literal> with four arguments.
</para><para>
The lambda functor created by the comma operator adheres to the C++ rule of always evaluating the left operand before the right one.
In the above example, each element of <literal>a</literal> is first incremented, then written to the stream.
</para></section><section id="lambda.function_call_operator"><title>Function call operator</title><para>
The function call operators have the effect of evaluating the lambda
functor. 
Calls with too few arguments lead to a compile time error.
</para></section><section id="lambda.member_pointer_operator"><title>Member pointer operator</title><para>
The member pointer operator <literal>operator-&gt;*</literal> can be overloaded freely. 
Hence, for user defined types, member pointer operator is no special case.
The built-in meaning, however, is a somewhat more complicated case.
The built-in member pointer operator is applied if the left argument is a pointer to an object of some class <literal>A</literal>, and the right hand argument is a pointer to a member of <literal>A</literal>, or a pointer to a member of a class from which <literal>A</literal> derives.
We must separate two cases:

<itemizedlist><listitem><para>The right hand argument is a pointer to a data member. 
In this case the lambda functor simply performs the argument substitution and calls the built-in member pointer operator, which returns a reference to the member pointed to. 
For example:
<programlisting>
struct A { int d; };
A* a = new A();
  ...
(a -&gt;* &amp;A::d);     // returns a reference to a-&gt;d 
(_1 -&gt;* &amp;A::d)(a); // likewise
</programlisting></para></listitem><listitem><para>
The right hand argument is a pointer to a member function.
For a built-in call like this, the result is kind of a delayed member function call. 
Such an expression must be followed by a function argument list, with which the delayed member function call is performed.
For example:
<programlisting>
struct B { int foo(int); };
B* b = new B();
  ...
(b -&gt;* &amp;B::foo)         // returns a delayed call to b-&gt;foo
                        // a function argument list must follow
(b -&gt;* &amp;B::foo)(1)      // ok, calls b-&gt;foo(1)

(_1 -&gt;* &amp;B::foo)(b);    // returns a delayed call to b-&gt;foo, 
                        // no effect as such
(_1 -&gt;* &amp;B::foo)(b)(1); // calls b-&gt;foo(1)
</programlisting></para></listitem></itemizedlist></para></section></section><section id="lambda.bind_expressions"><title>Bind expressions</title><para>
Bind expressions can have two forms: 

<programlisting>
bind(<parameter>target-function</parameter>, <parameter>bind-argument-list</parameter>)
bind(<parameter>target-member-function</parameter>, <parameter>object-argument</parameter>, <parameter>bind-argument-list</parameter>)
</programlisting>

A bind expression delays the call of a function. 
If this <emphasis>target function</emphasis> is <emphasis>n</emphasis>-ary, then the <literal><emphasis>bind-argument-list</emphasis></literal> must contain <emphasis>n</emphasis> arguments as well.
In the current version of the BLL, <inlineequation>0 &lt;= n &lt;= 9</inlineequation> must hold. 
For member functions, the number of arguments must be at most <inlineequation>8</inlineequation>, as the object argument takes one argument position.

Basically, the
<emphasis><literal>bind-argument-list</literal></emphasis> must be a valid argument list for the target function, except that any argument can be replaced with a placeholder, or more generally, with a lambda expression. 
Note that also the target function can be a lambda expression.

The result of a bind expression is either a nullary, unary, binary or 3-ary function object depending on the use of placeholders in the <emphasis><literal>bind-argument-list</literal></emphasis> (see <xref linkend="lambda.placeholders"/>).
</para><para>
The return type of the lambda functor created by the bind expression can be given as an explicitly specified template parameter, as in the following example:
<programlisting>
bind&lt;<emphasis>RET</emphasis>&gt;(<emphasis>target-function</emphasis>, <emphasis>bind-argument-list</emphasis>)
</programlisting>
This is only necessary if the return type of the target function cannot be deduced.
</para><para>
The following sections describe the different types of bind expressions.
</para><section id="lambda.function_pointers_as_targets"><title>Function pointers or references as targets</title><para>The target function can be a pointer or a reference to a function and it can be either bound or unbound. For example:
<programlisting>
X foo(A, B, C); A a; B b; C c;
bind(foo, _1, _2, c)(a, b);
bind(&amp;foo, _1, _2, c)(a, b);
bind(_1, a, b, c)(foo);
</programlisting>
 
The return type deduction always succeeds with this type of bind expressions. 
</para><para>
Note, that in C++ it is possible to take the address of an overloaded function only if the address is assigned to, or used as an initializer of, a variable, the type of which solves the amibiguity, or if an explicit cast expression is used.
This means that overloaded functions cannot be used in bind expressions directly, e.g.:
<programlisting>
void foo(int);
void foo(float);
int i; 
  ...
bind(&amp;foo, _1)(i);                            // error 
  ...
void (*pf1)(int) = &amp;foo;
bind(pf1, _1)(i);                             // ok
bind(static_cast&lt;void(*)(int)&gt;(&amp;foo), _1)(i); // ok
</programlisting></para></section><section id="member_functions_as_targets"><title>Member functions as targets</title><para>
The syntax for using pointers to member function in bind expression is:
<programlisting>
bind(<parameter>target-member-function</parameter>, <parameter>object-argument</parameter>, <parameter>bind-argument-list</parameter>)
</programlisting>

The object argument can be a reference or pointer to the object, the BLL supports both cases with a uniform interface: 

<programlisting>
bool A::foo(int) const; 
A a;
vector&lt;int&gt; ints; 
  ...
find_if(ints.begin(), ints.end(), bind(&amp;A::foo, a, _1)); 
find_if(ints.begin(), ints.end(), bind(&amp;A::foo, &amp;a, _1));
</programlisting>

Similarly, if the object argument is unbound, the resulting lambda functor can be called both via a pointer or a reference:

<programlisting>
bool A::foo(int); 
list&lt;A&gt; refs; 
list&lt;A*&gt; pointers; 
  ...
find_if(refs.begin(), refs.end(), bind(&amp;A::foo, _1, 1)); 
find_if(pointers.begin(), pointers.end(), bind(&amp;A::foo, _1, 1));
</programlisting></para><para>
Even though the interfaces are the same, there are important semantic differences between using a pointer or a reference as the object argument.
The differences stem from the way <literal>bind</literal>-functions take their parameters, and how the bound parameters are stored within the lambda functor.
The object argument has the same parameter passing and storing mechanism as any other bind argument slot (see <xref linkend="lambda.storing_bound_arguments"/>); it is passed as a const reference and stored as a const copy in the lambda functor.
This creates some asymmetry between the lambda functor and the original member function, and between seemingly similar lambda functors. For example:
<programlisting>
class A {
  int i; mutable int j;
public:

  A(int ii, int jj) : i(ii), j(jj) {};
  void set_i(int x) { i = x; }; 
  void set_j(int x) const { j = x; }; 
};
</programlisting>

When a pointer is used, the behavior is what the programmer might expect:

<programlisting>
A a(0,0); int k = 1;
bind(&amp;A::set_i, &amp;a, _1)(k); // a.i == 1
bind(&amp;A::set_j, &amp;a, _1)(k); // a.j == 1
</programlisting>

Even though a const copy of the object argument is stored, the original object <literal>a</literal> is still modified.
This is since the object argument is a pointer, and the pointer is copied, not the object it points to.
When we use a reference, the behaviour is different:

<programlisting>
A a(0,0); int k = 1;
bind(&amp;A::set_i, a, _1)(k); // error; a const copy of a is stored. 
                           // Cannot call a non-const function set_i
bind(&amp;A::set_j, a, _1)(k); // a.j == 0, as a copy of a is modified
</programlisting></para><para>
To prevent the copying from taking place, one can use the <literal>ref</literal> or <literal>cref</literal> wrappers (<literal>var</literal> and <literal>constant_ref</literal> would do as well):
<programlisting>
bind(&amp;A::set_i, ref(a), _1)(k); // a.j == 1
bind(&amp;A::set_j, cref(a), _1)(k); // a.j == 1
</programlisting></para><para>Note that the preceding discussion is relevant only for bound arguments. 
If the object argument is unbound, the parameter passing mode is always by reference. 
Hence, the argument <literal>a</literal> is not copied in the calls to the two lambda functors below:
<programlisting>
A a(0,0);
bind(&amp;A::set_i, _1, 1)(a); // a.i == 1
bind(&amp;A::set_j, _1, 1)(a); // a.j == 1
</programlisting></para></section><section id="lambda.members_variables_as_targets"><title>Member variables as targets</title><para>
A pointer to a member variable is not really a function, but 
the first argument to the <literal>bind</literal> function can nevertheless
be a pointer to a member variable.
Invoking such a bind expression returns a reference to the data member.
For example:

<programlisting>
struct A { int data; };
A a;
bind(&amp;A::data, _1)(a) = 1;     // a.data == 1
</programlisting>

The cv-qualifiers of the object whose member is accessed are respected.
For example, the following tries to write into a const location:
<programlisting>
const A ca = a;
bind(&amp;A::data, _1)(ca) = 1;     // error
</programlisting></para></section><section id="lambda.function_objects_as_targets"><title>Function objects as targets</title><para>

Function objects, that is, class objects which have the function call 
operator defined, can be used as target functions. 

In general, BLL cannot deduce the return type of an arbitrary function object. 

However, there are two methods for giving BLL this capability for a certain 
function object class.

</para><simplesect><title>The result_type typedef</title><para>

The BLL supports the standard library convention of declaring the return type
of a function object with a member typedef named <literal>result_type</literal> in the
function object class.

Here is a simple example:
<programlisting>
struct A {
  typedef B result_type;
  B operator()(X, Y, Z); 
};
</programlisting>

If a function object does not define a <literal>result_type</literal> typedef, 
the method described below (<literal>sig</literal> template) 
is attempted to resolve the return type of the
function object. If a function object defines both <literal>result_type</literal>
and <literal>sig</literal>, <literal>result_type</literal> takes precedence.

</para></simplesect><simplesect><title>The sig template</title><para>
Another mechanism that make BLL aware of the return type(s) of a function object is defining
member template struct 
<literal>sig&lt;Args&gt;</literal> with a typedef 
<literal>type</literal> that specifies the return type.

Here is a simple example:
<programlisting>
struct A {
  template &lt;class Args&gt; struct sig { typedef B type; }
  B operator()(X, Y, Z); 
};
</programlisting>

The template argument <literal>Args</literal> is a 
<literal>tuple</literal> (or more precisely a <literal>cons</literal> list) 
type <xref linkend="cit:boost::tuple"/>, where the first element 
is the function 
object type itself, and the remaining elements are the types of 
the arguments, with which the function object is being called.

This may seem overly complex compared to defining the <literal>result_type</literal> typedef.
Howver, there are two significant restrictions with using just a simple
typedef to express the return type:
<orderedlist><listitem><para>
If the function object defines several function call operators, there is no way to specify different result types for them.
</para></listitem><listitem><para>
If the function call operator is a template, the result type may 
depend on the template parameters. 
Hence, the typedef ought to be a template too, which the C++ language 
does not support.
</para></listitem></orderedlist>

The following code shows an example, where the return type depends on the type
of one of the arguments, and how that dependency can be expressed with the
<literal>sig</literal> template:

<programlisting>
struct A {

  // the return type equals the third argument type:
  template&lt;class T1, class T2, class T3&gt;
  T3 operator()(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3) const;

  template &lt;class Args&gt; 
  class sig {
    // get the third argument type (4th element)
    typedef typename 
      boost::tuples::element&lt;3, Args&gt;::type T3;
  public:
    typedef typename 
      boost::remove_cv&lt;T3&gt;::type type;
  };
};
</programlisting>


The elements of the <literal>Args</literal> tuple are always 
non-reference types.

Moreover, the element types can have a const or volatile qualifier
(jointly referred to as <emphasis>cv-qualifiers</emphasis>), or both.
This is since the cv-qualifiers in the arguments can affect the return type.
The reason for including the potentially cv-qualified function object 
type itself into the <literal>Args</literal> tuple, is that the function
object class can contain both const and non-const (or volatile, even
const volatile) function call operators, and they can each have a different
return type.
</para><para>
The <literal>sig</literal> template can be seen as a 
<emphasis>meta-function</emphasis> that maps the argument type tuple to 
the result type of the call made with arguments of the types in the tuple.

As the example above demonstrates, the template can end up being somewhat 
complex.
Typical tasks to be performed are the extraction of the relevant types 
from the tuple, removing cv-qualifiers etc.
See the Boost type_traits <xref linkend="cit:boost::type_traits"/> and
Tuple <xref linkend="cit:boost::type_traits"/> libraries 
for tools that can aid in these tasks.
The <literal>sig</literal> templates are a refined version of a similar
mechanism first introduced in the FC++ library  
<xref linkend="cit:fc++"/>.
</para></simplesect></section></section><section id="lambda.overriding_deduced_return_type"><title>Overriding the deduced return type</title><para>
The return type deduction system may not be able to deduce the return types of some user defined operators or bind expressions with class objects.

A special lambda expression type is provided for stating the return type explicitly and overriding the deduction system. 
To state that the return type of the lambda functor defined by the lambda expression <literal>e</literal> is <literal>T</literal>, you can write:

<programlisting>ret&lt;T&gt;(e);</programlisting>

The effect is that the return type deduction is not performed for the lambda expression <literal>e</literal> at all, but instead, <literal>T</literal> is used as the return type. 
Obviously <literal>T</literal> cannot be an arbitrary type, the true result of the lambda functor must be implicitly convertible to <literal>T</literal>. 
For example:

<programlisting>
A a; B b;
C operator+(A, B);
int operator*(A, B); 
  ...
ret&lt;D&gt;(_1 + _2)(a, b);     // error (C cannot be converted to D)
ret&lt;C&gt;(_1 + _2)(a, b);     // ok
ret&lt;float&gt;(_1 * _2)(a, b); // ok (int can be converted to float)
  ...
struct X {
  Y operator(int)();   
};
  ...
X x; int i;
bind(x, _1)(i);            // error, return type cannot be deduced
ret&lt;Y&gt;(bind(x, _1))(i);    // ok
</programlisting>
For bind expressions, there is a short-hand notation that can be used instead of <literal>ret</literal>. 
The last line could alternatively be written as:

<programlisting>bind&lt;Z&gt;(x, _1)(i);</programlisting>
This feature is modeled after the Boost Bind library <xref linkend="cit:boost::bind"/>.

</para><para>Note that within nested lambda expressions, 
the <literal>ret</literal> must be used at each subexpression where 
the deduction would otherwise fail. 
For example:
<programlisting>
A a; B b;
C operator+(A, B); D operator-(C);
  ...
ret&lt;D&gt;( - (_1 + _2))(a, b); // error 
ret&lt;D&gt;( - ret&lt;C&gt;(_1 + _2))(a, b); // ok
</programlisting></para><para>If you find yourself using  <literal>ret</literal> repeatedly with the same types, it is worth while extending the return type deduction (see <xref linkend="lambda.extending"/>).
</para><section id="lambda.nullary_functors_and_ret"><title>Nullary lambda functors and ret</title><para>
As stated above, the effect of <literal>ret</literal> is to prevent the return type deduction to be performed. 
However, there is an exception. 
Due to the way the C++ template instantiation works, the compiler is always forced to instantiate the return type deduction templates for zero-argument lambda functors.
This introduces a slight problem with <literal>ret</literal>, best described with an example:

<programlisting>
struct F { int operator()(int i) const; }; 
F f;
  ...
bind(f, _1);           // fails, cannot deduce the return type
ret&lt;int&gt;(bind(f, _1)); // ok
  ...
bind(f, 1);            // fails, cannot deduce the return type
ret&lt;int&gt;(bind(f, 1));  // fails as well!
</programlisting>
The BLL cannot deduce the return types of the above bind calls, as <literal>F</literal> does not define the typedef <literal>result_type</literal>. 
One would expect <literal>ret</literal> to fix this, but for the nullary lambda functor that results from a bind expression (last line above) this does not work.
The return type deduction templates are instantiated, even though it would not be necessary and the result is a compilation error.
</para><para>The solution to this is not to use the <literal>ret</literal> function, but rather define the return type as an explicitly specified template parameter in the <literal>bind</literal> call:
<programlisting>
bind&lt;int&gt;(f, 1);       // ok
</programlisting>

The lambda functors created with 
<literal>ret&lt;<parameter>T</parameter>&gt;(bind(<parameter>arg-list</parameter>))</literal> and 
<literal>bind&lt;<parameter>T</parameter>&gt;(<parameter>arg-list</parameter>)</literal> have the exact same functionality &#x2014;
apart from the fact that for some nullary lambda functors the former does not work while the latter does. 
</para></section></section><section id="lambda.delaying_constants_and_variables"><title>Delaying constants and variables</title><para>
The unary functions <literal>constant</literal>,
<literal>constant_ref</literal> and <literal>var</literal> turn their argument into a lambda functor, that implements an identity mapping.
The former two are for constants, the latter for variables. 
The use of these <emphasis>delayed</emphasis> constants and variables is sometimes necessary due to the lack of explicit syntax for lambda expressions. 
For example:
<programlisting>
for_each(a.begin(), a.end(), cout &lt;&lt; _1 &lt;&lt; ' ');
for_each(a.begin(), a.end(), cout &lt;&lt; ' ' &lt;&lt; _1);
</programlisting>
The first line outputs the elements of <literal>a</literal> separated by spaces, while the second line outputs a space followed by the elements of <literal>a</literal> without any separators.
The reason for this is that neither of the operands of 
<literal>cout &lt;&lt; ' '</literal> is a lambda expression, hence <literal>cout &lt;&lt; ' '</literal> is evaluated immediately.

To delay the evaluation of <literal>cout &lt;&lt; ' '</literal>, one of the operands must be explicitly marked as a lambda expression. 
This is accomplished with the <literal>constant</literal> function:
<programlisting>
for_each(a.begin(), a.end(), cout &lt;&lt; constant(' ') &lt;&lt; _1);
</programlisting>

The call <literal>constant(' ')</literal> creates a nullary lambda functor which stores the character constant <literal>' '</literal> 
and returns a reference to it when invoked. 
The function <literal>constant_ref</literal> is similar, except that it
stores a constant reference to its argument.

The <literal>constant</literal> and <literal>consant_ref</literal> are only
needed when the operator call has side effects, like in the above example.
</para><para>
Sometimes we need to delay the evaluation of a variable. 
Suppose we wanted to output the elements of a container in a numbered list:

<programlisting>
int index = 0; 
for_each(a.begin(), a.end(), cout &lt;&lt; ++index &lt;&lt; ':' &lt;&lt; _1 &lt;&lt; '\n');
for_each(a.begin(), a.end(), cout &lt;&lt; ++var(index) &lt;&lt; ':' &lt;&lt; _1 &lt;&lt; '\n');
</programlisting>

The first <literal>for_each</literal> invocation does not do what we want; <literal>index</literal> is incremented only once, and its value is written into the output stream only once.
By using <literal>var</literal> to make <literal>index</literal> a lambda expression, we get the desired effect.
</para><para>
In sum, <literal>var(x)</literal> creates a nullary lambda functor, 
which stores a reference to the variable <literal>x</literal>. 
When the lambda functor is invoked, a reference to <literal>x</literal> is returned.
</para><simplesect><title>Naming delayed constants and variables</title><para>
It is possible to predefine and name a delayed variable or constant outside a lambda expression. 
The templates <literal>var_type</literal>, <literal>constant_type</literal> 
and <literal>constant_ref_type</literal> serve for this purpose. 
They are used as:
<programlisting>
var_type&lt;T&gt;::type delayed_i(var(i));
constant_type&lt;T&gt;::type delayed_c(constant(c));
</programlisting>
The first line defines the variable <literal>delayed_i</literal> which is a delayed version of the variable <literal>i</literal> of type <literal>T</literal>.
Analogously, the second line defines the constant <literal>delayed_c</literal> as a delayed version of the constant <literal>c</literal>.
For example:

<programlisting>
int i = 0; int j;
for_each(a.begin(), a.end(), (var(j) = _1, _1 = var(i), var(i) = var(j))); 
</programlisting>
is equivalent to:
<programlisting>
int i = 0; int j;
var_type&lt;int&gt;::type vi(var(i)), vj(var(j));
for_each(a.begin(), a.end(), (vj = _1, _1 = vi, vi = vj));
</programlisting></para><para>
Here is an example of naming a delayed constant:
<programlisting>
constant_type&lt;char&gt;::type space(constant(' '));
for_each(a.begin(),a.end(), cout &lt;&lt; space &lt;&lt; _1);
</programlisting></para></simplesect><simplesect><title>About assignment and subscript operators</title><para>
As described in <xref linkend="lambda.assignment_and_subscript"/>, assignment and subscripting operators are always defined as member functions.
This means, that for expressions of the form
<literal>x = y</literal> or <literal>x[y]</literal> to be interpreted as lambda expressions, the left-hand operand <literal>x</literal> must be a lambda expression. 
Consequently, it is sometimes necessary to use <literal>var</literal> for this purpose.
We repeat the example from <xref linkend="lambda.assignment_and_subscript"/>:

<programlisting>
int i; 
i = _1;       // error
var(i) = _1;  // ok
</programlisting></para><para>

Note that the compound assignment operators <literal>+=</literal>, <literal>-=</literal> etc. can be defined as non-member functions, and thus they are interpreted as lambda expressions even if only the right-hand operand is a lambda expression.
Nevertheless, it is perfectly ok to delay the left operand explicitly. 
For example, <literal>i += _1</literal> is equivalent to <literal>var(i) += _1</literal>.
</para></simplesect></section><section id="lambda.lambda_expressions_for_control_structures"><title>Lambda expressions for control structures</title><para>
BLL defines several functions to create lambda functors that represent control structures. 
They all take lambda functors as parameters and return <literal>void</literal>.
To start with an example, the following code outputs all even elements of some container <literal>a</literal>:

<programlisting>
for_each(a.begin(), a.end(), 
         if_then(_1 % 2 == 0, cout &lt;&lt; _1));  
</programlisting></para><para>
The BLL supports the following function templates for control structures: 

<programlisting>
if_then(condition, then_part)
if_then_else(condition, then_part, else_part)
if_then_else_return(condition, then_part, else_part)
while_loop(condition, body)
while_loop(condition) // no body case
do_while_loop(condition, body)
do_while_loop(condition) // no body case 
for_loop(init, condition, increment, body)
for_loop(init, condition, increment) // no body case
switch_statement(...)
</programlisting>

The return types of all control construct lambda functor is 
<literal>void</literal>, except for <literal>if_then_else_return</literal>,
which wraps a call to the conditional operator 
<programlisting>
condition ? then_part : else_part
</programlisting>
The return type rules for this operator are somewhat complex. 
Basically, if the branches have the same type, this type is the return type.
If the type of the branches differ, one branch, say of type 
<literal>A</literal>, must be convertible to the other branch, 
say of type <literal>B</literal>.
In this situation, the result type is <literal>B</literal>.
Further, if the common type is an lvalue, the return type will be an lvalue
too.
</para><para>
Delayed variables tend to be commonplace in control structure lambda expressions. 
For instance, here we use the <literal>var</literal> function to turn the arguments of <literal>for_loop</literal> into lambda expressions. 
The effect of the code is to add 1 to each element of a two-dimensional array:

<programlisting>
int a[5][10]; int i;
for_each(a, a+5, 
  for_loop(var(i)=0, var(i)&lt;10, ++var(i), 
           _1[var(i)] += 1));  
</programlisting></para><para>
The BLL supports an alternative syntax for control expressions, suggested
by Joel de Guzmann. 
By overloading the <literal>operator[]</literal> we can
get a closer resemblance with the built-in control structures:

<programlisting>
if_(condition)[then_part]
if_(condition)[then_part].else_[else_part]
while_(condition)[body]
do_[body].while_(condition)
for_(init, condition, increment)[body]
</programlisting>

For example, using this syntax the <literal>if_then</literal> example above
can be written as:
<programlisting>
for_each(a.begin(), a.end(), 
         if_(_1 % 2 == 0)[ cout &lt;&lt; _1 ])  
</programlisting>

As more experience is gained, we may end up deprecating one or the other 
of these syntaces. 

</para><section id="lambda.switch_statement"><title>Switch statement</title></section><para>
The lambda expressions for <literal>switch</literal> control structures are more complex since the number of cases may vary. 
The general form of a switch lambda expression is:

<programlisting>
switch_statement(<parameter>condition</parameter>, 
  case_statement&lt;<parameter>label</parameter>&gt;(<parameter>lambda expression</parameter>),
  case_statement&lt;<parameter>label</parameter>&gt;(<parameter>lambda expression</parameter>),
  ...
  default_statement(<parameter>lambda expression</parameter>)
)
</programlisting>

The <literal><parameter>condition</parameter></literal> argument must be a lambda expression that creates a lambda functor with an integral return type.
The different cases are created with the <literal>case_statement</literal> functions, and the optional default case with the <literal>default_statement</literal> function.
The case labels are given as explicitly specified template arguments to <literal>case_statement</literal> functions and 
<literal>break</literal> statements are implicitly part of each case. 
For example, <literal>case_statement&lt;1&gt;(a)</literal>, where <literal>a</literal> is some lambda functor,  generates the code:

<programlisting>
case 1: 
  <parameter>evaluate lambda functor</parameter> a; 
  break;
</programlisting>
The <literal>switch_statement</literal> function is specialized for up to 9 case statements.

</para><para>
As a concrete example, the following code iterates over some container <literal>v</literal> and ouptuts <quote>zero</quote> for each <literal>0</literal>, <quote>one</quote> for each <literal>1</literal>, and <quote>other: <parameter>n</parameter></quote> for any other value <parameter>n</parameter>.
Note that another lambda expression is sequenced after the <literal>switch_statement</literal> to output a line break after each element:

<programlisting>
std::for_each(v.begin(), v.end(),
  ( 
    switch_statement(
      _1,
      case_statement&lt;0&gt;(std::cout &lt;&lt; constant("zero")),
      case_statement&lt;1&gt;(std::cout &lt;&lt; constant("one")),
      default_statement(cout &lt;&lt; constant("other: ") &lt;&lt; _1)
    ), 
    cout &lt;&lt; constant("\n") 
  )
);
</programlisting></para></section><section id="lambda.exceptions"><title>Exceptions</title><para>
The BLL provides lambda functors that throw and catch exceptions.
Lambda functors for throwing exceptions are created with the unary function <literal>throw_exception</literal>.
The argument to this function is the exception to be thrown, or a lambda functor which creates the exception to be thrown.
A lambda functor for rethrowing exceptions is created with the nullary <literal>rethrow</literal> function.
</para><para>
Lambda expressions for handling exceptions are somewhat more complex.
The general form of a lambda expression for try catch blocks is as follows:

<programlisting>
try_catch(
  <parameter>lambda expression</parameter>,
  catch_exception&lt;<parameter>type</parameter>&gt;(<parameter>lambda expression</parameter>),
  catch_exception&lt;<parameter>type</parameter>&gt;(<parameter>lambda expression</parameter>),
  ...
  catch_all(<parameter>lambda expression</parameter>)
)
</programlisting>

The first lambda expression is the try block. 
Each <literal>catch_exception</literal> defines a catch block where the 
explicitly specified template argument defines the type of the exception 
to catch.

The lambda expression within the <literal>catch_exception</literal> defines 
the actions to take if the exception is caught.

Note that the resulting exception handlers catch the exceptions as 
references, i.e., <literal>catch_exception&lt;T&gt;(...)</literal> 
results in the catch block:

<programlisting>
catch(T&amp; e) { ... }
</programlisting>

The last catch block can alternatively be a call to 
<literal>catch_exception&lt;<parameter>type</parameter>&gt;</literal> 
or to 
<literal>catch_all</literal>, which is the lambda expression equivalent to 
<literal>catch(...)</literal>.

</para><para>

The <xref linkend="ex:exceptions"/> demonstrates the use of the BLL 
exception handling tools. 
The first handler catches exceptions of type <literal>foo_exception</literal>. 
Note the use of <literal>_1</literal> placeholder in the body of the handler.
</para><para>
The second handler shows how to throw exceptions, and demonstrates the 
use of the <emphasis>exception placeholder</emphasis><literal>_e</literal>.

It is a special placeholder, which refers to the caught exception object 
within the handler body.

Here we are handling an exception of type <literal>std::exception</literal>, 
which carries a string explaining the cause of the exception. 

This explanation can be queried with the zero-argument member 
function <literal>what</literal>.

The expression
<literal>bind(&amp;std::exception::what, _e)</literal> creates the lambda 
function for making that call.

Note that <literal>_e</literal> cannot be used outside of an exception handler lambda expression.


The last line of the second handler constructs a new exception object and 
throws that with <literal>throw exception</literal>. 

Constructing and destructing objects within lambda expressions is 
explained in <xref linkend="lambda.construction_and_destruction"/></para><para>
Finally, the third handler (<literal>catch_all</literal>) demonstrates 
rethrowing exceptions.
</para><example id="ex:exceptions"><title>Throwing and handling exceptions in lambda expressions.</title><programlisting>
for_each(
  a.begin(), a.end(),
  try_catch(
    bind(foo, _1),                 // foo may throw
    catch_exception&lt;foo_exception&gt;(
      cout &lt;&lt; constant("Caught foo_exception: ") 
           &lt;&lt; "foo was called with argument = " &lt;&lt; _1
    ),
    catch_exception&lt;std::exception&gt;(
      cout &lt;&lt; constant("Caught std::exception: ") 
           &lt;&lt; bind(&amp;std::exception::what, _e),
      throw_exception(bind(constructor&lt;bar_exception&gt;(), _1)))
    ),      
    catch_all(
      (cout &lt;&lt; constant("Unknown"), rethrow())
    )
  )
);
</programlisting></example></section><section id="lambda.construction_and_destruction"><title>Construction and destruction</title><para>
Operators <literal>new</literal> and <literal>delete</literal> can be 
overloaded, but their return types are fixed. 

Particularly, the return types cannot be lambda functors, 
which prevents them to be overloaded for lambda expressions.

It is not possible to take the address of a constructor, 
hence constructors cannot be used as target functions in bind expressions.

The same is true for destructors.

As a way around these constraints, BLL defines wrapper classes for 
<literal>new</literal> and <literal>delete</literal> calls, 
as well as for constructors and destructors.

Instances of these classes are function objects, that can be used as 
target functions of bind expressions. 

For example:

<programlisting>
int* a[10];
for_each(a, a+10, _1 = bind(new_ptr&lt;int&gt;())); 
for_each(a, a+10, bind(delete_ptr(), _1));
</programlisting>

The <literal>new_ptr&lt;int&gt;()</literal> expression creates 
a function object that calls <literal>new int()</literal> when invoked, 
and wrapping that inside <literal>bind</literal> makes it a lambda functor.

In the same way, the expression <literal>delete_ptr()</literal> creates 
a function object that invokes <literal>delete</literal> on its argument. 

Note that <literal>new_ptr&lt;<parameter>T</parameter>&gt;()</literal> 
can take arguments as well.

They are passed directly to the constructor invocation and thus allow 
calls to constructors which take arguments. 

</para><para>

As an example of constructor calls in lambda expressions, 
the following code reads integers from two containers <literal>x</literal> 
and <literal>y</literal>, 
constructs pairs out of them and inserts them into a third container:

<programlisting>
vector&lt;pair&lt;int, int&gt; &gt; v;
transform(x.begin(), x.end(), y.begin(), back_inserter(v),
          bind(constructor&lt;pair&lt;int, int&gt; &gt;(), _1, _2));
</programlisting><xref linkend="table:constructor_destructor_fos"/> lists all the function 
objects related to creating and destroying objects,
 showing the expression to create and call the function object, 
and the effect of evaluating that expression.

</para><table id="table:constructor_destructor_fos"><title>Construction and destruction related function objects.</title><tgroup cols="2"><thead><row><entry>Function object call</entry><entry>Wrapped expression</entry></row></thead><tbody><row><entry><literal>constructor&lt;T&gt;()(<parameter>arg_list</parameter>)</literal></entry><entry>T(<parameter>arg_list</parameter>)</entry></row><row><entry><literal>destructor()(a)</literal></entry><entry><literal>a.~A()</literal>, where <literal>a</literal> is of type <literal>A</literal></entry></row><row><entry><literal>destructor()(pa)</literal></entry><entry><literal>pa-&gt;~A()</literal>, where <literal>pa</literal> is of type <literal>A*</literal></entry></row><row><entry><literal>new_ptr&lt;T&gt;()(<parameter>arg_list</parameter>)</literal></entry><entry><literal>new T(<parameter>arg_list</parameter>)</literal></entry></row><row><entry><literal>new_array&lt;T&gt;()(sz)</literal></entry><entry><literal>new T[sz]</literal></entry></row><row><entry><literal>delete_ptr()(p)</literal></entry><entry><literal>delete p</literal></entry></row><row><entry><literal>delete_array()(p)</literal></entry><entry><literal>delete p[]</literal></entry></row></tbody></tgroup></table></section><section><title>Special lambda expressions</title><section><title>Preventing argument substitution</title><para>
When a lambda functor is called, the default behavior is to substitute 
the actual arguments for the placeholders within all subexpressions.

This section describes the tools to prevent the substitution and 
evaluation of a subexpression, and explains when these tools should be used.
</para><para>
The arguments to a bind expression can be arbitrary lambda expressions, 
e.g., other bind expressions.

For example:

<programlisting>
int foo(int); int bar(int);
...
int i;
bind(foo, bind(bar, _1)(i);
</programlisting>

The last line makes the call <literal>foo(bar(i));</literal>

Note that the first argument in a bind expression, the target function, 
is no exception, and can thus be a bind expression too.

The innermost lambda functor just has to return something that can be used 
as a target function: another lambda functor, function pointer, 
pointer to member function etc. 

For example, in the following code the innermost lambda functor makes 
a selection between two functions, and returns a pointer to one of them:

<programlisting>
int add(int a, int b) { return a+b; }
int mul(int a, int b) { return a*b; }

int(*)(int, int)  add_or_mul(bool x) { 
  return x ? add : mul; 
}

bool condition; int i; int j;
...
bind(bind(&amp;add_or_mul, _1), _2, _3)(condition, i, j);
</programlisting></para><section id="lambda.unlambda"><title>Unlambda</title><para>A nested bind expression may occur inadvertently, 
if the target function is a variable with a type that depends on a 
template parameter. 

Typically the target function could be a formal parameter of a 
function template. 

In such a case, the programmer may not know whether the target function is a lambda functor or not.
</para><para>Consider the following function template:

<programlisting>
template&lt;class F&gt;
int nested(const F&amp; f) {
  int x;
  ...
  bind(f, _1)(x);
  ...
}
</programlisting>

Somewhere inside the function the formal parameter
<literal>f</literal> is used as a target function in a bind expression. 

In order for this <literal>bind</literal> call to be valid, 
<literal>f</literal> must be a unary function.

Suppose the following two calls to <literal>nested</literal> are made:

<programlisting>
int foo(int);
int bar(int, int);
nested(&amp;foo);
nested(bind(bar, 1, _1));
</programlisting>

Both are unary functions, or function objects, with appropriate argument 
and return types, but the latter will not compile.

In the latter call, the bind expression inside <literal>nested</literal> 
will become:

<programlisting>
bind(bind(bar, 1, _1), _1) 
</programlisting>

When this is invoked with <literal>x</literal>, 
after substituitions we end up trying to call

<programlisting>
bar(1, x)(x)
</programlisting>

which is an error. 

The call to <literal>bar</literal> returns int, 
not a unary function or function object.
</para><para>
In the example above, the intent of the bind expression in the 
<literal>nested</literal> function is to treat <literal>f</literal> 
as an ordinary function object, instead of a lambda functor. 

The BLL provides the function template <literal>unlambda</literal> to 
express this: a lambda functor wrapped inside <literal>unlambda</literal> 
is not a lambda functor anymore, and does not take part into the 
argument substitution process.

Note that for all other argument types <literal>unlambda</literal> is 
an identity operation, except for making non-const objects const.
</para><para>
Using <literal>unlambda</literal>, the <literal>nested</literal> 
function is written as:

<programlisting>
template&lt;class F&gt;
int nested(const F&amp; f) {
  int x;
  ...
  bind(unlambda(f), _1)(x);
  ...
}
</programlisting></para></section><section><title>Protect</title><para>
The <literal>protect</literal> function is related to unlambda. 

It is also used to prevent the argument substitution taking place, 
but whereas <literal>unlambda</literal> turns a lambda functor into 
an ordinary function object for good, <literal>protect</literal> does 
this temporarily, for just one evaluation round.

For example:

<programlisting>
int x = 1, y = 10;
(_1 + protect(_1 + 2))(x)(y);
</programlisting>
    
The first call substitutes <literal>x</literal> for the leftmost 
<literal>_1</literal>, and results in another lambda functor 
<literal>x + (_1 + 2)</literal>, which after the call with 
<literal>y</literal> becomes <literal>x + (y + 2)</literal>, 
and thus finally 13.
</para><para>
Primary motivation for including <literal>protect</literal> into the library, 
was to allow nested STL algorithm invocations 
(<xref linkend="lambda.nested_stl_algorithms"/>).
</para></section></section><section id="lambda.rvalues_as_actual_arguments"><title>Rvalues as actual arguments to lambda functors</title><para>
Actual arguments to the lambda functors cannot be non-const rvalues.
This is due to a deliberate design decision: either we have this restriction, 
or there can be no side-effects to the actual arguments.

There are ways around this limitation.

We repeat the example from section 
<xref linkend="lambda.actual_arguments_to_lambda_functors"/> and list the 
different solutions:

<programlisting>
int i = 1; int j = 2; 
(_1 + _2)(i, j); // ok
(_1 + _2)(1, 2); // error (!)
</programlisting><orderedlist><listitem><para>
If the rvalue is of a class type, the return type of the function that 
creates the rvalue should be defined as const. 
Due to an unfortunate language restriction this does not work for 
built-in types, as built-in rvalues cannot be const qualified. 
</para></listitem><listitem><para>
If the lambda function call is accessible, the <literal>make_const</literal> 
function can be used to <emphasis>constify</emphasis> the rvalue. E.g.:

<programlisting>
(_1 + _2)(make_const(1), make_const(2)); // ok
</programlisting>

Commonly the lambda function call site is inside a standard algorithm 
function template, preventing this solution to be used.

</para></listitem><listitem><para>
If neither of the above is possible, the lambda expression can be wrapped 
in a <literal>const_parameters</literal> function. 
It creates another type of lambda functor, which takes its arguments as 
const references. For example:

<programlisting>
const_parameters(_1 + _2)(1, 2); // ok
</programlisting>

Note that <literal>const_parameters</literal> makes all arguments const.
Hence, in the case were one of the arguments is a non-const rvalue, 
and another argument needs to be passed as a non-const reference, 
this approach cannot be used.
</para></listitem><listitem><para>If none of the above is possible, there is still one solution, 
which unfortunately can break const correctness.

The solution is yet another lambda functor wrapper, which we have named 
<literal>break_const</literal> to alert the user of the potential dangers 
of this function. 

The <literal>break_const</literal> function creates a lambda functor that 
takes its arguments as const, and casts away constness prior to the call 
to the original wrapped lambda functor.

For example:
<programlisting>
int i; 
...
(_1 += _2)(i, 2);                 // error, 2 is a non-const rvalue
const_parameters(_1 += _2)(i, 2); // error, i becomes const
break_const(_1 += _2)(i, 2);      // ok, but dangerous
</programlisting>

Note, that the results of <literal> break_const</literal> or 
<literal>const_parameters</literal> are not lambda functors, 
so they cannot be used as subexpressions of lambda expressions. For instance:

<programlisting>
break_const(_1 + _2) + _3; // fails.
const_parameters(_1 + _2) + _3; // fails.
</programlisting>

However, this kind of code should never be necessary, 
since calls to sub lambda functors are made inside the BLL, 
and are not affected by the non-const rvalue problem.
</para></listitem></orderedlist></para></section></section><section><title>Casts, sizeof and typeid</title><section id="lambda.cast_expressions"><title>
Cast expressions
</title><para>
The BLL defines its counterparts for the four cast expressions 
<literal>static_cast</literal>, <literal>dynamic_cast</literal>, 
<literal>const_cast</literal> and <literal>reinterpret_cast</literal>.

The BLL versions of the cast expressions have the prefix 
<literal>ll_</literal>.

The type to cast to is given as an explicitly specified template argument, 
and the sole argument is the expression from which to perform the cast.

If the argument is a lambda functor, the lambda functor is evaluated first.

For example, the following code uses <literal>ll_dynamic_cast</literal> 
to count the number of <literal>derived</literal> instances in the container 
<literal>a</literal>:

<programlisting>
class base {};
class derived : public base {};

vector&lt;base*&gt; a;
...
int count = 0;
for_each(a.begin(), a.end(), 
         if_then(ll_dynamic_cast&lt;derived*&gt;(_1), ++var(count)));
</programlisting></para></section><section><title>Sizeof and typeid</title><para>
The BLL counterparts for these expressions are named 
<literal>ll_sizeof</literal> and <literal>ll_typeid</literal>.

Both take one argument, which can be a lambda expression.
The lambda functor created wraps the <literal>sizeof</literal> or 
<literal>typeid</literal> call, and when the lambda functor is called 
the wrapped operation is performed.

For example:

<programlisting>
vector&lt;base*&gt; a; 
...
for_each(a.begin(), a.end(), 
         cout &lt;&lt; bind(&amp;type_info::name, ll_typeid(*_1)));
</programlisting>

Here <literal>ll_typeid</literal> creates a lambda functor for 
calling <literal>typeid</literal> for each element.

The result of a <literal>typeid</literal> call is an instance of 
the <literal>type_info</literal> class, and the bind expression creates 
a lambda functor for calling the <literal>name</literal> member 
function of that class.

</para></section></section><section id="lambda.nested_stl_algorithms"><title>Nesting STL algorithm invocations</title><para>
The BLL defines common STL algorithms as function object classes, 
instances of which can be used as target functions in bind expressions.
For example, the following code iterates over the elements of a 
two-dimensional array, and computes their sum.

<programlisting>
int a[100][200];
int sum = 0;

std::for_each(a, a + 100, 
	      bind(ll::for_each(), _1, _1 + 200, protect(sum += _1)));
</programlisting>

The BLL versions of the STL algorithms are classes, which define the function call operator (or several overloaded ones) to call the corresponding function templates in the <literal>std</literal> namespace.
All these structs are placed in the subnamespace <literal>boost::lambda:ll</literal>. 
</para><para>
Note that there is no easy way to express an overloaded member function 
call in a lambda expression. 

This limits the usefulness of nested STL algorithms, as for instance 
the <literal>begin</literal> function has more than one overloaded 
definitions in container templates.

In general, something analogous to the pseudo-code below cannot be written:

<programlisting>
std::for_each(a.begin(), a.end(), 
	      bind(ll::for_each(), _1.begin(), _1.end(), protect(sum += _1)));
</programlisting>

Some aid for common special cases can be provided though.

The BLL defines two helper function object classes, 
<literal>call_begin</literal> and <literal>call_end</literal>, 
which wrap a call to the <literal>begin</literal> and, respectively, 
<literal>end</literal> functions of a container, and return the 
<literal>const_iterator</literal> type of the container.

With these helper templates, the above code becomes:
<programlisting>
std::for_each(a.begin(), a.end(), 
	      bind(ll::for_each(), 
                   bind(call_begin(), _1), bind(call_end(), _1),
                        protect(sum += _1)));
</programlisting></para></section></section><section id="lambda.extending"><title>Extending return type deduction system</title><para>

In this section, we explain  how to extend the return type deduction system 
to cover user defined operators. 

In many cases this is not necessary, 
as the BLL defines default return types for operators.

For example, the default return type for all comparison operators is 
<literal>bool</literal>, and as long as the user defined comparison operators 
have a bool return type, there is no need to write new specializations 
for the return type deduction classes.

Sometimes this cannot be avoided, though.

</para><para>
The overloadable user defined operators are either unary or binary. 

For each arity, there are two traits templates that define the 
return types of the different operators.

Hence, the return type system can be extended by providing more 
specializations for these templates.

The templates for unary functors are

<literal>
plain_return_type_1&lt;Action, A&gt;
</literal>

and 

<literal>
return_type_1&lt;Action, A&gt;
</literal>, and 

<literal>
plain_return_type_2&lt;Action, A, B&gt;
</literal>

and 

<literal>
return_type_2&lt;Action, A, B&gt;
</literal>

respectively for binary functors.

</para><para>
The first parameter (<literal>Action</literal>) to all these templates 
is the <emphasis>action</emphasis> class, which specifies the operator. 

Operators with similar return type rules are grouped together into 
<emphasis>action groups</emphasis>, 
and only the action class and action group together define the operator 
unambiguously. 

As an example, the action type 
<literal>arithmetic_action&lt;plus_action&gt;</literal> stands for 
<literal>operator+</literal>. 

The complete listing of different action types is shown in 
<xref linkend="table:actions"/>. 
</para><para>
The latter parameters, <literal>A</literal> in the unary case, 
or <literal>A</literal> and <literal>B</literal> in the binary case, 
stand for the argument types of the operator call. 

The two sets of templates, 
<literal>plain_return_type_<parameter>n</parameter></literal> and 
<literal>return_type_<parameter>n</parameter></literal> 
(<parameter>n</parameter> is 1 or 2) differ in the way how parameter types 
are presented to them.

For the former templates, the parameter types are always provided as 
non-reference types, and do not have const or volatile qualifiers.

This makes specializing easy, as commonly one specialization for each 
user defined operator, or operator group, is enough.

On the other hand, if a particular operator is overloaded for different 
cv-qualifications of the same argument types, 
and the return types of these overloaded versions differ, a more fine-grained control is needed.

Hence, for the latter templates, the parameter types preserve the 
cv-qualifiers, and are non-reference types as well. 
 
The downside is, that for an overloaded set of operators of the 
kind described above, one may end up needing up to 
16 <literal>return_type_2</literal> specializations.
</para><para>
Suppose the user has overloaded the following operators for some user defined 
types <literal>X</literal>, <literal>Y</literal> and <literal>Z</literal>:

<programlisting>
Z operator+(const X&amp;, const Y&amp;);
Z operator-(const X&amp;, const Y&amp;);
</programlisting>

Now, one can add a specialization stating, that if the left hand argument 
is of type <literal>X</literal>, and the right hand one of type 
<literal>Y</literal>, the return type of all such binary arithmetic 
operators is <literal>Z</literal>:

<programlisting>
namespace boost { 
namespace lambda {
  
template&lt;class Act&gt; 
struct plain_return_type_2&lt;arithmetic_action&lt;Act&gt;, X, Y&gt; {
  typedef Z type;
};

}
}
</programlisting>

Having this specialization defined, BLL is capable of correctly 
deducing the return type of the above two operators.

Note, that the specializations must be in the same namespace, 
<literal>::boost::lambda</literal>, with the primary template. 

For brevity, we do not show the namespace definitions in the examples below.
</para><para>
It is possible to specialize on the level of an individual operator as well, 
in addition to providing a specialization for a group of operators. 
Say, we add a new arithmetic operator for argument types <literal>X</literal> 
and <literal>Y</literal>:

<programlisting>
X operator*(const X&amp;, const Y&amp;);
</programlisting>

Our first rule for all arithmetic operators specifies that the return 
type of this operator is <literal>Z</literal>, 
which obviously is not the case.
Hence, we provide a new rule for the multiplication operator:

<programlisting>
template&lt;&gt; 
struct plain_return_type_2&lt;arithmetic_action&lt;multiply_action&gt;, X, Y&gt; {
  typedef X type;
};
</programlisting></para><para>
The specializations can define arbitrary mappings from the argument types 
to the return type. 

Suppose we have some mathematical vector type, templated on the element type:

<programlisting>
template &lt;class T&gt; class my_vector;
</programlisting>

Suppose the addition operator is defined between any two 
<literal>my_vector</literal> instantiations, 
as long as the addition operator is defined between their element types. 

Furthermore, the element type of the resulting <literal>my_vector</literal> 
is the same as the result type of the addition between the element types.

E.g., adding <literal>my_vector&lt;int&gt;</literal> and 
<literal>my_vector&lt;double&gt;</literal> results in 
<literal>my_vector&lt;double&gt;</literal>.

The BLL has traits classes to perform the implicit built-in and standard 
type conversions between integral, floating point, and complex classes.

Using BLL tools, the addition operator described above can be defined as:

<programlisting>
template&lt;class A, class B&gt; 
my_vector&lt;typename return_type_2&lt;arithmetic_action&lt;plus_action&gt;, A, B&gt;::type&gt;
operator+(const my_vector&lt;A&gt;&amp; a, const my_vector&lt;B&gt;&amp; b)
{
  typedef typename 
    return_type_2&lt;arithmetic_action&lt;plus_action&gt;, A, B&gt;::type res_type;
  return my_vector&lt;res_type&gt;();
}
</programlisting></para><para>
To allow BLL to deduce the type of <literal>my_vector</literal> 
additions correctly, we can define:

<programlisting>
template&lt;class A, class B&gt; 
class plain_return_type_2&lt;arithmetic_action&lt;plus_action&gt;, 
                           my_vector&lt;A&gt;, my_vector&lt;B&gt; &gt; {
  typedef typename 
    return_type_2&lt;arithmetic_action&lt;plus_action&gt;, A, B&gt;::type res_type;
public:
  typedef my_vector&lt;res_type&gt; type;
};
</programlisting>
Note, that we are reusing the existing specializations for the 
BLL <literal>return_type_2</literal> template, 
which require that the argument types are references. 
</para><table id="table:actions"><title>Action types</title><tgroup cols="2"><tbody><row><entry><literal>+</literal></entry><entry><literal>arithmetic_action&lt;plus_action&gt;</literal></entry></row><row><entry><literal>-</literal></entry><entry><literal>arithmetic_action&lt;minus_action&gt;</literal></entry></row><row><entry><literal>*</literal></entry><entry><literal>arithmetic_action&lt;multiply_action&gt;</literal></entry></row><row><entry><literal>/</literal></entry><entry><literal>arithmetic_action&lt;divide_action&gt;</literal></entry></row><row><entry><literal>%</literal></entry><entry><literal>arithmetic_action&lt;remainder_action&gt;</literal></entry></row><row><entry><literal>+</literal></entry><entry><literal>unary_arithmetic_action&lt;plus_action&gt;</literal></entry></row><row><entry><literal>-</literal></entry><entry><literal>unary_arithmetic_action&lt;minus_action&gt;</literal></entry></row><row><entry><literal>&amp;</literal></entry><entry><literal>bitwise_action&lt;and_action&gt;</literal></entry></row><row><entry><literal>|</literal></entry><entry><literal>bitwise_action&lt;or_action&gt;</literal></entry></row><row><entry><literal>~</literal></entry><entry><literal>bitwise_action&lt;not_action&gt;</literal></entry></row><row><entry><literal>^</literal></entry><entry><literal>bitwise_action&lt;xor_action&gt;</literal></entry></row><row><entry><literal>&lt;&lt;</literal></entry><entry><literal>bitwise_action&lt;leftshift_action_no_stream&gt;</literal></entry></row><row><entry><literal>&gt;&gt;</literal></entry><entry><literal>bitwise_action&lt;rightshift_action_no_stream&gt;</literal></entry></row><row><entry><literal>&amp;&amp;</literal></entry><entry><literal>logical_action&lt;and_action&gt;</literal></entry></row><row><entry><literal>||</literal></entry><entry><literal>logical_action&lt;or_action&gt;</literal></entry></row><row><entry><literal>!</literal></entry><entry><literal>logical_action&lt;not_action&gt;</literal></entry></row><row><entry><literal>&lt;</literal></entry><entry><literal>relational_action&lt;less_action&gt;</literal></entry></row><row><entry><literal>&gt;</literal></entry><entry><literal>relational_action&lt;greater_action&gt;</literal></entry></row><row><entry><literal>&lt;=</literal></entry><entry><literal>relational_action&lt;lessorequal_action&gt;</literal></entry></row><row><entry><literal>&gt;=</literal></entry><entry><literal>relational_action&lt;greaterorequal_action&gt;</literal></entry></row><row><entry><literal>==</literal></entry><entry><literal>relational_action&lt;equal_action&gt;</literal></entry></row><row><entry><literal>!=</literal></entry><entry><literal>relational_action&lt;notequal_action&gt;</literal></entry></row><row><entry><literal>+=</literal></entry><entry><literal>arithmetic_assignment_action&lt;plus_action&gt;</literal></entry></row><row><entry><literal>-=</literal></entry><entry><literal>arithmetic_assignment_action&lt;minus_action&gt;</literal></entry></row><row><entry><literal>*=</literal></entry><entry><literal>arithmetic_assignment_action&lt;multiply_action&gt;</literal></entry></row><row><entry><literal>/=</literal></entry><entry><literal>arithmetic_assignment_action&lt;divide_action&gt;</literal></entry></row><row><entry><literal>%=</literal></entry><entry><literal>arithmetic_assignment_action&lt;remainder_action&gt;</literal></entry></row><row><entry><literal>&amp;=</literal></entry><entry><literal>bitwise_assignment_action&lt;and_action&gt;</literal></entry></row><row><entry><literal>=|</literal></entry><entry><literal>bitwise_assignment_action&lt;or_action&gt;</literal></entry></row><row><entry><literal>^=</literal></entry><entry><literal>bitwise_assignment_action&lt;xor_action&gt;</literal></entry></row><row><entry><literal>&lt;&lt;=</literal></entry><entry><literal>bitwise_assignment_action&lt;leftshift_action&gt;</literal></entry></row><row><entry><literal>&gt;&gt;=</literal></entry><entry><literal>bitwise_assignment_action&lt;rightshift_action&gt;</literal></entry></row><row><entry><literal>++</literal></entry><entry><literal>pre_increment_decrement_action&lt;increment_action&gt;</literal></entry></row><row><entry><literal>--</literal></entry><entry><literal>pre_increment_decrement_action&lt;decrement_action&gt;</literal></entry></row><row><entry><literal>++</literal></entry><entry><literal>post_increment_decrement_action&lt;increment_action&gt;</literal></entry></row><row><entry><literal>--</literal></entry><entry><literal>post_increment_decrement_action&lt;decrement_action&gt;</literal></entry></row><row><entry><literal>&amp;</literal></entry><entry><literal>other_action&lt;address_of_action&gt;</literal></entry></row><row><entry><literal>*</literal></entry><entry><literal>other_action&lt;contents_of_action&gt;</literal></entry></row><row><entry><literal>,</literal></entry><entry><literal>other_action&lt;comma_action&gt;</literal></entry></row></tbody></tgroup></table></section><section><title>Practical considerations</title><section><title>Performance</title><para>In theory, all overhead of using STL algorithms and lambda functors 
compared to hand written loops can be optimized away, just as the overhead 
from standard STL function objects and binders can.

Depending on the compiler, this can also be true in practice.
We ran two tests with the GCC 3.0.4 compiler on 1.5 GHz Intel Pentium 4.
The optimization flag -03 was used.
</para><para>
In the first test we compared lambda functors against explicitly written 
function objects. 
We used both of these styles to define unary functions which multiply the
argument repeatedly by itself. 
We started with the identity function, going up to 
x<superscript>5</superscript>.
The expressions were called inside a <literal>std::transform</literal> loop, 
reading the argument from one <literal>std::vector&lt;int&gt;</literal> 
and placing the result into another.
The length of the vectors was 100 elements.
The running times are listed in 
<xref linkend="table:increasing_arithmetic_test"/>.

We can observe that there is no significant difference between the
two approaches.
</para><para>
In the second test we again used <literal>std::transform</literal> to 
perform an operation to each element in a 100-element long vector.
This time the element type of the vectors was <literal>double</literal>
and we started with very simple arithmetic expressions and moved to 
more complex ones.
The running times are listed in <xref linkend="table:ll_vs_stl_test"/>.

Here, we also included classic STL style unnamed functions into tests.
We do not show these expressions, as they get rather complex. 
For example, the
last expression in <xref linkend="table:ll_vs_stl_test"/> written with
classic STL tools contains 7 calls to <literal>compose2</literal>, 
8 calls to <literal>bind1st</literal>
and altogether 14 constructor invocations for creating 
<literal>multiplies</literal>, <literal>minus</literal> 
and <literal>plus</literal> objects.

In this test the BLL expressions are a little slower (roughly 10% on average,
less than 14% in all cases)
than the corresponding hand-written function objects.
The performance hit is a bit greater with classic STL expressions,
up to 27% for the simplest expressios.
</para><para>
The tests suggest that the BLL does not introduce a loss of performance 
compared to STL function objects.  
With a reasonable optimizing compiler, one should expect the performance characteristics be comparable to using classic STL.
Moreover, with simple expressions the performance can be expected to be close
to that of explicitly written function objects.



Note however, that evaluating a lambda functor consist of a sequence of calls to small functions that are declared inline. 
If the compiler fails to actually expand these functions inline, 
the performance can suffer. 
The running time can more than double if this happens.
Although the above tests do not include such an expression, we have experienced
this for some seemingly simple expressions.


<table id="table:increasing_arithmetic_test"><title>Test 1</title><caption>CPU time of expressions with integer multiplication written as a lambda expression and as a traditional hand-coded function object class. 
The running times are expressed in arbitrary units.</caption><tgroup cols="3"><thead><row><entry>expression</entry><entry>lambda expression</entry><entry>hand-coded function object</entry></row></thead><tbody><row><entry>x</entry><entry>240</entry><entry>230</entry></row><row><entry>x*x</entry><entry>340</entry><entry>350</entry></row><row><entry>x*x*x</entry><entry>770</entry><entry>760</entry></row><row><entry>x*x*x*x</entry><entry>1180</entry><entry>1210</entry></row><row><entry>x*x*x*x*x</entry><entry>1950</entry><entry>1910</entry></row></tbody></tgroup></table></para><para><table id="table:ll_vs_stl_test"><title>Test 2</title><caption>CPU time of arithmetic expressions written as lambda 
expressions, as classic STL unnamed functions (using <literal>compose2</literal>, <literal>bind1st</literal> etc.) and as traditional hand-coded function object classes. 
Using BLL terminology, 
<literal>a</literal> and <literal>b</literal> are bound arguments in the expressions, and <literal>x</literal> is open. 
All variables were of types <literal>double</literal>.
The running times are expressed in arbitrary units.</caption><tgroup cols="4"><thead><row><entry>expression</entry><entry>lambda expression</entry><entry>classic STL expression</entry><entry>hand-coded function object</entry></row></thead><tbody><row><entry>ax</entry><entry>330</entry><entry>370</entry><entry>290</entry></row><row><entry>-ax</entry><entry>350</entry><entry>370</entry><entry>310</entry></row><row><entry>ax-(a+x)</entry><entry>470</entry><entry>500</entry><entry>420</entry></row><row><entry>(ax-(a+x))(a+x)</entry><entry>620</entry><entry>670</entry><entry>600</entry></row><row><entry>((ax) - (a+x))(bx - (b+x))(ax - (b+x))(bx - (a+x))</entry><entry>1660</entry><entry>1660</entry><entry>1460</entry></row></tbody></tgroup></table></para><para>Some additional performance testing with an earlier version of the
library is described
<xref linkend="cit:jarvi:00"/>.
</para></section><section><title>About compiling</title><para>The BLL uses templates rather heavily, performing numerous recursive instantiations of the same templates. 
This has (at least) three implications:
<itemizedlist><listitem><para>
While it is possible to write incredibly complex lambda expressions, it probably isn't a good idea. 
Compiling such expressions may end up requiring a lot of memory 
at compile time, and being slow to compile.
</para></listitem><listitem><para>
The types of lambda functors that result from even the simplest lambda expressions are cryptic. 
Usually the programmer doesn't need to deal with the lambda functor types at all, but in the case of an error in a lambda expression, the compiler usually outputs the types of the lambda functors involved. 
This can make the error messages very long and difficult to interpret, particularly if the compiler outputs the whole chain of template instantiations.
</para></listitem><listitem><para>
The C++ Standard suggests a template nesting level of 17 to help detect infinite recursion. 
Complex lambda templates can easily exceed this limit. 
Most compilers allow a greater number of nested templates, but commonly require the limit explicitly increased with a command line argument.
</para></listitem></itemizedlist></para></section><section><title>Portability</title><para>
The BLL works with the following compilers, that is, the compilers are capable of compiling the test cases that are included with the BLL:

      <itemizedlist><listitem>GCC 3.0.4
	</listitem><listitem>KCC 4.0f with EDG 2.43.1
	</listitem><listitem>GCC 2.96 (fails with one test case, the <filename>exception_test.cpp</filename> results in an internal compiler error.
)

	</listitem></itemizedlist></para><section><title>Test coverage</title><para>The following list describes the test files included and the features that each file covers:

<itemizedlist><listitem><para><filename>bind_tests_simple.cpp</filename> : Bind expressions of different arities and types of target functions: function pointers, function objects and member functions.
Function composition with bind expressions.</para></listitem><listitem><para><filename>bind_tests_simple_function_references.cpp</filename> :
Repeats all tests from <filename moreinfo="none">bind_tests_simple.cpp</filename> where the target function is a function pointer, but uses function references instead.
</para></listitem><listitem><para><filename>bind_tests_advanced.cpp</filename> : Contains tests for nested bind expressions, <literal>unlambda</literal>, <literal>protect</literal>, <literal>const_parameters</literal> and <literal>break_const</literal>.
Tests passing lambda functors as actual arguments to other lambda functors, currying, and using the <literal>sig</literal> template to specify the return type of a function object.
</para></listitem><listitem><para><filename>operator_tests_simple.cpp</filename> :
Tests using all operators that are overloaded for lambda expressions, that is, unary and binary arithmetic, 
bitwise, 
comparison, 
logical,
increment and decrement, 
compound, 
assignment,
subscrict, 
address of,
dereference, and comma operators.
The streaming nature of shift operators is tested, as well as pointer arithmetic with plus and minus operators.
</para></listitem><listitem><para><filename>member_pointer_test.cpp</filename> : The pointer to member operator is complex enough to warrant a separate test file.
</para></listitem><listitem><para><filename>control_structures.cpp</filename> :
Tests for the looping and if constructs.
</para></listitem><listitem><para><filename>switch_construct.cpp</filename> :
Includes tests for all supported arities of the switch statement, both with and without the default case.
</para></listitem><listitem><para><filename>exception_test.cpp</filename> :
Includes tests for throwing exceptions and for try/catch constructs with varying number of catch blocks.
</para></listitem><listitem><para><filename>constructor_tests.cpp</filename> :
Contains tests for <literal>constructor</literal>, <literal>destructor</literal>, <literal>new_ptr</literal>, <literal>delete_ptr</literal>, <literal>new_array</literal> and <literal>delete_array</literal>.
</para></listitem><listitem><para><filename>cast_test.cpp</filename> : Tests for the four cast expressions, as well as <filename>typeid</filename> and <literal>sizeof</literal>.
</para></listitem><listitem><para><filename>extending_return_type_traits.cpp</filename> : Tests extending the return type deduction system for user defined types.
Contains several user defined operators and the corresponding specializations for the return type deduction templates.
</para></listitem><listitem><para><filename>is_instance_of_test.cpp</filename> : Includes tests for an internally used traits template, which can detect whether a given type is an instance of a certain template or not. 
</para></listitem><listitem><para><filename>bll_and_function.cpp</filename> :
Contains tests for using <literal>boost::function</literal> together with lambda functors.
</para></listitem></itemizedlist></para></section></section></section><section><title>Relation to other Boost libraries</title><section><title>Boost Function</title><para>Sometimes it is convenient to store lambda functors in variables.
However, the types of even the simplest lambda functors are long and unwieldy, and it is in general unfeasible to declare variables with lambda functor types.
<emphasis>The Boost Function library</emphasis><xref linkend="cit:boost::function"/> defines wrappers for arbitrary function objects, for example 
lambda functors; and these wrappers have types that are easy to type out.

For example:

<programlisting>
boost::function&lt;int(int, int)&gt; f = _1 + _2;
boost::function&lt;int&amp;(int&amp;)&gt; g = (_1 += 10);
int i = 1, j = 2;
f(i, j); // returns 3
g(i);    // sets i to = 11;
</programlisting>

The return and parameter types of the wrapped function object must be written explicilty as the template argument to the wrapper template <literal>boost::function</literal>; even when lambda functors, which otherwise have generic parameters, are wrapped.
Wrapping a function object with <literal>boost::function</literal> introduces a performance cost comparable to virtual function dispatch, though virtual functions are not actually used.

Note that storing lambda functors inside <literal>boost::function</literal> 
introduces a danger.
Certain types of lambda functors may store references to the bound 
arguments, instead as taking copies of the arguments of the lambda expression.
When temporary lambda functor objects are used 
in STL algorithm invocations this is always safe, as the lambda functor gets 
destructed immediately after the STL algortihm invocation is completed.

However, a lambda functor wrapped inside <literal>boost::function</literal> 
may continue to exist longer, creating the possibility of dangling references.
For example:

<programlisting>
int* sum = new int();
*sum = 0;
boost::function&lt;int&amp;(int)&gt; counter = *sum += _1;
counter(5); // ok, *sum = 5;
delete sum; 
counter(3); // error, *sum does not exist anymore
</programlisting></para></section><section><title>Boost Bind</title><para><emphasis>The Boost Bind</emphasis><xref linkend="cit:boost::bind"/> library has partially overlapping functionality with the BLL. 
Basically, the Boost Bind library (BB in the sequel) implements the bind expression part of BLL.
There are, however, some semantical differerences.
</para><para>
The BLL and BB evolved separately, and have different implementations. 
This means that the bind expressions from the BB cannot be used within 
bind expressions, or within other type of lambda expressions, of the BLL.
The same holds for using BLL bind expressions in the BB.
The libraries can coexist, however, as
the names of the BB library are in <literal>boost</literal> namespace, 
whereas the BLL names are in <literal>boost::lambda</literal> namespace.
</para><para>
The BLL requires a compiler that is reasonably conformant to the 
C++ standard, whereas the BB library is more portable, and works with 
a larger set of compilers. 
</para><para>
The following two sections describe what are the semantic differences 
between the bind expressions in BB and BLL.
</para><section><title>First argument of bind expression</title>

In BB the first argument of the bind expression, the target function, 
is treated differently from the other arguments, 
as no argument substitution takes place within that argument.
In BLL the first argument is not a special case in this respect.

For example:

<programlisting>
template&lt;class F&gt;
int foo(const F&amp; f) {
  int x;
  ..
  bind(f, _1)(x);
  ...
}
</programlisting><programlisting>
int bar(int, int);
nested(bind(bar, 1, _1));
</programlisting>

The bind expression inside <literal>foo</literal> becomes:
<programlisting>
bind(bind(bar, 1, _1), _1)(x)
</programlisting>

The BLL interpretes this as:
<programlisting>
bar(1, x)(x)
</programlisting>
whereas the BB library as
<programlisting>
bar(1, x)
</programlisting>

To get this functionality in BLL, the bind expression inside the <literal moreinfo="none">foo</literal> function can be written as:
<programlisting>
bind(unlambda(f), _1)(x);
</programlisting>
as explained in <xref linkend="lambda.unlambda"/>. 

</section><para>
The BB library supports up to nine placeholders, while the BLL 
defines only three placeholders. 
The rationale for not providing more, is that the highest arity of the
function objects accepted by any STL algorithm is two. 
The placeholder count is easy to increase in the BB library.
In BLL it is possible, but more laborous.
The BLL currently passes the actual arguments to the lambda functors
internally just as they are and does not wrap them inside a tuple object.
The reason for this is that some widely used compilers are not capable
of optimizing the intermediate tuple objects away. 
The creation of the intermediate tuples would cause a significant
performance hit, particularly for the simplest (and thus the most common) 
lambda functors.  
We are working on a hybrid approach, which will allow more placeholders
but not compromise the performance of simple lambda functors.
</para></section></section><section><title>Contributors</title>

The main body of the library was written by Jaakko J&#xE4;rvi and Gary Powell.
We've got outside help, suggestions and ideas from Jeremy Siek, Peter Higley, Peter Dimov, Valentin Bonnard, William Kempf.
We would particularly like to mention Joel de Guzmann and his work with 
Phoenix which has influenced BLL significantly, making it considerably simpler 
to extend the library with new features.

</section><appendix><title>Rationale for some of the design decisions</title><section id="lambda.why_weak_arity"><title>
Lambda functor arity
</title><para>
The highest placeholder index in a lambda expression determines the arity of the resulting function object.
However, this is just the minimal arity, as the function object can take arbitrarily many arguments; those not needed are discarded.
Consider the two bind expressions and their invocations below:

<programlisting>
bind(g, _3, _3, _3)(x, y, z); 
bind(g, _1, _1, _1)(x, y, z); 
</programlisting>

This first line discards arguments <literal>x</literal> and
<literal>y</literal>, and makes the call:
<programlisting>
g(z, z, z) 
</programlisting>
whereas the second line discards arguments <literal>y</literal> and
<literal>z</literal>, and calls:
<programlisting>
g(x, x, x)
</programlisting>
In earlier versions of the library, the latter line resulted in a compile 
time error.

This is basically a tradeoff between safety and flexibility, and the issue
was extensively discussed during the Boost review period of the library.
The main points for the <emphasis>strict arity</emphasis> checking
was that it might
catch a programming error at an earlier time and that a lambda expression that
explicitly discards its arguments is easy to write:
<programlisting>
(_3, bind(g, _1, _1, _1))(x, y, z);
</programlisting>
This lambda expression takes three arguments.
The left-hand argument of the comma operator does nothing, and as comma 
returns the result of evaluating the right-hand argument we end up with 
the call
<literal>g(x, x, x)</literal>
even with the strict arity.
</para><para>
The main points against the strict arity checking were that the need to 
discard arguments is commonplace, and should therefore be straightforward, 
and that strict arity checking does not really buy that much more safety, 
particularly as it is not symmetric.
For example, if the programmer wanted to write the expression 
<literal>_1 + _2</literal> but mistakenly wrote <literal>_1 + 2</literal>, 
with strict arity checking, the complier would spot the error.
However, if the erroneous expression was <literal>1 + _2</literal> instead,
the error would go unnoticed.
Furthermore, weak arity checking simplifies the implementation a bit.
Following the recommendation of the Boost review, strict arity checking 
was dropped.
</para></section></appendix><bibliography><biblioentry id="cit:stepanov:94"><abbrev>STL94</abbrev><authorgroup><author><surname>Stepanov</surname><firstname>A. A.</firstname></author><author><surname>Lee</surname><firstname>M.</firstname></author></authorgroup><title>The Standard Template Library</title><orgname>Hewlett-Packard Laboratories</orgname><pubdate>1994</pubdate><bibliomisc><ulink url="http://www.hpl.hp.com/techreports">www.hpl.hp.com/techreports</ulink></bibliomisc></biblioentry><biblioentry id="cit:sgi:02"><abbrev>SGI02</abbrev><title>The SGI Standard Template Library</title><pubdate>2002</pubdate><bibliomisc><ulink url="http://www.sgi.com/tech/stl/">www.sgi.com/tech/stl/</ulink></bibliomisc></biblioentry><biblioentry id="cit:c++:98"><abbrev>C++98</abbrev><title>International Standard, Programming Languages &#x2013; C++</title><subtitle>ISO/IEC:14882</subtitle><pubdate>1998</pubdate></biblioentry><biblioentry id="cit:jarvi:99"><abbrev>J&#xE4;r99</abbrev><articleinfo><author><surname>J&#xE4;rvi</surname><firstname>Jaakko</firstname></author><title>C++ Function Object Binders Made Easy</title></articleinfo><title>Lecture Notes in Computer Science</title><volumenum>1977</volumenum><publishername>Springer</publishername><pubdate>2000</pubdate></biblioentry><biblioentry id="cit:jarvi:00"><abbrev>J&#xE4;r00</abbrev><author><surname>J&#xE4;rvi</surname><firstname>Jaakko</firstname></author><author><firstname>Gary</firstname><surname>Powell</surname></author><title>The Lambda Library : Lambda Abstraction in C++</title><orgname>Turku Centre for Computer Science</orgname><bibliomisc>Technical Report </bibliomisc><issuenum>378</issuenum><pubdate>2000</pubdate><bibliomisc><ulink url="http://www.tucs.fi/Publications/techreports/TR378.php">www.tucs.fi/publications</ulink></bibliomisc></biblioentry><biblioentry id="cit:jarvi:01"><abbrev>J&#xE4;r01</abbrev><author><surname>J&#xE4;rvi</surname><firstname>Jaakko</firstname></author><author><firstname>Gary</firstname><surname>Powell</surname></author><title>The Lambda Library : Lambda Abstraction in C++</title><confgroup><conftitle>Second  Workshop on C++ Template Programming</conftitle><address>Tampa Bay, OOPSLA'01</address></confgroup><pubdate>2001</pubdate><bibliomisc><ulink url="http://www.oonumerics.org/tmpw01/">www.oonumerics.org/tmpw01/</ulink></bibliomisc></biblioentry><biblioentry id="cit:jarvi:03"><abbrev>J&#xE4;r03</abbrev><articleinfo><author><surname>J&#xE4;rvi</surname><firstname>Jaakko</firstname></author><author><firstname>Gary</firstname><surname>Powell</surname></author><author><firstname>Andrew</firstname><surname>Lumsdaine</surname></author><title>The Lambda Library : unnamed functions in C++</title></articleinfo><title>Software - Practice and Expreience</title><volumenum>33:259-291</volumenum><pubdate>2003</pubdate></biblioentry><biblioentry id="cit:boost::tuple"><abbrev>tuple</abbrev><title>The Boost Tuple Library</title><bibliomisc><ulink url="http://www.boost.org/libs/tuple/doc/tuple_users_guide.html">www.boost.org/libs/tuple/doc/tuple_users_guide.html</ulink></bibliomisc><pubdate>2002</pubdate></biblioentry><biblioentry id="cit:boost::type_traits"><abbrev>type_traits</abbrev><title>The Boost type_traits</title><bibliomisc><ulink url="http://www.boost.org/libs/type_traits/index.htm">www.boost.org/libs/type_traits/</ulink></bibliomisc><pubdate>2002</pubdate></biblioentry><biblioentry id="cit:boost::ref"><abbrev>ref</abbrev><title>Boost ref</title><bibliomisc><ulink url="http://www.boost.org/libs/bind/ref.html">www.boost.org/libs/bind/ref.html</ulink></bibliomisc><pubdate>2002</pubdate></biblioentry><biblioentry id="cit:boost::bind"><abbrev>bind</abbrev><title>Boost Bind Library</title><bibliomisc><ulink url="http://www.boost.org/libs/bind/bind.html">www.boost.org/libs/bind/bind.html</ulink></bibliomisc><pubdate>2002</pubdate></biblioentry><biblioentry id="cit:boost::function"><abbrev>function</abbrev><title>Boost Function Library</title><bibliomisc><ulink url="http://www.boost.org/libs/function/">www.boost.org/libs/function/</ulink></bibliomisc><pubdate>2002</pubdate></biblioentry><biblioentry id="cit:fc++"><abbrev>fc++</abbrev><title>The FC++ library: Functional Programming in C++</title><author><surname>Smaragdakis</surname><firstname>Yannis</firstname></author><author><firstname>Brian</firstname><surname>McNamara</surname></author><bibliomisc><ulink url="http://www.cc.gatech.edu/~yannis/fc++/">www.cc.gatech.edu/~yannis/fc++/</ulink></bibliomisc><pubdate>2002</pubdate></biblioentry></bibliography></chapter><chapter xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="program_options" rev:last-revision="$Date: 2004/07/30 13:20:27 $"><chapterinfo><author><firstname>Vladimir</firstname><surname>Prus</surname></author><copyright><year>2002</year><year>2003</year><year>2004</year><holder>Vladimir Prus</holder></copyright><legalnotice><para>Distributed under the Boost Software License, Version 1.0.
      (See accompanying file <filename>LICENSE_1_0.txt</filename> or copy at 
      <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
      </para></legalnotice></chapterinfo><title>Boost.Program_options</title><section><title>Introduction</title><para>The program_options library allows program developers to obtain
    <emphasis>program options</emphasis>, that is (name, value) pairs from the user,
    via conventional methods such as command line and config file.</para><para>Why would you use such a library, and why is it better than parsing
    your command line by straightforward hand-written code?
      <itemizedlist><listitem><para>It's easier. The syntax for declaring options is simple, and
          the library itself is small. Things like conversion of option values to
          desired type and storing into program variables are handled
          automatically.
          </para></listitem><listitem><para>Error reporting is better. All the problems with the command line are
            reported, while hand-written code can just misparse the input. In
            addition, the usage message can be automatically generated, to
            avoid falling out of sync with the real list of options.</para></listitem><listitem><para>Options can be read from anywhere. Sooner or later the command
          line will be not enough for your users, and you'll want config files
          or maybe even environment variables. These can be added without significant 
          effort on your part.
          </para></listitem></itemizedlist></para><para>
      Now let's see some examples of the library usage in the <xref linkend="program_options.tutorial"/>.
    </para></section><section id="program_options.tutorial" xml:base="../libs/program_options/doc/tutorial.xml"><title>Tutorial</title><para>In this section, we'll take a look at the most common usage scenarios
  of the program_options library, starting with the simplest one. The examples
  show only the interesting code parts, but the complete programs can be found
  in the "BOOST_ROOT/libs/program_options/example" directory. Through all the
  examples, we'll assume that the following namespace alias is in effect:
<programlisting>namespace po = boost::program_options;</programlisting></para><section><title>Getting Started</title><para>The first example is the simplest possible: it only handles two
    options. Here's the source code (the full program is in
    "example/first.cpp"):

<programlisting>
// Declare the supported options.
po::options_description desc("Allowed options");
desc.add_options()
    ("help", "produce help message")
    ("compression", po::value&lt;int&gt;(), "set compression level")
;

po::variables_map vm;
po::store(po::parse_command_line(ac, av, desc), vm);
po::notify(vm);    

if (vm.count("help")) {
    cout &lt;&lt; desc &lt;&lt; "\n";
    return 1;
}

if (vm.count("compression")) {
    cout &lt;&lt; "Compression level was set to " 
 &lt;&lt; vm["compression"].as&lt;int&gt;() &lt;&lt; ".\n";
} else {
    cout &lt;&lt; "Compression level was not set.\n";
}
</programlisting></para><para>We start by declaring all allowed options using the
    <link linkend="options_description">options_description</link> class. The <computeroutput>add_options</computeroutput> method of that
    class returns a special proxy object that defines
    <computeroutput>operator()</computeroutput>. Calls to that operator actually declare
    options. The parameters are option name, information about value, and option
    description. In this example, the first option has no value, and the second
    one has a value of type <computeroutput>int</computeroutput>.
  </para><para>After that, an object of class <computeroutput>variables_map</computeroutput> is
    declared. That class is intended to store values of options, and can store
    values of arbitrary types. Next, the calls to <computeroutput>store</computeroutput>,
    <computeroutput>parse_command_line</computeroutput> and <computeroutput>notify</computeroutput> functions cause
    <computeroutput>vm</computeroutput> to contain all the options found on the command
    line.</para><para>And now, finally, we can use the options as we like. The
    <computeroutput>variables_map</computeroutput> class can be used just like
    <computeroutput>std::map</computeroutput>, except that values stored there must be retrieved
    with the <computeroutput>as</computeroutput> method shown above. (If the type specified in the
    call to the <computeroutput>as</computeroutput> method is different from the actually stored
    type, an exception is thrown.)
  </para><para>It's now a good time to try compiling the code yourself, but if
    you're not yet ready, here's an example session:
<screen>
$bin/gcc/debug/first
Compression level was not set.
$bin/gcc/debug/first --help
Allowed options:
  --help                 : produce help message
  --compression arg      : set compression level

$bin/gcc/debug/first --compression 10
Compression level was set to 10.
    </screen></para></section><section><title>Option Details</title><para>An option value, surely, can have other types than <computeroutput>int</computeroutput>, and
  can have other interesting properties, which we'll discuss right now. The
  complete version of the code snipped below can be found in
  "example/options_description.cpp".</para><para>Imagine we're writing a compiler. It should take the optimization
    level, a number of include paths, and a number of input files, and perform some
    interesting work. Let's describe the options:
    <programlisting>
int opt;
po::options_description desc("Allowed options");
desc.add_options()
    ("help", "produce help message")
    ("optimization", po::value&lt;int&gt;(&amp;opt)-&gt;default_value(10), 
  "optimization level")
    ("include-path,I", po::value&lt; vector&lt;string&gt; &gt;(), 
  "include path")
    ("input-file", po::value&lt; vector&lt;string&gt; &gt;(), "input file")
;
</programlisting></para><para>The "--help" option should be familiar from the previous example. 
    It's a good idea to have this option in all cases.</para><para>The "optimization" option shows two new features. First, we specify
    the address of the variable(<computeroutput>&amp;opt</computeroutput>). After storing values, that
    variable will have the value of the option. Second, we specify a default
    value of 10, which will be used if no value is specified by the user.
  </para><para>The "include-path" option is an example of the only case where
    the interface of the <computeroutput>options_description</computeroutput> class serves only one
    source -- the command line. Users typically like to use short option names
    for common options, and the "include-path,I" name specifies that short
    option name is "I". So, both "--include-path" and "-I" can be used.
  </para><para>The "input-file" option specifies the list of files to
    process. That's okay for a start, but, of course, writing something like:
    <screen>
compiler --input-file=a.cpp
    </screen>
    is a little non-standard, compared with
    <screen>
compiler a.cpp
    </screen>
    We'll address this in a moment.
  </para><para>
    The command line tokens which have no option name, as above, are
    called "positional options" by this library. They can be handled
    too. With a little help from the user, the library can decide that "a.cpp"
    really means the same as "--input-file=a.cpp". Here's the additional code
    we need:
    <programlisting>
po::positional_options_description p;
p.add("input-file", -1);

po::variables_map vm;
po::store(po::command_line_parser(ac, av).
          options(desc).positional(p).run(), vm);
po::notify(vm);
    </programlisting></para><para>
    The first two lines say that all positional options should be translated
    into "input-file" options. Also note that we use the
    command_line_parser class to parse the command
    line, not the <link linkend="parse_command_line">parse_command_line</link>
    function. The latter is a convenient wrapper for simple cases, but now we
    need to pass additional information.
  </para><para>By now, all options are described and parsed. We'll save ourselves the
      trouble of implementing the rest of the compiler logic and only print the
      options:
    <programlisting>
if (vm.count("include-path"))
{
    cout &lt;&lt; "Include paths are: " 
         &lt;&lt; vm["include-path"].as&lt; vector&lt;string&gt; &gt;() &lt;&lt; "\n";
}

if (vm.count("input-file"))
{
    cout &lt;&lt; "Input files are: " 
         &lt;&lt; vm["input-file"].as&lt; vector&lt;string&gt; &gt;() &lt;&lt; "\n";
}

cout &lt;&lt; "Optimization level is " &lt;&lt; opt &lt;&lt; "\n";                
</programlisting></para><para>Here's an example session:
    <screen>
$bin/gcc/debug/options_description --help
Usage: options_description [options]
Allowed options:
  --help                 : produce help message
  --optimization arg     : optimization level
  -I [ --include-path ] arg : include path
  --input-file arg       : input file
$bin/gcc/debug/options_description
Optimization level is 10
$bin/gcc/debug/options_description --optimization 4 -I foo a.cpp
Include paths are: foo
Input files are: a.cpp
Optimization level is 4
</screen></para><para>
    Oops, there's a slight problem. It's still possible to specify the
    "--input-file" option, and usage message says so, which can be confusing
    for the user. It would be nice to hide this information, but let's wait
    for the next example.
  </para></section><section><title>Multiple Sources</title><para>It's quite likely that specifying all options to our compiler on the
    command line will annoy users. What if a user installs a new library and
    wants to always pass an additional command line element? What if he has
    made some choices which should be applied on every run? It's desirable to
    create a config file with common settings which will be used together with
    the command line.
    </para><para>Of course, there will be a need to combine the values from command
    line and config file. For example, the optimization level specified on the
    command line should override the value from the config file. On the other
    hand, include paths should be combined.
    </para><para>Let's see the code now. The complete program is in
      "examples/multiple_sources.cpp". The option definition has two interesting
      details. First, we declare several instances of the
      <computeroutput>options_description</computeroutput> class. The reason is that, in general,
      not all options are alike. Some options, like "input-file" above, should
      not be presented in an automatic help message. Some options make sense only
      in the config file. Finally, it's nice to have some structure in the help message,
      not just a long list of options. Let's declare several option groups:
      <programlisting>
// Declare a group of options that will be 
// allowed only on command line
po::options_description generic("Generic options");
generic.add_options()
    ("version,v", "print version string")
    ("help", "produce help message")    
    ;
    
// Declare a group of options that will be 
// allowed both on command line and in
// config file
po::options_description config("Configuration");
config.add_options()
    ("optimization", po::value&lt;int&gt;(&amp;opt)-&gt;default_value(10), 
          "optimization level")
    ("include-path,I", 
         po::value&lt; vector&lt;string&gt; &gt;()-&gt;composing(), 
         "include path")
    ;

// Hidden options, will be allowed both on command line and
// in config file, but will not be shown to the user.
po::options_description hidden("Hidden options");
hidden.add_options()
    ("input-file", po::value&lt; vector&lt;string&gt; &gt;(), "input file")
    ;        
</programlisting>
      Note the call to the <computeroutput>composing</computeroutput> method in the declaration of the
      "include-path" option. It tells the library that values from different sources
      should be composed together, as we'll see shortly.
    </para><para>    
      The <computeroutput>add</computeroutput> method of the <computeroutput>options_description</computeroutput>
      class can be used to further group the options:
      <programlisting>
po::options_description cmdline_options;
cmdline_options.add(generic).add(config).add(hidden);

po::options_description config_file_options;
config_file_options.add(config).add(hidden);

po::options_description visible("Allowed options");
visible.add(generic).add(config);
      </programlisting></para><para>The parsing and storing of values follows the usual pattern, except that
      we additionally call parse_config_file, and
      call the <link linkend="id281355">store</link> function twice. But what
      happens if the same value is specified both on the command line and in
      config file? Usually, the value stored first is preferred. This is what
      happens for the "--optimization" option. For "composing" options, like
      "include-file", the values are merged.
    </para><para>Here's an example session:
<screen>
$bin/gcc/debug/multiple_sources
Include paths are: /opt
Optimization level is 1
$bin/gcc/debug/multiple_sources --help
Allows options:

Generic options:
  -v [ --version ]       : print version string
  --help                 : produce help message

Configuration:
  --optimization n       : optimization level
  -I [ --include-path ] path : include path

$bin/gcc/debug/multiple_sources --optimization=4 -I foo a.cpp b.cpp
Include paths are: foo /opt
Input files are: a.cpp b.cpp
Optimization level is 4
</screen>
      The first invocation uses values from the configuration file. The second
      invocation also uses values from command line. As we see, the include
      paths on the command line and in the configuration file are merged,
      while optimization is taken from the command line.
    </para></section></section><section id="program_options.overview" xml:base="../libs/program_options/doc/overview.xml"><title>Library Overview</title><para>In the tutorial section, we saw several examples of library usage.
    Here we will describe the overall library design including the primary
    components and their function.
  </para><para>The library has three main components:
    <itemizedlist><listitem><para>The options description component, which describes the allowed options
          and what to do with the values of the options.
        </para></listitem><listitem><para>The parsers component, which uses this information to find option names
          and values in the input sources and return them. 
        </para></listitem><listitem><para>The storage component, which provides the
          interface to access the value of an option. It also converts the string
          representation of values that parsers return into desired C++ types.
        </para></listitem></itemizedlist></para><para>To be a little more concrete, the <computeroutput>options_description</computeroutput>
  class is from the options description component, the
  <computeroutput>parse_command_line</computeroutput> function is from the parsers component, and the
  <computeroutput>variables_map</computeroutput> class is from the storage component. </para><para>In the tutorial we've learned how those components can be used by the
    <computeroutput>main</computeroutput> function to parse the command line and config
    file. Before going into the details of each component, a few notes about
    the world outside of <computeroutput>main</computeroutput>.
  </para><para>
    For that outside world, the storage component is the most important. It
    provides a class which stores all option values and that class can be
    freely passed around your program to modules which need access to the
    options. All the other components can be used only in the place where
    the actual parsing is the done.  However, it might also make sense for the
    individual program modules to describe their options and pass them to the
    main module, which will merge all options. Of course, this is only
    important when the number of options is large and declaring them in one
    place becomes troublesome.
  </para><section><title>Options Description Component</title><para>The options description component has three main classes:
      <link linkend="option_description">option_description</link>, <link linkend="value_semantic">value_semantic</link> and <link linkend="options_description">options_description</link>. The
      first two together describe a single option. The <link linkend="option_description">option_description</link>
      class contains the option's name, description and a pointer to <link linkend="value_semantic">value_semantic</link>,
      which, in turn, knows the type of the option's value and can parse the value,
      apply the default value, and so on. The <link linkend="options_description">options_description</link> class is a
      container for instances of <link linkend="option_description">option_description</link>.
    </para><para>For almost every library, those classes could be created in a
      conventional way: that is, you'd create new options using constructors and
      then call the <computeroutput>add</computeroutput> method of <link linkend="options_description">options_description</link>. However,
      that's overly verbose for declaring 20 or 30 options. This concern led
      to creation of the syntax that you've already seen:
<programlisting>
options_description desc;
desc.add_options()
    ("help", "produce help")
    ("optimization", value&lt;int&gt;()-&gt;default_value(10), "optimization level")
    ;
</programlisting></para><para>The call to the <computeroutput>value</computeroutput> function creates an instance of
      a class derived from the <computeroutput>value_semantic</computeroutput> class: <computeroutput>typed_value</computeroutput>.
      That class contains the code to parse
      values of a specific type, and contains a number of methods which can be
      called by the user to specify additional information. (This
      essentially emulates named parameters of the constructor.) Calls to
      <computeroutput>operator()</computeroutput> on the object returned by <computeroutput>add_options</computeroutput>
      forward arguments to the constructor of the <computeroutput>option_description</computeroutput>
      class and add the new instance. 
    </para><para>
      Note that in addition to the
      <computeroutput>value</computeroutput>, library provides the <computeroutput>bool_switch</computeroutput>
      function, and user can write his own function which will return
      other subclasses of <computeroutput>value_semantic</computeroutput> with 
      different behaviour. For the remainder of this section, we'll talk only
      about the <computeroutput>value</computeroutput> function.
    </para><para>The information about an option is divided into syntactic and
      semantic. Syntactic information includes the name of the option and the
      number of tokens which can be used to specify the value. This
      information is used by parsers to group tokens into (name, value) pairs,
      where value is just a vector of strings
      (<computeroutput>std::vector&lt;std::string&gt;</computeroutput>). The semantic layer
      is responsible for converting the value of the option into more usable C++
      types. 
    </para><para>This separation is an important part of library design. The parsers
      use only the syntactic layer, which takes away some of the freedom to
      use overly complex structures. For example, it's not easy to parse
      syntax like: <screen>calc --expression=1 + 2/3</screen> because it's not
      possible to parse <screen>1 + 2/3</screen> without knowing that it's a C
      expression. With a little help from the user the task becomes trivial,
      and the syntax clear: <screen>calc --expression="1 + 2/3"</screen></para><section><title>Syntactic information</title><para>The syntactic information is provided by the
        <link linkend="options_description">boost::program_options::options_description</link> class
        and some methods of the
        <link linkend="value_semantic">boost::program_options::value_semantic</link> class.
        The simplest usage is illustrated below:
        <programlisting>
          options_description desc;
          desc.add_options()
          ("help", "produce help message")
          ;
        </programlisting>
        This declares one option named "help" and associates a description with
        it. The user is not allowed to specify any value.
      </para><para>To make an option accept a value, you'd need the
        <computeroutput>value</computeroutput> function mentioned above:
        <programlisting>
          options_description desc;
          desc.add_options()
          ("compression", "compression level", value&lt;string&gt;())
          ("verbose", "verbosity level", value&lt;string&gt;()-&gt;implicit())
          ("email", "email to send to", value&lt;string&gt;()-&gt;multitoken());
        </programlisting>
        With these declarations, the user must specify a value for
        the first option, using a single token. For the second option, the user
        may either provide a single token for the value, or no token at
        all. For the last option, the value can span several tokens. For
        example, the following command line is OK:
        <screen>
          test --compression 10 --verbose --email beadle@mars beadle2@mars
        </screen></para></section><section><title>Semantic information</title><para>The semantic information is completely provided by the 
        <link linkend="value_semantic">boost::program_options::value_semantic</link> class. For
        example:
<programlisting>
options_description desc;
desc.add_options()
    ("compression", "compression level", value&lt;int&gt;()-&gt;default(10));
    ("email", "email", value&lt; vector&lt;string&gt; &gt;()
        -&gt;composing()-&gt;notify(&amp;your_function);
</programlisting>      
        These declarations specify that default value of the first option is 10,
        that the second option can appear several times and all instances should
        be merged, and that after parsing is done, the library will  call
        function <computeroutput>&amp;your_function</computeroutput>, passing the value of the
        "email" option as argument.      
      </para></section><section><title>Positional options</title><para>Our definition of option as (name, value) pairs is simple and
        useful, but in one special case of the command line, there's a
        problem. A command line can include a <firstterm>positional option</firstterm>,
        which does not specify any name at all, for example:
        <screen>
          archiver --compression=9 /etc/passwd
        </screen>
        Here, the "/etc/passwd" element does not have any option name.
      </para><para>One solution is to ask the user to extract positional options
        himself and process them as he likes. However, there's a nicer approach
        -- provide a method to automatically assign the names for positional
        options, so that the above command line can be interpreted the same way
        as:
        <screen>
          archiver --compression=9 --input-file=/etc/passwd
        </screen></para><para>The <link linkend="id277022">positional_options_description</link> class allows the command line
        parser to assign the names. The class specifies how many positional options
        are allowed, and for each allowed option, specifies the name. For example:
        <programlisting>
          positional_options_description pd; pd.add("input-file", 1, 1);
        </programlisting> specifies that for exactly one, first, positional
        option the name will be "input-file".
      </para><para>It's possible to specify that a number, or even all positional options, be
        given the same name.
        <programlisting>
          positional_options_description pd;
          pd.add("output-file", 2, 2).add_optional("input-file", 0, -1);
        </programlisting>
        In the above example, the first two positional options will be associated
        with name "output-file", and any others with the name "input-file".
      </para></section></section><section><title>Parsers Component</title><para>The parsers component splits input sources into (name, value) pairs.
      Each parser looks for possible options and consults the options
      description component to determine if the option is known and how its value
      is specified. In the simplest case, the name is explicitly specified,
      which allows the library to decide if such option is known. If it is known, the
      <link linkend="value_semantic">value_semantic</link> instance determines how the value is specified. (If
      it is not known, an exception is thrown.) Common
      cases are when the value is explicitly specified by the user, and when
      the value cannot be specified by the user, but the presence of the
      option implies some value (for example, <computeroutput>true</computeroutput>). So, the
      parser checks that the value is specified when needed and not specified
      when not needed, and returns new (name, value) pair.
    </para><para>
      To invoke a parser you typically call a function, passing the options
      description and command line or config file or something else.
      The results of parsing are returned as an instance of the parsed_options
      class. Typically, that object is passed directly to the storage
      component. However, it also can be used directly, or undergo some additional
      processing. 
    </para><para>
      There are three exceptions to the above model -- all related to
      traditional usage of the command line. While they require some support
      from the options description component, the additional complexity is
      tolerable.
      <itemizedlist><listitem><para>The name specified on the command line may be
            different from the option name -- it's common to provide a "short option
            name" alias to a longer name. It's also common to allow an abbreviated name
            to be specified on the command line.
          </para></listitem><listitem><para>Sometimes it's desirable to specify value as several
          tokens. For example, an option "--email-recipient" may be followed
          by several emails, each as a separate command line token. This
          behaviour is supported, though it can lead to parsing ambiguities
          and is not enabled by default.
          </para></listitem><listitem><para>The command line may contain positional options -- elements
            which don't have any name. The command line parser provides a
            mechanism to guess names for such options, as we've seen in the
            tutorial.
          </para></listitem></itemizedlist></para></section><section><title>Storage Component</title><para>The storage component is responsible for:
      <itemizedlist><listitem><para>Storing the final values of an option into a special class and in
            regular variables</para></listitem><listitem><para>Handling priorities among different sources.</para></listitem><listitem><para>Calling user-specified <computeroutput>notify</computeroutput> functions with the final
         values of options.</para></listitem></itemizedlist></para><para>Let's consider an example:
      <programlisting>
        variables_map vm;
        store(parse_command_line(argc, argv, desc), vm);
        store(parse_config_file("example.cfg", desc), vm);
        notify(vm);
      </programlisting>
      The <computeroutput>variables_map</computeroutput> class is used to store the option
      values. The two calls to the <computeroutput>store</computeroutput> function add values
      found on the command line and in the config file. Finally the call to
      the <computeroutput>notify</computeroutput> function runs the user-specified notify
      functions and stores the values into regular variables, if needed.
    </para><para>The priority is handled in a simple way: the <computeroutput>store</computeroutput>
      function will not change the value of an option if it's already
      assigned. In this case, if the command line specifies the value for an
      option, any value in the config file is ignored.
    </para><warning><para>Don't forget to call the <computeroutput>notify</computeroutput> function after you've
      stored all parsed values.</para></warning></section><section><title>Annotated List of Symbols</title><para>The following table describes all the important symbols in the
      library, for quick access.</para><informaltable pgwide="1"><tgroup cols="2"><colspec colname="c1"/><colspec colname="c2"/><thead><row><entry>Symbol</entry><entry>Description</entry></row></thead><tbody><row><entry namest="c1" nameend="c2">Options description component</entry></row><row><entry><link linkend="options_description">options_description</link></entry><entry>describes a number of options</entry></row><row><entry><link linkend="value">value</link></entry><entry>defines the option's value</entry></row><row><entry namest="c1" nameend="c2">Parsers component</entry></row><row><entry><link linkend="parse_command_line">parse_command_line</link></entry><entry>parses command line</entry></row><row><entry><link linkend="parse_config_file">parse_config_file</link></entry><entry>parses config file</entry></row><row><entry><link linkend="id264411">parse_environment</link></entry><entry>parses environment</entry></row><row><entry namest="c1" nameend="c2">Storage component</entry></row><row><entry><link linkend="variables_map">variables_map</link></entry><entry>storage for option values</entry></row></tbody></tgroup></informaltable></section></section><section id="program_options.howto" xml:base="../libs/program_options/doc/howto.xml"><title>How To</title><para>This section describes how the library can be used in specific
  situations.</para><section><title>Non-conventional Syntax</title><para>Sometimes, standard command line syntaxes are not enough. For
    example, the gcc compiler has "-frtti" and -fno-rtti" options, and this
    syntax is not directly supported.
    </para><indexterm><primary>additional parser</primary></indexterm><para>For such cases, the library allows the user to provide an
    <firstterm>additional parser</firstterm> -- a function which will be called on each
    command line element, before any processing by the library. If the
    additional parser recognises the syntax, it returns the option name and
    value, which are used directly. The above example can be handled by the
    following code:
    </para><para><programlisting>
pair&lt;string, string&gt; reg_foo(const string&amp; s)
{
    if (s.find("-f") == 0) {
        if (s.substr(2, 3) == "no-")
            return make_pair(s.substr(5), string("false"));
        else
            return make_pair(s.substr(2), string("true"));
    } else {
        return make_pair(string(), string());
    }
}
</programlisting>
      Here's the definition of the additional parser. When parsing the command
      line, we pass the additional parser:
<programlisting>
store(command_line_parser(ac, av).options(desc).extra_parser(reg_foo)
        .run(), vm);
</programlisting>
      The complete example can be found in the "example/custom_syntax.cpp"
      file.                
    </para></section><section><title>Response Files</title><indexterm><primary>response files</primary></indexterm><para>Some operating system have very low limits of the command line
      length. The common way to work around those limitations is using
      <firstterm>response files</firstterm>.  A response file is just a
      configuration file which uses the same syntax as the command line. If
      the command line specifies a name of response file to use, it's loaded
      and parsed in addition to the command line.  The library does not
      provide direct support for response files, so you'll need to write some
      extra code.
    </para><para>
      First, you need to define an option for the response file:
<programlisting>
("response-file", value&lt;string&gt;(), 
     "can be specified with '@name', too")
</programlisting></para><para>Second, you'll need an additional parser to support the standard syntax
    for specifying response files: "@file":
<programlisting>
pair&lt;string, string&gt; at_option_parser(string const&amp;s)
{
    if ('@' == s[0])
        return std::make_pair(string("response-file"), s.substr(1));
    else
        return pair&lt;string, string&gt;();
}

</programlisting></para><para>Finally, when the "response-file" option is found, you'll have to
    load that file and pass it to the command line parser. This part is the
    hardest. We'll use the Boost.Tokenizer library, which works but has some
    limitations. You might also consider Boost.StringAlgo. The code is:
<programlisting>
if (vm.count("response-file")) {
     // Load the file and tokenize it
     ifstream ifs(vm["response-file"].as&lt;string&gt;().c_str());
     if (!ifs) {
         cout &lt;&lt; "Could no open the response file\n";
         return 1;
     }
     // Read the whole file into a string
     stringstream ss;
     ss &lt;&lt; ifs.rdbuf();
     // Split the file content
     char_separator&lt;char&gt; sep(" \n\r");
     tokenizer&lt;char_separator&lt;char&gt; &gt; tok(ss.str(), sep);
     vector&lt;string&gt; args;
     copy(tok.begin(), tok.end(), back_inserter(args));
     // Parse the file and store the options
     store(command_line_parser(args).options(desc).run(), vm);     
}

</programlisting>
      The complete example can be found in the "example/response_file.cpp"
      file.                
    </para></section><section><title>Winmain Command Line</title><para>On the Windows operating system, GUI applications receive the
    command line as a single string, not split into elements. For that reason,
    the command line parser cannot be used directly. At least on some
    compilers, it is possible to obtain
    the split command line, but it's not clear if all compilers support the
    same mechanism on all versions of the operating system. The
    <computeroutput>split_command_line</computeroutput> function is a portable mechanism provided
    by the library.</para><para>Here's an example of use:
<programlisting>
vector&lt;string&gt; args = split_winmain(lpCmdLine);
store(command_line_parser(args).options(desc).run(), vm);
</programlisting>      
      The function is an overload for <computeroutput>wchar_t</computeroutput> strings, so can
      also be used in Unicode applications.
    </para></section><section><title>Option Groups and Hidden Options</title><para>Having a single instance of the <link linkend="options_description">options_description</link> class with all
    the program's options can be problematic:
      <itemizedlist><listitem><para>Some options make sense only for specific source, for example,
          configuration files.</para></listitem><listitem><para>The user would prefer some structure in the generated help message.</para></listitem><listitem><para>Some options shouldn't appear in the generated help message at all.</para></listitem></itemizedlist></para><para>To solve the above issues, the library allows a programmer to create several
      instances of the <link linkend="options_description">options_description</link> class, which can be merged in
      different combinations. The following example will define three groups of
      options: command line specific, and two options group for specific program
      modules, only one of which is shown in the generated help message.
    </para><para>Each group is defined using standard syntax. However, you should
      use reasonable names for each <link linkend="options_description">options_description</link> instance:
<programlisting>
options_description general("General options");
general.add_options()
    ("help", "produce a help message")
    ("help-module", value&lt;string&gt;()-&gt;implicit(),
        "produce a help for a given module")
    ("version", "output the version number")
    ;

options_description gui("GUI options");
gui.add_options()
    ("display", value&lt;string&gt;(), "display to use")
    ;

options_description backend("Backend options");
backend.add_options()
    ("num-threads", value&lt;int&gt;(), "the initial number of threads")
    ;
</programlisting></para><para>After declaring options groups, we merge them in two
      combinations. The first will include all options and be used for parsing. The
      second will be used for the "--help" option.
<programlisting>
// Declare an options description instance which will include
// all the options
options_description all("Allowed options");
all.add(general).add(gui).add(backend);

// Declare an options description instance which will be shown
// to the user
options_description visible("Allowed options");
visible.add(general).add(gui);
</programlisting></para><para>What is left is to parse and handle the options:
<programlisting>
variables_map vm;
store(parse_command_line(ac, av, all), vm);

if (vm.count("help")) 
{
    cout &lt;&lt; visible;
    return 0;
}
if (vm.count("help-module")) {
    const string&amp; s = vm["help-module"].as&lt;string&gt;();
    if (s == "gui") {
        cout &lt;&lt; gui;
    } else if (s == "backend") {
        cout &lt;&lt; backend;
    } else {
        cout &lt;&lt; "Unknown module '" 
             &lt;&lt; s &lt;&lt; "' in the --help-module option\n";
        return 1;
    }
    return 0;
}
if (vm.count("num-threads")) {
    cout &lt;&lt; "The 'num-threads' options was set to "
         &lt;&lt; vm["num-threads"].as&lt;int&gt;() &lt;&lt; "\n";            
}                           
</programlisting>
      When parsing the command line, all options are allowed. The "--help"
      message, however, does not include the "Backend options" group -- the
      options in that group are hidden. The user can explicitly force the
      display of that options group by passing "--help-module backend"
      option. The complete example can be found in the
      "example/option_groups.cpp" file.
    </para></section><section><title>Custom Validators</title><para>By default, the conversion of option's value from string into C++
      type is done using iostreams, which sometimes is not convenient. The
      library allows the user to customize the conversion for specific
      classes. In order to do so, the user should provide suitable overload of
      the <computeroutput>validate</computeroutput> function.
    </para><para>
      Let's first define a simple class:
<programlisting>
struct magic_number {
public:
    magic_number(int n) : n(n) {}
    int n;
};
</programlisting> and then overload the <computeroutput>validate</computeroutput> function:
<programlisting>
void validate(boost::any&amp; v, 
              const std::vector&lt;std::string&gt;&amp; values,
              magic_number* target_type, int)
{
    static regex r("\\d\\d\\d-(\\d\\d\\d)");

    using namespace boost::program_options;

    // Make sure no previous assignment to 'a' was made.
    validators::check_first_occurence(v);
    // Extract the first string from 'values'. If there is more than
    // one string, it's an error, and exception will be thrown.
    const string&amp; s = validators::get_single_string(values);

    // Do regex match and convert the interesting part to 
    // int.
    smatch match;
    if (regex_match(s, match, r)) {
        v = any(magic_number(lexical_cast&lt;int&gt;(match[1])));
    } else {
        throw validation_error("invalid value");
    }        
}
        
</programlisting>The function takes four parameters. The first is the storage
      for the value, and in this case is either empty or contains an instance of
      the <computeroutput>magic_number</computeroutput> class. The second is the list of strings
      found in the next occurrence of the option. The remaining two parameters
      are needed to workaround the lack of partial template specialization and
      partial function template ordering on some compilers.
    </para><para>The function first checks that we don't try to assign to the same
      option twice. Then it checks that only a single string was passed
      in. Next the string is verified with the help of the Boost.Regex
      library. If that test is passed, the parsed value is stored into the
      <computeroutput>v</computeroutput> variable.
    </para><para>The complete example can be found in the "example/regex.cpp" file.
    </para></section><section><title>Unicode Support</title><para>To use the library with Unicode, you'd need to:
      <itemizedlist><listitem><para>Use Unicode-aware parsers for Unicode input</para></listitem><listitem><para>Require Unicode support for options which need it</para></listitem></itemizedlist></para><para>Most of the parsers have Unicode versions. For example, the
      <link linkend="parse_command_line">parse_command_line</link> function has an overload which takes
      <computeroutput>wchar_t</computeroutput> strings, instead of ordinary <computeroutput>char</computeroutput>.
    </para><para>Even if some of the parsers are Unicode-aware, it does not mean you
    need to change definition of all the options. In fact, for many options,
    like integer ones, it makes no sense. To make use of Unicode you'll need
    <emphasis>some</emphasis> Unicode-aware options. They are different from
    ordinary options in that they accept <computeroutput>wstring</computeroutput> input, and
    process it using wide character streams. Creating an Unicode-aware option
    is easy: just use the the <computeroutput>wvalue</computeroutput> function instead of the
    regular <computeroutput>value</computeroutput>.
    </para><para>When an ascii parser passes data to an ascii option, or a Unicode
      parser passes data to a Unicode option, the data are not changed at
      all. So, the ascii option will see a string in local 8-bit encoding, and
      the Unicode option will see whatever string was passed as the Unicode
      input.
    </para><para>What happens when Unicode data is passed to an ascii option, and
      vice versa? The library automatically performs the conversion from
      Unicode to local 8-bit encoding. For example, if command line is in
      ascii, but you use <computeroutput>wstring</computeroutput> options, then the ascii input
      will be converted into Unicode.
    </para><para>To perform the conversion, the library uses the <computeroutput>codecvt&lt;wchar_t,
    char&gt;</computeroutput> locale facet from the global locale. If
    you want to work with strings that use local 8-bit encoding (as opposed to
    7-bit ascii subset), your application should start with:
      <programlisting>
locale::global(locale(""));
      </programlisting>
      which would set up the conversion facet according to the user's selected
      locale. 
    </para><para>It's wise to check the status of the C++ locale support on your
      implementation, though. The quick test involves three steps:
      <orderedlist><listitem><para>Go the the "test" directory and build the "test_convert" binary.</para></listitem><listitem><para>Set some non-ascii locale in the environmemt. On Linux, one can
          run, for example: <screen>
$ export LC_CTYPE=ru_RU.KOI8-R
</screen></para></listitem><listitem><para>Run the "test_convert" binary with any non-ascii string in the
            selected encoding as its parameter. If you see a list of Unicode codepoints,
            everything's OK. Otherwise, locale support on your system might be
            broken.</para></listitem></orderedlist></para></section></section><section id="program_options.design" xml:base="../libs/program_options/doc/design.xml"><title>Design Discussion</title><para>This section focuses on some of the design questions.
  </para><section id="program_options.design.unicode"><title>Unicode Support</title><para>Unicode support was one of the features specifically requested
      during the formal review. Throughout this document "Unicode support" is
      a synonym for "wchar_t" support, assuming that "wchar_t" always uses
      Unicode encoding.  Also, when talking about "ascii" (in lowercase) we'll
      not mean strict 7-bit ASCII encoding, but rather "char" strings in local
      8-bit encoding.
    </para><para>
      Generally, "Unicode support" can mean
      many things, but for the program_options library it means that:

      <itemizedlist><listitem><para>Each parser should accept either <computeroutput>char*</computeroutput>
          or <computeroutput>wchar_t*</computeroutput>, correctly split the input into option
          names and option values and return the data.
          </para></listitem><listitem><para>For each option, it should be possible to specify whether the conversion
            from string to value uses ascii or Unicode.
          </para></listitem><listitem><para>The library guarantees that:
            <itemizedlist><listitem><para>ascii input is passed to an ascii value without change
                </para></listitem><listitem><para>Unicode input is passed to a Unicode value without change</para></listitem><listitem><para>ascii input passed to a Unicode value, and Unicode input
                  passed to an ascii value will be converted using a codecvt
                  facet (which may be specified by the user(which can be
                  specified by the user)
                </para></listitem></itemizedlist></para></listitem></itemizedlist></para><para>The important point is that it's possible to have some "ascii
      options" together with "Unicode options". There are two reasons for
      this. First, for a given type you might not have the code to extract the
      value from Unicode string and it's not good to require that such code be written.
      Second, imagine a reusable library which has some options and exposes
      options description in its interface. If <emphasis>all</emphasis>
      options are either ascii or Unicode, and the library does not use any
      Unicode strings, then the author will likely to use ascii options, which
      would make the library unusable inside Unicode
      applications. Essentially, it would be necessary to provide two versions
      of the library -- ascii and Unicode.
    </para><para>Another important point is that ascii strings are passed though
      without modification. In other words, it's not possible to just convert
      ascii to Unicode and process the Unicode further. The problem is that the
      default conversion mechanism -- the <computeroutput>codecvt</computeroutput> facet -- might
      not work with 8-bit input without additional setup.
    </para><para>The Unicode support outlined above is not complete. For example, we
      don't plan allow Unicode in option names. Unicode support is hard and
      requires a Boost-wide solution. Even comparing two arbitrary Unicode
      strings is non-trivial. Finally, using Unicode in option names is
      related to internationalization, which has it's own
      complexities. E.g. if option names depend on current locale, then all
      program parts and other parts which use the name must be
      internationalized too.
    </para><para>The primary question in implementing the Unicode support is whether
      to use templates and <computeroutput>std::basic_string</computeroutput> or to use some
      internal encoding and convert between internal and external encodings on
      the interface boundaries.            
    </para><para>The choice, mostly, is between code size and execution
      speed. A templated solution would either link library code into every
      application that uses the library (thereby making shared library
      impossible), or provide explicit instantiations in the shared library
      (increasing its size). The solution based on internal encoding would
      necessarily make conversions in a number of places and will be somewhat slower.
      Since speed is generally not an issue for this library, the second
      solution looks more attractive, but we'll take a closer look at
      individual components.
    </para><para>For the parsers component, we have three choices:
      <itemizedlist><listitem><para>Use a fully templated implementation: given a string of a
            certain type, a parser will return a parsed_options instance
            with strings of the same type (i.e. the parsed_options class
            will be templated).</para></listitem><listitem><para>Use internal encoding: same as above, but strings will be converted to and
            from the internal encoding.</para></listitem><listitem><para>Use and partly expose the internal encoding: same as above,
            but the strings in the parsed_options instance will be in the
            internal encoding. This might avoid a conversion if
            parsed_options instance is passed directly to other components,
            but can be also dangerous or confusing for a user.
          </para></listitem></itemizedlist></para><para>The second solution appears to be the best -- it does not increase
    the code size much and is cleaner than the third. To avoid extra
    conversions, the Unicode version of parsed_options can also store
    strings in internal encoding.
    </para><para>For the options descriptions component, we don't have much
      choice. Since it's not desirable to have either all options use ascii or all
      of them use Unicode, but rather have some ascii and some Unicode options, the
      interface of the <link linkend="value_semantic">value_semantic</link> must work with both. The only way is
      to pass an additional flag telling if strings use ascii or internal encoding.
      The instance of <link linkend="value_semantic">value_semantic</link> can then convert into some
      other encoding if needed.
    </para><para>For the storage component, the only affected function is <link linkend="id281355">store</link>.
      For Unicode input, the <link linkend="id281355">store</link> function should convert the value to the
      internal encoding.  It should also inform the <link linkend="value_semantic">value_semantic</link> class
      about the used encoding.
    </para><para>Finally, what internal encoding should we use? The
    alternatives are:
    <computeroutput>std::wstring</computeroutput> (using UCS-4 encoding) and
    <computeroutput>std::string</computeroutput> (using UTF-8 encoding). The difference between
    alternatives is:
      <itemizedlist><listitem><para>Speed: UTF-8 is a bit slower</para></listitem><listitem><para>Space: UTF-8 takes less space when input is ascii</para></listitem><listitem><para>Code size: UTF-8 requires additional conversion code. However,
            it allows one to use existing parsers without converting them to
            <computeroutput>std::wstring</computeroutput> and such conversion is likely to create a
            number of new instantiations.
          </para></listitem></itemizedlist>
      There's no clear leader, but the last point seems important, so UTF-8
      will be used.      
    </para><para>Choosing the UTF-8 encoding allows the use of existing parsers, 
      because 7-bit ascii characters retain their values in UTF-8, 
      so searching for 7-bit strings is simple. However, there are
      two subtle issues:
      <itemizedlist><listitem><para>We need to assume the character literals use ascii encoding
          and that inputs use Unicode encoding.</para></listitem><listitem><para>A Unicode character (say '=') can be followed by 'composing
          character' and the combination is not the same as just '=', so a
          simple search for '=' might find the wrong character.
          </para></listitem></itemizedlist>
      Neither of these issues appear to be critical in practice, since ascii is
      almost universal encoding and since composing characters following '=' (and
      other characters with special meaning to the library) are not likely to appear.
    </para></section></section><section xml:base="../libs/program_options/doc/acknowledgements.xml"><title>Acknowledgements</title><para>I'm very gratefull to all the people who helped with the development, 
    by discussion, fixes, and as users. It was pleasant
    to see all that involvement, which made the library much better than it
    would be otherwise.
  </para><para>In the early stages, the library was affected by discussions with 
    Gennadiy Rozental, William Kempf and Alexander Okhotin.
  </para><para>Hartmut Kaiser was the first person to try the library on his project
    and send a number of suggestions and fixes.    
  </para><para>The formal review lead to numerous comments and enhancements. Pavol
  Droba helped with the option description semantic. Gennadiy Rozental has
  criticised many aspects of the library which caused various simplifications.
  Pavel Vozenilek did carefull review of the implementation. A number of
  comments were made by:
    <itemizedlist><listitem><para>David Abrahams</para></listitem><listitem><para>Neal D. Becker</para></listitem><listitem><para>Misha Bergal</para></listitem><listitem><para>James Curran</para></listitem><listitem><para>Carl Daniel</para></listitem><listitem><para>Beman Dawes</para></listitem><listitem><para>Tanton Gibbs</para></listitem><listitem><para>Holger Grund</para></listitem><listitem><para>Hartmut Kaiser</para></listitem><listitem><para>Petr Kocmid</para></listitem><listitem><para>Baptiste Lepilleur</para></listitem><listitem><para>Marcelo E. Magallon</para></listitem><listitem><para>Chuck Messenger</para></listitem><listitem><para>John Torjo</para></listitem><listitem><para>Matthias Troyer</para></listitem></itemizedlist></para><para>Doug Gregor and Reece Dunn helped to resolve the issues with Boostbook
    version of the documentation.
  </para><para>Even after review, a number of people have helped with further development:
    <itemizedlist><listitem><para>Rob Lievaart</para></listitem><listitem><para>Thorsten Ottosen</para></listitem><listitem><para>Joseph Wu</para></listitem><listitem><para>Ferdinand Prantl</para></listitem><listitem><para>Miro Jurisic</para></listitem><listitem><para>John Maddock</para></listitem><listitem><para>Janusz Piwowarski</para></listitem><listitem><para>Charles Brockman</para></listitem><listitem><para>Jonathan Wakely</para></listitem></itemizedlist></para></section><section id="program_options.reference"><title>Reference</title><section id="id246856"><title>Header &lt;<ulink url="../../boost/program_options/cmdline.hpp">boost/program_options/cmdline.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> program_options {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> command_line_style {
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <link linkend="id321818">style_t</link>;
&#xA0;&#xA0;&#xA0;&#xA0;}
&#xA0;&#xA0;}
}</synopsis><refentry id="id321818"><refmeta><refentrytitle>Type style_t</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::command_line_style::style_t</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">enum</emphasis> style_t { allow_long =  1, allow_short =  allow_long &lt;&lt; 1, allow_dash_for_short =  allow_short &lt;&lt; 1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;allow_slash_for_short =  allow_dash_for_short &lt;&lt; 1, long_allow_adjacent =  allow_slash_for_short &lt;&lt; 1, long_allow_next =  long_allow_adjacent &lt;&lt; 1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;short_allow_adjacent =  long_allow_next &lt;&lt; 1, short_allow_next =  short_allow_adjacent &lt;&lt; 1, allow_sticky =  short_allow_next &lt;&lt; 1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;allow_guessing =  allow_sticky &lt;&lt; 1, case_insensitive =  allow_guessing &lt;&lt; 1, allow_long_disguise =  case_insensitive &lt;&lt; 1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;unix_style =  (allow_short | short_allow_adjacent | short_allow_next
                      | allow_long | long_allow_adjacent | long_allow_next
                      | allow_sticky | allow_guessing 
                      | allow_dash_for_short), default_style =  unix_style };</synopsis></refsynopsisdiv></refentry></section><section id="id436818"><title>Header &lt;<ulink url="../../boost/program_options/environment_iterator.hpp">boost/program_options/environment_iterator.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="environment_iterator">environment_iterator</link>;
}</synopsis><refentry id="environment_iterator"><refmeta><refentrytitle>Class environment_iterator</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::environment_iterator</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> environment_iterator : <emphasis role="bold">public</emphasis> boost::eof_iterator&lt; environment_iterator, std::pair&lt; std::string, std::string &gt; &gt;
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="environment_iteratorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id409373-bb">environment_iterator</link>(<emphasis role="bold">char</emphasis> **);
&#xA0;&#xA0;<link linkend="id365913-bb">environment_iterator</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id355347-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id284447-bb">get</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="environment_iteratorconstruct-copy-destruct"/><computeroutput>environment_iterator</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id409373-bb"/>environment_iterator(<emphasis role="bold">char</emphasis> ** environment);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id365913-bb"/>environment_iterator();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id355347-bb"/><computeroutput>environment_iterator</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id284447-bb"/>get() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id280769"><title>Header &lt;<ulink url="../../boost/program_options/eof_iterator.hpp">boost/program_options/eof_iterator.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Derived, <emphasis role="bold">typename</emphasis> ValueType&gt; <emphasis role="bold">class</emphasis> <link linkend="eof_iterator">eof_iterator</link>;
}</synopsis><refentry id="eof_iterator"><refmeta><refentrytitle>Class template eof_iterator</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::eof_iterator</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Derived, <emphasis role="bold">typename</emphasis> ValueType&gt; 
<emphasis role="bold">class</emphasis> eof_iterator {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="eof_iteratorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id379817-bb">eof_iterator</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id355116-bb">public member functions</link></emphasis>

&#xA0;&#xA0;<emphasis>// <link linkend="id409557-bb">protected member functions</link></emphasis>
&#xA0;&#xA0;<type>ValueType &amp;</type> <link linkend="id339711-bb">value</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id391088-bb">found_eof</link>() ;

&#xA0;&#xA0;<emphasis>// <link linkend="id356130-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id264690-bb">increment</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id220769-bb">equal</link>(<emphasis role="bold">const</emphasis> <link linkend="eof_iterator">eof_iterator</link> &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> ValueType &amp;</type> <link linkend="id226005-bb">dereference</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The 'eof_iterator' class is useful for constructing forward iterators in cases where iterator extract data from some source and it's easy to detect 'eof' -- i.e. the situation where there's no data. One apparent example is reading lines from a file.</para><para>Implementing such iterators using 'iterator_facade' directly would require to create class with three core operation, a couple of constructors. When using 'eof_iterator', the derived class should define only one method to get new value, plus a couple of constructors.</para><para>The basic idea is that iterator has 'eof' bit. Two iterators are equal only if both have their 'eof' bits set. The 'get' method either obtains the new value or sets the 'eof' bit.</para><para>Specifically, derived class should define:</para><para>1. A default constructor, which creates iterator with 'eof' bit set. The constructor body should call 'found_eof' method defined here. 2. Some other constructor. It should initialize some 'data pointer' used in iterator operation and then call 'get'. 3. The 'get' method. It should operate this way:<itemizedlist><listitem><para>look at some 'data pointer' to see if new element is available; if not, it should call 'found_eof'.</para></listitem><listitem><para>extract new element and store it at location returned by the 'value' method.</para></listitem><listitem><para>advance the data pointer.</para></listitem></itemizedlist></para><para>Essentially, the 'get' method has the functionality of both 'increment' and 'dereference'. It's very good for the cases where data extraction implicitly moves data pointer, like for stream operation. </para><refsect2><title><anchor id="eof_iteratorconstruct-copy-destruct"/><computeroutput>eof_iterator</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id379817-bb"/>eof_iterator();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id355116-bb"/><computeroutput>eof_iterator</computeroutput> public member functions</title><orderedlist/></refsect2><refsect2><title><anchor id="id409557-bb"/><computeroutput>eof_iterator</computeroutput> protected member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>ValueType &amp;</type> <anchor id="id339711-bb"/>value() ;</literallayout></para><para>Returns the reference which should be used by derived class to store the next value. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id391088-bb"/>found_eof() ;</literallayout></para><para>Should be called by derived class to indicate that it can't produce next element. </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id356130-bb"/><computeroutput>eof_iterator</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id264690-bb"/>increment() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id220769-bb"/>equal(<emphasis role="bold">const</emphasis> <link linkend="eof_iterator">eof_iterator</link> &amp; other) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> ValueType &amp;</type> <anchor id="id226005-bb"/>dereference() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id427440"><title>Header &lt;<ulink url="../../boost/program_options/errors.hpp">boost/program_options/errors.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> program_options {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="error">error</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="invalid_syntax">invalid_syntax</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="unknown_option">unknown_option</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="ambiguous_option">ambiguous_option</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="multiple_values">multiple_values</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="multiple_occurrences">multiple_occurrences</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="validation_error">validation_error</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="invalid_option_value">invalid_option_value</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="id278842">too_many_positional_options_error</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="id436306">too_few_positional_options_error</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="id233214">invalid_command_line_syntax</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="invalid_command_line_style">invalid_command_line_style</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="error"><refmeta><refentrytitle>Class error</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::error</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> error {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="errorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id311722-bb">error</link>(<emphasis role="bold">const</emphasis> std::string &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id408913-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Base class for all errors in the library. </para><refsect2><title><anchor id="errorconstruct-copy-destruct"/><computeroutput>error</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id311722-bb"/>error(<emphasis role="bold">const</emphasis> std::string &amp; what);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id408913-bb"/><computeroutput>error</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="invalid_syntax"><refmeta><refentrytitle>Class invalid_syntax</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::invalid_syntax</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> invalid_syntax : <emphasis role="bold">public</emphasis> boost::program_options::error {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="invalid_syntaxconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id335696-bb">invalid_syntax</link>(<emphasis role="bold">const</emphasis> std::string &amp;, <emphasis role="bold">const</emphasis> std::string &amp;);
&#xA0;&#xA0;<link linkend="id322075-bb">~invalid_syntax</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id443182-bb">public member functions</link></emphasis>

&#xA0;&#xA0;std::string tokens;
&#xA0;&#xA0;std::string msg;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="invalid_syntaxconstruct-copy-destruct"/><computeroutput>invalid_syntax</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id335696-bb"/>invalid_syntax(<emphasis role="bold">const</emphasis> std::string &amp; tokens, <emphasis role="bold">const</emphasis> std::string &amp; msg);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id322075-bb"/>~invalid_syntax();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id443182-bb"/><computeroutput>invalid_syntax</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="unknown_option"><refmeta><refentrytitle>Class unknown_option</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::unknown_option</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> unknown_option : <emphasis role="bold">public</emphasis> boost::program_options::error {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="unknown_optionconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id239278-bb">unknown_option</link>(<emphasis role="bold">const</emphasis> std::string &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id218507-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class thrown when option name is not recognized. </para><refsect2><title><anchor id="unknown_optionconstruct-copy-destruct"/><computeroutput>unknown_option</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id239278-bb"/>unknown_option(<emphasis role="bold">const</emphasis> std::string &amp; name);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id218507-bb"/><computeroutput>unknown_option</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="ambiguous_option"><refmeta><refentrytitle>Class ambiguous_option</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::ambiguous_option</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> ambiguous_option : <emphasis role="bold">public</emphasis> boost::program_options::error {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="ambiguous_optionconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id447412-bb">ambiguous_option</link>(<emphasis role="bold">const</emphasis> std::string &amp;, <emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp;);
&#xA0;&#xA0;<link linkend="id354263-bb">~ambiguous_option</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id375072-bb">public member functions</link></emphasis>

&#xA0;&#xA0;std::vector&lt; std::string &gt; alternatives;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class thrown when there's ambiguity amoung several possible options. </para><refsect2><title><anchor id="ambiguous_optionconstruct-copy-destruct"/><computeroutput>ambiguous_option</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id447412-bb"/>ambiguous_option(<emphasis role="bold">const</emphasis> std::string &amp; name, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp; alternatives);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id354263-bb"/>~ambiguous_option();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id375072-bb"/><computeroutput>ambiguous_option</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="multiple_values"><refmeta><refentrytitle>Class multiple_values</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::multiple_values</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> multiple_values : <emphasis role="bold">public</emphasis> boost::program_options::error {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="multiple_valuesconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id254121-bb">multiple_values</link>(<emphasis role="bold">const</emphasis> std::string &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id415576-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class thrown when there are several option values, but user called a method which cannot return them all. </para><refsect2><title><anchor id="multiple_valuesconstruct-copy-destruct"/><computeroutput>multiple_values</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id254121-bb"/>multiple_values(<emphasis role="bold">const</emphasis> std::string &amp; what);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id415576-bb"/><computeroutput>multiple_values</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="multiple_occurrences"><refmeta><refentrytitle>Class multiple_occurrences</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::multiple_occurrences</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> multiple_occurrences : <emphasis role="bold">public</emphasis> boost::program_options::error {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="multiple_occurrencesconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id322038-bb">multiple_occurrences</link>(<emphasis role="bold">const</emphasis> std::string &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id365068-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class thrown when there are several occurrences of an option, but user called a method which cannot return them all. </para><refsect2><title><anchor id="multiple_occurrencesconstruct-copy-destruct"/><computeroutput>multiple_occurrences</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id322038-bb"/>multiple_occurrences(<emphasis role="bold">const</emphasis> std::string &amp; what);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id365068-bb"/><computeroutput>multiple_occurrences</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="validation_error"><refmeta><refentrytitle>Class validation_error</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::validation_error</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> validation_error : <emphasis role="bold">public</emphasis> boost::program_options::error {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="validation_errorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id361394-bb">validation_error</link>(<emphasis role="bold">const</emphasis> std::string &amp;);
&#xA0;&#xA0;<link linkend="id349166-bb">~validation_error</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id352641-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id228785-bb">set_option_name</link>(<emphasis role="bold">const</emphasis> std::string &amp;) ;

&#xA0;&#xA0;<emphasis>// <link linkend="id337074-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <link linkend="id287982-bb">what</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class thrown when value of option is incorrect. </para><refsect2><title><anchor id="validation_errorconstruct-copy-destruct"/><computeroutput>validation_error</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id361394-bb"/>validation_error(<emphasis role="bold">const</emphasis> std::string &amp; what);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id349166-bb"/>~validation_error();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id352641-bb"/><computeroutput>validation_error</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id228785-bb"/>set_option_name(<emphasis role="bold">const</emphasis> std::string &amp; option) ;</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id337074-bb"/><computeroutput>validation_error</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <anchor id="id287982-bb"/>what() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="invalid_option_value"><refmeta><refentrytitle>Class invalid_option_value</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::invalid_option_value</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> invalid_option_value
  :  : <emphasis role="bold">public</emphasis> boost::program_options::validation_error
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="invalid_option_valueconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id264397-bb">invalid_option_value</link>(<emphasis role="bold">const</emphasis> std::string &amp;);
&#xA0;&#xA0;<link linkend="id349280-bb">invalid_option_value</link>(<emphasis role="bold">const</emphasis> std::wstring &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id346387-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="invalid_option_valueconstruct-copy-destruct"/><computeroutput>invalid_option_value</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id264397-bb"/>invalid_option_value(<emphasis role="bold">const</emphasis> std::string &amp; value);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id349280-bb"/>invalid_option_value(<emphasis role="bold">const</emphasis> std::wstring &amp; value);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id346387-bb"/><computeroutput>invalid_option_value</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="id278842"><refmeta><refentrytitle>Class too_many_positional_options_error</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::too_many_positional_options_error</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> too_many_positional_options_error
  :  : <emphasis role="bold">public</emphasis> boost::program_options::error
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="id278842construct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id251844-bb">too_many_positional_options_error</link>(<emphasis role="bold">const</emphasis> std::string &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id277956-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class thrown when there are too many positional options. </para><refsect2><title><anchor id="id278842construct-copy-destruct"/><computeroutput>too_many_positional_options_error</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id251844-bb"/>too_many_positional_options_error(<emphasis role="bold">const</emphasis> std::string &amp; what);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id277956-bb"/><computeroutput>too_many_positional_options_error</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="id436306"><refmeta><refentrytitle>Class too_few_positional_options_error</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::too_few_positional_options_error</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> too_few_positional_options_error
  :  : <emphasis role="bold">public</emphasis> boost::program_options::error
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="id436306construct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id443859-bb">too_few_positional_options_error</link>(<emphasis role="bold">const</emphasis> std::string &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id345762-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class thrown when there are too few positional options. </para><refsect2><title><anchor id="id436306construct-copy-destruct"/><computeroutput>too_few_positional_options_error</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id443859-bb"/>too_few_positional_options_error(<emphasis role="bold">const</emphasis> std::string &amp; what);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id345762-bb"/><computeroutput>too_few_positional_options_error</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry><refentry id="id233214"><refmeta><refentrytitle>Class invalid_command_line_syntax</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::invalid_command_line_syntax</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> invalid_command_line_syntax {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="id233214construct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id396748-bb">invalid_command_line_syntax</link>(<emphasis role="bold">const</emphasis> std::string &amp;, kind_t);

&#xA0;&#xA0;<emphasis>// <link linkend="id279856-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>kind_t</type> <link linkend="id279859-bb">kind</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id362648-bb">protected static functions</link></emphasis>
&#xA0;&#xA0;<type>std::string</type> <link linkend="id393065-bb">error_message</link>(kind_t) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id233214construct-copy-destruct"/><computeroutput>invalid_command_line_syntax</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id396748-bb"/>invalid_command_line_syntax(<emphasis role="bold">const</emphasis> std::string &amp; tokens, kind_t kind);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id279856-bb"/><computeroutput>invalid_command_line_syntax</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>kind_t</type> <anchor id="id279859-bb"/>kind() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id362648-bb"/><computeroutput>invalid_command_line_syntax</computeroutput> protected static functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>std::string</type> <anchor id="id393065-bb"/>error_message(kind_t kind) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="invalid_command_line_style"><refmeta><refentrytitle>Class invalid_command_line_style</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::invalid_command_line_style</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> invalid_command_line_style : <emphasis role="bold">public</emphasis> boost::program_options::error {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="invalid_command_line_styleconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id387863-bb">invalid_command_line_style</link>(<emphasis role="bold">const</emphasis> std::string &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id387860-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="invalid_command_line_styleconstruct-copy-destruct"/><computeroutput>invalid_command_line_style</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id387863-bb"/>invalid_command_line_style(<emphasis role="bold">const</emphasis> std::string &amp; msg);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id387860-bb"/><computeroutput>invalid_command_line_style</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry></section><section id="id419627"><title>Header &lt;<ulink url="../../boost/program_options/option.hpp">boost/program_options/option.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> program_options {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; <emphasis role="bold">class</emphasis> <link linkend="basic_option">basic_option</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="basic_option">basic_option</link>&lt; <emphasis role="bold">char</emphasis> &gt; option;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="basic_option">basic_option</link>&lt; <emphasis role="bold">wchar_t</emphasis> &gt; woption;
&#xA0;&#xA0;}
}</synopsis><refentry id="basic_option"><refmeta><refentrytitle>Class template basic_option</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::basic_option</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
<emphasis role="bold">class</emphasis> basic_option {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="basic_optionconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id260800-bb">basic_option</link>();
&#xA0;&#xA0;<link linkend="id260802-bb">basic_option</link>(<emphasis role="bold">const</emphasis> std::string &amp;, <emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id430785-bb">public member functions</link></emphasis>

&#xA0;&#xA0;std::string string_key;
&#xA0;&#xA0;int position_key;
&#xA0;&#xA0;std::vector&lt; std::basic_string&lt; charT &gt; &gt; value;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Option found in input source. Contains a key and a value. The key, in turn, can be a string (name of an option), or an integer (position in input source) -- in case no name is specified. The latter is only possible for command line. The template parameter specifies the type of char used for storing the option's value. </para><refsect2><title><anchor id="basic_optionconstruct-copy-destruct"/><computeroutput>basic_option</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id260800-bb"/>basic_option();</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id260802-bb"/>basic_option(<emphasis role="bold">const</emphasis> std::string &amp; string_key, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp; value);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id430785-bb"/><computeroutput>basic_option</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry></section><section id="id258673"><title>Header &lt;<ulink url="../../boost/program_options/options_description.hpp">boost/program_options/options_description.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> program_options {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="option_description">option_description</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="id367899">options_description_easy_init</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="options_description">options_description</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="duplicate_option_error">duplicate_option_error</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="option_description"><refmeta><refentrytitle>Class option_description</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::option_description</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> option_description {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="option_descriptionconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id340432-bb">option_description</link>();
&#xA0;&#xA0;<link linkend="id245011-bb">option_description</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *, <emphasis role="bold">const</emphasis> <link linkend="value_semantic">value_semantic</link> *);
&#xA0;&#xA0;<link linkend="id420495-bb">option_description</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *, <emphasis role="bold">const</emphasis> <link linkend="value_semantic">value_semantic</link> *, <emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *);
&#xA0;&#xA0;<link linkend="id320330-bb">~option_description</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id406814-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> std::string &amp;</type> <link linkend="id239618-bb">short_name</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> std::string &amp;</type> <link linkend="id394157-bb">long_name</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> std::string &amp;</type> <link linkend="id419353-bb">description</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>shared_ptr&lt; <emphasis role="bold">const</emphasis> <link linkend="value_semantic">value_semantic</link> &gt;</type> <link linkend="id247866-bb">semantic</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>std::string</type> <link linkend="id301982-bb">format_name</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>std::string</type> <link linkend="id429607-bb">format_parameter</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id319434-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type><link linkend="option_description">option_description</link> &amp;</type> <link linkend="id255460-bb">name</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Describes one possible command line/config file option. There are two kinds of properties of an option. First describe it syntactically and are used only to validate input. Second affect interpretation of the option, for example default value for it or function that should be called when the value is finally known. Routines which perform parsing never use second kind of properties -- they are side effect free. <para>options_description </para></para><refsect2><title><anchor id="option_descriptionconstruct-copy-destruct"/><computeroutput>option_description</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id340432-bb"/>option_description();</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id245011-bb"/>option_description(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> * name, <emphasis role="bold">const</emphasis> <link linkend="value_semantic">value_semantic</link> * s);</literallayout></para><para>Initializes the object with the passed data.</para><para>Note: it would be nice to make the second parameter auto_ptr, to explicitly pass ownership. Unfortunately, it's often needed to create objects of types derived from 'value_semantic': options_description d; d.add_options()("a", parameter&lt;int&gt;("n")-&gt;default_value(1)); Here, the static type returned by 'parameter' should be derived from value_semantic.</para><para>Alas, derived-&gt;base conversion for auto_ptr does not really work, see http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2000/n1232.pdf http://std.dkuug.dk/jtc1/sc22/wg21/docs/cwg_defects.html#84</para><para>So, we have to use plain old pointers. Besides, users are not expected to use the constructor directly.</para><para>The 'name' parameter is interpreted by the following rules:<itemizedlist><listitem><para>if there's no "," character in 'name', it specifies long name</para></listitem><listitem><para>otherwise, the part before "," specifies long name and the part after -- long name. </para></listitem></itemizedlist></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id420495-bb"/>option_description(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> * name, <emphasis role="bold">const</emphasis> <link linkend="value_semantic">value_semantic</link> * s, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> * description);</literallayout></para><para>Initializes the class with the passed data. </para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id320330-bb"/>~option_description();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id406814-bb"/><computeroutput>option_description</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> std::string &amp;</type> <anchor id="id239618-bb"/>short_name() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> std::string &amp;</type> <anchor id="id394157-bb"/>long_name() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> std::string &amp;</type> <anchor id="id419353-bb"/>description() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>shared_ptr&lt; <emphasis role="bold">const</emphasis> <link linkend="value_semantic">value_semantic</link> &gt;</type> <anchor id="id247866-bb"/>semantic() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>std::string</type> <anchor id="id301982-bb"/>format_name() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>std::string</type> <anchor id="id429607-bb"/>format_parameter() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Return the parameter name and properties, formatted suitably for usage message. </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id319434-bb"/><computeroutput>option_description</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><link linkend="option_description">option_description</link> &amp;</type> <anchor id="id255460-bb"/>name(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> * name) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id367899"><refmeta><refentrytitle>Class options_description_easy_init</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::options_description_easy_init</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> options_description_easy_init {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="id367899construct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id299517-bb">options_description_easy_init</link>(<link linkend="options_description">options_description</link> *);

&#xA0;&#xA0;<emphasis>// <link linkend="id415060-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><link linkend="id367899">options_description_easy_init</link> &amp;</type> <link linkend="id253871-bb"><emphasis role="bold">operator</emphasis>()</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *, <emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *) ;
&#xA0;&#xA0;<type><link linkend="id367899">options_description_easy_init</link> &amp;</type> 
&#xA0;&#xA0;<link linkend="id267818-bb"><emphasis role="bold">operator</emphasis>()</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *, <emphasis role="bold">const</emphasis> <link linkend="value_semantic">value_semantic</link> *) ;
&#xA0;&#xA0;<type><link linkend="id367899">options_description_easy_init</link> &amp;</type> 
&#xA0;&#xA0;<link linkend="id362654-bb"><emphasis role="bold">operator</emphasis>()</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *, <emphasis role="bold">const</emphasis> <link linkend="value_semantic">value_semantic</link> *, <emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class which provides convenient creation syntax to option_description. </para><refsect2><title><anchor id="id367899construct-copy-destruct"/><computeroutput>options_description_easy_init</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id299517-bb"/>options_description_easy_init(<link linkend="options_description">options_description</link> * owner);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id415060-bb"/><computeroutput>options_description_easy_init</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><link linkend="id367899">options_description_easy_init</link> &amp;</type> 
<anchor id="id253871-bb"/><emphasis role="bold">operator</emphasis>()(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> * name, <emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> * description) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="id367899">options_description_easy_init</link> &amp;</type> 
<anchor id="id267818-bb"/><emphasis role="bold">operator</emphasis>()(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> * name, <emphasis role="bold">const</emphasis> <link linkend="value_semantic">value_semantic</link> * s) ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="id367899">options_description_easy_init</link> &amp;</type> 
<anchor id="id362654-bb"/><emphasis role="bold">operator</emphasis>()(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> * name, <emphasis role="bold">const</emphasis> <link linkend="value_semantic">value_semantic</link> * s, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> * description) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="options_description"><refmeta><refentrytitle>Class options_description</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::options_description</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> options_description {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="options_descriptionconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id244008-bb">options_description</link>();
&#xA0;&#xA0;<link linkend="id220391-bb">options_description</link>(<emphasis role="bold">const</emphasis> std::string &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id247472-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id429915-bb">add</link>(shared_ptr&lt; <link linkend="option_description">option_description</link> &gt;) ;
&#xA0;&#xA0;<type><link linkend="options_description">options_description</link> &amp;</type> <link linkend="id229417-bb">add</link>(<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp;) ;
&#xA0;&#xA0;<type><link linkend="id367899">options_description_easy_init</link></type> <link linkend="id338953-bb">add_options</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">unsigned</emphasis></type> <link linkend="id249381-bb">count</link>(<emphasis role="bold">const</emphasis> std::string &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">unsigned</emphasis></type> <link linkend="id266214-bb">count_approx</link>(<emphasis role="bold">const</emphasis> std::string &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <link linkend="option_description">option_description</link> &amp;</type> <link linkend="id384118-bb">find</link>(<emphasis role="bold">const</emphasis> std::string &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <link linkend="option_description">option_description</link> &amp;</type> <link linkend="id343294-bb">find_approx</link>(<emphasis role="bold">const</emphasis> std::string &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>std::set&lt; std::string &gt;</type> <link linkend="id270925-bb">keys</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>std::set&lt; std::string &gt;</type> <link linkend="id256323-bb">primary_keys</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>std::set&lt; std::string &gt;</type> <link linkend="id319045-bb">approximations</link>(<emphasis role="bold">const</emphasis> std::string &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id249649-bb">print</link>(std::ostream &amp;) <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id262614-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type>approximation_range</type> <link linkend="id251061-bb">find_approximation</link>(<emphasis role="bold">const</emphasis> std::string &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>A set of option descriptions. This provides convenient interface for adding new option (the add_options) method, and facilities to search for options by name.</para><para>See here  for option adding interface discussion. <para>option_description </para></para><refsect2><title><anchor id="options_descriptionconstruct-copy-destruct"/><computeroutput>options_description</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id244008-bb"/>options_description();</literallayout></para><para>Creates the instance. </para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id220391-bb"/>options_description(<emphasis role="bold">const</emphasis> std::string &amp; caption);</literallayout></para><para>Creates the instance. The 'caption' parameter gives the name of this 'options_description' instance. Primarily useful for output. </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id247472-bb"/><computeroutput>options_description</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id429915-bb"/>add(shared_ptr&lt; <link linkend="option_description">option_description</link> &gt; desc) ;</literallayout></para><para>Adds new variable description. Throws duplicate_variable_error if either short or long name matches that of already present one. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="options_description">options_description</link> &amp;</type> <anchor id="id229417-bb"/>add(<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp; desc) ;</literallayout></para><para>Adds a group of option description. This has the same effect as adding all option_descriptions in 'desc' individually, except that output operator will show a separate group. Returns *this. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="id367899">options_description_easy_init</link></type> <anchor id="id338953-bb"/>add_options() ;</literallayout></para><para>Returns an object of implementation-defined type suitable for adding options to options_description. The returned object will have overloaded operator() with parameter type matching 'option_description' constructors. Calling the operator will create new option_description instance and add it. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">unsigned</emphasis></type> <anchor id="id249381-bb"/>count(<emphasis role="bold">const</emphasis> std::string &amp; name) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Count the number of option descriptions with given name. Returns 0 or 1. The 'name' parameter can be either name of long option, and short option prefixed by '-'. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">unsigned</emphasis></type> <anchor id="id266214-bb"/>count_approx(<emphasis role="bold">const</emphasis> std::string &amp; prefix) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Count the number of descriptions having the given string as prefix. This makes sense only for long options. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <link linkend="option_description">option_description</link> &amp;</type> <anchor id="id384118-bb"/>find(<emphasis role="bold">const</emphasis> std::string &amp; name) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Returns description given a name. 
</para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><para>count(name) == 1 </para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <link linkend="option_description">option_description</link> &amp;</type> <anchor id="id343294-bb"/>find_approx(<emphasis role="bold">const</emphasis> std::string &amp; prefix) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Returns description given a prefix. Throws 
</para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><para>count_approx(name) == 1 </para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>std::set&lt; std::string &gt;</type> <anchor id="id270925-bb"/>keys() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>std::set&lt; std::string &gt;</type> <anchor id="id256323-bb"/>primary_keys() <emphasis role="bold">const</emphasis>;</literallayout></para><para>For each option description stored, contains long name if not empty, if it is empty, short name is returned. </para></listitem><listitem><para><literallayout class="monospaced"><type>std::set&lt; std::string &gt;</type> <anchor id="id319045-bb"/>approximations(<emphasis role="bold">const</emphasis> std::string &amp; prefix) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id249649-bb"/>print(std::ostream &amp; os) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Output 'desc' to the specified stream, calling 'f' to output each option_description element. </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id262614-bb"/><computeroutput>options_description</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>approximation_range</type> <anchor id="id251061-bb"/>find_approximation(<emphasis role="bold">const</emphasis> std::string &amp; prefix) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="duplicate_option_error"><refmeta><refentrytitle>Class duplicate_option_error</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::duplicate_option_error</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> duplicate_option_error : <emphasis role="bold">public</emphasis> boost::program_options::error {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="duplicate_option_errorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id414336-bb">duplicate_option_error</link>(<emphasis role="bold">const</emphasis> std::string &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id414999-bb">public member functions</link></emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class thrown when duplicate option description is found. </para><refsect2><title><anchor id="duplicate_option_errorconstruct-copy-destruct"/><computeroutput>duplicate_option_error</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id414336-bb"/>duplicate_option_error(<emphasis role="bold">const</emphasis> std::string &amp; what);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id414999-bb"/><computeroutput>duplicate_option_error</computeroutput> public member functions</title><orderedlist/></refsect2></refsect1></refentry></section><section id="id225750"><title>Header &lt;<ulink url="../../boost/program_options/parsers.hpp">boost/program_options/parsers.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> program_options {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; <emphasis role="bold">class</emphasis> <link linkend="basic_parsed_options">basic_parsed_options</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;&gt; <emphasis role="bold">class</emphasis> <link linkend="id389683-bb">basic_parsed_options</link>&lt;<emphasis role="bold">wchar_t</emphasis>&gt;;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="common_command_line_parser">common_command_line_parser</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; <emphasis role="bold">class</emphasis> <link linkend="basic_command_line_parser">basic_command_line_parser</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="basic_parsed_options">basic_parsed_options</link>&lt; <emphasis role="bold">char</emphasis> &gt; parsed_options;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="basic_parsed_options">basic_parsed_options</link>&lt; <emphasis role="bold">wchar_t</emphasis> &gt; wparsed_options;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> function1&lt; std::pair&lt; std::string, std::string &gt;, <emphasis role="bold">const</emphasis> std::string &amp; &gt; ext_parser;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="basic_command_line_parser">basic_command_line_parser</link>&lt; <emphasis role="bold">char</emphasis> &gt; command_line_parser;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="basic_command_line_parser">basic_command_line_parser</link>&lt; <emphasis role="bold">wchar_t</emphasis> &gt; wcommand_line_parser;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="basic_parsed_options">basic_parsed_options</link>&lt; charT &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="parse_command_line">parse_command_line</link>(<emphasis role="bold">int</emphasis>, charT *, <emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp;, <emphasis role="bold">int</emphasis> = 0, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;function1&lt; std::pair&lt; std::string, std::string &gt;, <emphasis role="bold">const</emphasis> std::string &amp; &gt; = ext_parser());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_PROGRAM_OPTIONS_DECL <link linkend="basic_parsed_options">basic_parsed_options</link>&lt; charT &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="parse_config_file">parse_config_file</link>(std::basic_istream&lt; charT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_PROGRAM_OPTIONS_DECL parsed_options</type> 
&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id264411">parse_environment</link>(<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> function1&lt; std::string, std::string &gt; &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_PROGRAM_OPTIONS_DECL parsed_options</type> 
&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id285434">parse_environment</link>(<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp;, <emphasis role="bold">const</emphasis> std::string &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_PROGRAM_OPTIONS_DECL parsed_options</type> 
&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id285434">parse_environment</link>(<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp;, <emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *);
&#xA0;&#xA0;}
}</synopsis><refentry id="basic_parsed_options"><refmeta><refentrytitle>Class template basic_parsed_options</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::basic_parsed_options</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
<emphasis role="bold">class</emphasis> basic_parsed_options {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="basic_parsed_optionsconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id338135-bb">basic_parsed_options</link>(<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> *);

&#xA0;&#xA0;<emphasis>// <link linkend="id251453-bb">public member functions</link></emphasis>

&#xA0;&#xA0;std::vector&lt; <link linkend="basic_option">basic_option</link>&lt; charT &gt; &gt; options;
&#xA0;&#xA0;const <link linkend="options_description">options_description</link> * description;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Results of parsing an input source. The primary use of this class is passing information from parsers component to value storage component. This class does not makes much sense itself. </para><refsect2><title><anchor id="basic_parsed_optionsconstruct-copy-destruct"/><computeroutput>basic_parsed_options</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id338135-bb"/>basic_parsed_options(<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> * description);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id251453-bb"/><computeroutput>basic_parsed_options</computeroutput> public member functions</title><orderedlist/></refsect2><refsect2><title>Specializations</title><itemizedlist><listitem><para><link linkend="id389683-bb">Class basic_parsed_options&lt;wchar_t&gt;</link></para></listitem></itemizedlist></refsect2></refsect1></refentry><refentry id="id389683-bb"><refmeta><refentrytitle>Class basic_parsed_options&lt;wchar_t&gt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::basic_parsed_options&lt;wchar_t&gt;</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> basic_parsed_options&lt;<emphasis role="bold">wchar_t</emphasis>&gt; {
<emphasis role="bold">public</emphasis>:

&#xA0;&#xA0;<emphasis>// <link linkend="id274196-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type/> <link linkend="id332756-bb">basic_parsed_options</link>(<emphasis role="bold">const</emphasis> <link linkend="basic_parsed_options">basic_parsed_options</link>&lt; <emphasis role="bold">char</emphasis> &gt; &amp;) ;

&#xA0;&#xA0;std::vector&lt; <link linkend="basic_option">basic_option</link>&lt; wchar_t &gt; &gt; options;
&#xA0;&#xA0;const <link linkend="options_description">options_description</link> * description;
&#xA0;&#xA0;<link linkend="basic_parsed_options">basic_parsed_options</link>&lt; char &gt; utf8_encoded_options;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Specialization of basic_parsed_options which:<itemizedlist><listitem><para>provides convenient conversion from basic_parsed_options&lt;char&gt;</para></listitem><listitem><para>stores the passed char-based options for later use. </para></listitem></itemizedlist></para><refsect2><title><anchor id="id274196-bb"/><computeroutput>basic_parsed_options</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type/> <anchor id="id332756-bb"/>basic_parsed_options(<emphasis role="bold">const</emphasis> <link linkend="basic_parsed_options">basic_parsed_options</link>&lt; <emphasis role="bold">char</emphasis> &gt; &amp; po) ;</literallayout></para><para>Constructs wrapped options from options in UTF8 encoding. </para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="common_command_line_parser"><refmeta><refentrytitle>Class common_command_line_parser</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::common_command_line_parser</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> common_command_line_parser {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="common_command_line_parserconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id392934-bb">common_command_line_parser</link>(<emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id412751-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>parsed_options</type> <link linkend="id303632-bb">run</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Character-type independent command line parser. </para><refsect2><title><anchor id="common_command_line_parserconstruct-copy-destruct"/><computeroutput>common_command_line_parser</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id392934-bb"/>common_command_line_parser(<emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp; args);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id412751-bb"/><computeroutput>common_command_line_parser</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>parsed_options</type> <anchor id="id303632-bb"/>run() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Parses the command line and returns parsed options in internal encoding. </para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="basic_command_line_parser"><refmeta><refentrytitle>Class template basic_command_line_parser</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::basic_command_line_parser</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
<emphasis role="bold">class</emphasis> basic_command_line_parser
  :  : <emphasis role="bold">private</emphasis> boost::program_options::common_command_line_parser
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="basic_command_line_parserconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id247431-bb">basic_command_line_parser</link>(<emphasis role="bold">const</emphasis> std::vector&lt; std::basic_string&lt; charT &gt; &gt; &amp;);
&#xA0;&#xA0;<link linkend="id330930-bb">basic_command_line_parser</link>(<emphasis role="bold">int</emphasis>, charT *);

&#xA0;&#xA0;<emphasis>// <link linkend="id397948-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><link linkend="basic_command_line_parser">basic_command_line_parser</link> &amp;</type> <link linkend="id386229-bb">options</link>(<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp;) ;
&#xA0;&#xA0;<type><link linkend="basic_command_line_parser">basic_command_line_parser</link> &amp;</type> 
&#xA0;&#xA0;<link linkend="id220774-bb">positional</link>(<emphasis role="bold">const</emphasis> <link linkend="id277022">positional_options_description</link> &amp;) ;
&#xA0;&#xA0;<type><link linkend="basic_command_line_parser">basic_command_line_parser</link> &amp;</type> <link linkend="id302369-bb">style</link>(<emphasis role="bold">int</emphasis>) ;
&#xA0;&#xA0;<type><link linkend="basic_command_line_parser">basic_command_line_parser</link> &amp;</type> <link linkend="id405167-bb">extra_parser</link>(ext_parser) ;
&#xA0;&#xA0;<type><link linkend="basic_parsed_options">basic_parsed_options</link>&lt; charT &gt;</type> <link linkend="id361367-bb">run</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Command line parser.</para><para>The class allows one to specify all the information needed for parsing and to parser the parse the command line. It is primarily needed to emulate named function parameters -- a regular function with 5 parameters will be hard to use and creating overloads with a smaller nuber of parameters will be confusing.</para><para>For the most common case, the function parse_command_line is a better alternative. </para><refsect2><title><anchor id="basic_command_line_parserconstruct-copy-destruct"/><computeroutput>basic_command_line_parser</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id247431-bb"/>basic_command_line_parser(<emphasis role="bold">const</emphasis> std::vector&lt; std::basic_string&lt; charT &gt; &gt; &amp; args);</literallayout></para><para>Creates a command line parser for the specified arguments list. The 'args' parameter should not include program name. </para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id330930-bb"/>basic_command_line_parser(<emphasis role="bold">int</emphasis> argc, charT * argv);</literallayout></para><para>Creates a command line parser for the specified arguments list. The parameter should be the same as passes to 'main'. </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id397948-bb"/><computeroutput>basic_command_line_parser</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><link linkend="basic_command_line_parser">basic_command_line_parser</link> &amp;</type> <anchor id="id386229-bb"/>options(<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp; desc) ;</literallayout></para><para>Sets options descriptions to use. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="basic_command_line_parser">basic_command_line_parser</link> &amp;</type> 
<anchor id="id220774-bb"/>positional(<emphasis role="bold">const</emphasis> <link linkend="id277022">positional_options_description</link> &amp; desc) ;</literallayout></para><para>Sets positional options description to use. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="basic_command_line_parser">basic_command_line_parser</link> &amp;</type> <anchor id="id302369-bb"/>style(<emphasis role="bold">int</emphasis> ) ;</literallayout></para><para>Sets the command line style. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="basic_command_line_parser">basic_command_line_parser</link> &amp;</type> <anchor id="id405167-bb"/>extra_parser(ext_parser ) ;</literallayout></para><para>Sets the extra parsers. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="basic_parsed_options">basic_parsed_options</link>&lt; charT &gt;</type> <anchor id="id361367-bb"/>run() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Parses the command line and returns parsed options in internal encoding. </para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="parse_command_line"><refmeta><refentrytitle>Function template parse_command_line</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::parse_command_line</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;<type><link linkend="basic_parsed_options">basic_parsed_options</link>&lt; charT &gt;</type> 
&#xA0;&#xA0;parse_command_line(<emphasis role="bold">int</emphasis> argc, charT * argv, <emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp; , 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">int</emphasis> style = 0, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;function1&lt; std::pair&lt; std::string, std::string &gt;, <emphasis role="bold">const</emphasis> std::string &amp; &gt; ext = ext_parser());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Creates instance of 'command_line_parser', passes parameters to it, and returns the result of calling the 'run' method. </para></refsect1></refentry><refentry id="parse_config_file"><refmeta><refentrytitle>Function template parse_config_file</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::parse_config_file</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
&#xA0;&#xA0;<type>BOOST_PROGRAM_OPTIONS_DECL <link linkend="basic_parsed_options">basic_parsed_options</link>&lt; charT &gt;</type> 
&#xA0;&#xA0;parse_config_file(std::basic_istream&lt; charT &gt; &amp; , 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp; );</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Parse a config file. </para></refsect1></refentry><refentry id="id264411"><refmeta><refentrytitle>Function parse_environment</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::parse_environment</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type>BOOST_PROGRAM_OPTIONS_DECL parsed_options</type> 
parse_environment(<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp; , 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> function1&lt; std::string, std::string &gt; &amp; name_mapper);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Parse environment.</para><para>For each environment variable, the 'name_mapper' function is called to obtain the option name. If it returns empty string, the variable is ignored.</para><para>This is done since naming of environment variables is typically different from the naming of command line options. </para></refsect1></refentry><refentry id="id285434"><refmeta><refentrytitle>Function parse_environment</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::parse_environment</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type>BOOST_PROGRAM_OPTIONS_DECL parsed_options</type> 
parse_environment(<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp; , <emphasis role="bold">const</emphasis> std::string &amp; prefix);
<type>BOOST_PROGRAM_OPTIONS_DECL parsed_options</type> 
parse_environment(<emphasis role="bold">const</emphasis> <link linkend="options_description">options_description</link> &amp; , <emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> * prefix);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Parse environment.</para><para>Takes all environment variables which start with 'prefix'. The option name is obtained from variable name by removing the prefix and converting the remaining string into lower case. </para></refsect1></refentry></section><section id="id420630"><title>Header &lt;<ulink url="../../boost/program_options/positional_options.hpp">boost/program_options/positional_options.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> program_options {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="id277022">positional_options_description</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="id277022"><refmeta><refentrytitle>Class positional_options_description</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::positional_options_description</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> positional_options_description {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="id277022construct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id223900-bb">positional_options_description</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id228419-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id228425-bb">add</link>(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *, <emphasis role="bold">int</emphasis>) ;
&#xA0;&#xA0;<type><emphasis role="bold">unsigned</emphasis></type> <link linkend="id415172-bb">max_total_count</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> std::string &amp;</type> <link linkend="id354769-bb">name_for_position</link>(<emphasis role="bold">unsigned</emphasis>) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Describes positional options.</para><para>The class allows to guess option names for positional options, which are specified on the command line and are identified by the position. The class uses the information provided by the user to associate a name with every positional option, or tell that no name is known.</para><para>The primary assumption is that only the relative order of the positional options themselves matters, and that any interleaving ordinary options don't affect interpretation of positional options.</para><para>The user initializes the class by specifying that first N positional options should be given the name X1, following M options should be given the name X2 and so on. </para><refsect2><title><anchor id="id277022construct-copy-destruct"/><computeroutput>positional_options_description</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id223900-bb"/>positional_options_description();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id228419-bb"/><computeroutput>positional_options_description</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id228425-bb"/>add(<emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> * name, <emphasis role="bold">int</emphasis> max_count) ;</literallayout></para><para>Species that up to 'max_count' next positional options should be given the 'name'. The value of '-1' means 'unlimited'. No calls to 'add' can be made after call with 'max_value' equal to '-1'. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">unsigned</emphasis></type> <anchor id="id415172-bb"/>max_total_count() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Returns the maximum number of positional options that can be present. Can return numeric_limits&lt;unsigned&gt;::max() to indicate unlimited number. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> std::string &amp;</type> <anchor id="id354769-bb"/>name_for_position(<emphasis role="bold">unsigned</emphasis> position) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Returns the name that should be associated with positional options at 'position'. Precondition: position &lt; max_total_count() </para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id391535"><title>Header &lt;<ulink url="../../boost/program_options/value_semantic.hpp">boost/program_options/value_semantic.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> program_options {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="value_semantic">value_semantic</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; <emphasis role="bold">class</emphasis> <link linkend="id309957">value_semantic_codecvt_helper</link>;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;&gt; <emphasis role="bold">class</emphasis> <link linkend="id361348-bb">value_semantic_codecvt_helper</link>&lt;<emphasis role="bold">char</emphasis>&gt;;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;&gt; <emphasis role="bold">class</emphasis> <link linkend="id410043-bb">value_semantic_codecvt_helper</link>&lt;<emphasis role="bold">wchar_t</emphasis>&gt;;

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="untyped_value">untyped_value</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; <emphasis role="bold">class</emphasis> <link linkend="typed_value">typed_value</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type><link linkend="typed_value">typed_value</link>&lt; T &gt; *</type> <link linkend="value">value</link>();
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type><link linkend="typed_value">typed_value</link>&lt; T &gt; *</type> <link linkend="value">value</link>(T *);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type><link linkend="typed_value">typed_value</link>&lt; T, <emphasis role="bold">wchar_t</emphasis> &gt; *</type> <link linkend="wvalue">wvalue</link>();
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type><link linkend="typed_value">typed_value</link>&lt; T, <emphasis role="bold">wchar_t</emphasis> &gt; *</type> <link linkend="wvalue">wvalue</link>(T *);
&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_PROGRAM_OPTIONS_DECL <link linkend="typed_value">typed_value</link>&lt; <emphasis role="bold">bool</emphasis> &gt; *</type> <link linkend="bool_switch">bool_switch</link>();
&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_PROGRAM_OPTIONS_DECL <link linkend="typed_value">typed_value</link>&lt; <emphasis role="bold">bool</emphasis> &gt; *</type> <link linkend="bool_switch">bool_switch</link>(<emphasis role="bold">bool</emphasis> *);
&#xA0;&#xA0;}
}</synopsis><refentry id="value_semantic"><refmeta><refentrytitle>Class value_semantic</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::value_semantic</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> value_semantic {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="value_semanticconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id309952-bb">~value_semantic</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id322469-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> std::string</type> <link linkend="id306456-bb">name</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <link linkend="id323449-bb">is_zero_tokens</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <link linkend="id286767-bb">is_composing</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <link linkend="id252748-bb">is_implicit</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <link linkend="id421912-bb">is_multitoken</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> 
&#xA0;&#xA0;<link linkend="id301567-bb">parse</link>(boost::any &amp;, <emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp;, <emphasis role="bold">bool</emphasis>) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <link linkend="id283436-bb">apply_default</link>(boost::any &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id226631-bb">notify</link>(<emphasis role="bold">const</emphasis> boost::any &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class which specifies how the option's value is to be parsed and converted into C++ types. </para><refsect2><title><anchor id="value_semanticconstruct-copy-destruct"/><computeroutput>value_semantic</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id309952-bb"/>~value_semantic();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id322469-bb"/><computeroutput>value_semantic</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> std::string</type> <anchor id="id306456-bb"/>name() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Returns the name of the option. The name is only meaningful for automatic help message. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <anchor id="id323449-bb"/>is_zero_tokens() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Returns true if value cannot be specified in source at all. Other methods can still set the value somehow, but user can't affect it. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <anchor id="id286767-bb"/>is_composing() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Returns true if values from different sources should be composed. Otherwise, value from the first source is used and values from other sources are discarded. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <anchor id="id252748-bb"/>is_implicit() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Returns true if explicit value of an option can be omitted. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <anchor id="id421912-bb"/>is_multitoken() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Returns true if value can span several token in input source. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> 
<anchor id="id301567-bb"/>parse(boost::any &amp; value_store, <emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp; new_tokens, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">bool</emphasis> utf8) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Parses a group of tokens that specify a value of option. Stores the result in 'value_store', using whatever representation is desired. May be be called several times if value of the same option is specified more than once. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <anchor id="id283436-bb"/>apply_default(boost::any &amp; value_store) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Called to assign default value to 'value_store'. Returns true if default value is assigned, and false if no default value exists. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <anchor id="id226631-bb"/>notify(<emphasis role="bold">const</emphasis> boost::any &amp; value_store) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Called when final value of an option is determined. </para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id309957"><refmeta><refentrytitle>Class template value_semantic_codecvt_helper</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::value_semantic_codecvt_helper</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> charT&gt; 
<emphasis role="bold">class</emphasis> value_semantic_codecvt_helper {
<emphasis role="bold">public</emphasis>:
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Helper class which perform necessary character conversions in the 'parse' method and forwards the data further. </para><refsect2><title>Specializations</title><itemizedlist><listitem><para><link linkend="id361348-bb">Class value_semantic_codecvt_helper&lt;char&gt;</link></para></listitem><listitem><para><link linkend="id410043-bb">Class value_semantic_codecvt_helper&lt;wchar_t&gt;</link></para></listitem></itemizedlist></refsect2></refsect1></refentry><refentry id="id361348-bb"><refmeta><refentrytitle>Class value_semantic_codecvt_helper&lt;char&gt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::value_semantic_codecvt_helper&lt;char&gt;</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> value_semantic_codecvt_helper&lt;<emphasis role="bold">char</emphasis>&gt; {
<emphasis role="bold">public</emphasis>:

&#xA0;&#xA0;<emphasis>// <link linkend="id275200-bb">protected member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id263057-bb">xparse</link>(boost::any &amp;, <emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp;) <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id226527-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id226532-bb">parse</link>(boost::any &amp;, <emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp;, <emphasis role="bold">bool</emphasis>) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id275200-bb"/><computeroutput>value_semantic_codecvt_helper</computeroutput> protected member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> 
<anchor id="id263057-bb"/>xparse(boost::any &amp; value_store, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp; new_tokens) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id226527-bb"/><computeroutput>value_semantic_codecvt_helper</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id226532-bb"/>parse(boost::any &amp; value_store, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp; new_tokens, <emphasis role="bold">bool</emphasis> utf8) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id410043-bb"><refmeta><refentrytitle>Class value_semantic_codecvt_helper&lt;wchar_t&gt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::value_semantic_codecvt_helper&lt;wchar_t&gt;</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> value_semantic_codecvt_helper&lt;<emphasis role="bold">wchar_t</emphasis>&gt;
  :  : <emphasis role="bold">public</emphasis> boost::program_options::value_semantic
{
<emphasis role="bold">public</emphasis>:

&#xA0;&#xA0;<emphasis>// <link linkend="id306954-bb">protected member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> <link linkend="id221580-bb">xparse</link>(boost::any &amp;, <emphasis role="bold">const</emphasis> std::vector&lt; std::wstring &gt; &amp;) <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id258112-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id258116-bb">parse</link>(boost::any &amp;, <emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp;, <emphasis role="bold">bool</emphasis>) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id306954-bb"/><computeroutput>value_semantic_codecvt_helper</computeroutput> protected member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">void</emphasis></type> 
<anchor id="id221580-bb"/>xparse(boost::any &amp; value_store, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::vector&lt; std::wstring &gt; &amp; new_tokens) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id258112-bb"/><computeroutput>value_semantic_codecvt_helper</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id258116-bb"/>parse(boost::any &amp; value_store, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp; new_tokens, <emphasis role="bold">bool</emphasis> utf8) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="untyped_value"><refmeta><refentrytitle>Class untyped_value</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::untyped_value</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> untyped_value
  :  : <emphasis role="bold">public</emphasis> boost::program_options::value_semantic_codecvt_helper&lt; charT &gt;
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="untyped_valueconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id322390-bb">untyped_value</link>(<emphasis role="bold">bool</emphasis> = false);

&#xA0;&#xA0;<emphasis>// <link linkend="id415126-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>std::string</type> <link linkend="id278850-bb">name</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id402093-bb">is_zero_tokens</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id355976-bb">is_composing</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id405358-bb">is_implicit</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id345393-bb">is_multitoken</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id327856-bb">xparse</link>(boost::any &amp;, <emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id244525-bb">apply_default</link>(boost::any &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id303782-bb">notify</link>(<emphasis role="bold">const</emphasis> boost::any &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class which specifies a simple handling of a value: the value will have string type and only one token is allowed. </para><refsect2><title><anchor id="untyped_valueconstruct-copy-destruct"/><computeroutput>untyped_value</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id322390-bb"/>untyped_value(<emphasis role="bold">bool</emphasis> zero_tokens = false);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id415126-bb"/><computeroutput>untyped_value</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>std::string</type> <anchor id="id278850-bb"/>name() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id402093-bb"/>is_zero_tokens() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id355976-bb"/>is_composing() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id405358-bb"/>is_implicit() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id345393-bb"/>is_multitoken() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id327856-bb"/>xparse(boost::any &amp; value_store, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::vector&lt; std::string &gt; &amp; new_tokens) <emphasis role="bold">const</emphasis>;</literallayout></para><para>If 'value_store' is already initialized, or new_tokens has more than one elements, throws. Otherwise, assigns the first string from 'new_tokens' to 'value_store', without any modifications. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id244525-bb"/>apply_default(boost::any &amp; ) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Does nothing. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id303782-bb"/>notify(<emphasis role="bold">const</emphasis> boost::any &amp; ) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Does nothing. </para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="typed_value"><refmeta><refentrytitle>Class template typed_value</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::typed_value</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, <emphasis role="bold">typename</emphasis> charT = <emphasis role="bold">char</emphasis>&gt; 
<emphasis role="bold">class</emphasis> typed_value
  :  : <emphasis role="bold">public</emphasis> boost::program_options::value_semantic_codecvt_helper&lt; charT &gt;
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="typed_valueconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id337354-bb">typed_value</link>(T *);

&#xA0;&#xA0;<emphasis>// <link linkend="id429890-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><link linkend="typed_value">typed_value</link> *</type> <link linkend="id429896-bb">default_value</link>(<emphasis role="bold">const</emphasis> T &amp;) ;
&#xA0;&#xA0;<type><link linkend="typed_value">typed_value</link> *</type> <link linkend="id409360-bb">default_value</link>(<emphasis role="bold">const</emphasis> T &amp;, <emphasis role="bold">const</emphasis> std::string &amp;) ;
&#xA0;&#xA0;<type><link linkend="typed_value">typed_value</link> *</type> <link linkend="id329497-bb">notifier</link>(function1&lt; <emphasis role="bold">void</emphasis>, <emphasis role="bold">const</emphasis> T &amp; &gt;) ;
&#xA0;&#xA0;<type><link linkend="typed_value">typed_value</link> *</type> <link linkend="id427386-bb">composing</link>() ;
&#xA0;&#xA0;<type><link linkend="typed_value">typed_value</link> *</type> <link linkend="id320553-bb">implicit</link>() ;
&#xA0;&#xA0;<type><link linkend="typed_value">typed_value</link> *</type> <link linkend="id380325-bb">multitoken</link>() ;
&#xA0;&#xA0;<type><link linkend="typed_value">typed_value</link> *</type> <link linkend="id370021-bb">zero_tokens</link>() ;
&#xA0;&#xA0;<type>std::string</type> <link linkend="id440186-bb">name</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id241145-bb">is_zero_tokens</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id334476-bb">is_composing</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id388193-bb">is_implicit</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id419316-bb">is_multitoken</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id354937-bb">xparse</link>(boost::any &amp;, <emphasis role="bold">const</emphasis> std::vector&lt; std::basic_string&lt; charT &gt; &gt; &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <link linkend="id350566-bb">apply_default</link>(boost::any &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id277875-bb">notify</link>(<emphasis role="bold">const</emphasis> boost::any &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class which handles value of a specific type. </para><refsect2><title><anchor id="typed_valueconstruct-copy-destruct"/><computeroutput>typed_value</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id337354-bb"/>typed_value(T * store_to);</literallayout></para><para>Ctor. The 'store_to' parameter tells where to store the value when it's known. The parameter can be NULL. </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id429890-bb"/><computeroutput>typed_value</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><link linkend="typed_value">typed_value</link> *</type> <anchor id="id429896-bb"/>default_value(<emphasis role="bold">const</emphasis> T &amp; v) ;</literallayout></para><para>Specifies default value, which will be used if none is explicitly specified. The type 'T' should provide operator&lt;&lt; for ostream. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="typed_value">typed_value</link> *</type> <anchor id="id409360-bb"/>default_value(<emphasis role="bold">const</emphasis> T &amp; v, <emphasis role="bold">const</emphasis> std::string &amp; textual) ;</literallayout></para><para>Specifies default value, which will be used if none is explicitly specified. Unlike the above overload, the type 'T' need not provide operator&lt;&lt; for ostream, but textual representation of default value must be provided by the user. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="typed_value">typed_value</link> *</type> <anchor id="id329497-bb"/>notifier(function1&lt; <emphasis role="bold">void</emphasis>, <emphasis role="bold">const</emphasis> T &amp; &gt; f) ;</literallayout></para><para>Specifies a function to be called when the final value is determined. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="typed_value">typed_value</link> *</type> <anchor id="id427386-bb"/>composing() ;</literallayout></para><para>Specifies that the value is composing. See the 'is_composing' method for explanation. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="typed_value">typed_value</link> *</type> <anchor id="id320553-bb"/>implicit() ;</literallayout></para><para>Specifies that the value is implicit. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="typed_value">typed_value</link> *</type> <anchor id="id380325-bb"/>multitoken() ;</literallayout></para><para>Specifies that the value can span multiple tokens. </para></listitem><listitem><para><literallayout class="monospaced"><type><link linkend="typed_value">typed_value</link> *</type> <anchor id="id370021-bb"/>zero_tokens() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type>std::string</type> <anchor id="id440186-bb"/>name() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id241145-bb"/>is_zero_tokens() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id334476-bb"/>is_composing() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id388193-bb"/>is_implicit() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id419316-bb"/>is_multitoken() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id354937-bb"/>xparse(boost::any &amp; value_store, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::vector&lt; std::basic_string&lt; charT &gt; &gt; &amp; new_tokens) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Creates an instance of the 'validator' class and calls its operator() to perform athe ctual conversion. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">bool</emphasis></type> <anchor id="id350566-bb"/>apply_default(boost::any &amp; value_store) <emphasis role="bold">const</emphasis>;</literallayout></para><para>If default value was specified via previous call to 'default_value', stores that value into 'value_store'. Returns true if default value was stored. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id277875-bb"/>notify(<emphasis role="bold">const</emphasis> boost::any &amp; value_store) <emphasis role="bold">const</emphasis>;</literallayout></para><para>If an address of variable to store value was specified when creating *this, stores the value there. Otherwise, does nothing. </para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="value"><refmeta><refentrytitle>Function value</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::value</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type><link linkend="typed_value">typed_value</link>&lt; T &gt; *</type> value();
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type><link linkend="typed_value">typed_value</link>&lt; T &gt; *</type> value(T * v);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Creates a typed_value&lt;T&gt; instance. This function is the primary method to create value_semantic instance for a specific type, which can later be passed to 'option_description' constructor. The second overload is used when it's additionally desired to store the value of option into program variable. </para></refsect1></refentry><refentry id="wvalue"><refmeta><refentrytitle>Function wvalue</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::wvalue</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type><link linkend="typed_value">typed_value</link>&lt; T, <emphasis role="bold">wchar_t</emphasis> &gt; *</type> wvalue();
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type><link linkend="typed_value">typed_value</link>&lt; T, <emphasis role="bold">wchar_t</emphasis> &gt; *</type> wvalue(T * v);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Creates a typed_value&lt;T&gt; instance. This function is the primary method to create value_semantic instance for a specific type, which can later be passed to 'option_description' constructor. </para></refsect1></refentry><refentry id="bool_switch"><refmeta><refentrytitle>Function bool_switch</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::bool_switch</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type>BOOST_PROGRAM_OPTIONS_DECL <link linkend="typed_value">typed_value</link>&lt; <emphasis role="bold">bool</emphasis> &gt; *</type> bool_switch();
<type>BOOST_PROGRAM_OPTIONS_DECL <link linkend="typed_value">typed_value</link>&lt; <emphasis role="bold">bool</emphasis> &gt; *</type> bool_switch(<emphasis role="bold">bool</emphasis> * v);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Works the same way as the 'value&lt;bool&gt;' function, but the created value_semantic won't accept any explicit value. So, if the option is present on the command line, the value will be 'true'. </para></refsect1></refentry></section><section id="id361047"><title>Header &lt;<ulink url="../../boost/program_options/variables_map.hpp">boost/program_options/variables_map.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> program_options {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="variable_value">variable_value</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="abstract_variables_map">abstract_variables_map</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="variables_map">variables_map</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_PROGRAM_OPTIONS_DECL <emphasis role="bold">void</emphasis></type> 
&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id281355">store</link>(<emphasis role="bold">const</emphasis> <link linkend="basic_parsed_options">basic_parsed_options</link>&lt; <emphasis role="bold">char</emphasis> &gt; &amp;, <link linkend="variables_map">variables_map</link> &amp;, <emphasis role="bold">bool</emphasis> = false);
&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_PROGRAM_OPTIONS_DECL <emphasis role="bold">void</emphasis></type> 
&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id386334">store</link>(<emphasis role="bold">const</emphasis> <link linkend="basic_parsed_options">basic_parsed_options</link>&lt; <emphasis role="bold">wchar_t</emphasis> &gt; &amp;, <link linkend="variables_map">variables_map</link> &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<type>BOOST_PROGRAM_OPTIONS_DECL <emphasis role="bold">void</emphasis></type> <link linkend="notify">notify</link>(<link linkend="variables_map">variables_map</link> &amp;);
&#xA0;&#xA0;}
}</synopsis><refentry id="variable_value"><refmeta><refentrytitle>Class variable_value</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::variable_value</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> variable_value {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="variable_valueconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id320650-bb">variable_value</link>();
&#xA0;&#xA0;<link linkend="id320653-bb">variable_value</link>(<emphasis role="bold">const</emphasis> boost::any &amp;, <emphasis role="bold">bool</emphasis>);

&#xA0;&#xA0;<emphasis>// <link linkend="id338122-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type><emphasis role="bold">const</emphasis> T &amp;</type> <link linkend="id338128-bb">as</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type>T &amp;</type> <link linkend="id429394-bb">as</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id331097-bb">empty</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id425639-bb">defaulted</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> boost::any &amp;</type> <link linkend="id246647-bb">value</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>boost::any &amp;</type> <link linkend="id335698-bb">value</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class holding value of option. Contains details about how the value is set and allows to conveniently obtain the value. </para><refsect2><title><anchor id="variable_valueconstruct-copy-destruct"/><computeroutput>variable_value</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id320650-bb"/>variable_value();</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id320653-bb"/>variable_value(<emphasis role="bold">const</emphasis> boost::any &amp; v, <emphasis role="bold">bool</emphasis> defaulted);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id338122-bb"/><computeroutput>variable_value</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type><emphasis role="bold">const</emphasis> T &amp;</type> <anchor id="id338128-bb"/>as() <emphasis role="bold">const</emphasis>;</literallayout></para><para>If stored value if of type T, returns that value. Otherwise, throws boost::bad_any_cast exception. </para></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type>T &amp;</type> <anchor id="id429394-bb"/>as() ;</literallayout></para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id331097-bb"/>empty() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id425639-bb"/>defaulted() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Returns true if the value was not explicitly given, but has default value. </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> boost::any &amp;</type> <anchor id="id246647-bb"/>value() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Returns the contained value. </para></listitem><listitem><para><literallayout class="monospaced"><type>boost::any &amp;</type> <anchor id="id335698-bb"/>value() ;</literallayout></para><para>Returns the contained value. </para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="abstract_variables_map"><refmeta><refentrytitle>Class abstract_variables_map</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::abstract_variables_map</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> abstract_variables_map {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="abstract_variables_mapconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id228728-bb">abstract_variables_map</link>();
&#xA0;&#xA0;<link linkend="id228731-bb">abstract_variables_map</link>(<emphasis role="bold">const</emphasis> <link linkend="abstract_variables_map">abstract_variables_map</link> *);
&#xA0;&#xA0;<link linkend="id225470-bb">~abstract_variables_map</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id421775-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <link linkend="variable_value">variable_value</link> &amp;</type> <link linkend="id421781-bb"><emphasis role="bold">operator</emphasis>[]</link>(<emphasis role="bold">const</emphasis> std::string &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id436274-bb">next</link>(<link linkend="abstract_variables_map">abstract_variables_map</link> *) ;

&#xA0;&#xA0;<emphasis>// <link linkend="id225473-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">const</emphasis> <link linkend="variable_value">variable_value</link> &amp;</type> <link linkend="id325125-bb">get</link>(<emphasis role="bold">const</emphasis> std::string &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Implements string-&gt;string mapping with convenient value casting facilities. </para><refsect2><title><anchor id="abstract_variables_mapconstruct-copy-destruct"/><computeroutput>abstract_variables_map</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id228728-bb"/>abstract_variables_map();</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id228731-bb"/>abstract_variables_map(<emphasis role="bold">const</emphasis> <link linkend="abstract_variables_map">abstract_variables_map</link> * next);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id225470-bb"/>~abstract_variables_map();</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id421775-bb"/><computeroutput>abstract_variables_map</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <link linkend="variable_value">variable_value</link> &amp;</type> <anchor id="id421781-bb"/><emphasis role="bold">operator</emphasis>[](<emphasis role="bold">const</emphasis> std::string &amp; name) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Obtains the value of variable 'name', from *this and possibly from the chain of variable maps.</para><para><itemizedlist><listitem><para>if there's no value in *this.<itemizedlist><listitem><para>if there's next variable map, returns value from it</para></listitem><listitem><para>otherwise, returns empty value</para></listitem></itemizedlist></para></listitem></itemizedlist></para><para><itemizedlist><listitem><para>if there's defaulted value<itemizedlist><listitem><para>if there's next varaible map, which has a non-defauled value, return that</para></listitem><listitem><para>otherwise, return value from *this</para></listitem></itemizedlist></para></listitem></itemizedlist></para><para><itemizedlist><listitem><para>if there's a non-defauled value, returns it. </para></listitem></itemizedlist></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id436274-bb"/>next(<link linkend="abstract_variables_map">abstract_variables_map</link> * next) ;</literallayout></para><para>Sets next variable map, which will be used to find variables not found in *this. </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id225473-bb"/><computeroutput>abstract_variables_map</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">virtual</emphasis> <emphasis role="bold">const</emphasis> <link linkend="variable_value">variable_value</link> &amp;</type> <anchor id="id325125-bb"/>get(<emphasis role="bold">const</emphasis> std::string &amp; name) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Returns value of variable 'name' stored in *this, or empty value otherwise. </para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="variables_map"><refmeta><refentrytitle>Class variables_map</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::variables_map</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> variables_map
  :  : <emphasis role="bold">public</emphasis> boost::program_options::abstract_variables_map
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="variables_mapconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id330558-bb">variables_map</link>();
&#xA0;&#xA0;<link linkend="id341365-bb">variables_map</link>(<emphasis role="bold">const</emphasis> <link linkend="abstract_variables_map">abstract_variables_map</link> *);

&#xA0;&#xA0;<emphasis>// <link linkend="id310840-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <link linkend="variable_value">variable_value</link> &amp;</type> <link linkend="id374310-bb"><emphasis role="bold">operator</emphasis>[]</link>(<emphasis role="bold">const</emphasis> std::string &amp;) <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id361413-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> <link linkend="variable_value">variable_value</link> &amp;</type> <link linkend="id225736-bb">get</link>(<emphasis role="bold">const</emphasis> std::string &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Concrete variables map which store variables in real map. </para><refsect2><title><anchor id="variables_mapconstruct-copy-destruct"/><computeroutput>variables_map</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id330558-bb"/>variables_map();</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id341365-bb"/>variables_map(<emphasis role="bold">const</emphasis> <link linkend="abstract_variables_map">abstract_variables_map</link> * next);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id310840-bb"/><computeroutput>variables_map</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <link linkend="variable_value">variable_value</link> &amp;</type> <anchor id="id374310-bb"/><emphasis role="bold">operator</emphasis>[](<emphasis role="bold">const</emphasis> std::string &amp; name) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Obtains the value of variable 'name', from *this and possibly from the chain of variable maps.</para><para><itemizedlist><listitem><para>if there's no value in *this.<itemizedlist><listitem><para>if there's next variable map, returns value from it</para></listitem><listitem><para>otherwise, returns empty value</para></listitem></itemizedlist></para></listitem></itemizedlist></para><para><itemizedlist><listitem><para>if there's defaulted value<itemizedlist><listitem><para>if there's next varaible map, which has a non-defauled value, return that</para></listitem><listitem><para>otherwise, return value from *this</para></listitem></itemizedlist></para></listitem></itemizedlist></para><para><itemizedlist><listitem><para>if there's a non-defauled value, returns it. </para></listitem></itemizedlist></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id361413-bb"/><computeroutput>variables_map</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> <link linkend="variable_value">variable_value</link> &amp;</type> <anchor id="id225736-bb"/>get(<emphasis role="bold">const</emphasis> std::string &amp; name) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Implementation of abstract_variables_map::get which does 'find' in *this. </para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id281355"><refmeta><refentrytitle>Function store</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::store</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type>BOOST_PROGRAM_OPTIONS_DECL <emphasis role="bold">void</emphasis></type> 
store(<emphasis role="bold">const</emphasis> <link linkend="basic_parsed_options">basic_parsed_options</link>&lt; <emphasis role="bold">char</emphasis> &gt; &amp; options, <link linkend="variables_map">variables_map</link> &amp; m, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">bool</emphasis> utf8 = false);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Stores in 'm' all options that are defined in 'options'. If 'm' already has a non-defaulted value of an option, that value is not changed, even if 'options' specify some value. </para></refsect1></refentry><refentry id="id386334"><refmeta><refentrytitle>Function store</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::store</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type>BOOST_PROGRAM_OPTIONS_DECL <emphasis role="bold">void</emphasis></type> 
store(<emphasis role="bold">const</emphasis> <link linkend="basic_parsed_options">basic_parsed_options</link>&lt; <emphasis role="bold">wchar_t</emphasis> &gt; &amp; options, <link linkend="variables_map">variables_map</link> &amp; m);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Stores in 'm' all options that are defined in 'options'. If 'm' already has a non-defaulted value of an option, that value is not changed, even if 'options' specify some value. This is wide character variant. </para></refsect1></refentry><refentry id="notify"><refmeta><refentrytitle>Function notify</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::program_options::notify</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<type>BOOST_PROGRAM_OPTIONS_DECL <emphasis role="bold">void</emphasis></type> notify(<link linkend="variables_map">variables_map</link> &amp; m);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Runs all 'notify' function for options in 'm'. </para></refsect1></refentry></section><section id="id401803"><title>Header &lt;<ulink url="../../boost/program_options/version.hpp">boost/program_options/version.hpp</ulink>&gt;</title><synopsis>

<link linkend="id401809">BOOST_PROGRAM_OPTIONS_VERSION</link></synopsis><refentry id="id401809"><refmeta><refentrytitle>Macro BOOST_PROGRAM_OPTIONS_VERSION</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>BOOST_PROGRAM_OPTIONS_VERSION</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>BOOST_PROGRAM_OPTIONS_VERSION</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The version of the source interface. The value will be incremented whenever a change is made which might cause compilation errors for existing code. </para></refsect1></refentry></section></section></chapter><chapter xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="ref" rev:last-revision="$Date: 2004/07/09 00:56:42 $"><chapterinfo><author><firstname>Jaakko</firstname><surname>J&#xE4;rvi</surname></author><author><firstname>Peter</firstname><surname>Dimov</surname></author><author><firstname>Douglas</firstname><surname>Gregor</surname></author><author><firstname>Dave</firstname><surname>Abrahams</surname></author><copyright><year>1999</year><year>2000</year><holder>Jaakko J&#xE4;rvi</holder></copyright><copyright><year>2001</year><year>2002</year><holder>Peter Dimov</holder></copyright><copyright><year>2002</year><holder>David Abrahams</holder></copyright><legalnotice><para>Permission to copy, use, modify, sell and distribute this
      software is granted provided this copyright notice appears in
      all copies.  This software is provided "as is" without express
      or implied warranty, and with no claim as to its suitability for
      any purpose.
      </para></legalnotice></chapterinfo><title>Boost.Ref</title><section id="ref.intro"><title>Introduction</title><para>The Ref library is a small library that is useful for passing
  references to function templates (algorithms) that would usually
  take copies of their arguments. It defines the class template
  <computeroutput><link linkend="reference_wrapper">boost::reference_wrapper&lt;T&gt;</link></computeroutput>,
  the two functions
  <computeroutput><link linkend="id376299">boost::ref</link></computeroutput> and
  <computeroutput><link linkend="cref">boost::cref</link></computeroutput> that return
  instances of <computeroutput>boost::reference_wrapper&lt;T&gt;</computeroutput>, and the
  two traits classes
  <computeroutput><link linkend="is_reference_wrapper">boost::is_reference_wrapper&lt;T&gt;</link></computeroutput>
  and
  <computeroutput><link linkend="unwrap_reference">boost::unwrap_reference&lt;T&gt;</link></computeroutput>.</para><para>The purpose of
  <computeroutput>boost::reference_wrapper&lt;T&gt;</computeroutput> is to
  contain a reference to an object of type T. It is primarily used to
  "feed" references to function templates (algorithms) that take their
  parameter by value.</para><para>To support this usage,
  <computeroutput>boost::reference_wrapper&lt;T&gt;</computeroutput> provides an implicit
  conversion to <computeroutput>T&amp;</computeroutput>. This usually allows the function
  templates to work on references unmodified.</para><para><computeroutput>boost::reference_wrapper&lt;T&gt;</computeroutput> is
  both CopyConstructible and Assignable (ordinary references are not
  Assignable).</para><para>The expression <computeroutput>boost::ref(x)</computeroutput>
  returns a
  <computeroutput>boost::reference_wrapper&lt;X&gt;(x)</computeroutput> where X
  is the type of x. Similarly,
  <computeroutput>boost::cref(x)</computeroutput> returns a
  <computeroutput>boost::reference_wrapper&lt;X const&gt;(x)</computeroutput>.</para><para>The expression
  <computeroutput>boost::is_reference_wrapper&lt;T&gt;::value</computeroutput>
  is true if T is a <computeroutput>reference_wrapper</computeroutput>, and
  false otherwise.</para><para>The type-expression
  <computeroutput>boost::unwrap_reference&lt;T&gt;::type</computeroutput> is T::type if T
  is a <computeroutput>reference_wrapper</computeroutput>, T otherwise.</para></section><section id="ref.reference"><title>Reference</title><section id="header.boost.ref.hpp"><title>Header &lt;<ulink url="../../boost/ref.hpp">boost/ref.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <emphasis role="bold">class</emphasis> <link linkend="reference_wrapper">reference_wrapper</link>;
&#xA0;&#xA0;<type>reference_wrapper&lt;T&gt;</type> <link linkend="id376299">ref</link>(T&amp;);
&#xA0;&#xA0;<type>reference_wrapper&lt;T <emphasis role="bold">const</emphasis>&gt;</type> <link linkend="cref">cref</link>(T <emphasis role="bold">const</emphasis>&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <emphasis role="bold">class</emphasis> <link linkend="is_reference_wrapper">is_reference_wrapper</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <emphasis role="bold">class</emphasis> <link linkend="unwrap_reference">unwrap_reference</link>;
}</synopsis><refentry id="reference_wrapper"><refmeta><refentrytitle>Class template reference_wrapper</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::reference_wrapper</refname><refpurpose>
        Contains a reference to an object of type
        <computeroutput>T</computeroutput>. 
      </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; 
<emphasis role="bold">class</emphasis> reference_wrapper {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T type;

&#xA0;&#xA0;<emphasis>// <link linkend="reference_wrapperconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">explicit</emphasis> <link linkend="id177704-bb">reference_wrapper</link>(T&amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id274636-bb">access</link></emphasis>
&#xA0;&#xA0;<link linkend="id244380-bb"><emphasis role="bold">operator</emphasis> T&amp;</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>T&amp;</type> <link linkend="id434315-bb">get</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>T*</type> <link linkend="id231874-bb">get_pointer</link>() <emphasis role="bold">const</emphasis>;
};

<emphasis>// <link linkend="id376296-bb">constructors</link></emphasis>
<type>reference_wrapper&lt;T&gt;</type> <link linkend="id376299">ref</link>(T&amp;);
<type>reference_wrapper&lt;T <emphasis role="bold">const</emphasis>&gt;</type> <link linkend="cref">cref</link>(T <emphasis role="bold">const</emphasis>&amp;);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para><computeroutput><link linkend="reference_wrapper">reference_wrapper</link></computeroutput>
        is primarily used to "feed" references to function templates
        (algorithms) that take their parameter by value.  It provides
        an implicit conversion to
        <computeroutput>T&amp;</computeroutput>, which usually allows
        the function templates to work on references
        unmodified.</para><refsect2><title><anchor id="reference_wrapperconstruct-copy-destruct"/><computeroutput>reference_wrapper</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">explicit</emphasis> <anchor id="id177704-bb"/>reference_wrapper(T&amp; t);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Constructs a
        <computeroutput><link linkend="reference_wrapper">reference_wrapper</link></computeroutput>
        object that stores a reference to
        <computeroutput>t</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Does not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id274636-bb"/><computeroutput>reference_wrapper</computeroutput> access</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id244380-bb"/><emphasis role="bold">operator</emphasis> T&amp;() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>The stored reference.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Does not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>T&amp;</type> <anchor id="id434315-bb"/>get() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>The stored reference.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Does not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>T*</type> <anchor id="id231874-bb"/>get_pointer() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>A pointer to the object referenced by the stored reference.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Does not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id376296-bb"/><computeroutput>reference_wrapper</computeroutput> constructors</title><orderedlist><listitem><para><literallayout class="monospaced"><type>reference_wrapper&lt;T&gt;</type> <anchor id="id376299"/>ref(T&amp; t);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput><link linkend="reference_wrapper">reference_wrapper</link>&lt;T&gt;(t)</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Does not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>reference_wrapper&lt;T <emphasis role="bold">const</emphasis>&gt;</type> <anchor id="cref"/>cref(T <emphasis role="bold">const</emphasis>&amp; t);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput><link linkend="reference_wrapper">reference_wrapper</link>&lt;T const&gt;(t)</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Does not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="is_reference_wrapper"><refmeta><refentrytitle>Class template is_reference_wrapper</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::is_reference_wrapper</refname><refpurpose>Determine if a type <computeroutput>T</computeroutput> is an instantiation of <computeroutput><link linkend="reference_wrapper">reference_wrapper</link></computeroutput>.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; 
<emphasis role="bold">class</emphasis> is_reference_wrapper {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// static constants</emphasis>
&#xA0;&#xA0;<emphasis role="bold">static</emphasis> <emphasis role="bold">const</emphasis> <emphasis role="bold">bool</emphasis> value = unspecified;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <computeroutput>value</computeroutput> static
        constant will be <computeroutput>true</computeroutput> iff the
        type <computeroutput>T</computeroutput> is a specialization of
        <computeroutput><link linkend="reference_wrapper">reference_wrapper</link></computeroutput>.</para></refsect1></refentry><refentry id="unwrap_reference"><refmeta><refentrytitle>Class template unwrap_reference</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::unwrap_reference</refname><refpurpose>Find the type in a <computeroutput><link linkend="reference_wrapper">reference_wrapper</link></computeroutput>.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; 
<emphasis role="bold">class</emphasis> unwrap_reference {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>unspecified</emphasis> type;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The typedef <computeroutput>type</computeroutput> is
        <computeroutput>T::type</computeroutput> if
        <computeroutput>T</computeroutput> is a
        <computeroutput><link linkend="reference_wrapper">reference_wrapper</link></computeroutput>,
        <computeroutput>T</computeroutput> otherwise.</para></refsect1></refentry></section></section><section id="ref.ack"><title>Acknowledgements</title><para><link linkend="id376299">ref</link> and <link linkend="cref">cref</link>
  were originally part of the <ulink url="../../libs/tuple/index.html">Tuple</ulink> library
  by Jaakko J&#xE4;rvi. They were "promoted to boost:: status" by
  Peter Dimov because they are generally useful.  Douglas Gregor and
  Dave Abrahams contributed
  <link linkend="is_reference_wrapper">is_reference_wrapper</link> and
  <link linkend="unwrap_reference">unwrap_reference</link>.</para></section></chapter><chapter xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="signals" rev:last-revision="$Date: 2004/05/04 18:17:22 $"><chapterinfo><author><firstname>Douglas</firstname><surname>Gregor</surname></author><copyright><year>2001</year><year>2002</year><year>2003</year><year>2004</year><holder>Douglas Gregor</holder></copyright><legalnotice><para>Use, modification and distribution is subject to the Boost
    Software License, Version 1.0. (See accompanying file
    <filename>LICENSE_1_0.txt</filename> or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)</para></legalnotice></chapterinfo><title>Boost.Signals</title><section rev:last-revision="$Date: 2003/03/12 23:27:23 $" xml:base="../libs/signals/doc/introduction.xml"><title>Introduction</title><para>The Boost.Signals library is an implementation of a managed
signals and slots system. Signals represent callbacks with multiple
targets, and are also called publishers or events in similar
systems. Signals are connected to some set of slots, which are
callback receivers (also called event targets or subscribers), which
are called when the signal is "emitted."</para><para>Signals and slots are managed, in that signals and slots (or,
more properly, objects that occur as part of the slots) track all
connections and are capable of automatically disconnecting signal/slot
connections when either is destroyed. This enables the user to make
signal/slot connections without expending a great effort to manage the
lifetimes of those connections with regard to the lifetimes of all
objects involved.</para><para>When signals are connected to multiple slots, there is a
question regarding the relationship between the return values of the
slots and the return value of the signals. Boost.Signals allows the
user to specify the manner in which multiple return values are
combined.</para></section><section rev:last-revision="$Date: 2004/11/18 23:15:15 $" id="signals.tutorial" xml:base="../libs/signals/doc/tutorial.xml"><title>Tutorial</title><section><title>How to Read this Tutorial</title><para>This tutorial is not meant to be read linearly. Its top-level
structure roughly separates different concepts in the library
(e.g., handling calling multiple slots, passing values to and from
slots) and in each of these concepts the basic ideas are presented
first and then more complex uses of the library are described
later. Each of the sections is marked <emphasis>Beginner</emphasis>,
<emphasis>Intermediate</emphasis>, or <emphasis>Advanced</emphasis> to help guide the
reader. The <emphasis>Beginner</emphasis> sections include information that all
library users should know; one can make good use of the Signals
library after having read only the <emphasis>Beginner</emphasis> sections. The
<emphasis>Intermediate</emphasis> sections build on the <emphasis>Beginner</emphasis>
sections with slightly more complex uses of the library. Finally,
the <emphasis>Advanced</emphasis> sections detail very advanced uses of the
Signals library, that often require a solid working knowledge of
the <emphasis>Beginner</emphasis> and <emphasis>Intermediate</emphasis> topics; most users
will not need to read the <emphasis>Advanced</emphasis> sections.</para></section><section><title>Compatibility Note</title><para>Boost.Signals has two syntactical forms: the preferred form and
the compatibility form. The preferred form fits more closely with the
C++ language and reduces the number of separate template parameters
that need to be considered, often improving readability; however, the
preferred form is not supported on all platforms due to compiler
bugs. The compatible form will work on all compilers supported by
Boost.Signals. Consult the table below to determine which syntactic
form to use for your compiler. Users of Boost.Function, please note
that the preferred syntactic form in Signals is equivalent to that of
Function's preferred syntactic form.</para><para>If your compiler does not appear in this list, please try the
preferred syntax and report your results to the Boost list so that
we can keep this table up-to-date.</para><informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><itemizedlist><listitem><para>GNU C++ 2.95.x, 3.0.x, 3.1.x</para></listitem><listitem><para>Comeau C++ 4.2.45.2</para></listitem><listitem><para>SGI MIPSpro 7.3.0</para></listitem><listitem><para>Intel C++ 5.0, 6.0</para></listitem><listitem><para>Compaq's cxx 6.2</para></listitem><listitem><para>Microsoft Visual C++ 7.1</para></listitem></itemizedlist></entry><entry><itemizedlist><listitem><para><emphasis>Any compiler supporting the preferred syntax</emphasis></para></listitem><listitem><para>Microsoft Visual C++ 6.0, 7.0</para></listitem><listitem><para>Borland C++ 5.5.1</para></listitem><listitem><para>Sun WorkShop 6 update 2 C++ 5.3</para></listitem><listitem><para>Metrowerks CodeWarrior 8.1</para></listitem></itemizedlist></entry></row></tbody></tgroup></informaltable></section><section><title>Hello, World! (Beginner)</title><para>The following example writes "Hello, World!" using signals and
slots. First, we create a signal <computeroutput>sig</computeroutput>, a signal that
takes no arguments and has a void return value. Next, we connect
the <computeroutput>hello</computeroutput> function object to the signal using the
<computeroutput>connect</computeroutput> method. Finally, use the signal
<computeroutput>sig</computeroutput> like a function to call the slots, which in turns
invokes <computeroutput>HelloWorld::operator()</computeroutput> to print "Hello,
World!".</para><informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting>
struct HelloWorld 
{
  void operator()() const 
  { 
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;
  } 
};

// ...

// Signal with no arguments and a void return value
<link linkend="signal">boost::signal</link>&lt;void ()&gt; sig;

// Connect a HelloWorld slot
HelloWorld hello;
sig.<link linkend="id503915-bb">connect</link>(hello);

// Call all of the slots
sig();
</programlisting></entry><entry><programlisting>
struct HelloWorld 
{
  void operator()() const 
  { 
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;
  } 
};

// ...

// Signal with no arguments and a void return value
<link linkend="signalN">boost::signal0</link>&lt;void&gt; sig;

// Connect a HelloWorld slot
HelloWorld hello;
sig.<link linkend="id503915-bb">connect</link>(hello);

// Call all of the slots
sig();
</programlisting></entry></row></tbody></tgroup></informaltable></section><section><title>Calling multiple slots</title><section><title>Connecting multiple slots (Beginner)</title><para>Calling a single slot from a signal isn't very interesting, so
we can make the Hello, World program more interesting by splitting
the work of printing "Hello, World!" into two completely separate
slots. The first slot will print "Hello" and may look like
this:</para><programlisting>
struct Hello 
{
  void operator()() const
  {
    std::cout &lt;&lt; "Hello";
  }
};
</programlisting><para>The second slot will print ", World!" and a newline, to complete
the program. The second slot may look like this:</para><programlisting>
struct World
{
  void operator()() const
  {
    std::cout &lt;&lt; ", World!" &lt;&lt; std::endl;
  }
};
</programlisting><para>Like in our previous example, we can create a signal
<computeroutput>sig</computeroutput> that takes no arguments and has a
<computeroutput>void</computeroutput> return value. This time, we connect both a
<computeroutput>hello</computeroutput> and a <computeroutput>world</computeroutput> slot to the same
signal, and when we call the signal both slots will be called.</para><informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting><link linkend="signal">boost::signal</link>&lt;void ()&gt; sig;

sig.<link linkend="id503915-bb">connect</link>(Hello());
sig.<link linkend="id503915-bb">connect</link>(World());

sig();
</programlisting></entry><entry><programlisting><link linkend="signalN">boost::signal0</link>&lt;void&gt; sig;

sig.<link linkend="id503915-bb">connect</link>(Hello());
sig.<link linkend="id503915-bb">connect</link>(World());

sig();
</programlisting></entry></row></tbody></tgroup></informaltable><para>By default, slots are called in first-in first-out (FIFO) order,
so the output of this program will be as expected:</para><programlisting>
Hello, World!
</programlisting></section><section><title>Ordering slot call groups (Intermediate)</title><para>Slots are free to have side effects, and that can mean that some
slots will have to be called before others even if they are not connected in that order. The Boost.Signals
library allows slots to be placed into groups that are ordered in
some way. For our Hello, World program, we want "Hello" to be
printed before ", World!", so we put "Hello" into a group that must
be executed before the group that ", World!" is in. To do this, we
can supply an extra parameter at the beginning of the
<computeroutput>connect</computeroutput> call that specifies the group. Group values
are, by default, <computeroutput>int</computeroutput>s, and are ordered by the integer
&lt; relation. Here's how we construct Hello, World:</para><informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting><link linkend="signal">boost::signal</link>&lt;void ()&gt; sig;
sig.<link linkend="id503915-bb">connect</link>(1, World());
sig.<link linkend="id503915-bb">connect</link>(0, Hello());
sig();
</programlisting></entry><entry><programlisting><link linkend="signalN">boost::signal0</link>&lt;void&gt; sig;
sig.<link linkend="id503915-bb">connect</link>(1, World());
sig.<link linkend="id503915-bb">connect</link>(0, Hello());
sig();
</programlisting></entry></row></tbody></tgroup></informaltable><para>This program will correctly print "Hello, World!", because the
<computeroutput>Hello</computeroutput> object is in group 0, which precedes group 1 where
the <computeroutput>World</computeroutput> object resides. The group
parameter is, in fact, optional. We omitted it in the first Hello,
World example because it was unnecessary when all of the slots are
independent. So what happens if we mix calls to connect that use the
group parameter and those that don't? The "unnamed" slots (i.e., those
that have been connected without specifying a group name) can be
placed at the front or back of the slot list (by passing
<computeroutput>boost::signals::at_front</computeroutput> or <computeroutput>boost::signals::at_back</computeroutput>
as the last parameter to <computeroutput><link linkend="id503915-bb">connect</link></computeroutput>, respectively), and defaults to the end of the list. When
a group is specified, the final parameter describes where the slot
will be placed within the group ordering. If we add a new slot
to our example like this:</para><programlisting>
struct GoodMorning
{
  void operator()() const
  {
    std::cout &lt;&lt; "... and good morning!" &lt;&lt; std::endl;
  }
};

sig.<link linkend="id503915-bb">connect</link>(GoodMorning());
</programlisting><para>... we will get the result we wanted:</para><programlisting>
Hello, World!
... and good morning!
</programlisting></section></section><section><title>Passing values to and from slots</title><section><title>Slot Arguments (Beginner)</title><para>Signals can propagate arguments to each of the slots they call.
For instance, a signal that propagates mouse motion events might
want to pass along the new mouse coordinates and whether the mouse
buttons are pressed.</para><para>As an example, we'll create a signal that passes two
<computeroutput>float</computeroutput> arguments to its slots. Then we'll create a few
slots that print the results of various arithmetic operations on
these values.</para><programlisting>
void print_sum(float x, float y)
{
  std::cout &lt;&lt; "The sum is " &lt;&lt; x+y &lt;&lt; std::endl;
}

void print_product(float x, float y)
{
  std::cout &lt;&lt; "The product is " &lt;&lt; x*y &lt;&lt; std::endl;
}

void print_difference(float x, float y)
{
  std::cout &lt;&lt; "The difference is " &lt;&lt; x-y &lt;&lt; std::endl;
}

void print_quotient(float x, float y)
{
  std::cout &lt;&lt; "The quotient is " &lt;&lt; x/y &lt;&lt; std::endl;
}
</programlisting><informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting><link linkend="signal">boost::signal</link>&lt;void (float, float)&gt; sig;

sig.<link linkend="id503915-bb">connect</link>(&amp;print_sum);
sig.<link linkend="id503915-bb">connect</link>(&amp;print_product);
sig.<link linkend="id503915-bb">connect</link>(&amp;print_difference);
sig.<link linkend="id503915-bb">connect</link>(&amp;print_quotient);

sig(5, 3);
</programlisting></entry><entry><programlisting><link linkend="signalN">boost::signal2</link>&lt;void, float, float&gt; sig;

sig.<link linkend="id503915-bb">connect</link>(&amp;print_sum);
sig.<link linkend="id503915-bb">connect</link>(&amp;print_product);
sig.<link linkend="id503915-bb">connect</link>(&amp;print_difference);
sig.<link linkend="id503915-bb">connect</link>(&amp;print_quotient);

sig(5, 3);
</programlisting></entry></row></tbody></tgroup></informaltable><para>This program will print out the following:</para><programlisting>
The sum is 8
The difference is 2
The product is 15
The quotient is 1.66667
</programlisting><para>So any values that are given to <computeroutput>sig</computeroutput> when it is
called like a function are passed to each of the slots. We have to
declare the types of these values up front when we create the
signal. The type <computeroutput><link linkend="signal">boost::signal</link>&lt;void (float,
float)&gt;</computeroutput> means that the signal has a <computeroutput>void</computeroutput>
return value and takes two <computeroutput>float</computeroutput> values. Any slot
connected to <computeroutput>sig</computeroutput> must therefore be able to take two
<computeroutput>float</computeroutput> values.</para></section><section><title>Signal Return Values (Advanced)</title><para>Just as slots can receive arguments, they can also return
values. These values can then be returned back to the caller of the
signal through a <firstterm>combiner</firstterm>. The combiner is a mechanism
that can take the results of calling slots (there many be no
results or a hundred; we don't know until the program runs) and
coalesces them into a single result to be returned to the caller.
The single result is often a simple function of the results of the
slot calls: the result of the last slot call, the maximum value
returned by any slot, or a container of all of the results are some
possibilities.</para><para>We can modify our previous arithmetic operations example
slightly so that the slots all return the results of computing the
product, quotient, sum, or difference. Then the signal itself can
return a value based on these results to be printed:</para><informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting>
float product(float x, float y) { return x*y; }
float quotient(float x, float y) { return x/y; }
float sum(float x, float y) { return x+y; }
float difference(float x, float y) { return x-y; }

<link linkend="signal">boost::signal</link>&lt;float (float x, float y)&gt; sig;

sig.<link linkend="id503915-bb">connect</link>(&amp;product);
sig.<link linkend="id503915-bb">connect</link>(&amp;quotient);
sig.<link linkend="id503915-bb">connect</link>(&amp;sum);
sig.<link linkend="id503915-bb">connect</link>(&amp;difference);

std::cout &lt;&lt; sig(5, 3) &lt;&lt; std::endl;
</programlisting></entry><entry><programlisting>
float product(float x, float y) { return x*y; }
float quotient(float x, float y) { return x/y; }
float sum(float x, float y) { return x+y; }
float difference(float x, float y) { return x-y; }

<link linkend="signalN">boost::signal2</link>&lt;float, float, float&gt; sig;

sig.<link linkend="id503915-bb">connect</link>(&amp;product);
sig.<link linkend="id503915-bb">connect</link>(&amp;quotient);
sig.<link linkend="id503915-bb">connect</link>(&amp;sum);
sig.<link linkend="id503915-bb">connect</link>(&amp;difference);

std::cout &lt;&lt; sig(5, 3) &lt;&lt; std::endl;
</programlisting></entry></row></tbody></tgroup></informaltable><para>This example program will output <computeroutput>2</computeroutput>. This is because the
default behavior of a signal that has a return type
(<computeroutput>float</computeroutput>, the first template argument given to the
<computeroutput><link linkend="signal">boost::signal</link></computeroutput> class template) is to call all slots and
then return the result returned by the last slot called. This
behavior is admittedly silly for this example, because slots have
no side effects and the result is the last slot connect.</para><para>A more interesting signal result would be the maximum of the
values returned by any slot. To do this, we create a custom
combiner that looks like this:</para><programlisting>
template&lt;typename T&gt;
struct maximum
{
  typedef T result_type;

  template&lt;typename InputIterator&gt;
  T operator()(InputIterator first, InputIterator last) const
  {
    // If there are no slots to call, just return the
    // default-constructed value
    if (first == last)
      return T();

    T max_value = *first++;
    while (first != last) {
      if (max_value &lt; *first)
        max_value = *first;
      ++first;
    }
  
    return max_value;
  }
};
</programlisting><para>The <computeroutput>maximum</computeroutput> class template acts as a function
object. Its result type is given by its template parameter, and
this is the type it expects to be computing the maximum based on
(e.g., <computeroutput>maximum&lt;float&gt;</computeroutput> would find the maximum
<computeroutput>float</computeroutput> in a sequence of <computeroutput>float</computeroutput>s). When a
<computeroutput>maximum</computeroutput> object is invoked, it is given an input
iterator sequence <computeroutput>[first, last)</computeroutput> that includes the
results of calling all of the slots. <computeroutput>maximum</computeroutput> uses this
input iterator sequence to calculate the maximum element, and
returns that maximum value.</para><para>We actually use this new function object type by installing it
as a combiner for our signal. The combiner template argument
follows the signal's calling signature:</para><informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting><link linkend="signal">boost::signal</link>&lt;float (float x, float y), 
              maximum&lt;float&gt; &gt; sig;
</programlisting></entry><entry><programlisting><link linkend="signalN">boost::signal2</link>&lt;float, float, float, 
               maximum&lt;float&gt; &gt; sig;
</programlisting></entry></row></tbody></tgroup></informaltable><para>Now we can connect slots that perform arithmetic functions and
use the signal:</para><programlisting>
sig.<link linkend="id503915-bb">connect</link>(&amp;quotient);
sig.<link linkend="id503915-bb">connect</link>(&amp;product);
sig.<link linkend="id503915-bb">connect</link>(&amp;sum);
sig.<link linkend="id503915-bb">connect</link>(&amp;difference);

std::cout &lt;&lt; sig(5, 3) &lt;&lt; std::endl;
</programlisting><para>The output of this program will be <computeroutput>15</computeroutput>, because
regardless of the order in which the slots are connected, the product
of 5 and 3 will be larger than the quotient, sum, or
difference.</para><para>In other cases we might want to return all of the values
computed by the slots together, in one large data structure. This
is easily done with a different combiner:</para><programlisting>
template&lt;typename Container&gt;
struct aggregate_values
{
  typedef Container result_type;

  template&lt;typename InputIterator&gt;
  Container operator()(InputIterator first, InputIterator last) const
  {
    return Container(first, last);
  }
};
</programlisting><para>
Again, we can create a signal with this new combiner: 
</para><informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting><link linkend="signal">boost::signal</link>&lt;float (float, float), 
    aggregate_values&lt;std::vector&lt;float&gt; &gt; &gt; sig;

sig.<link linkend="id503915-bb">connect</link>(&amp;quotient);
sig.<link linkend="id503915-bb">connect</link>(&amp;product);
sig.<link linkend="id503915-bb">connect</link>(&amp;sum);
sig.<link linkend="id503915-bb">connect</link>(&amp;difference);

std::vector&lt;float&gt; results = sig(5, 3);
std::copy(results.begin(), results.end(), 
    std::ostream_iterator&lt;float&gt;(cout, " "));
</programlisting></entry><entry><programlisting><link linkend="signalN">boost::signal2</link>&lt;float, float, float,
    aggregate_values&lt;std::vector&lt;float&gt; &gt; &gt; sig;

sig.<link linkend="id503915-bb">connect</link>(&amp;quotient);
sig.<link linkend="id503915-bb">connect</link>(&amp;product);
sig.<link linkend="id503915-bb">connect</link>(&amp;sum);
sig.<link linkend="id503915-bb">connect</link>(&amp;difference);

std::vector&lt;float&gt; results = sig(5, 3);
std::copy(results.begin(), results.end(), 
    std::ostream_iterator&lt;float&gt;(cout, " "));
</programlisting></entry></row></tbody></tgroup></informaltable><para>The output of this program will contain 15, 8, 1.6667, and 2. It
is interesting here that
the first template argument for the <computeroutput>signal</computeroutput> class,
<computeroutput>float</computeroutput>, is not actually the return type of the signal.
Instead, it is the return type used by the connected slots and will
also be the <computeroutput>value_type</computeroutput> of the input iterators passed
to the combiner. The combiner itself is a function object and its
<computeroutput>result_type</computeroutput> member type becomes the return type of the
signal.</para><para>The input iterators passed to the combiner transform dereference
operations into slot calls. Combiners therefore have the option to
invoke only some slots until some particular criterion is met. For
instance, in a distributed computing system, the combiner may ask
each remote system whether it will handle the request. Only one
remote system needs to handle a particular request, so after a
remote system accepts the work we do not want to ask any other
remote systems to perform the same task. Such a combiner need only
check the value returned when dereferencing the iterator, and
return when the value is acceptable. The following combiner returns
the first non-NULL pointer to a <computeroutput>FulfilledRequest</computeroutput> data
structure, without asking any later slots to fulfill the
request:</para><programlisting>
struct DistributeRequest {
  typedef FulfilledRequest* result_type;

  template&lt;typename InputIterator&gt;
  result_type operator()(InputIterator first, InputIterator last) const
  {
    while (first != last) {
      if (result_type fulfilled = *first)
        return fulfilled;
      ++first;
    }
    return 0;
  }
};
</programlisting></section></section><section><title>Connection Management</title><section><title>Disconnecting Slots (Beginner)</title><para>Slots aren't expected to exist indefinately after they are
connected. Often slots are only used to receive a few events and
are then disconnected, and the programmer needs control to decide
when a slot should no longer be connected.</para><para>The entry point for managing connections explicitly is the
<computeroutput><link linkend="connection">boost::signals::connection</link></computeroutput> class. The
<computeroutput><link linkend="connection">connection</link></computeroutput> class uniquely represents the connection
between a particular signal and a particular slot. The
<computeroutput><link linkend="id466837-bb">connected</link>()</computeroutput> method checks if the signal and slot are
still connected, and the <computeroutput><link linkend="id300085-bb">disconnect()</link></computeroutput> method
disconnects the signal and slot if they are connected before it is
called. Each call to the signal's <computeroutput>connect()</computeroutput> method
returns a connection object, which can be used to determine if the
connection still exists or to disconnect the signal and slot.</para><programlisting>
boost::signals::connection c = sig.<link linkend="id503915-bb">connect</link>(HelloWorld());
if (c.connected()) {
<emphasis>// c is still connected to the signal</emphasis>
  sig(); <emphasis>// Prints "Hello, World!"</emphasis>
}

c.disconnect(); <emphasis>// Disconnect the HelloWorld object</emphasis>
assert(!c.connected()); <emphasis>c isn't connected any more</emphasis>

sig(); <emphasis>// Does nothing: there are no connected slots</emphasis></programlisting></section><section><title>Scoped connections (Intermediate)</title><para>The <computeroutput>boost::signals::scoped_connection</computeroutput> class
references a signal/slot connection that will be disconnected when
the <computeroutput>scoped_connection</computeroutput> class goes out of scope. This
ability is useful when a connection need only be temporary,
e.g.,</para><programlisting>
{
  boost::signals::scoped_connection c = sig.<link linkend="id503915-bb">connect</link>(ShortLived());
  sig(); <emphasis>// will call ShortLived function object</emphasis>
}
sig(); <emphasis>// ShortLived function object no longer connected to sig</emphasis></programlisting></section><section><title>Disconnecting equivalent slots (Intermediate)</title><para>One can disconnect slots that are equivalent to a given function
object using a form of the
<computeroutput><link linkend="id387664-bb">disconnect</link></computeroutput> method, so long as
the type of the function object has an accessible <computeroutput>==</computeroutput>
operator. For instance:

</para><informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting>
void foo();
void bar();

signal&lt;void()&gt; sig;

sig.connect(&amp;foo);
sig.connect(&amp;bar);

// disconnects foo, but not bar
sig.disconnect(&amp;foo);
</programlisting></entry><entry><programlisting>
void foo();
void bar();

signal0&lt;void&gt; sig;

sig.connect(&amp;foo);
sig.connect(&amp;bar);

// disconnects foo, but not bar
sig.disconnect(&amp;foo);
</programlisting></entry></row></tbody></tgroup></informaltable></section><section><title>Automatic connection management (Intermediate)</title><para>Boost.Signals can automatically track the lifetime of objects
involved in signal/slot connections, including automatic
disconnection of slots when objects involved in the slot call are
destroyed. For instance, consider a simple news delivery service,
where clients connect to a news provider that then sends news to
all connected clients as information arrives. The news delivery
service may be constructed like this: </para><informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting>
class NewsItem { /* ... */ };

boost::signal&lt;void (const NewsItem&amp;)&gt; deliverNews;
</programlisting></entry><entry><programlisting>
class NewsItem { /* ... */ };

boost::signal1&lt;void, const NewsItem&amp;&gt; deliverNews;
</programlisting></entry></row></tbody></tgroup></informaltable><para>Clients that wish to receive news updates need only connect a
function object that can receive news items to the
<computeroutput>deliverNews</computeroutput> signal. For instance, we may have a
special message area in our application specifically for news,
e.g.,:</para><programlisting>
struct NewsMessageArea : public MessageArea
{
public:
  // ...

  void displayNews(const NewsItem&amp; news) const
  {
    messageText = news.text();
    update();
  }
};

// ...
NewsMessageArea newsMessageArea = new NewsMessageArea(/* ... */);
// ...
deliverNews.<link linkend="id503915-bb">connect</link>(boost::bind(&amp;NewsMessageArea::displayNews, 
                                newsMessageArea, _1));
</programlisting><para>However, what if the user closes the news message area,
destroying the <computeroutput>newsMessageArea</computeroutput> object that
<computeroutput>deliverNews</computeroutput> knows about? Most likely, a segmentation
fault will occur. However, with Boost.Signals one need only make
<computeroutput>NewsMessageArea</computeroutput><emphasis>trackable</emphasis>, and the slot
involving <computeroutput>newsMessageArea</computeroutput> will be disconnected when
<computeroutput>newsMessageArea</computeroutput> is destroyed. The
<computeroutput>NewsMessageArea</computeroutput> class is made trackable by deriving
publicly from the <computeroutput>boost::signals::trackable</computeroutput> class,
e.g.:</para><programlisting>
struct NewsMessageArea : public MessageArea, public boost::signals::trackable
{
  // ...
};
</programlisting><para>At this time there is a significant limitation to the use of
<computeroutput>trackable</computeroutput> objects in making slot connections: function
objects built using Boost.Bind are understood, such that pointers
or references to <computeroutput>trackable</computeroutput> objects passed to
<computeroutput>boost::bind</computeroutput> will be found and tracked.</para><para><emphasis role="bold">Warning</emphasis>: User-defined function objects and function
objects from other libraries (e.g., Boost.Function or Boost.Lambda)
do not implement the required interfaces for <computeroutput>trackable</computeroutput>
object detection, and <emphasis>will silently ignore any bound trackable
objects</emphasis>. Future versions of the Boost libraries will address
this limitation.</para></section><section><title>When can disconnections occur? (Intermediate)</title><para>Signal/slot disconnections occur when any of these conditions
occur:</para><itemizedlist><listitem><para>The connection is explicitly disconnected via the connection's
<computeroutput>disconnect</computeroutput> method directly, or indirectly via the
signal's <computeroutput>disconnect</computeroutput> method or
<computeroutput>scoped_connection</computeroutput>'s destructor.</para></listitem><listitem><para>A <computeroutput>trackable</computeroutput> object bound to the slot is
destroyed.</para></listitem><listitem><para>The signal is destroyed.</para></listitem></itemizedlist><para>These events can occur at any time without disrupting a signal's
calling sequence. If a signal/slot connection is disconnected at
any time during a signal's calling sequence, the calling sequence
will still continue but will not invoke the disconnected slot.
Additionally, a signal may be destroyed while it is in a calling
sequence, and which case it will complete its slot call sequence
but may not be accessed directly.</para><para>Signals may be invoked recursively (e.g., a signal A calls a
slot B that invokes signal A...). The disconnection behavior does
not change in the recursive case, except that the slot calling
sequence includes slot calls for all nested invocations of the
signal.</para></section><section><title>Passing slots (Intermediate)</title><para>Slots in the Boost.Signals library are created from arbitrary
function objects, and therefore have no fixed type. However, it is
commonplace to require that slots be passed through interfaces that
cannot be templates. Slots can be passed via the
<computeroutput>slot_type</computeroutput> for each particular signal type and any
function object compatible with the signature of the signal can be
passed to a <computeroutput>slot_type</computeroutput> parameter. For instance:</para><informaltable><tgroup cols="2" align="left"><thead><row><entry>Preferred syntax</entry><entry>Portable syntax</entry></row></thead><tbody><row><entry><programlisting>
class Button 
{
  typedef boost::signal&lt;void (int x, int y)&gt; OnClick;

public:
  void doOnClick(const OnClick::slot_type&amp; slot);

private:
  OnClick onClick;
};

void Button::doOnClick(
      const OnClick::slot_type&amp; slot
    )
{
  onClick.<link linkend="id503915-bb">connect</link>(slot);
}

void printCoordinates(long x, long y)
{
  std::cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")\n";
}

void f(Button&amp; button)
{
  button.doOnClick(&amp;printCoordinates);
}
</programlisting></entry><entry><programlisting>
class Button 
{
  typedef <link linkend="signalN">boost::signal2</link>&lt;void,int,int&gt; OnClick;

public:
  void doOnClick(const OnClick::slot_type&amp; slot);

private:
  OnClick onClick;
};

void Button::doOnClick(
      const OnClick::slot_type&amp; slot
    )
{
  onClick.<link linkend="id503915-bb">connect</link>(slot);
}

void printCoordinates(long x, long y)
{
  std::cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")\n";
}

void f(Button&amp; button)
{
  button.doOnClick(&amp;printCoordinates);
}
</programlisting></entry></row></tbody></tgroup></informaltable><para>The <computeroutput>doOnClick</computeroutput> method is now functionally equivalent
to the <computeroutput>connect</computeroutput> method of the <computeroutput>onClick</computeroutput>
signal, but the details of the <computeroutput>doOnClick</computeroutput> method can be
hidden in an implementation detail file.</para></section></section><section><title>Linking against the Signals library</title><para>Part of the Boost.Signals library is compiled into a binary
  library that must be linked into your application to use Signals. To
  build this library, execute the command <command>bjam</command> in
  either the top-level Boost directory or in
  <computeroutput>libs/signals/build</computeroutput>. On Unix, the directory
  <computeroutput>libs/signals/build/bin-stage</computeroutput> will then contain
  libraries named, e.g., <computeroutput>libboost_signals.a</computeroutput> that can be
  linked in your program with <computeroutput>-lboost_signals</computeroutput>.</para><para>On Windows, with Microsoft Visual C++ or Borland C++, the
  linking process is nearly automatic. As with the
  <ulink url="../../libs/regex/index.html">Regex</ulink> library, the libraries in
  <computeroutput>libs\signals\build\bin-stage</computeroutput> will have mangled names
  and will be automatically be including in the link process. To link
  against the Signals library binary dynamically (e.g., using the
  Signals DLL), define <computeroutput>BOOST_SIGNALS_DYN_LINK</computeroutput> when
  building your application; to link statically, define
  <computeroutput>BOOST_SIGNALS_STATIC_LINK</computeroutput>. </para></section></section><section id="signals.reference"><title>Reference</title><section id="header.boost.signal.hpp"><title>Header &lt;<ulink url="../../boost/signal.hpp">boost/signal.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> R, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Combiner = <link linkend="last_value">last_value</link>&lt;R&gt;, <emphasis role="bold">typename</emphasis> Group = <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> GroupCompare = std::less&lt;Group&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> SlotFunction = <link linkend="functionN">functionN</link>&lt;R, T1, T2, ..., TN&gt; &gt; 
  &#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="signalN">signalN</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis role="bold">typename</emphasis> Combiner = <link linkend="last_value">last_value</link>&lt;R&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Group = <emphasis role="bold">int</emphasis>, <emphasis role="bold">typename</emphasis> GroupCompare = std::less&lt;Group&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> SlotFunction = <link linkend="functionN">functionN</link>&lt;Signature&gt; &gt; 
  &#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="signal">signal</link>;
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> signals {

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <anchor id="id283726"/>connect_position { at_front, at_back };
&#xA0;&#xA0;}
}</synopsis><refentry id="signalN"><refmeta><refentrytitle>Class template signalN</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::signalN</refname><refpurpose>Set of safe multicast callback types.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> R, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Combiner = <link linkend="last_value">last_value</link>&lt;R&gt;, <emphasis role="bold">typename</emphasis> Group = <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> GroupCompare = std::less&lt;Group&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> SlotFunction = <link linkend="functionN">functionN</link>&lt;R, T1, T2, ..., TN&gt; &gt; 
<emphasis role="bold">class</emphasis> signalN : <emphasis role="bold">public</emphasis> <link linkend="trackable">signals::trackable</link>,
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">private</emphasis> noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis role="bold">typename</emphasis> Combiner::result_type result_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> Combiner&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; combiner_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> Group&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; group_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> GroupCompare&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; group_compare_type;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> SlotFunction&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; slot_function_type;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="slot">slot</link>&lt;SlotFunction&gt;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; slot_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>unspecified</emphasis>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; slot_result_type;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>unspecified</emphasis>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; slot_call_iterator;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; argument_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// If N == 1</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; first_argument_type;&#xA0;  <emphasis>// If N == 2</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; second_argument_type;  <emphasis>// If N == 2</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; arg1_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; arg2_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;.
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;.
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;.
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> TN&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; argN_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// static constants</emphasis>
&#xA0;&#xA0;<emphasis role="bold">static</emphasis> <emphasis role="bold">const</emphasis> <emphasis role="bold">int</emphasis> arity = N;

&#xA0;&#xA0;<emphasis>// <link linkend="signalNconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id261347-bb">signalN</link>(<emphasis role="bold">const</emphasis> combiner_type&amp; = combiner_type(), 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> group_compare_type&amp; = group_compare_type());
&#xA0;&#xA0;<link linkend="id219050-bb">~signalN</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id386837-bb">connection management</link></emphasis>
&#xA0;&#xA0;<type><link linkend="connection">signals::connection</link></type> 
&#xA0;&#xA0;<link linkend="id233017-bb">connect</link>(<emphasis role="bold">const</emphasis> slot_type&amp;, signals::connect_position = signals::at_back);
&#xA0;&#xA0;<type><link linkend="connection">signals::connection</link></type> 
&#xA0;&#xA0;<link linkend="id225812-bb">connect</link>(<emphasis role="bold">const</emphasis> group_type&amp;, <emphasis role="bold">const</emphasis> slot_type&amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;signals::connect_position = signals::at_back);
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id283648-bb">disconnect</link>(<emphasis role="bold">const</emphasis> group_type&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Slot&gt; <type><emphasis role="bold">void</emphasis></type> <link linkend="id325500-bb">disconnect</link>(<emphasis role="bold">const</emphasis> Slot&amp;);
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id411689-bb">disconnect_all_slots</link>();
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id324310-bb">empty</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>std::size_t</type> <link linkend="id374214-bb">num_slots</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id426739-bb">invocation</link></emphasis>
&#xA0;&#xA0;<type>result_type</type> <link linkend="id378613-bb"><emphasis role="bold">operator</emphasis>()</link>(arg1_type, arg2_type, ..., argN_type);
&#xA0;&#xA0;<type>result_type</type> <link linkend="id444795-bb"><emphasis role="bold">operator</emphasis>()</link>(arg1_type, arg2_type, ..., argN_type) <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id270382-bb">combiner access</link></emphasis>
&#xA0;&#xA0;<type>combiner_type&amp;</type> <link linkend="id337814-bb">combiner</link>();
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> combiner_type&amp;</type> <link linkend="id308951-bb">combiner</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The class template <link linkend="signalN">signalN</link> covers
         several related classes signal0, signal1, signal2, etc.,
         where the number suffix describes the number of function
         parameters the signal and its connected slots will
         take. Instead of enumerating all classes, a single pattern
         <link linkend="signalN">signalN</link> will be described, where N
         represents the number of function parameters.</para><refsect2><title><anchor id="signalNconstruct-copy-destruct"/><computeroutput>signalN</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id261347-bb"/>signalN(<emphasis role="bold">const</emphasis> combiner_type&amp; combiner = combiner_type(), 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> group_compare_type&amp; compare = group_compare_type());</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Initializes the signal to contain no slots, copies the given combiner into internal storage, and stores the given group comparison function object to compare groups.</simpara></listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><simpara><computeroutput>this-&gt;<link linkend="id324310-bb">empty</link>()</computeroutput></simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id219050-bb"/>~signalN();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Disconnects all slots connected to <computeroutput>*this</computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id386837-bb"/><computeroutput>signalN</computeroutput> connection management</title><orderedlist><listitem><para id="id503915-bb"><literallayout class="monospaced"><type><link linkend="connection">signals::connection</link></type> 
<anchor id="id233017-bb"/>connect(<emphasis role="bold">const</emphasis> slot_type&amp; slot, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;signals::connect_position at = signals::at_back);
<type><link linkend="connection">signals::connection</link></type> 
<anchor id="id225812-bb"/>connect(<emphasis role="bold">const</emphasis> group_type&amp; group, <emphasis role="bold">const</emphasis> slot_type&amp; slot, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;signals::connect_position at = signals::at_back);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Connects the signal this to the incoming
          slot. If the slot is inactive, i.e., any of the trackable
          objects bound by the slot call have been destroyed, then the
          call to connect is a no-op. If the second version of
          <computeroutput>connect</computeroutput> is invoked, the
          slot is associated with the given group. The <computeroutput>at</computeroutput>
          parameter specifies where the slot should be connected:
          <computeroutput>at_front</computeroutput> indicates that the slot will be
          connected at the front of the list or group of slots and
          <computeroutput>at_back</computeroutput> indicates that the slot will be
          connected at the back of the list or group of
          slots.</simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara>A
          <computeroutput><link linkend="connection">signals::connection</link></computeroutput>
          object that references the newly-created connection between
          the signal and the slot; if the slot is inactive, returns a
          disconnected connection.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>This routine meets the strong exception guarantee,
          where any exception thrown will cause the slot to not be
          connected to the signal.</simpara></listitem></varlistentry><varlistentry><term>Complexity</term><listitem><simpara>Constant time when connecting a slot
          without a group name or logarithmic in the number of groups
          when connecting to a particular
          group.</simpara></listitem></varlistentry><varlistentry><term>Notes</term><listitem><simpara>It is unspecified whether connecting a slot while the
          signal is calling will result in the slot being called
          immediately.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para id="id387664-bb"><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id283648-bb"/>disconnect(<emphasis role="bold">const</emphasis> group_type&amp; group);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Slot&gt; <type><emphasis role="bold">void</emphasis></type> <anchor id="id325500-bb"/>disconnect(<emphasis role="bold">const</emphasis> Slot&amp; slot);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>If the parameter is (convertible to) a
          group name, any slots in the given group are
          disconnected. Otherwise, any slots equal to the given slot
          are disconnected.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw unless a user destructor or
          equality operator <computeroutput>==</computeroutput> throws. If either throws,
          not all slots may be disconnected.</simpara></listitem></varlistentry><varlistentry><term>Complexity</term><listitem><simpara>If a group is given, O(lg g) + k where
          g is the number of groups in the signal and k is the
          number of slots in the group. Otherwise, linear in the
          number of slots connected to the
          signal.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id411689-bb"/>disconnect_all_slots();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Disconnects all slots connected to the signal.</simpara></listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><simpara><computeroutput>this-&gt;<link linkend="id324310-bb">empty</link>()</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>If disconnecting a slot causes an exception to be
          thrown, not all slots may be disconnected.</simpara></listitem></varlistentry><varlistentry><term>Complexity</term><listitem><simpara>Linear in the number of slots known to the
          signal.</simpara></listitem></varlistentry><varlistentry><term>Notes</term><listitem><simpara>May be called at any time within the lifetime of the
          signal, including during calls to the signal's slots.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id324310-bb"/>empty() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>true</computeroutput> if no slots
          are connected to the signal, and
          <computeroutput>false</computeroutput> otherwise.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry><varlistentry><term>Complexity</term><listitem><simpara>Linear in the number of slots known to the
          signal.</simpara></listitem></varlistentry><varlistentry><term>Rationale</term><listitem><simpara>Slots can disconnect at any point in time,
          including while those same slots are being invoked. It is
          therefore possible that the implementation must search
          through a list of disconnected slots to determine if any
          slots are still connected.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>std::size_t</type> <anchor id="id374214-bb"/>num_slots() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>The number of slots connected to the signal</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry><varlistentry><term>Complexity</term><listitem><simpara>Linear in the number of slots known to the
          signal.</simpara></listitem></varlistentry><varlistentry><term>Rationale</term><listitem><simpara>Slots can disconnect at any point in time,
          including while those same slots are being invoked. It is
          therefore possible that the implementation must search
          through a list of disconnected slots to determine how many
          slots are still connected.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id426739-bb"/><computeroutput>signalN</computeroutput> invocation</title><orderedlist><listitem><para id="id403960-bb"><literallayout class="monospaced"><type>result_type</type> <anchor id="id378613-bb"/><emphasis role="bold">operator</emphasis>()(arg1_type a1, arg2_type a2, ... , argN_type aN);
<type>result_type</type> <anchor id="id444795-bb"/><emphasis role="bold">operator</emphasis>()(arg1_type a1, arg2_type a2, ... , argN_type aN) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Invokes the combiner with a
          <computeroutput>slot_call_iterator</computeroutput> range
          [first, last) corresponding to the sequence of calls to the
          slots connected to signal
          <computeroutput>*this</computeroutput>. Dereferencing an
          iterator in this range causes a slot call with the given set
          of parameters <computeroutput>(a1, a2, ...,
          aN)</computeroutput>, the result of which is returned from
          the iterator dereference operation.</simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara>The result returned by the combiner.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>If an exception is thrown by a slot call, or if the
          combiner does not dereference any slot past some given slot,
          all slots after that slot in the internal list of connected
          slots will not be invoked.</simpara></listitem></varlistentry><varlistentry><term>Notes</term><listitem><simpara>Only the slots associated with iterators that are
          actually dereferenced will be invoked. Multiple dereferences
          of the same iterator will not result in multiple slot
          invocations, because the return value of the slot will be
          cached.</simpara><simpara>The <computeroutput>const</computeroutput> version of
          the function call operator will invoke the combiner as
          <computeroutput>const</computeroutput>, whereas the
          non-<computeroutput>const</computeroutput> version will
          invoke the combiner as
          non-<computeroutput>const</computeroutput>.</simpara><simpara>Calling the function call operator may invoke undefined
          behavior if no slots are connected to the signal, depending
          on the combiner used. The default combiner is well-defined
          for zero slots when the return type is void but is undefined
          when the return type is any other type (because there is no
          way to synthesize a return value).</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id270382-bb"/><computeroutput>signalN</computeroutput> combiner access</title><orderedlist><listitem><para id="id373067-bb"><literallayout class="monospaced"><type>combiner_type&amp;</type> <anchor id="id337814-bb"/>combiner();
<type><emphasis role="bold">const</emphasis> combiner_type&amp;</type> <anchor id="id308951-bb"/>combiner() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>A reference to the stored combiner.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="signal"><refmeta><refentrytitle>Class template signal</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::signal</refname><refpurpose>Safe multicast callback.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Signature, <emphasis>  // Function type R (T1, T2, ..., TN)</emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Combiner = <link linkend="last_value">last_value</link>&lt;R&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Group = <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> GroupCompare = std::less&lt;Group&gt;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> SlotFunction = <link linkend="functionN">functionN</link>&lt;Signature&gt; &gt; 
<emphasis role="bold">class</emphasis> signal : <emphasis role="bold">public</emphasis> <link linkend="signalN">signalN</link>&lt;R, T1, T2, ..., TN, Combiner, Group, GroupCompare, SlotFunction&gt;
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="signalconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id299131-bb">signal</link>(<emphasis role="bold">const</emphasis> combiner_type&amp; = combiner_type(), 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> group_compare_type&amp; = group_compare_type());
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Class template <link linkend="signal">signal</link> is a thin
        wrapper around the numbered class templates <link linkend="signalN">signal0</link>, <link linkend="signalN">signal1</link>, etc. It accepts a function
        type with N arguments instead of N separate arguments, and
        derives from the appropriate <link linkend="signalN">signalN</link>
        instantiation.</para><para>All functionality of this class template is in its base
        class <link linkend="signalN">signalN</link>.</para><refsect2><title><anchor id="signalconstruct-copy-destruct"/><computeroutput>signal</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id299131-bb"/>signal(<emphasis role="bold">const</emphasis> combiner_type&amp; combiner = combiner_type(), 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> group_compare_type&amp; compare = group_compare_type());</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Initializes the base class with the given combiner
        and comparison objects.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id341848"><title>Header &lt;<ulink url="../../boost/signals/slot.hpp">boost/signals/slot.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SlotFunction&gt; <emphasis role="bold">class</emphasis> <link linkend="slot">slot</link>;
}</synopsis><refentry id="slot"><refmeta><refentrytitle>Class template slot</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::slot</refname><refpurpose>Pass slots as function arguments.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SlotFunction&gt; 
<emphasis role="bold">class</emphasis> slot {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="slotconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Slot&gt; <link linkend="id425481-bb">slot</link>(Slot);
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="slotconstruct-copy-destruct"/><computeroutput>slot</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Slot&gt; <anchor id="id425481-bb"/>slot(Slot target);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para>Invokes
        <computeroutput><link linkend="visit_each">visit_each</link></computeroutput>
        (unqualified) to discover pointers and references to
        <computeroutput><link linkend="trackable">signals::trackable</link></computeroutput>
        objects in <computeroutput>target</computeroutput>.</para><para>Initializes <computeroutput>this</computeroutput> to
          contain the incoming slot
          <computeroutput>target</computeroutput>, which may be any
          function object with which a
          <computeroutput>SlotFunction</computeroutput> can be
          constructed.</para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id225819"><title>Header &lt;<ulink url="../../boost/signals/trackable.hpp">boost/signals/trackable.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> signals {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="trackable">trackable</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="trackable"><refmeta><refentrytitle>Class trackable</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::signals::trackable</refname><refpurpose>Enables safe use of multicast callbacks.</refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> trackable {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="trackableconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id388314-bb">trackable</link>();
&#xA0;&#xA0;<link linkend="id431043-bb">trackable</link>(<emphasis role="bold">const</emphasis> <link linkend="trackable">trackable</link>&amp;);
&#xA0;&#xA0;trackable&amp; <link linkend="id338348-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> <link linkend="trackable">trackable</link>&amp;);
&#xA0;&#xA0;<link linkend="id364828-bb">~trackable</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <computeroutput>trackable</computeroutput> class provides automatic
          disconnection of signals and slots when objects bound in
          slots (via pointer or reference) are destroyed. The
          <computeroutput>trackable</computeroutput> class may only be used as a public
          base class for some other class; when used as such, that
          class may be bound to function objects used as part of
          slots. The manner in which a <computeroutput>trackable</computeroutput> object
          tracks the set of signal-slot connections it is a part of is
          unspecified.</para><para>The actual use of <computeroutput>trackable</computeroutput> is contingent
          on the presence of appropriate
          <link linkend="visit_each">visit_each</link> overloads for any
          type that may contain pointers or references to trackable
          objects.</para><refsect2><title><anchor id="trackableconstruct-copy-destruct"/><computeroutput>trackable</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id388314-bb"/>trackable();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para>Sets the list of connected slots to empty.</para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><para>Will not throw.</para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id431043-bb"/>trackable(<emphasis role="bold">const</emphasis> <link linkend="trackable">trackable</link>&amp; other);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para>Sets the list of connected slots to empty.</para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><para>Will not throw.</para></listitem></varlistentry><varlistentry><term>Rationale</term><listitem><para>Signal-slot connections can only be created via calls to an explicit connect method, and therefore cannot be created here when trackable objects are copied.</para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced">trackable&amp; <anchor id="id338348-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> <link linkend="trackable">trackable</link>&amp; other);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para>Sets the list of connected slots to empty.</para></listitem></varlistentry><varlistentry><term>Returns</term><listitem><para><computeroutput>*this</computeroutput></para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><para>Will not throw.</para></listitem></varlistentry><varlistentry><term>Rationale</term><listitem><para>Signal-slot connections can only be created via calls to an explicit connect method, and therefore cannot be created here when trackable objects are copied.</para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id364828-bb"/>~trackable();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para>Disconnects all signal/slot connections that
          contain a pointer or reference to this trackable object that
          can be found by
          <link linkend="visit_each">visit_each</link>.</para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id490968"><title>Header &lt;<ulink url="../../boost/signals/connection.hpp">boost/signals/connection.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> signals {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="connection">connection</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id344320">swap</link>(<link linkend="connection">connection</link>&amp;, <link linkend="connection">connection</link>&amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="scoped_connection">scoped_connection</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="connection"><refmeta><refentrytitle>Class connection</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::signals::connection</refname><refpurpose>Query/disconnect a signal-slot connection.</refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> connection {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="connectionconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id262567-bb">connection</link>();
&#xA0;&#xA0;<link linkend="id346486-bb">connection</link>(<emphasis role="bold">const</emphasis> <link linkend="connection">connection</link>&amp;);
&#xA0;&#xA0;connection&amp; <link linkend="id385847-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> <link linkend="connection">connection</link>&amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id281275-bb">connection management</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id300085-bb">disconnect</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id466837-bb">connected</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id243349-bb">modifiers</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id281970-bb">swap</link>(<emphasis role="bold">const</emphasis> <link linkend="connection">connection</link>&amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id404035-bb">comparisons</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id507421-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="connection">connection</link>&amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id426800-bb"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> <link linkend="connection">connection</link>&amp;) <emphasis role="bold">const</emphasis>;
};

<emphasis>// <link linkend="id410784-bb">specialized algorithms</link></emphasis>
<type><emphasis role="bold">void</emphasis></type> <link linkend="id344320">swap</link>(<link linkend="connection">connection</link>&amp;, <link linkend="connection">connection</link>&amp;);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <link linkend="connection">connection</link> class represents
          a connection between a Signal and a Slot. It is a
          lightweight object that has the ability to query whether the
          signal and slot are currently connected, and to disconnect
          the signal and slot. It is always safe to query or
          disconnect a connection.</para><refsect2><title><anchor id="connectionconstruct-copy-destruct"/><computeroutput>connection</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id262567-bb"/>connection();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para>Sets the currently represented connection to the
          NULL connection.</para></listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><para><computeroutput>!this-&gt;<link linkend="id466837-bb">connected</link>()</computeroutput>.</para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><para>Will not throw.</para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id346486-bb"/>connection(<emphasis role="bold">const</emphasis> <link linkend="connection">connection</link>&amp; other);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para><computeroutput>this</computeroutput> references
          the connection referenced by
          <computeroutput>other</computeroutput>.</para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><para>Will not throw.</para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced">connection&amp; <anchor id="id385847-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> <link linkend="connection">connection</link>&amp; other);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para><computeroutput>this</computeroutput> references
          the connection referenced by
          <computeroutput>other</computeroutput>.</para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><para>Will not throw.</para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id281275-bb"/><computeroutput>connection</computeroutput> connection management</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id300085-bb"/>disconnect() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para>If
             <computeroutput>this-&gt;<link linkend="id466837-bb">connected</link>()</computeroutput>,
             disconnects the signal and slot referenced by this;
             otherwise, this operation is a no-op.</para></listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><para><computeroutput>!this-&gt;<link linkend="id466837-bb">connected</link>()</computeroutput>.</para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id466837-bb"/>connected() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para><computeroutput>true</computeroutput> if this
            references a non-NULL connection that is still active
            (connected), and <computeroutput>false</computeroutput>
            otherwise.</para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><para>Will not throw.</para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id243349-bb"/><computeroutput>connection</computeroutput> modifiers</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id281970-bb"/>swap(<emphasis role="bold">const</emphasis> <link linkend="connection">connection</link>&amp; other);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para>Swaps the connections referenced in
            <computeroutput>this</computeroutput> and
            <computeroutput>other</computeroutput>.</para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><para>Will not throw.</para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id404035-bb"/><computeroutput>connection</computeroutput> comparisons</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id507421-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="connection">connection</link>&amp; other) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para><computeroutput>true</computeroutput> if
            <computeroutput>this</computeroutput> and
            <computeroutput>other</computeroutput> reference the same
            connection or both reference the NULL connection, and
            <computeroutput>false</computeroutput>
            otherwise.</para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><para>Will not throw.</para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id426800-bb"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> <link linkend="connection">connection</link>&amp; other) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para><computeroutput>true</computeroutput> if the
            connection referenced by
            <computeroutput>this</computeroutput> precedes the
            connection referenced by
            <computeroutput>other</computeroutput> based on some
            unspecified ordering, and
            <computeroutput>false</computeroutput>
            otherwise.</para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><para>Will not throw.</para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id410784-bb"/><computeroutput>connection</computeroutput> specialized algorithms</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id344320"/>swap(<link linkend="connection">connection</link>&amp; x, <link linkend="connection">connection</link>&amp; y);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para><computeroutput>x.swap(y)</computeroutput></para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><para>Will not throw.</para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="scoped_connection"><refmeta><refentrytitle>Class scoped_connection</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::signals::scoped_connection</refname><refpurpose>Limits a signal-slot connection lifetime to a particular scope.</refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> scoped_connection : <emphasis role="bold">private</emphasis> noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="scoped_connectionconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id411563-bb">scoped_connection</link>(<emphasis role="bold">const</emphasis> <link linkend="connection">connection</link>&amp;);
&#xA0;&#xA0;<link linkend="id457026-bb">~scoped_connection</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id445023-bb">connection management</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id381141-bb">disconnect</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id274267-bb">connected</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="scoped_connectionconstruct-copy-destruct"/><computeroutput>scoped_connection</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id411563-bb"/>scoped_connection(<emphasis role="bold">const</emphasis> <link linkend="connection">connection</link>&amp; other);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para><computeroutput>this</computeroutput> references
          the connection referenced by
          <computeroutput>other</computeroutput>.</para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><para>Will not throw.</para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id457026-bb"/>~scoped_connection();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para>If
          <computeroutput>this-&gt;<link linkend="id274267-bb">connected</link>()</computeroutput>,
          disconnects the signal-slot connection.</para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id445023-bb"/><computeroutput>scoped_connection</computeroutput> connection management</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id381141-bb"/>disconnect() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para>If
             <computeroutput>this-&gt;<link linkend="id274267-bb">connected</link>()</computeroutput>,
             disconnects the signal and slot referenced by this;
             otherwise, this operation is a no-op.</para></listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><para><computeroutput>!this-&gt;<link linkend="id274267-bb">connected</link>()</computeroutput>.</para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id274267-bb"/>connected() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para><computeroutput>true</computeroutput> if this
            references a non-NULL connection that is still active
            (connected), and <computeroutput>false</computeroutput>
            otherwise.</para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><para>Will not throw.</para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id234067"><title>Header &lt;<ulink url="../../boost/visit_each.hpp">boost/visit_each.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Visitor, <emphasis role="bold">typename</emphasis> T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="visit_each">visit_each</link>(<emphasis role="bold">const</emphasis> Visitor&amp;, <emphasis role="bold">const</emphasis> T&amp;, <emphasis role="bold">int</emphasis>);
}</synopsis><refentry id="visit_each"><refmeta><refentrytitle>Function template visit_each</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::visit_each</refname><refpurpose>Allow limited exploration of class members.</refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Visitor, <emphasis role="bold">typename</emphasis> T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> visit_each(<emphasis role="bold">const</emphasis> Visitor&amp; visitor, <emphasis role="bold">const</emphasis> T&amp; t, <emphasis role="bold">int</emphasis> );</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <link linkend="visit_each">visit_each</link> mechanism
        allows a visitor to be applied to every subobject in a given
        object. It is used by the Signals library to discover
        <link linkend="trackable">signals::trackable</link> objects within a
        function object, but other uses may surface if used
        universally (e.g., conservative garbage collection). To fit
        within the <link linkend="visit_each">visit_each</link> framework,
        a <link linkend="visit_each">visit_each</link> overload must be
        supplied for each object type. </para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para><computeroutput>visitor(t)</computeroutput>, and for
      every subobject <computeroutput>x</computeroutput> of
      <computeroutput>t</computeroutput>: 
        <itemizedlist><listitem><para>If <computeroutput>x</computeroutput> is a reference, <computeroutput>visit_each(visitor, <link linkend="id376299">ref</link>(x), 0)</computeroutput></para></listitem><listitem><para>Otherwise, <computeroutput>visit_each(visitor, x, 0)</computeroutput></para></listitem></itemizedlist></para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The third parameter is
      <computeroutput>long</computeroutput> for the fallback version
      of <link linkend="visit_each">visit_each</link> and the argument
      supplied to this third paramter must always be 0. The third
      parameter is an artifact of the widespread lack of proper
      function template ordering, and will be removed in the future.</para><para>Library authors will be expected to add additional
      overloads that specialize the T argument for their classes, so
      that subobjects can be visited.</para><para>Calls to visit_each are required to be unqualified, to
      enable argument-dependent lookup.</para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id236836"><title>Header &lt;<ulink url="../../boost/last_value.hpp">boost/last_value.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <emphasis role="bold">class</emphasis> <link linkend="last_value">last_value</link>;

&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;&gt; <emphasis role="bold">class</emphasis> <link linkend="id429900-bb">last_value</link>&lt;<emphasis role="bold">void</emphasis>&gt;;
}</synopsis><refentry id="last_value"><refmeta><refentrytitle>Class template last_value</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::last_value</refname><refpurpose>Evaluate an <link linkend="InputIterator">InputIterator</link> sequence and return the
      last value in the sequence.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; 
<emphasis role="bold">class</emphasis> last_value {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T result_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id323338-bb">invocation</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> <link linkend="InputIterator">InputIterator</link>&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type>result_type</type> <link linkend="id325204-bb"><emphasis role="bold">operator</emphasis>()</link>(InputIterator, InputIterator) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id323338-bb"/><computeroutput>last_value</computeroutput> invocation</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> <link linkend="InputIterator">InputIterator</link>&gt; 
&#xA0;&#xA0;<type>result_type</type> <anchor id="id325204-bb"/><emphasis role="bold">operator</emphasis>()(InputIterator first, InputIterator last) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><para><computeroutput>first != last</computeroutput></para></listitem></varlistentry><varlistentry><term>Effects</term><listitem><para>Dereferences every iterator in the sequence <computeroutput>[first, last)</computeroutput>.</para></listitem></varlistentry><varlistentry><term>Returns</term><listitem><para>The result of dereferencing the iterator <computeroutput>last-1</computeroutput>.</para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title>Specializations</title><itemizedlist><listitem><para><link linkend="id429900-bb">Class last_value&lt;void&gt;</link></para></listitem></itemizedlist></refsect2></refsect1></refentry><refentry id="id429900-bb"><refmeta><refentrytitle>Class last_value&lt;void&gt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::last_value&lt;void&gt;</refname><refpurpose>Evaluate an InputIterator sequence.</refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> last_value&lt;<emphasis role="bold">void</emphasis>&gt; {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>unspecified</emphasis> result_type;

&#xA0;&#xA0;<emphasis>// <link linkend="id392780-bb">invocation</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> <link linkend="InputIterator">InputIterator</link>&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type>result_type</type> <link linkend="id508933-bb"><emphasis role="bold">operator</emphasis>()</link>(InputIterator, InputIterator) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="id392780-bb"/><computeroutput>last_value</computeroutput> invocation</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> <link linkend="InputIterator">InputIterator</link>&gt; 
&#xA0;&#xA0;<type>result_type</type> <anchor id="id508933-bb"/><emphasis role="bold">operator</emphasis>()(InputIterator first, InputIterator last) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><para>Dereferences every iterator in the sequence <computeroutput>[first, last)</computeroutput>.</para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section></section><section rev:last-revision="$Date: 2003/03/12 23:27:23 $" xml:base="../libs/signals/doc/faq.xml"><title>Frequently Asked Questions</title><qandaset><qandaentry><question><para>Don't noncopyable signal semantics mean that a class
        with a signal member will be noncopyable as well?</para></question><answer><para>No. The compiler will not be able to generate a copy
        constructor or copy assignment operator for your class if it
        has a signal as a member, but you are free to write your own
        copy constructor and/or copy assignment operator. Just don't
        try to copy the signal.</para></answer></qandaentry><qandaentry><question><para>Is Boost.Signals thread-safe?</para></question><answer><para>No. Using Boost.Signals in a multithreaded concept is
        very dangerous, and it is very likely that the results will be
        less than satisfying. Boost.Signals will support thread safety
        in the future.</para></answer></qandaentry><qandaentry><question><para>How do I get Boost.Signals to work with Qt?</para></question><answer><para>When building with Qt, the Moc keywords
        <computeroutput>signals</computeroutput> and <computeroutput>slots</computeroutput> are defined using
        preprocessor macros, causing programs using Boost.Signals and
        Qt together to fail to compile. Although this is a problem
        with Qt and not Boost.Signals, a user can use the two systems
        together by defining the <computeroutput>BOOST_SIGNALS_NAMESPACE</computeroutput>
        macro to some other identifier (e.g., <computeroutput>signalslib</computeroutput>)
        when building and using the Boost.Signals library. Then the
        namespace of the Boost.Signals library will be
        <computeroutput>boost::BOOST_SIGNALS_NAMESPACE</computeroutput> instead of
        <computeroutput>boost::signals</computeroutput>. To retain the original namespace
        name in translation units that do not interact with Qt, you
        can use a namespace alias:</para><programlisting>
  namespace boost {
    namespace signals = BOOST_SIGNALS_NAMESPACE;
  }
</programlisting></answer></qandaentry></qandaset></section><section rev:last-revision="$Date: 2003/03/12 23:27:22 $" xml:base="../libs/signals/doc/design.xml"><title>Design Overview</title><section><title>Type Erasure</title><para>"Type erasure", where static type information is eliminated
    by the use of dynamically dispatched interfaces, is used
    extensively within the Boost.Signals library to reduce the amount
    of code generated by template instantiation. Each signal must
    manage a list of slots and their associated connections, along
    with a <computeroutput>std::map</computeroutput> to map from group identifiers to
    their associated connections. However, instantiating this map for
    every token type, and perhaps within each translation unit (for
    some popular template instantiation strategies) increase compile
    time overhead and space overhead.</para><para> To combat this so-called "template bloat", we use
    Boost.Function and Boost.Any to store unknown types and
    operations. Then, all of the code for handling the list of slots
    and the mapping from slot identifiers to connections is factored
    into the class <computeroutput>signal_base</computeroutput>
    that deals exclusively with the <computeroutput>any</computeroutput> and
    <computeroutput><link linkend="boost.function">function</link></computeroutput> objects, hiding the
    actual implementations using the well-known pimpl idiom. The
    actual <computeroutput><link linkend="signalN">signalN</link></computeroutput> class templates
    deal only with code that will change depending on the number of
    arguments or which is inherently template-dependent (such as
    connection).</para></section><section><title><computeroutput>connection</computeroutput> class</title><para> The <computeroutput><link linkend="connection">connection</link></computeroutput> class is
    central to the behavior of the Boost.Signals library. It is the
    only entity within the Boost.Signals system that has knowledge of
    all objects that are associated by a given connection. To be
    specific, the <computeroutput><link linkend="connection">connection</link></computeroutput> class
    itself is merely a thin wrapper over a
    <computeroutput>shared_ptr</computeroutput> to a
    <computeroutput>basic_connection</computeroutput> object.</para><para><computeroutput><link linkend="connection">connection</link></computeroutput> objects are
    stored by all participants in the Signals system: each
    <computeroutput><link linkend="trackable">trackable</link></computeroutput> object contains a
    list of <computeroutput><link linkend="connection">connection</link></computeroutput> objects
    describing all connections it is a part of; similarly, all signals
    contain a set of pairs that define a slot. The pairs consist of a
    slot function object (generally a Boost.Function object) and a
    <computeroutput><link linkend="connection">connection</link></computeroutput> object (that will
    disconnect on destruction). Finally, the mapping from slot groups
    to slots is based on the key value in a
    <computeroutput>std::multimap</computeroutput> (the stored data
    in the <computeroutput>std::multimap</computeroutput> is the
    slot pair).</para></section><section><title>Slot Call Iterator</title><para> The slot call iterator is conceptually a stack of iterator
    adaptors that modify the behavior of the underlying iterator
    through the list of slots. The following table describes the type
    and behavior of each iterator adaptor required. Note that this is
    only a conceptual model: the implementation collapses all these
    layers into a single iterator adaptor because several popular
    compilers failed to compile the implementation of the conceptual
    model.</para><informaltable><tgroup cols="2" align="left"><thead><row><entry>Iterator Adaptor</entry><entry>Purpose</entry></row></thead><tbody><row><entry><para>Slot List Iterator</para></entry><entry><para>An iterator through the list of slots
            connected to a signal. The <computeroutput>value_type</computeroutput> of this
            iterator will be
            <computeroutput>std::pair&lt;any,
            connection&gt;</computeroutput>, where the
            <computeroutput><link linkend="boost.any">any</link></computeroutput> contains an
            instance of the slot function type.</para></entry></row><row><entry><para>Filter Iterator Adaptor</para></entry><entry><para>This filtering iterator adaptor filters out
            slots that have been disconnected, so we never see a
            disconnected slot in later stages.</para></entry></row><row><entry><para>Projection Iterator Adaptor</para></entry><entry><para>The projection iterator adaptor returns a
            reference to the first member of the pair that constitutes
            a connected slot (e.g., just the
            <computeroutput><link linkend="boost.any">boost::any</link></computeroutput> object that
            holds the slot function).</para></entry></row><row><entry><para>Transform Iterator Adaptor</para></entry><entry><para>This transform iterator adaptor performs an
            <computeroutput><link linkend="any_cast">any_cast</link></computeroutput> to
            extract a reference to the slot function with the
            appropriate slot function type.</para></entry></row><row><entry><para>Transform Iterator Adaptor</para></entry><entry><para>This transform iterator adaptor calls the
            function object returned by dereferencing the underlying
            iterator with the set of arguments given to the signal
            itself, and returns the result of that slot
            call.</para></entry></row><row><entry><para>Input Caching Iterator Adaptor</para></entry><entry><para>This iterator adaptor caches the result of
            dereferencing the underlying iterator. Therefore,
            dereferencing this iterator multiple times will only
            result in the underlying iterator being dereferenced once;
            thus, a slot can only be called once but its result can be
            used multiple times.</para></entry></row><row><entry><para>Slot Call Iterator</para></entry><entry><para>Iterates over calls to each slot.</para></entry></row></tbody></tgroup></informaltable></section><section><title><computeroutput>visit_each</computeroutput> function template</title><para> The <computeroutput><link linkend="visit_each">visit_each</link></computeroutput>
    function template is a mechanism for discovering objects that are
    stored within another object. Function template
    <computeroutput><link linkend="visit_each">visit_each</link></computeroutput> takes three
    arguments: an object to explore, a visitor function object that is
    invoked with each subobject, and the <computeroutput>int</computeroutput> 0. </para><para> The third parameter is merely a temporary solution to the
    widespread lack of proper function template partial ordering. The
    primary <computeroutput><link linkend="visit_each">visit_each</link></computeroutput>
    function template specifies this third parameter type to be
    <computeroutput>long</computeroutput>, whereas any user specializations must specify
    their third parameter to be of type <computeroutput>int</computeroutput>. Thus, even
    though a broken compiler cannot tell the ordering between, e.g., a
    match against a parameter <computeroutput>T</computeroutput> and a parameter
    <computeroutput>A&lt;T&gt;</computeroutput>, it can determine that the conversion from
    the integer 0 to <computeroutput>int</computeroutput> is better than the conversion to
    <computeroutput>long</computeroutput>. The ordering determined by this conversion thus
    achieves partial ordering of the function templates in a limited,
    but successful, way. The following example illustrates the use of
    this technique:</para><programlisting>
template&lt;typename&gt; class A {};
template&lt;typename T&gt; void foo(T, long);
template&lt;typename T&gt; void foo(A&lt;T&gt;, int);
A&lt;T&gt; at;
foo(at, 0);
</programlisting><para> In this example, we assume that our compiler can not tell
    that <computeroutput>A&lt;T&gt;</computeroutput> is a better match than
    <computeroutput>T</computeroutput>, and therefore assume that the function templates
    cannot be ordered based on that parameter. Then the conversion
    from 0 to <computeroutput>int</computeroutput> is better than the conversion from 0 to
    <computeroutput>long</computeroutput>, and the second function template is
    chosen. </para></section></section><section rev:last-revision="$Date: 2004/07/20 17:03:55 $" xml:base="../libs/signals/doc/rationale.xml"><title>Design Rationale</title><section><title>Choice of Slot Definitions</title><para> The definition of a slot differs amongst signals and slots
    libraries. Within Boost.Signals, a slot is defined in a very loose
    manner: it can be any function object that is callable given
    parameters of the types specified by the signal, and whose return
    value is convertible to the result type expected by the
    signal. However, alternative definitions have associated pros and
    cons that were considered prior to the construction of
    Boost.Signals.</para><itemizedlist><listitem><para><emphasis role="bold">Slots derive from a specific base
        class</emphasis>: generally a scheme such as this will require
        all user-defined slots to derive from some library-specified
        <computeroutput>Slot</computeroutput> abstract class that defines a virtual
        function calling the slot. Adaptors can be used to convert a
        definition such as this to a definition similar to that used
        by Boost.Signals, but the use of a large number of small
        adaptor classes containing virtual functions has been found to
        cause an unacceptable increase in the size of executables
        (polymorphic class types require more code than
        non-polymorphic types).</para><para> This approach does have the benefit of simplicity of
        implementation and user interface, from an object-oriented
        perspective.</para></listitem><listitem><para><emphasis role="bold">Slots constructed from a set of
        primitives</emphasis>: in this scheme the slot can have a
        limited set of types (often derived from a common abstract
        base class) that are constructed from some library-defined set
        of primitives that often include conversions from free
        function pointers and member function pointers, and a limited
        set of binding capabilities. Such an approach is reasonably
        simple and cover most common cases, but it does not allow a
        large degree of flexibility in slot construction. Libraries
        for function object composition have become quite advanced and
        it is out of the scope of a signals and slots library to
        encorporate such enhancements. Thus Boost.Signals does not
        include argument binding or function object composition
        primitives, but instead provides a hook (via the
        <computeroutput><link linkend="visit_each">visit_each</link></computeroutput>
        mechanism) that allows existing binder/composition libraries
        to provide the necessary information to Signals.</para></listitem></itemizedlist><para> Users not satisfied with the slot definition choice may opt
    to replace the default slot function type with an alternative that
    meets their specific needs.</para></section><section><title>User-level Connection Management</title><para> Users need to have fine control over the connection of
    signals to slots and their eventual disconnection. The approach
    taken by Boost.Signals is to return a
    <computeroutput><link linkend="connection">connection</link></computeroutput> object that enables
    connected/disconnected query, manual disconnection, and an
    automatic disconnection on destruction mode. Some other possible
    interfaces include:</para><itemizedlist><listitem><para><emphasis role="bold">Pass slot to
        disconnect</emphasis>: in this interface model, the
        disconnection of a slot connected with
        <computeroutput>sig.<link linkend="id503915-bb">connect</link>(slot)</computeroutput> is
        performed via
        <computeroutput>sig.<link linkend="id387664-bb">disconnect</link>(slot)</computeroutput>. Internally,
        a linear search using slot comparison is performed and the
        slot, if found, is removed from the list. Unfortunately,
        querying connectedness will generally also end up as
        linear-time operations. This model also fails for
        implementation reasons when slots become more complex than
        simple function pointers, member function pointers and a
        limited set of compositions and argument binders: to match the
        slot given in the call to
        <computeroutput><link linkend="id387664-bb">disconnect</link></computeroutput> with an
        existing slot we would need to be able to compare arbitrary
        function objects, which is not feasible.</para></listitem><listitem><para><emphasis role="bold">Pass a token to
        disconnect</emphasis>: this approach identifies slots with a
        token that is easily comparable (e.g., a string), enabling
        slots to be arbitrary function objects. While this approach is
        essentially equivalent to the approach taken by Boost.Signals,
        it is possibly more error-prone for several reasons:</para><itemizedlist><listitem><para>Connections and disconnections must be paired, so
            the problem becomes similar to the problems incurred when
            pairing <computeroutput>new</computeroutput> and <computeroutput>delete</computeroutput> for
            dynamic memory allocation. While errors of this sort would
            not be catastrophic for a signals and slots
            implementation, their detection is generally
            nontrivial.</para></listitem><listitem><para>Tokens must be unique, otherwise two slots will have
            the same name and will be indistinguishable. In
            environments where many connections will be made
            dynamically, name generation becomes an additional task
            for the user. Uniqueness of tokens also results in an
            additional failure mode when attempting to connect a slot
            using a token that has already been used.</para></listitem><listitem><para>More parameterization would be required, because the
            token type must be user-defined. Additional
            parameterization steepens the learning curver and
            overcomplicates a simple interface.</para></listitem></itemizedlist><para> This type of interface is supported in Boost.Signals
        via the slot grouping mechanism. It augments the
        <computeroutput><link linkend="connection">connection</link></computeroutput> object-based
        connection management scheme.</para></listitem></itemizedlist></section><section><title>Combiner Interface</title><para> The Combiner interface was chosen to mimic a call to an
    algorithm in the C++ standard library. It is felt that by viewing
    slot call results as merely a sequence of values accessed by input
    iterators, the combiner interface would be most natural to a
    proficient C++ programmer. Competing interface design generally
    required the combiners to be constructed to conform to an
    interface that would be customized for (and limited to) the
    Signals library. While these interfaces are generally enable more
    straighforward implementation of the signals &amp; slots
    libraries, the combiners are unfortunately not reusable (either in
    other signals &amp; slots libraries or within other generic
    algorithms), and the learning curve is steepened slightly to learn
    the specific combiner interface.</para><para> The Signals formulation of combiners is based on the
    combiner using the "pull" mode of communication, instead of the
    more complex "push" mechanism. With a "pull" mechanism, the
    combiner's state can be kept on the stack and in the program
    counter, because whenever new data is required (i.e., calling the
    next slot to retrieve its return value), there is a simple
    interface to retrieve that data immediately and without returning
    from the combiner's code. Contrast this with the "push" mechanism,
    where the combiner must keep all state in class members because
    the combiner's routines will be invoked for each signal
    called. Compare, for example, a combiner that returns the maximum
    element from calling the slots. If the maximum element ever
    exceeds 100, no more slots are to be called.</para><informaltable><tgroup cols="2" align="left"><thead><row><entry><para>Pull</para></entry><entry><para>Push</para></entry></row></thead><tbody><row><entry><programlisting>
struct pull_max {
  typedef int result_type;

  template&lt;typename InputIterator&gt;
  result_type operator()(InputIterator first,
                         InputIterator last)
  {
    if (first == last)
      throw std::runtime_error("Empty!");

    int max_value = *first++;
    while(first != last &amp;&amp; *first &lt;= 100) {
      if (*first &gt; max_value)
        max_value = *first;
      ++first;
    }

    return max_value;
  }
};
</programlisting></entry><entry><programlisting>
struct push_max {
  typedef int result_type;

  push_max() : max_value(), got_first(false) {}

  // returns false when we want to stop
  bool operator()(int result) {
    if (result &gt; 100)
      return false;

    if (!got_first) {
      got_first = true;
      max_value = result;
      return true;
    }

    if (result &gt; max_value)
      max_value = result;

    return true;
  }

  int get_value() const 
  { 
    if (!got_first)
      throw std::runtime_error("Empty!");
    return max_value; 
  }

private:
  int  max_value; 
  bool got_first;
};
</programlisting></entry></row></tbody></tgroup></informaltable><para>There are several points to note in these examples. The
    "pull" version is a reusable function object that is based on an
    input iterator sequence with an integer <computeroutput>value_type</computeroutput>,
    and is very straightforward in design. The "push" model, on the
    other hand, relies on an interface specific to the caller and is
    not generally reusable. It also requires extra state values to
    determine, for instance, if any elements have been
    received. Though code quality and ease-of-use is generally
    subjective, the "pull" model is clearly shorter and more reusable
    and will often be construed as easier to write and understand,
    even outside the context of a signals &amp; slots library.</para><para> The cost of the "pull" combiner interface is paid in the
    implementation of the Signals library itself. To correctly handle
    slot disconnections during calls (e.g., when the dereference
    operator is invoked), one must construct the iterator to skip over
    disconnected slots. Additionally, the iterator must carry with it
    the set of arguments to pass to each slot (although a reference to
    a structure containing those arguments suffices), and must cache
    the result of calling the slot so that multiple dereferences don't
    result in multiple calls. This apparently requires a large degree
    of overhead, though if one considers the entire process of
    invoking slots one sees that the overhead is nearly equivalent to
    that in the "push" model, but we have inverted the control
    structures to make iteration and dereference complex (instead of
    making combiner state-finding complex).</para></section><section><title>Connection Interfaces: +=  operator</title><para> Boost.Signals supports a connection syntax with the form
    <computeroutput>sig.<link linkend="id503915-bb">connect</link>(slot)</computeroutput>, but a
    more terse syntax <computeroutput>sig += slot</computeroutput> has been suggested (and
    has been used by other signals &amp; slots implementations). There
    are several reasons as to why this syntax has been
    rejected:</para><itemizedlist><listitem><para><emphasis role="bold">It's unnecessary</emphasis>: the
        connection syntax supplied by Boost.Signals is no less
        powerful that that supplied by the <computeroutput>+=</computeroutput>
        operator. The savings in typing (<computeroutput>connect()</computeroutput>
        vs. <computeroutput>+=</computeroutput>) is essentially negligible. Furthermore,
        one could argue that calling <computeroutput>connect()</computeroutput> is more
        readable than an overload of <computeroutput>+=</computeroutput>.</para></listitem><listitem><para><emphasis role="bold">Ambiguous return type</emphasis>:
        there is an ambiguity concerning the return value of the
        <computeroutput>+=</computeroutput> operation: should it be a reference to the
        signal itself, to enable <computeroutput>sig += slot1 += slot2</computeroutput>,
        or should it return a
        <computeroutput><link linkend="connection">connection</link></computeroutput> for the
        newly-created signal/slot connection?</para></listitem><listitem><para><emphasis role="bold">Gateway to operators -=,
        +</emphasis>: when one has added a connection operator
        <computeroutput>+=</computeroutput>, it seems natural to have a disconnection
        operator <computeroutput>-=</computeroutput>. However, this presents problems when
        the library allows arbitrary function objects to implicitly
        become slots, because slots are no longer comparable.  </para><para> The second obvious addition when one has
        <computeroutput>operator+=</computeroutput> would be to add a <computeroutput>+</computeroutput>
        operator that supports addition of multiple slots, followed by
        assignment to a signal. However, this would require
        implementing <computeroutput>+</computeroutput> such that it can accept any two
        function objects, which is technically infeasible.</para></listitem></itemizedlist></section><section><title><computeroutput>trackable</computeroutput> rationale</title><para> The <computeroutput><link linkend="trackable">trackable</link></computeroutput>
      class is the primary user interface to automatic connection
      lifetime management, and its design affects users directly. Two
      issues stick out most: the odd copying behavior of
      <computeroutput>trackable</computeroutput>, and the limitation requiring users to
      derive from <computeroutput>trackable</computeroutput> to create types that can
      participate in automatic connection management.</para><section><title><computeroutput>trackable</computeroutput> copying behavior</title><para> The copying behavior of
      <computeroutput><link linkend="trackable">trackable</link></computeroutput> is essentially
      that <computeroutput><link linkend="trackable">trackable</link></computeroutput> subobjects
      are never copied; instead, the copy operation is merely a
      no-op. To understand this, we look at the nature of a
      signal-slot connection and note that the connection is based on
      the entities that are being connected; when one of the entities
      is destroyed, the connection is destroyed. Therefore, when a
      <computeroutput><link linkend="trackable">trackable</link></computeroutput> subobject is
      copied, we cannot copy the connections because the connections
      don't refer to the target entity - they refer to the source
      entity. This reason is dual to the reason signals are
      noncopyable: the slots connected to them are connected to that
      particular signal, not the data contained in the signal.</para></section><section><title>Why derivation from <computeroutput>trackable</computeroutput>?</title><para> For <computeroutput><link linkend="trackable">trackable</link></computeroutput> to work
      properly, there are two constraints:</para><itemizedlist><listitem><para><computeroutput><link linkend="trackable">trackable</link></computeroutput> must
          have storage space to keep track of all connections made to
          this object.</para></listitem><listitem><para><computeroutput><link linkend="trackable">trackable</link></computeroutput> must be
          notified when the object is being destructed so that it can
          disconnect its connections.</para></listitem></itemizedlist><para>Clearly, deriving from
      <computeroutput><link linkend="trackable">trackable</link></computeroutput> meets these two
      guidelines. We have not yet found a superior solution.</para></section></section><section><title>Comparison with other Signal/Slot implementations</title><section><title>libsigc++</title><para><ulink url="http://libsigc.sourceforge.net">libsigc++</ulink> is a C++
      signals &amp; slots library that originally started as part of
      an initiative to wrap the C interfaces to <ulink url="http://www.gtk.org">GTK</ulink> libraries in C++, and has
      grown to be a separate library maintained by Karl Nelson. There
      are many similarities between libsigc++ and Boost.Signals, and
      indeed Boost.Signals was strongly influenced by Karl Nelson and
      libsigc++. A cursory inspection of each library will find a
      similar syntax for the construction of signals and in the use of
      connections and automatic connection lifetime management. There
      are some major differences in design that separate these
      libraries:</para><itemizedlist><listitem><para><emphasis role="bold">Slot definitions</emphasis>:
          slots in libsigc++ are created using a set of primitives
          defined by the library. These primitives allow binding of
          objects (as part of the library), explicit adaptation from
          the argument and return types of the signal to the argument
          and return types of the slot (libsigc++ is, by default, more
          strict about types than Boost.Signals). A discussion of this
          approach with a comparison against the approach taken by
          Boost.Signals is given in Choice of Slot Definitions.</para></listitem><listitem><para><emphasis role="bold">Combiner/Marshaller
          interface</emphasis>: the equivalent to Boost.Signals
          combiners in libsigc++ are the marshallers. Marshallers are
          similar to the "push" interface described in Combiner
          Interface, and a proper treatment of the topic is given
          there.</para></listitem></itemizedlist></section><section><title>.NET delegates</title><para><ulink url="http://www.microsoft.com">Microsoft</ulink>
      has introduced the .NET Framework and an associated set of
      languages and language extensions, one of which is the
      delegate. Delegates are similar to signals and slots, but they
      are more limited than most C++ signals and slots implementations
      in that they:</para><itemizedlist><listitem><para>Require exact type matches between a delegate and what
          it is calling.</para></listitem><listitem><para>Only return the result of the last target called, with no option for customization.</para></listitem><listitem><para>Must call a method with <computeroutput>this</computeroutput> already
          bound.</para></listitem></itemizedlist></section></section></section><section id="signals.tests"><title>Testsuite</title><section><title>Acceptance tests</title><informaltable><tgroup cols="3"><colspec colnum="2" colwidth="1in"/><thead><row><entry>Test</entry><entry>Type</entry><entry>Description</entry><entry>If failing...</entry></row></thead><tbody><row><entry><simpara><ulink url="../../libs/signals/test/dead_slot_test.cpp">dead_slot_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Ensure that calling connect with a slot
that has already been disconnected via deletion does not actually
connect to the slot.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/signals/test/deletion_test.cpp">deletion_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test deletion of slots.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/signals/test/ordering_test.cpp">ordering_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test slot group ordering.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/signals/test/signal_n_test.cpp">signal_n_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Basic test of signal/slot connections and invocation using the
<link linkend="signalN">boost::signalN</link> class templates.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/signals/test/signal_test.cpp">signal_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Basic test of signal/slot connections and invocation using the
<link linkend="signal">boost::signal</link> class template.</para></entry><entry><para>The <link linkend="signal">boost::signal</link> class template may not
be usable on your compiler. However, the
<link linkend="signalN">boost::signalN</link> class templates may still be
usable.</para></entry></row><row><entry><simpara><ulink url="../../libs/signals/test/trackable_test.cpp">trackable_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test automatic lifetime management using
      boost::trackable objects.</para></entry><entry/></row></tbody></tgroup></informaltable></section></section></chapter><chapter xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="string_algo" rev:last-revision="$Date: 2004/07/16 07:51:36 $"><chapterinfo><author><firstname>Pavol</firstname><surname>Droba</surname></author><copyright><year>2002</year><year>2003</year><year>2004</year><holder>Pavol Droba</holder></copyright><legalnotice><para>Use, modification and distribution is subject to the Boost
                Software License, Version 1.0. (See accompanying file
                <filename>LICENSE_1_0.txt</filename> or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
            </para></legalnotice></chapterinfo><title>Boost String Algorithms Library</title><section id="string_algo.intro" rev:last-revision="$Date: 2004/07/15 21:47:21 $" xml:base="../libs/algorithm/string/doc/intro.xml"><title>Introduction</title><para>
        The String Algorithm Library provides a generic implementation of
        string-related algorithms which are missing in STL. It is an extension
        to the algorithms library of STL and it includes trimming, case conversion, 
        predicates and find/replace functions. All of them come in different variants 
        so it is easier to choose the best fit for a particular need.
    </para><para>
        The implementation is not restricted to work with a particular container 
        (like <computeroutput>std::basic_string</computeroutput>), rather it is as generic as
        possible. This generalization is not compromising the performance since
        algorithms are using container specific features when it means a performance
        gain.
    </para><para><emphasis role="bold">
            Important note: In this documentation we use term <emphasis>string</emphasis> to 
            designate a sequence of <emphasis>characters</emphasis> stored in an arbitrary container.
            A <emphasis>string</emphasis> is not restricted to <computeroutput>std::basic_string</computeroutput> and 
            <emphasis>character</emphasis> does not have to be <computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput>,
            although these are most common candidates.
        </emphasis>
        Consult the <link linkend="string_algo.design">design chapter</link> to see precise specification of
        supported string types.
    </para><para>      
        The library interface functions and classes are defined in namespace <computeroutput>boost::algorithm</computeroutput>, and
        they are lifted into namespace <computeroutput>boost</computeroutput> via using declaration.
    </para><para>
        The documentation is divided into several sections. For a quick start read the 
        <link linkend="string_algo.usage">Usage</link> section followed by 
        <link linkend="string_algo.quickref">Quick Reference</link>. 
        <link linkend="string_algo.design">The Design Topics</link>,
        <link linkend="string_algo.concept">Concepts</link> and <link linkend="string_algo.rationale">Rationale</link>
        provide some explanation about the library design and structure an explain how it should be used.
        See the <link linkend="string_algo.reference">Reference</link> for the complete list of provided utilities
        and algorithms. Functions and classes in the reference are organized by the headers in which they are defined.
        The reference contains links to the detailed description for every entity in the library.
    </para></section><section id="string_algo.usage" rev:last-revision="$Date: 2004/08/03 17:09:28 $" xml:base="../libs/algorithm/string/doc/usage.xml"><title>Usage</title><section><title>First Example</title><para>
            Using the algorithms is straightforward. Let us have a look at the first example:
        </para><programlisting>
    #include &lt;boost/algorithm/string.hpp&gt;
    using namespace std;
    using namespace boost;
    
    // ...

    string str1(" hello world! ");
    to_upper(str1);  // str1 == " HELLO WORLD! "
    trim(str1);      // str1 == "HELLO WORLD!"

    string str2=
       to_lower_copy(
          ireplace_first_copy(
             str1,"hello","goodbye")); // str2 == "goodbye world!"
        </programlisting><para>
            This example converts str1 to upper case and trims spaces from the start and the end
            of the string. str2 is then created as a copy of str1 with "hello" replaced with "goodbye".
            This example demonstrates several important concepts used in the library:
        </para><itemizedlist><listitem><para><emphasis role="bold">Container parameters:</emphasis>
                    Unlike in the STL algorithms, parameters are not specified only in the form
                    of iterators. The STL convention allows for great flexibility,
                    but it has several limitations. It is not possible to <emphasis>stack</emphasis> algorithms together, 
                    because a container is passed in two parameters. Therefore it is not possible to use 
                    a return value from another algorithm. It is considerably easier to write
                    <computeroutput>to_lower(str1)</computeroutput>, than <computeroutput>to_lower(str1.begin(), str1.end())</computeroutput>.
                </para><para>
                    The magic of <link linkend="string_algo.collection_traits">collection_traits</link> 
                    provides a uniform way of handling different string types. 
                    If there is a need to pass a pair of iterators, 
                    <link linkend="string_algo.iterator_range"><computeroutput>iterator_range</computeroutput></link>
                    can be used to package iterators into a structure with a compatible interface.
                </para></listitem><listitem><para><emphasis role="bold">Copy vs. Mutable:</emphasis>
                    Many algorithms in the library are performing a transformation of the input. 
                    The transformation can be done in-place, mutating the input sequence, or a copy 
                    of the transformed input can be created, leaving the input intact. None of 
                    these possibilities is superior to the other one and both have different 
                    advantages and disadvantages. For this reason, both are provided with the library. 
                </para></listitem><listitem><para><emphasis role="bold">Algorithm stacking:</emphasis>
                    Copy versions return a transformed input as a result, thus allow a simple chaining of
                    transformations within one expression (i.e. one can write <computeroutput>trim_copy(to_upper_copy(s))</computeroutput>). 
                    Mutable versions have <computeroutput>void</computeroutput> return, to avoid misuse.
                </para></listitem><listitem><para><emphasis role="bold">Naming:</emphasis>
                    Naming follows the conventions from the Standard C++ Library. If there is a 
                    copy and a mutable version of the same algorithm, the mutable version has no suffix 
                    and the copy version has the suffix <emphasis>_copy</emphasis>. 
                    Some algorithms have the prefix <emphasis>i</emphasis> 
                    (e.g. <link linkend="ifind_first">ifind_first()</link>).
                    This prefix identifies that the algorithm works in a case-insensitive manner.
                </para></listitem></itemizedlist><para>
            To use the library, include the <link linkend="id299529">boost/algorithm/string.hpp</link> header. 
            If the regex related functions are needed, include the 
            <link linkend="id263316">boost/algorithm/string_regex.hpp</link> header.
        </para></section><section><title>Case conversion</title><para>
            STL has a nice way of converting character case. Unfortunately, it works only
            for a single character and we want to convert a string, 
        </para><programlisting>
    string str1("HeLlO WoRld!");
    to_upper(str1); // str1=="HELLO WORLD!"
        </programlisting><para><link linkend="to_upper">to_upper()</link> and <link linkend="to_lower">to_lower()</link> convert the case of 
            characters in a string using a specified locale.
        </para><para>
            For more information see the reference for <link linkend="id350445">boost/algorithm/string/case_conv.hpp</link>.
        </para></section><section><title>Predicates and Classification</title><para>
            A part of the library deals with string related predicates. Consider this example:
        </para><programlisting>
    bool is_executable( string&amp; filename )
    {
        return 
            iends_with(filename, ".exe") ||
            iends_with(filename, ".com");
    }

    // ...
    string str1("command.com");
    cout 
        &lt;&lt; str1
        &lt;&lt; is_executable("command.com")? "is": "is not" 
        &lt;&lt; "an executable" 
        &lt;&lt; endl; // prints "command.com is an executable"
    
    //..
    char text1[]="hello world!";
    cout 
        &lt;&lt; text1 
        &lt;&lt; all( text1, is_lower() )? "is": "is not"
        &lt;&lt; " written in the lower case" 
        &lt;&lt; endl; // prints "hello world! is written in the lower case"
        </programlisting><para>
            The predicates determine whether if a substring is contained in the input string
            under various conditions. The conditions are: a string starts with the substring, 
            ends with the substring, 
            simply contains the substring or if both strings are equal. See the reference for 
            <link linkend="id366812">boost/algorithm/string/predicate.hpp</link> for more details. 
        </para><para>  
            In addition the algorithm <link linkend="all">all()</link> checks
            all elements of a container to satisfy a condition specified by a predicate. 
            This predicate can be any unary predicate, but the library provides a bunch of 
            useful string-related predicates and combinators ready for use.
            These are located in the <link linkend="id388523">boost/algorithm/string/classification.hpp</link> header.
            Classification predicates can be combined using logical combinators to form
            a more complex expressions. For example: <computeroutput>is_from_range('a','z') || is_digit()</computeroutput></para></section><section><title>Trimming</title><para>
            When parsing the input from a user, strings usually have unwanted leading or trailing 
            characters. To get rid of them, we need trim functions:
        </para><programlisting>
    string str1="     hello world!     ";
    string str2=trim_left_copy(str1);   // str2 == "hello world!     "
    string str3=trim_right_copy(str2);  // str3 == "     hello world!"
    trim(str1);                         // str1 == "hello world!"

    string phone="00423333444";
    // remove leading 0 from the phone number
    trim_left_if(phone,is_any_of("0")); // phone == "423333444"
        </programlisting><para>
            It is possible to trim the spaces on the right, on the left or on both sides of a string.
            And for those cases when there is a need to remove something else than blank space, there
            are <emphasis>_if</emphasis> variants. Using these, a user can specify a functor which will 
            select the <emphasis>space</emphasis> to be removed. It is possible to use classification 
            predicates like <link linkend="is_digit">is_digit()</link> mentioned in the previous paragraph.
            See the reference for the <link linkend="id263327">boost/algorithm/string/trim.hpp</link>.
        </para></section><section><title>Find algorithms</title><para>
            The library contains a set of find algorithms. Here is an example:
        </para><programlisting>
    char text[]="hello dolly!";
    iterator_range&lt;char*&gt; result=find_last(text,"ll");

    transform( result.begin(), result.end(), result.begin(), bind2nd(plus&lt;char&gt;(), 1) );
    // text = "hello dommy!"            

    to_upper(result); // text == "hello doMMy!"

    // iterator_range is convertible to bool
    if(find_first(text, "dolly"))
    {
        cout &lt;&lt; "Dolly is there" &lt;&lt; endl;
    }
        </programlisting><para>
            We have used <link linkend="find_last">find_last()</link> to search the <computeroutput>text</computeroutput> for "ll".
            The result is given in the <link linkend="string_algo.iterator_range"><computeroutput>iterator_range</computeroutput></link>. 
            This range delimits the
            part of the input which satisfies the find criteria. In our example it is the last occurrence of "ll".
            
            As we can see, input of the <link linkend="find_last">find_last()</link> algorithm can be also 
            char[] because this type is supported by 
            <link linkend="string_algo.collection_traits">collection_traits</link>.

            The following lines transform the result. Notice that 
            <link linkend="string_algo.iterator_range"><computeroutput>iterator_range</computeroutput></link> has familiar 
            <computeroutput>begin()</computeroutput> and <computeroutput>end()</computeroutput> methods, so it can be used like any other STL container.
            Also it is convertible to bool therefore it is easy to use find algorithms for a simple containment checking.
        </para><para>
            Find algorithms are located in <link linkend="id448104">boost/algorithm/string/find.hpp</link>.
        </para></section><section><title>Replace Algorithms</title><para>
            Find algorithms can be used for searching for a specific part of string. Replace goes one step
            further. After a matching part is found, it is substituted with something else. The substitution is computed
            from the original, using some transformation. 
        </para><programlisting>
    string str1="Hello  Dolly,   Hello World!"
    replace_first(str1, "Dolly", "Jane");      // str1 == "Hello  Jane,   Hello World!"
    replace_last(str1, "Hello", "Goodbye");    // str1 == "Hello  Jane,   Goodbye World!"
    erase_all(str1, " ");                      // str1 == "HelloJane,GoodbyeWorld!"
    erase_head(str1, 6);                       // str1 == "Jane,GoodbyeWorld!"
        </programlisting><para>
            For the complete list of replace and erase functions see the 
            <link linkend="string_algo.reference">reference</link>.
            There is a lot of predefined function for common usage, however, the library allows you to 
            define a custom <computeroutput>replace()</computeroutput> that suits a specific need. There is a generic <link linkend="find_format">find_format()</link> 
            function which takes two parameters.
            The first one is a <link linkend="string_algo.finder_concept">Finder</link> object, the second one is 
            a <link linkend="string_algo.formatter_concept">Formatter</link> object. 
            The Finder object is a functor which performs the searching for the replacement part. The Formatter object
            takes the result of the Finder (usually a reference to the found substring) and creates a 
            substitute for it. Replace algorithm puts these two together and makes the desired substitution. 
        </para><para>
            Check <link linkend="id439791">boost/algorithm/string/replace.hpp</link>, <link linkend="id236631">boost/algorithm/string/erase.hpp</link> and
            <link linkend="id333397">boost/algorithm/string/find_format.hpp</link> for reference.
        </para></section><section><title>Find Iterator</title><para>
            An extension to find algorithms it the Find Iterator. Instead of searching for just a one part of a string, 
            the find iterator allows us to iterate over the substrings matching the specified criteria.
            This facility is using the <link linkend="string_algo.finder_concept">Finder</link> to incrementally
            search the string. 
            Dereferencing a find iterator yields an <link linkend="string_algo.iterator_range"><computeroutput>iterator_range</computeroutput></link> 
            object, that delimits the current match.
        </para><para>
            There are two iterators provided <link linkend="find_iterator">find_iterator</link> and 
            <link linkend="split_iterator">split_iterator</link>. The former iterates over substrings that are found using the specified
            Finder. The latter iterates over the gaps between these substrings.
        </para><programlisting>
    string str1("abc-*-ABC-*-aBc");
    // Find all 'abc' substrings (ignoring the case)
    // Create a find_iterator
    typedef find_iterator&lt;string::iterator&gt; string_find_iterator;
    for(string_find_iterator It=
            make_find_iterator(str1, first_finder("abc", is_iequal()));
        It!=string_find_iterator();
        ++It)
    {
        cout &lt;&lt; copy_iterator_range&lt;std::string&gt;(*It) &lt;&lt; endl;
    }

    // Output will be:
    // abc
    // ABC
    // aBC
    
    typedef split_iterator&lt;string::iterator&gt; string_split_iterator;
    for(string_find_iterator It=
        make_split_iterator(str1, first_finder("-*-", is_iequal()));
        It!=string_find_iterator();
        ++It)
    {
        cout &lt;&lt; copy_iterator_range&lt;std::string&gt;(*It) &lt;&lt; endl;
    }

    // Output will be:
    // abc
    // ABC
    // aBC
        </programlisting><para>
            Note that the find iterators have only one template parameter. It is the base iterator type.
            The Finder is specified at runtime. This allows us to typedef a find iterator for
            common string types and reuse it. Additionally make_*_iterator functions help
            to construct a find iterator for a particular collection.
        </para><para>
            See the reference in <link linkend="id254240">boost/algorithm/string/find_iterator.hpp</link>.
        </para></section><section><title>Split</title><para>
            Split algorithms are an extension to the find iterator for one common usage scenario.
            These algorithms use a find iterator and store all matches into the provided
            container. This container must be able to hold copies (e.g. <computeroutput>std::string</computeroutput>) or 
            references (e.g. <computeroutput>iterator_range</computeroutput>) of the extracted substrings.
        </para><para>
            Two algorithms are provided. <link linkend="find_all">find_all()</link> finds all copies
            of a string in the input. <link linkend="id479732">split()</link> splits the input into parts.
        </para><programlisting>
    string str1("hello abc-*-ABC-*-aBc goodbye");

    typedef vector&lt; iterator_range&lt;string::iterator&gt; &gt; find_vector_type;
    
    find_vector_type FindVec; // #1: Search for separators
    ifind_all( FindVec, str1, "abc" ); // FindVec == { [abc],[ABC],[aBc] }

    typedef vector&lt; string &gt; split_vector_type;
    
    split_vector_type SplitVec; // #2: Search for tokens
    split( SplitVec, str1, is_any_of("-*") ); // SplitVec == { "hello abc","ABC","aBc goodbye" }
        </programlisting><para><computeroutput>[hello]</computeroutput> designates an <computeroutput>iterator_range</computeroutput> delimiting this substring.                       
        </para><para>
            First example show how to construct a container to hold references to all extracted
            substrings. Algorithm <link linkend="ifind_all">ifind_all()</link> puts into FindVec references
            to all substrings that are in case-insensitive manner equal to "abc".
        </para><para>
            Second example uses <link linkend="id479732">split()</link> to split string str1 into parts
            separated by characters '-' or '*'. These parts are then put into the SplitVec.
            It is possible to specify if adjacent separators are concatenated or not.
        </para><para>
            More information can be found in the reference: <link linkend="id477625">boost/algorithm/string/split.hpp</link>.
        </para></section></section><section id="string_algo.quickref" rev:last-revision="$Date: 2004/07/16 09:06:39 $" xml:base="../libs/algorithm/string/doc/quickref.xml"><title>Quick Reference</title><section><title>Algorithms</title><table><title>Case Conversion</title><tgroup cols="3" align="left"><thead><row><entry>Algorithm name</entry><entry>Description</entry><entry>Functions</entry></row></thead><tbody><row><entry><computeroutput>to_upper</computeroutput></entry><entry>Convert a string to upper case</entry><entry><link linkend="to_upper_copy">to_upper_copy()</link><sbr/><link linkend="to_upper">to_upper()</link></entry></row><row><entry><computeroutput>to_lower</computeroutput></entry><entry>Convert a string to lower case</entry><entry><link linkend="to_lower_copy">to_lower_copy()</link><sbr/><link linkend="to_lower">to_lower()</link></entry></row></tbody></tgroup></table><table><title>Trimming</title><tgroup cols="3" align="left"><thead><row><entry>Algorithm name</entry><entry>Description</entry><entry>Functions</entry></row></thead><tbody><row><entry><computeroutput>trim_left</computeroutput></entry><entry>Remove leading spaces from a string</entry><entry><link linkend="trim_left_copy_if">trim_left_copy_if()</link><sbr/><link linkend="trim_left_if">trim_left_if()</link><sbr/><link linkend="trim_left_copy">trim_left_copy()</link><sbr/><link linkend="trim_left">trim_left()</link></entry></row><row><entry><computeroutput>trim_right</computeroutput></entry><entry>Remove trailing spaces from a string</entry><entry><link linkend="trim_right_copy_if">trim_right_copy_if()</link><sbr/><link linkend="trim_right_if">trim_right_if()</link><sbr/><link linkend="trim_right_copy">trim_right_copy()</link><sbr/><link linkend="trim_right">trim_right()</link></entry></row><row><entry><computeroutput>trim</computeroutput></entry><entry>Remove leading and trailing spaces from a string</entry><entry><link linkend="trim_copy_if">trim_copy_if()</link><sbr/><link linkend="trim_if">trim_if()</link><sbr/><link linkend="trim_copy">trim_copy()</link><sbr/><link linkend="trim">trim()</link></entry></row></tbody></tgroup></table><table><title>Predicates</title><tgroup cols="3" align="left"><thead><row><entry>Algorithm name</entry><entry>Description</entry><entry>Functions</entry></row></thead><tbody><row><entry><computeroutput>starts_with</computeroutput></entry><entry>Check if a string is a prefix of the other one</entry><entry><link linkend="starts_with">starts_with()</link><sbr/><link linkend="istarts_with">istarts_with()</link></entry></row><row><entry><computeroutput>ends_with</computeroutput></entry><entry>Check if a string is a suffix of the other one</entry><entry><link linkend="ends_with">ends_with()</link><sbr/><link linkend="iends_with">iends_with()</link></entry></row><row><entry><computeroutput>contains</computeroutput></entry><entry>Check if a string is contained of the other one</entry><entry><link linkend="contains">contains()</link><sbr/><link linkend="icontains">icontains()</link></entry></row><row><entry><computeroutput>equals</computeroutput></entry><entry>Check if two strings are equal</entry><entry><link linkend="equals">equals()</link><sbr/><link linkend="iequals">iequals()</link></entry></row><row><entry><computeroutput>all</computeroutput></entry><entry>Check if all elements of a string satisfy the given predicate</entry><entry><link linkend="all">all()</link></entry></row></tbody></tgroup></table><table><title>Find algorithms</title><tgroup cols="3" align="left"><thead><row><entry>Algorithm name</entry><entry>Description</entry><entry>Functions</entry></row></thead><tbody><row><entry>find_first</entry><entry>Find the first occurrence of a string in the input</entry><entry><link linkend="find_first">find_first()</link><sbr/><link linkend="ifind_first">ifind_first()</link></entry></row><row><entry>find_last</entry><entry>Find the last occurrence of a string in the input</entry><entry><link linkend="find_last">find_last()</link><sbr/><link linkend="ifind_last">ifind_last()</link></entry></row><row><entry>find_nth</entry><entry>Find the nth (zero-indexed) occurrence of a string in the input</entry><entry><link linkend="find_nth">find_nth()</link><sbr/><link linkend="ifind_nth">ifind_nth()</link></entry></row><row><entry>find_head</entry><entry>Retrieve the head of a string</entry><entry><link linkend="find_head">find_head()</link></entry></row><row><entry>find_tail</entry><entry>Retrieve the tail of a string</entry><entry><link linkend="find_tail">find_tail()</link></entry></row><row><entry>find_token</entry><entry>Find first matching token in the string</entry><entry><link linkend="find_token">find_token()</link></entry></row><row><entry>find_regex</entry><entry>Use the regular expression to search the string</entry><entry><link linkend="find_regex">find_regex()</link></entry></row><row><entry>find</entry><entry>Generic find algorithm</entry><entry><link linkend="find">find()</link></entry></row></tbody></tgroup></table><table><title>Erase/Replace</title><tgroup cols="3" align="left"><thead><row><entry>Algorithm name</entry><entry>Description</entry><entry>Functions</entry></row></thead><tbody><row><entry>replace/erase_first</entry><entry>Replace/Erase the first occurrence of a string in the input</entry><entry><link linkend="replace_first">replace_first()</link><sbr/><link linkend="replace_first_copy">replace_first_copy()</link><sbr/><link linkend="ireplace_first">ireplace_first()</link><sbr/><link linkend="ireplace_first_copy">ireplace_first_copy()</link><sbr/><link linkend="erase_first">erase_first()</link><sbr/><link linkend="erase_first_copy">erase_first_copy()</link><sbr/><link linkend="ierase_first">ierase_first()</link><sbr/><link linkend="ierase_first_copy">ierase_first_copy()</link></entry></row><row><entry>replace/erase_last</entry><entry>Replace/Erase the last occurrence of a string in the input</entry><entry><link linkend="replace_last">replace_last()</link><sbr/><link linkend="replace_last_copy">replace_last_copy()</link><sbr/><link linkend="ireplace_last">ireplace_last()</link><sbr/><link linkend="ireplace_last_copy">ireplace_last_copy()</link><sbr/><link linkend="erase_last">erase_last()</link><sbr/><link linkend="erase_last_copy">erase_last_copy()</link><sbr/><link linkend="ierase_last">ierase_last()</link><sbr/><link linkend="ierase_last_copy">ierase_last_copy()</link></entry></row><row><entry>replace/erase_nth</entry><entry>Replace/Erase the nth (zero-indexed) occurrence of a string in the input</entry><entry><link linkend="replace_nth">replace_nth()</link><sbr/><link linkend="replace_nth_copy">replace_nth_copy()</link><sbr/><link linkend="ireplace_nth">ireplace_nth()</link><sbr/><link linkend="ireplace_nth_copy">ireplace_nth_copy()</link><sbr/><link linkend="erase_nth">erase_nth()</link><sbr/><link linkend="erase_nth_copy">erase_nth_copy()</link><sbr/><link linkend="ierase_nth">ierase_nth()</link><sbr/><link linkend="ierase_nth_copy">ierase_nth_copy()</link></entry></row><row><entry>replace/erase_all</entry><entry>Replace/Erase the all occurrences of a string in the input</entry><entry><link linkend="replace_all">replace_all()</link><sbr/><link linkend="replace_all_copy">replace_all_copy()</link><sbr/><link linkend="ireplace_all">ireplace_all()</link><sbr/><link linkend="ireplace_all_copy">ireplace_all_copy()</link><sbr/><link linkend="erase_all">erase_all()</link><sbr/><link linkend="erase_all_copy">erase_all_copy()</link><sbr/><link linkend="ierase_all">ierase_all()</link><sbr/><link linkend="ierase_all_copy">ierase_all_copy()</link></entry></row><row><entry>replace/erase_head</entry><entry>Replace/Erase the head of the input</entry><entry><link linkend="replace_head">replace_head()</link><sbr/><link linkend="replace_head_copy">replace_head_copy()</link><sbr/><link linkend="erase_head">erase_head()</link><sbr/><link linkend="erase_head_copy">erase_head_copy()</link><sbr/></entry></row><row><entry>replace/erase_tail</entry><entry>Replace/Erase the tail of the input</entry><entry><link linkend="replace_tail">replace_tail()</link><sbr/><link linkend="replace_tail_copy">replace_tail_copy()</link><sbr/><link linkend="erase_tail">erase_tail()</link><sbr/><link linkend="erase_tail_copy">erase_tail_copy()</link><sbr/></entry></row><row><entry>replace/erase_regex</entry><entry>Replace/Erase a substring matching the given regular expression</entry><entry><link linkend="replace_regex">replace_regex()</link><sbr/><link linkend="replace_regex_copy">replace_regex_copy()</link><sbr/><link linkend="erase_regex">erase_regex()</link><sbr/><link linkend="erase_regex_copy">erase_regex_copy()</link><sbr/></entry></row><row><entry>replace/erase_regex_all</entry><entry>Replace/Erase all substrings matching the given regular expression</entry><entry><link linkend="replace_all_regex">replace_all_regex()</link><sbr/><link linkend="replace_all_regex_copy">replace_all_regex_copy()</link><sbr/><link linkend="erase_all_regex">erase_all_regex()</link><sbr/><link linkend="erase_all_regex_copy">erase_all_regex_copy()</link><sbr/></entry></row><row><entry>find_format</entry><entry>Generic replace algorithm</entry><entry><link linkend="find_format">find_format()</link><sbr/><link linkend="find_format_copy">find_format_copy()</link><sbr/><link linkend="find_format_all">find_format_all()</link><sbr/><link linkend="find_format_all_copy">find_format_all_copy()()</link></entry></row></tbody></tgroup></table><table><title>Split</title><tgroup cols="3" align="left"><thead><row><entry>Algorithm name</entry><entry>Description</entry><entry>Functions</entry></row></thead><tbody><row><entry>find_all</entry><entry>Find/Extract all matching substrings in the input</entry><entry><link linkend="find_all">find_all()</link><sbr/><link linkend="ifind_all">ifind_all()</link><sbr/><link linkend="find_all_regex">find_all_regex()</link></entry></row><row><entry>split</entry><entry>Split input into parts</entry><entry><link linkend="id479732">split()</link><sbr/><link linkend="split_regex">split_regex()</link></entry></row></tbody></tgroup></table></section><section><title>Finders and Formatters</title><table><title>Finders</title><tgroup cols="3" align="left"><thead><row><entry>Finder</entry><entry>Description</entry><entry>Generators</entry></row></thead><tbody><row><entry>first_finder</entry><entry>Search for the first match of the string in an input</entry><entry><link linkend="first_finder">first_finder()</link></entry></row><row><entry>last_finder</entry><entry>Search for the last match of the string in an input</entry><entry><link linkend="last_finder">last_finder()</link></entry></row><row><entry>nth_finder</entry><entry>Search for the nth (zero-indexed) match of the string in an input</entry><entry><link linkend="nth_finder">nth_finder()</link></entry></row><row><entry>head_finder</entry><entry>Retrieve the head of an input</entry><entry><link linkend="head_finder">head_finder()</link></entry></row><row><entry>tail_finder</entry><entry>Retrieve the tail of an input</entry><entry><link linkend="tail_finder">tail_finder()</link></entry></row><row><entry>token_finder</entry><entry>Search for a matching token in an input</entry><entry><link linkend="token_finder">token_finder()</link></entry></row><row><entry>range_finder</entry><entry>Do no search, always returns the given range</entry><entry><link linkend="range_finder">range_finder()</link></entry></row><row><entry>regex_finder</entry><entry>Search for a substring matching the given regex</entry><entry><link linkend="id363826">regex_finder()</link></entry></row></tbody></tgroup></table><table><title>Formatters</title><tgroup cols="3" align="left"><thead><row><entry>Formatter</entry><entry>Description</entry><entry>Generators</entry></row></thead><tbody><row><entry>const_formatter</entry><entry>Constant formatter. Always return the specified string</entry><entry><link linkend="const_formatter">const_formatter()</link></entry></row><row><entry>identity_formatter</entry><entry>Identity formatter. Return unmodified input input</entry><entry><link linkend="identity_formatter">identity_formatter()</link></entry></row><row><entry>empty_formatter</entry><entry>Null formatter. Always return an empty string</entry><entry><link linkend="empty_formatter">empty_formatter()</link></entry></row><row><entry>regex_formatter</entry><entry>Regex formatter. Format regex match using the specification in the format string</entry><entry><link linkend="id308968">regex_formatter()</link></entry></row></tbody></tgroup></table></section><section><title>Iterators</title><table><title>Find Iterators</title><tgroup cols="3" align="left"><thead><row><entry>Iterator name</entry><entry>Description</entry><entry>Iterator class</entry></row></thead><tbody><row><entry>find_iterator</entry><entry>Iterates through matching substrings in the input</entry><entry><link linkend="find_iterator">find_iterator</link></entry></row><row><entry>split_iterator</entry><entry>Iterates through gaps between matching substrings in the input</entry><entry><link linkend="split_iterator">split_iterator</link></entry></row></tbody></tgroup></table></section><section><title>Classification</title><table><title>Predicates</title><tgroup cols="3" align="left"><thead><row><entry>Predicate name</entry><entry>Description</entry><entry>Generator</entry></row></thead><tbody><row><entry>is_classified</entry><entry>Generic <computeroutput>ctype</computeroutput> mask based classification</entry><entry><link linkend="is_classified">is_classified()</link></entry></row><row><entry>is_space</entry><entry>Recognize spaces</entry><entry><link linkend="is_space">is_space()</link></entry></row><row><entry>is_alnum</entry><entry>Recognize alphanumeric characters</entry><entry><link linkend="is_alnum">is_alnum()</link></entry></row><row><entry>is_alpha</entry><entry>Recognize letters</entry><entry><link linkend="is_alpha">is_alpha()</link></entry></row><row><entry>is_cntrl</entry><entry>Recognize control characters</entry><entry><link linkend="is_cntrl">is_cntrl()</link></entry></row><row><entry>is_digit</entry><entry>Recognize decimal digits</entry><entry><link linkend="is_digit">is_digit()</link></entry></row><row><entry>is_graph</entry><entry>Recognize graphical characters</entry><entry><link linkend="is_graph">is_graph()</link></entry></row><row><entry>is_lower</entry><entry>Recognize lower case characters</entry><entry><link linkend="is_lower">is_lower()</link></entry></row><row><entry>is_print</entry><entry>Recognize printable characters</entry><entry><link linkend="is_print">is_print()</link></entry></row><row><entry>is_punct</entry><entry>Recognize punctuation characters</entry><entry><link linkend="is_punct">is_punct()</link></entry></row><row><entry>is_upper</entry><entry>Recognize uppercase characters</entry><entry><link linkend="is_upper">is_upper()</link></entry></row><row><entry>is_xdigit</entry><entry>Recognize hexadecimal digits</entry><entry><link linkend="is_xdigit">is_xdigit()</link></entry></row></tbody></tgroup></table></section></section><section id="string_algo.design" rev:last-revision="$Date: 2004/07/16 09:06:39 $" xml:base="../libs/algorithm/string/doc/design.xml"><title>Design Topics</title><section id="string_algo.string"><title>String Representation</title><para>
            As the name suggest, this library works mainly with strings. However, in the context of this library,
            a string is not restricted to any particular implementation (like <computeroutput>std::basic_string</computeroutput>),
            rather it is a concept. This allows the algorithms in this library to be reused for any string type,
            that satisfies the given requirements.
        </para><para><emphasis role="bold">Definition:</emphasis> A string is a 
            <ulink url="../../libs/utility/Collection.html">collection</ulink> of characters accessible in sequential
            ordered fashion. Character is any value type with "cheap" copying and assignment.                
        </para><para>
            First requirement of string-type is that it must accessible using 
            <link linkend="string_algo.collection_traits">collection traits</link>. This facility allows to access
            the elements inside the string in a uniform iterator-based fashion. 
            This requirement is actually less stringent than that of collection concept. It implements 
            an <ulink url="../../libs/algorithm/string/doc/external_concepts.html">external</ulink> collection interface.
            This is sufficient for our library
        </para><para>            
            Second requirement defines the way in which the characters are stored in the string. Algorithms in 
            this library work with an assumption that copying a character is cheaper then allocating extra 
            storage to cache results. This is a natural assumption for common character types. Algorithms will 
            work even if this requirement is not satisfied, however at the cost of performance degradation.
        <para/>
            In addition some algorithms have additional requirements on the string-type. Particularly, it is required
            that an algorithm can create a new string of the given type. In this case, it is required that
            the type satisfies the sequence (Std &#xA7;23.1.1) requirements.
        </para><para>
            In the reference and also in the code, requirement on the string type is designated by the name of
            template argument. <computeroutput>CollectionT</computeroutput> means that the basic collection requirements must hold.
            <computeroutput>SequenceT</computeroutput> designates extended sequence requirements.
        </para></section><section id="string_algo.iterator_range"><title><computeroutput>iterator_range</computeroutput> class</title><para>
            An <link linkend="iterator_range">iterator_range</link> is an encapsulation of a pair of iterators that
            delimit a sequence (or, a range). This concept is widely used by 
            sequence manipulating algorithms. Although being so useful, there no direct support 
            for it in the standard library (The closest thing is that some algorithms return a pair of iterators). 
            Instead all STL algorithms have two distinct parameters for beginning and end of a range. This design 
            is natural for implementation of generic algorithms, but it forbids to work with a range as a single value. 
        </para><para>
            It is possible to encapsulate a range in <computeroutput>std::pair&lt;&gt;</computeroutput>, but
            <computeroutput>std::pair&lt;&gt;</computeroutput> is an overly generic encapsulation, so it is not best match for a range.
            For instance, it does not enforce that begin and end iterators be of the same type.
        </para><para>
            Naturally the range concept is heavily used also in this library. During the development of
            the library, it was discovered, that there is a need for a reasonable encapsulation for it, since
            core part of the library deals with substring searching algorithms and any such algorithm
            returns a range delimiting the result of the search. <computeroutput>std::pair&lt;&gt;</computeroutput> was deemed as 
            unsuitable. Therefore the <computeroutput>iterator_range</computeroutput> was defined.
        </para><para>
            The intention of the <computeroutput>iterator_range</computeroutput> class is to manage a range as a single value and provide 
            a basic interface for common operations. Its interface is similar to that of a collection. 
            In addition to <computeroutput>begin()</computeroutput>
            and <computeroutput>end()</computeroutput> accessors, it has member functions for checking whether the range is empty,
            or to determine the size of the range. It also has a set of member typedefs that extract
            type information from the encapsulated iterators. As such, the interface is compatible with 
            the <link linkend="string_algo.collection_traits">collection traits</link> requirements so
            it is possible to use this class as a parameter to many algorithms in this library.
        </para><para><link linkend="iterator_range">iterator_range</link> will be moved to Boost.Range library in the future
            releases. The internal version will be deprecated then.
        </para></section><section id="string_algo.collection_traits"><title>Collection Traits</title><para>
            Collection traits provide uniform access to different types of 
            <ulink url="../../libs/utility/Collection.html">collections</ulink> . 
            This functionality allows to write generic algorithms which work with several 
            different kinds of collections. For this library it means, that, for instance,
            many algorithms work with <computeroutput>std::string</computeroutput> as well as with <computeroutput>char[]</computeroutput>.
            This facility implements the
            <ulink url="../../libs/algorithm/string/doc/external_concepts.html">external</ulink> collection
            concept.
        </para><para>
            The following collection types are supported:
            <itemizedlist><listitem>
                    Standard containers
                </listitem><listitem>
                    Built-in arrays (like int[])
                </listitem><listitem>
                    Null terminated strings (this includes char[],wchar_t[],char*, and wchar_t*)
                </listitem><listitem>
                    std::pair&lt;iterator,iterator&gt;
                </listitem></itemizedlist></para><para>
            Collection traits support a subset of the container concept (Std &#xA7;23.1). This subset 
            can be described as an input container concept, e.g. a container with immutable content. 
            Its definition can be found in the header <link linkend="id407166">boost/algorithm/string/collection_traits.hpp</link>.
        </para><para>
            In the table C denotes a container and c is an object of C. 
        </para><table><title>Collection Traits</title><tgroup cols="3" align="left"><thead><row><entry>Name</entry><entry>Standard collection equivalent</entry><entry>Description</entry></row>Maeterlinck
                </thead><tbody><row><entry><link linkend="value_type_of">value_type_of&lt;C&gt;</link>::type</entry><entry><computeroutput>C::value_type</computeroutput></entry><entry>Type of contained values</entry></row><row><entry><link linkend="difference_type_of">difference_type_of&lt;C&gt;</link>::type</entry><entry><computeroutput>C::difference_type</computeroutput></entry><entry>difference type of the collection</entry></row><row><entry><link linkend="iterator_of">iterator_of&lt;C&gt;</link>::type</entry><entry><computeroutput>C::iterator</computeroutput></entry><entry>iterator type of the collection</entry></row><row><entry><link linkend="const_iterator_of">const_iterator_of&lt;C&gt;</link>::type</entry><entry><computeroutput>C::const_iterator</computeroutput></entry><entry>const_iterator type of the collection</entry></row><row><entry><link linkend="result_iterator_of">result_iterator_of&lt;C&gt;</link>::type</entry><entry/><entry>
                            result_iterator type of the collection. This type maps to <computeroutput>C::iterator</computeroutput>
                            for mutable collection and <computeroutput>C::const_iterator</computeroutput> for const collection.
                        </entry></row><row><entry><link linkend="begin">begin(c)</link></entry><entry><computeroutput>c.begin()</computeroutput></entry><entry>
                            Gets the iterator pointing to the start of the collection.
                        </entry></row><row><entry><link linkend="end">end(c)</link></entry><entry><computeroutput>c.end()</computeroutput></entry><entry>
                            Gets the iterator pointing to the end of the collection.
                        </entry></row><row><entry><link linkend="size">size(c)</link></entry><entry><computeroutput>c.size()</computeroutput></entry><entry>
                            Gets the size of the collection.
                        </entry></row><row><entry><link linkend="empty">empty(c)</link></entry><entry><computeroutput>c.empty()</computeroutput></entry><entry>
                            Checks if the collection is empty.
                        </entry></row></tbody></tgroup></table><para>
            The collection traits are only a temporary part of this library. They will be replaced in the future
            releases by Boost.Range library. Use of the internal implementation will be deprecated then.
        </para></section><section id="string_algo.sequence_traits"><title>Sequence Traits</title><para>
            The major difference between <computeroutput>std::list</computeroutput> and <computeroutput>std::vector</computeroutput> is not in the interfaces
            they provide, but rather in the inner details of the class and the way how it performs 
            various operations. The problem is that it is not possible to infer this difference from the 
            definitions of classes without some special mechanism.
            However, some algorithms can run significantly faster with the knowledge of the properties
            of a particular container.
        </para><para>
            Sequence traits allow one to specify additional properties of a sequence container (see Std.&#xA7;32.2).
            These properties are then used by algorithms to select optimized handling for some operations.
            The sequence traits are declared in the header 
            <link linkend="id264095">boost/algorithm/string/sequence_traits.hpp</link>.
        </para><para>
            In the table C denotes a container and c is an object of C.
        </para><table><title>Sequence Traits</title><tgroup cols="2" align="left"><thead><row><entry>Trait</entry><entry>Description</entry></row></thead><tbody><row><entry><link linkend="has_native_replace">has_native_replace&lt;C&gt;</link>::value</entry><entry>Specifies that the sequence has std::string like replace method</entry></row><row><entry><link linkend="has_stable_iterators">has_stable_iterators&lt;C&gt;</link>::value</entry><entry>
                            Specifies that the sequence has stable iterators. It means,
                            that operations like <computeroutput>insert</computeroutput>/<computeroutput>erase</computeroutput>/<computeroutput>replace</computeroutput> 
                            do not invalidate iterators.
                        </entry></row><row><entry><link linkend="has_const_time_insert">has_const_time_insert&lt;C&gt;</link>::value</entry><entry>
                            Specifies that the insert method of the sequence has 
                            constant time complexity.
                        </entry></row><row><entry><link linkend="has_const_time_erase">has_const_time_erase&lt;C&gt;</link>::value</entry><entry>
                            Specifies that the erase method of the sequence has constant time complexity
                        </entry></row></tbody></tgroup></table><para>
            Current implementation contains specializations for std::list&lt;T&gt; and
            std::basic_string&lt;T&gt; from the standard library and SGI's std::rope&lt;T&gt; and std::slist&lt;T&gt;.
        </para></section><section id="string_algo.find"><title>Find Algorithms</title><para>
            Find algorithms have similar functionality to <computeroutput>std::search()</computeroutput> algorithm. They provide a different 
            interface which is more suitable for common string operations. 
            Instead of returning just the start of matching subsequence they return a range which is necessary 
            when the length of the matching subsequence is not known beforehand. 
            This feature also allows a partitioning of  the input sequence into three 
            parts: a prefix, a substring and a suffix. 
        </para><para>
            Another difference is an addition of various searching methods besides find_first, including find_regex. 
        </para><para>
            It the library, find algorithms are implemented in terms of 
            <link linkend="string_algo.finder_concept">Finders</link>. Finders are used also by other facilities 
            (replace,split).
            For convenience, there are also function wrappers for these finders to simplify find operations.
        </para><para>
            Currently the library contains only naive implementation of find algorithms with complexity 
            O(n * m) where n is the size of the input sequence and m is the size of the search sequence. 
            There are algorithms with complexity O(n), but for smaller sequence a constant overhead is 
            rather big. For small m &lt;&lt; n (m by magnitude smaller than n) the current implementation 
            provides acceptable efficiency. 
            Even the C++ standard defines the required complexity for search algorithm as O(n * m). 
            It is possible that a future version of library will also contain algorithms with linear 
            complexity as an option
        </para></section><section id="string_algo.replace"><title>Replace Algorithms</title><para>
            The implementation of replace algorithms follows the layered structure of the library. The 
            lower layer implements generic substitution of a range in the input sequence. 
            This layer takes a <link linkend="string_algo.finder_concept">Finder</link> object and a 
            <link linkend="string_algo.formatter_concept">Formatter</link> object as an input. These two 
            functors define what to replace and what to replace it with. The upper layer functions 
            are just wrapping calls to the lower layer. Finders are shared with the find and split facility. 
        </para><para>
            As usual, the implementation of the lower layer is designed to work with a generic sequence while
            taking advantage of specific features if possible 
            (by using <link linkend="string_algo.sequence_traits">Sequence traits</link>)
        </para></section><section id="string_algo.split"><title>Find Iterators &amp; Split Algorithms</title><para>
            Find iterators are a logical extension of the <link linkend="string_algo.find">find facility</link>.
            Instead of searching for one match, the whole input can be iteratively searched for multiple matches.
            The result of the search is then used to partition the input. It depends on the algorithms which parts 
            are returned as the result. They can be the matching parts (<link linkend="find_iterator">find_iterator</link>) of the parts in
            between (<link linkend="split_iterator">split_iterator</link>). 
        </para><para>
            In addition the split algorithms like <link linkend="find_all">find_all()</link> and <link linkend="id479732">split()</link>
            can simplify the common operations. They use a find iterator to search the whole input and copy the 
            matches they found into the supplied container.
        </para></section><section id="string_algo.exception"><title>Exception Safety</title><para>
            The library requires that all operations on types used as template
            or function arguments provide the <emphasis>basic exception-safety guarantee</emphasis>. 
            In turn, all functions and algorithms in this library, except where stated
            otherwise, will provide the <emphasis>basic exception-safety guarantee</emphasis>.
            In other words:
            The library maintains its invariants and does not leak resources in
            the face of exceptions.  Some library operations give stronger
            guarantees, which are documented on an individual basis.
        </para><para>
            Some functions can provide the <emphasis>strong exception-safety guarantee</emphasis>.
            That means that following statements are true:    
            <itemizedlist><listitem>
                    If an exception is thrown, there are no effects other than those
                    of the function 
                </listitem><listitem>
                    If an exception is thrown other than by the function, there are no effects
                </listitem></itemizedlist>
            This guarantee can be provided under the condition that the operations 
            on the types used for arguments for these functions either
            provide the strong exception guarantee or do not alter the global state .
         </para><para>
            In the reference, under the term <emphasis>strong exception-safety guarantee</emphasis>, we mean the
            guarantee as defined above.            
        </para><para>
            For more information about the exception safety topics, follow this 
            <ulink url="../../more/generic_exception_safety.html">link</ulink></para></section></section><section id="string_algo.concept" rev:last-revision="$Date: 2004/07/16 09:06:39 $" xml:base="../libs/algorithm/string/doc/concept.xml"><title>Concepts</title><section><title>Definitions</title><table><title>Notation</title><tgroup cols="2" align="left"><tbody><row><entry><computeroutput>F</computeroutput></entry><entry>A type that is a model of Finder</entry></row><row><entry><computeroutput>Fmt</computeroutput></entry><entry>A type that is a model of Formatter</entry></row><row><entry><computeroutput>Iter</computeroutput></entry><entry>
                            Iterator Type
                        </entry></row><row><entry><computeroutput>f</computeroutput></entry><entry>Object of type <computeroutput>F</computeroutput></entry></row><row><entry><computeroutput>fmt</computeroutput></entry><entry>Object of type <computeroutput>Fmt</computeroutput></entry></row><row><entry><computeroutput>i,j</computeroutput></entry><entry>Objects of type <computeroutput>Iter</computeroutput></entry></row></tbody></tgroup></table></section><section id="string_algo.finder_concept"><title>Finder Concept</title><para>
            Finder is a functor which searches for an arbitrary part of a container. 
            The result of the search is given as an <link linkend="iterator_range">iterator_range</link> 
            delimiting the selected part.
        </para><table><title>Valid Expressions</title><tgroup cols="3" align="left"><thead><row><entry>Expression</entry><entry>Return Type</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>f(i,j)</computeroutput></entry><entry>Convertible to <computeroutput>iterator_range&lt;Iter&gt;</computeroutput></entry><entry>Perform the search on the interval [i,j) and returns the result of the search</entry></row></tbody></tgroup></table><para>
            Various algorithms need to perform a search in a container and a Finder is a generalization of such
            search operations that allows algorithms to abstract from searching. For instance, generic replace
            algorithms can replace any part of the input, and the Finder is used to select the desired one.
        </para><para>
            Note, that it is only required that the finder works with a particular iterator type. However,
            a Finder operation can be defined as a template, allowing the Finder to work with any iterator.
        </para><para><emphasis role="bold">Examples</emphasis></para><para><itemizedlist><listitem>
                    Finder implemented as a class. This Finder always returns the whole input as a match. <computeroutput>operator()</computeroutput>
                    is templated, so that the finder can be used on any iterator type.
                    
                    <programlisting>
struct simple_finder
{
    template&lt;typename ForwardIteratorT&gt;
    boost::iterator_range&lt;ForwardIterator&gt; operator()(
        ForwardIteratorT Begin,
        ForwardIteratorT End )
    {
        return boost::make_range( Begin, End );
    }
};
        </programlisting></listitem><listitem>
                    Function Finder. Finder can be any function object. That is, any ordinary function with the
                    required signature can be used as well. However, such a function can be used only for
                    a specific iterator type. 
                    
                    <programlisting>
boost::iterator_range&lt;std::string&gt; simple_finder(
    std::string::const_iterator Begin,
    std::string::const_iterator End )
{
    return boost::make_range( Begin, End );
}
        </programlisting></listitem></itemizedlist></para></section><section id="string_algo.formatter_concept"><title>Formatter concept</title><para>
            Formatters are used by <link linkend="string_algo.replace">replace algorithms</link>.
            They are used in close combination with finders.
            A formatter is a functor, which takes a result from a Finder operation and transforms it in a specific way. 
            The operation of the formatter can use additional information provided by a specific finder,
            for example <link linkend="id308968">regex_formatter()</link> uses the match information from
            <link linkend="id363826">regex_finder()</link> to format the result of formatter operation.
        </para><table><title>Valid Expressions</title><tgroup cols="3" align="left"><thead><row><entry>Expression</entry><entry>Return Type</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>fmt(f(i,j))</computeroutput></entry><entry>A container type, accessible using container traits</entry><entry>Formats the result of the finder operation</entry></row></tbody></tgroup></table><para>
            Similarly to finders, formatters generalize format operations. When a finder is used to 
            select a part of the input, formatter takes this selection and performs some formating
            on it. Algorithms can abstract from formating using a formatter.
        </para><para><emphasis role="bold">Examples</emphasis></para><para><itemizedlist><listitem>
                    Formatter implemented as a class. This Formatter does not perform any formating and 
                    returns the match, repackaged. <computeroutput>operator()</computeroutput>
                    is templated, so that the Formatter can be used on any Finder type.
                    
                    <programlisting>
struct simple_formatter
{
    template&lt;typename FindResultT&gt;
    std::string operator()( const FindResultT&amp; Match )
    {
        std::string Temp( Match.begin(), Match.end() );
        return Temp;
    }
};
                </programlisting></listitem><listitem>
                    Function Formatter. Similarly to Finder, Formatter can be any function object. 
                    However, as a function, it can be used only with a specific Finder type. 
                  
                    <programlisting>
std::string simple_formatter( boost::iterator_range&lt;std::string::const_iterator&gt;&amp; Match )
{
    std::string Temp( Match.begin(), Match.end() );
    return Temp;
}
                    </programlisting></listitem></itemizedlist></para></section></section><section id="string_algo.reference"><title>Reference</title><section id="id350445"><title>Header &lt;<ulink url="../../boost/algorithm/string/case_conv.hpp">boost/algorithm/string/case_conv.hpp</ulink>&gt;</title><para>Defines sequence case-conversion algorithms. Algorithms convert each element in the input sequence to the desired case using provided locales.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="to_lower_copy">to_lower_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="to_lower_copy">to_lower_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> MutableCollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="to_lower">to_lower</link>(MutableCollectionT &amp;, <emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="to_upper_copy">to_upper_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="to_upper_copy">to_upper_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> MutableCollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="to_upper">to_upper</link>(MutableCollectionT &amp;, <emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;}
}</synopsis><refentry id="to_lower_copy"><refmeta><refentrytitle>Function to_lower_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::to_lower_copy</refname><refpurpose>Convert to lower case. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;to_lower_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> to_lower_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Each element of the input sequence is converted to lower case. The result is a copy of the input converted to lower case. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input collection </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for conversion </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="to_lower"><refmeta><refentrytitle>Function template to_lower</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::to_lower</refname><refpurpose>Convert to lower case. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> MutableCollectionT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> to_lower(MutableCollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Each element of the input sequence is converted to lower case. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>A collection </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>a locale used for conversion </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="to_upper_copy"><refmeta><refentrytitle>Function to_upper_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::to_upper_copy</refname><refpurpose>Convert to upper case. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;to_upper_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> to_upper_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Each element of the input sequence is converted to upper case. The result is a copy of the input converted to upper case. It is returned as a sequence or copied to the output iterator</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input collection </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for conversion </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="to_upper"><refmeta><refentrytitle>Function template to_upper</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::to_upper</refname><refpurpose>Convert to upper case. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> MutableCollectionT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> to_upper(MutableCollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Each element of the input sequence is converted to upper case. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input collection </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>a locale used for conversion </para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id388523"><title>Header &lt;<ulink url="../../boost/algorithm/string/classification.hpp">boost/algorithm/string/classification.hpp</ulink>&gt;</title><para>Classification predicates are included in the library to give some more convenience when using algorithms like <computeroutput>trim()</computeroutput>  and <computeroutput>all()</computeroutput> . They wrap functionality of STL classification functions ( e.g. <computeroutput>std::isspace()</computeroutput>  ) into generic functors.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="is_classified">is_classified</link>(std::ctype_base::mask, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="is_space">is_space</link>(<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="is_alnum">is_alnum</link>(<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="is_alpha">is_alpha</link>(<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="is_cntrl">is_cntrl</link>(<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="is_digit">is_digit</link>(<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="is_graph">is_graph</link>(<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="is_lower">is_lower</link>(<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="is_print">is_print</link>(<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="is_punct">is_punct</link>(<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="is_upper">is_upper</link>(<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="is_xdigit">is_xdigit</link>(<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT&gt; <type><emphasis>unspecified</emphasis></type> <link linkend="is_any_of">is_any_of</link>(<emphasis role="bold">const</emphasis> ContainerT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT&gt; <type><emphasis>unspecified</emphasis></type> <link linkend="is_from_range">is_from_range</link>(CharT, CharT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Pred1T, <emphasis role="bold">typename</emphasis> Pred2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="id504418"><emphasis role="bold">operator</emphasis>&amp;&amp;</link>(<emphasis role="bold">const</emphasis> predicate_facade&lt; Pred1T &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> predicate_facade&lt; Pred2T &gt; &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Pred1T, <emphasis role="bold">typename</emphasis> Pred2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="id354683"><emphasis role="bold">operator</emphasis>||</link>(<emphasis role="bold">const</emphasis> predicate_facade&lt; Pred1T &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> predicate_facade&lt; Pred2T &gt; &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> PredT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="id273455"><emphasis role="bold">operator</emphasis>!</link>(<emphasis role="bold">const</emphasis> predicate_facade&lt; PredT &gt; &amp;);
&#xA0;&#xA0;}
}</synopsis><refentry id="is_classified"><refmeta><refentrytitle>Function is_classified</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_classified</refname><refpurpose>is_classified predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> is_classified(std::ctype_base::mask Type, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_classified</computeroutput>  predicate. This predicate holds if the input is of specified <computeroutput>std::ctype</computeroutput>  category.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Loc</term><listitem><para>A locale used for classification </para></listitem></varlistentry><varlistentry><term>Type</term><listitem><para>A <computeroutput>std::ctype</computeroutput>  category </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>is_classified</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="is_space"><refmeta><refentrytitle>Function is_space</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_space</refname><refpurpose>is_space predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> is_space(<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_classified</computeroutput>  predicate for the <computeroutput>ctype_base::space</computeroutput>  category.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Loc</term><listitem><para>A locale used for classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>is_classified</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="is_alnum"><refmeta><refentrytitle>Function is_alnum</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_alnum</refname><refpurpose>is_alnum predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> is_alnum(<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_classified</computeroutput>  predicate for the <computeroutput>ctype_base::alnum</computeroutput>  category.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Loc</term><listitem><para>A locale used for classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>is_classified</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="is_alpha"><refmeta><refentrytitle>Function is_alpha</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_alpha</refname><refpurpose>is_alpha predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> is_alpha(<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_classified</computeroutput>  predicate for the <computeroutput>ctype_base::alpha</computeroutput>  category.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Loc</term><listitem><para>A locale used for classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>is_classified</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="is_cntrl"><refmeta><refentrytitle>Function is_cntrl</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_cntrl</refname><refpurpose>is_cntrl predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> is_cntrl(<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_classified</computeroutput>  predicate for the <computeroutput>ctype_base::cntrl</computeroutput>  category.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Loc</term><listitem><para>A locale used for classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>is_classified</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="is_digit"><refmeta><refentrytitle>Function is_digit</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_digit</refname><refpurpose>is_digit predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> is_digit(<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_classified</computeroutput>  predicate for the <computeroutput>ctype_base::digit</computeroutput>  category.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Loc</term><listitem><para>A locale used for classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>is_classified</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="is_graph"><refmeta><refentrytitle>Function is_graph</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_graph</refname><refpurpose>is_graph predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> is_graph(<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_classified</computeroutput>  predicate for the <computeroutput>ctype_base::graph</computeroutput>  category.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Loc</term><listitem><para>A locale used for classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>is_classified</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="is_lower"><refmeta><refentrytitle>Function is_lower</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_lower</refname><refpurpose>is_lower predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> is_lower(<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_classified</computeroutput>  predicate for the <computeroutput>ctype_base::lower</computeroutput>  category.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Loc</term><listitem><para>A locale used for classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of <computeroutput>is_classified</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="is_print"><refmeta><refentrytitle>Function is_print</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_print</refname><refpurpose>is_print predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> is_print(<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_classified</computeroutput>  predicate for the <computeroutput>ctype_base::print</computeroutput>  category.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Loc</term><listitem><para>A locale used for classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>is_classified</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="is_punct"><refmeta><refentrytitle>Function is_punct</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_punct</refname><refpurpose>is_punct predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> is_punct(<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_classified</computeroutput>  predicate for the <computeroutput>ctype_base::punct</computeroutput>  category.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Loc</term><listitem><para>A locale used for classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>is_classified</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="is_upper"><refmeta><refentrytitle>Function is_upper</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_upper</refname><refpurpose>is_upper predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> is_upper(<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_classified</computeroutput>  predicate for the <computeroutput>ctype_base::upper</computeroutput>  category.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Loc</term><listitem><para>A locale used for classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>is_classified</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="is_xdigit"><refmeta><refentrytitle>Function is_xdigit</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_xdigit</refname><refpurpose>is_xdigit predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> is_xdigit(<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_classified</computeroutput>  predicate for the <computeroutput>ctype_base::xdigit</computeroutput>  category.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Loc</term><listitem><para>A locale used for classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>is_classified</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="is_any_of"><refmeta><refentrytitle>Function template is_any_of</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_any_of</refname><refpurpose>is_any_of predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT&gt; <type><emphasis>unspecified</emphasis></type> is_any_of(<emphasis role="bold">const</emphasis> ContainerT &amp; Set);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_any_of</computeroutput>  predicate. The predicate holds if the input is included in the specified set of characters.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Set</term><listitem><para>A set of characters to be recognized </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>is_any_of</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="is_from_range"><refmeta><refentrytitle>Function template is_from_range</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_from_range</refname><refpurpose>is_from_range predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT&gt; <type><emphasis>unspecified</emphasis></type> is_from_range(CharT From, CharT To);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>is_from_range</computeroutput>  predicate. The predicate holds if the input is included in the specified range. (i.e. From &lt;= Ch &lt;= To )</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>From</term><listitem><para>The start of the range </para></listitem></varlistentry><varlistentry><term>To</term><listitem><para>The end of the range </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>is_from_range</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id504418"><refmeta><refentrytitle>Function template operator&amp;&amp;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::operator&amp;&amp;</refname><refpurpose>predicate 'and' composition predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Pred1T, <emphasis role="bold">typename</emphasis> Pred2T&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <emphasis role="bold">operator</emphasis>&amp;&amp;(<emphasis role="bold">const</emphasis> predicate_facade&lt; Pred1T &gt; &amp; Pred1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> predicate_facade&lt; Pred2T &gt; &amp; Pred2);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>class_and</computeroutput>  predicate. This predicate can be used to logically combine two classification predicates. <computeroutput>class_and</computeroutput>  holds, if both predicates return true.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Pred1</term><listitem><para>The first predicate </para></listitem></varlistentry><varlistentry><term>Pred2</term><listitem><para>The second predicate </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>class_and</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id354683"><refmeta><refentrytitle>Function template operator||</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::operator||</refname><refpurpose>predicate 'or' composition predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Pred1T, <emphasis role="bold">typename</emphasis> Pred2T&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <emphasis role="bold">operator</emphasis>||(<emphasis role="bold">const</emphasis> predicate_facade&lt; Pred1T &gt; &amp; Pred1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> predicate_facade&lt; Pred2T &gt; &amp; Pred2);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>class_or</computeroutput>  predicate. This predicate can be used to logically combine two classification predicates. <computeroutput>class_or</computeroutput>  holds, if one of the predicates return true.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Pred1</term><listitem><para>The first predicate </para></listitem></varlistentry><varlistentry><term>Pred2</term><listitem><para>The second predicate </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>class_or</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id273455"><refmeta><refentrytitle>Function template operator!</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::operator!</refname><refpurpose>predicate negation operator </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> PredT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <emphasis role="bold">operator</emphasis>!(<emphasis role="bold">const</emphasis> predicate_facade&lt; PredT &gt; &amp; Pred);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>class_not</computeroutput>  predicate. This predicate represents a negation. <computeroutput>class_or</computeroutput>  holds if of the predicates return false.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Pred</term><listitem><para>The predicate to be negated </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>class_not</computeroutput>  predicate </para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id407166"><title>Header &lt;<ulink url="../../boost/algorithm/string/collection_traits.hpp">boost/algorithm/string/collection_traits.hpp</ulink>&gt;</title><para>Defines collection_traits class and related free-standing functions. This facility is used to unify the access to different types of collections. It allows the algorithms in the library to work with STL collections, c-style array, null-terminated c-strings (and more) using the same interface.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <emphasis role="bold">struct</emphasis> <link linkend="collection_traits">collection_traits</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <emphasis role="bold">struct</emphasis> <link linkend="value_type_of">value_type_of</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <emphasis role="bold">struct</emphasis> <link linkend="difference_type_of">difference_type_of</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <emphasis role="bold">struct</emphasis> <link linkend="iterator_of">iterator_of</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <emphasis role="bold">struct</emphasis> <link linkend="const_iterator_of">const_iterator_of</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <emphasis role="bold">struct</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <type><link linkend="collection_traits">collection_traits</link>&lt; C &gt;::size_type</type> <link linkend="size">size</link>(<emphasis role="bold">const</emphasis> C &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <type><emphasis role="bold">bool</emphasis></type> <link linkend="empty">empty</link>(<emphasis role="bold">const</emphasis> C &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <type><link linkend="collection_traits">collection_traits</link>&lt; C &gt;::iterator</type> <link linkend="begin">begin</link>(C &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="collection_traits">collection_traits</link>&lt; C &gt;::const_iterator</type> <link linkend="begin">begin</link>(<emphasis role="bold">const</emphasis> C &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <type><link linkend="collection_traits">collection_traits</link>&lt; C &gt;::iterator</type> <link linkend="end">end</link>(C &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <type><link linkend="collection_traits">collection_traits</link>&lt; C &gt;::const_iterator</type> <link linkend="end">end</link>(<emphasis role="bold">const</emphasis> C &amp;);
&#xA0;&#xA0;}
}</synopsis><refentry id="collection_traits"><refmeta><refentrytitle>Struct template collection_traits</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::collection_traits</refname><refpurpose>collection_traits class </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; 
<emphasis role="bold">struct</emphasis> collection_traits {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> container_helper_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; function_type;&#xA0;&#xA0;  <emphasis>// Function type. </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> container_helper_type::value_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; value_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// Value type. </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> container_helper_type::size_type&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; size_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// Size type. </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> container_helper_type::iterator&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; iterator;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// Iterator type. </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> container_helper_type::const_iterator&#xA0; const_iterator;&#xA0;  <emphasis>// Const iterator type. </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> container_helper_type::result_iterator result_iterator;  <emphasis>// Result iterator type ( iterator of const_iterator, depending on the constness of the container ). </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> container_helper_type::difference_type difference_type;  <emphasis>// Difference type. </emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Collection traits provide uniform access to different types of collections. This functionality allows to write generic algorithms which work with several different kinds of collections.</para><para>Currently following collection types are supported:<itemizedlist><listitem><para>containers with STL compatible container interface ( see ContainerConcept ) ( i.e. <computeroutput>std::vector&lt;&gt;</computeroutput> , <computeroutput>std::list&lt;&gt;</computeroutput> , <computeroutput>std::string&lt;&gt;</computeroutput>  ... )</para></listitem><listitem><para>c-style array ( <computeroutput>char</computeroutput> [10], <computeroutput>int</computeroutput> [15] ... )</para></listitem><listitem><para>null-terminated c-strings ( <computeroutput>char*</computeroutput> , <computeroutput>wchar_T*</computeroutput>  )</para></listitem><listitem><para>std::pair of iterators ( i.e <computeroutput>std::pair&lt;vector&lt;int&gt;::iterator</computeroutput> ,vector&lt;int&gt;::iterator&gt; )</para></listitem></itemizedlist></para><para>Collection traits provide an external collection interface operations. All are accessible using free-standing functions.</para><para>The following operations are supported:<itemizedlist><listitem><para><computeroutput>size()</computeroutput></para></listitem><listitem><para><computeroutput>empty()</computeroutput></para></listitem><listitem><para><computeroutput>begin()</computeroutput></para></listitem><listitem><para><computeroutput>end()</computeroutput></para></listitem></itemizedlist></para><para>Container traits have somewhat limited functionality on compilers not supporting partial template specialization and partial template ordering. </para></refsect1></refentry><refentry id="value_type_of"><refmeta><refentrytitle>Struct template value_type_of</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::value_type_of</refname><refpurpose>Container value_type trait. </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; 
<emphasis role="bold">struct</emphasis> value_type_of {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="collection_traits">collection_traits</link>&lt; C &gt;::value_type type;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Extract the type of elements contained in a container </para></refsect1></refentry><refentry id="difference_type_of"><refmeta><refentrytitle>Struct template difference_type_of</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::difference_type_of</refname><refpurpose>Container difference trait. </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; 
<emphasis role="bold">struct</emphasis> difference_type_of {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="collection_traits">collection_traits</link>&lt; C &gt;::difference_type type;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Extract the container's difference type </para></refsect1></refentry><refentry id="iterator_of"><refmeta><refentrytitle>Struct template iterator_of</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::iterator_of</refname><refpurpose>Container iterator trait. </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; 
<emphasis role="bold">struct</emphasis> iterator_of {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="collection_traits">collection_traits</link>&lt; C &gt;::iterator type;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Extract the container's iterator type </para></refsect1></refentry><refentry id="const_iterator_of"><refmeta><refentrytitle>Struct template const_iterator_of</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::const_iterator_of</refname><refpurpose>Container const_iterator trait. </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; 
<emphasis role="bold">struct</emphasis> const_iterator_of {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="collection_traits">collection_traits</link>&lt; C &gt;::const_iterator type;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Extract the container's const_iterator type </para></refsect1></refentry><refentry id="result_iterator_of"><refmeta><refentrytitle>Struct template result_iterator_of</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::result_iterator_of</refname><refpurpose>Container result_iterator. </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; 
<emphasis role="bold">struct</emphasis> result_iterator_of {
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="collection_traits">collection_traits</link>&lt; C &gt;::result_iterator type;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Extract the container's result_iterator type. This type maps to <computeroutput>C::iterator</computeroutput>  for mutable container and <computeroutput>C::const_iterator</computeroutput>  for const containers. </para></refsect1></refentry><refentry id="size"><refmeta><refentrytitle>Function template size</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::size</refname><refpurpose>Free-standing size() function. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <type><link linkend="collection_traits">collection_traits</link>&lt; C &gt;::size_type</type> size(<emphasis role="bold">const</emphasis> C &amp; c);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Get the size of the container. Uses collection_traits. </para></refsect1></refentry><refentry id="empty"><refmeta><refentrytitle>Function template empty</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::empty</refname><refpurpose>Free-standing empty() function. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <type><emphasis role="bold">bool</emphasis></type> empty(<emphasis role="bold">const</emphasis> C &amp; c);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Check whether the container is empty. Uses container traits. </para></refsect1></refentry><refentry id="begin"><refmeta><refentrytitle>Function begin</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::begin</refname><refpurpose>Free-standing begin() function. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <type><link linkend="collection_traits">collection_traits</link>&lt; C &gt;::iterator</type> begin(C &amp; c);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <type><link linkend="collection_traits">collection_traits</link>&lt; C &gt;::const_iterator</type> begin(<emphasis role="bold">const</emphasis> C &amp; c);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Get the begin iterator of the container. Uses collection_traits. </para></refsect1></refentry><refentry id="end"><refmeta><refentrytitle>Function end</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::end</refname><refpurpose>Free-standing end() function. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <type><link linkend="collection_traits">collection_traits</link>&lt; C &gt;::iterator</type> end(C &amp; c);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> C&gt; <type><link linkend="collection_traits">collection_traits</link>&lt; C &gt;::const_iterator</type> end(<emphasis role="bold">const</emphasis> C &amp; c);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Get the begin iterator of the container. Uses collection_traits. </para></refsect1></refentry></section><section id="id266856"><title>Header &lt;<ulink url="../../boost/algorithm/string/compare.hpp">boost/algorithm/string/compare.hpp</ulink>&gt;</title><para>Defines element comparison predicates. Many algorithms in this library can take an additional argument with a predicate used to compare elements. This makes it possible, for instance, to have case insensitive versions of the algorithms.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="is_equal">is_equal</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="is_iequal">is_iequal</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="is_equal"><refmeta><refentrytitle>Struct is_equal</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_equal</refname><refpurpose>is_equal functor </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> is_equal {

&#xA0;&#xA0;<emphasis>// <link linkend="id222448-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id222452-bb"><emphasis role="bold">operator</emphasis>()</link>(<emphasis role="bold">const</emphasis> T1 &amp;, <emphasis role="bold">const</emphasis> T2 &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Standard STL equal_to only handle comparison between arguments of the same type. This is a less restrictive version which wraps operator ==. </para><refsect2><title><anchor id="id222448-bb"/><computeroutput>is_equal</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id222452-bb"/><emphasis role="bold">operator</emphasis>()(<emphasis role="bold">const</emphasis> T1 &amp; Arg1, <emphasis role="bold">const</emphasis> T2 &amp; Arg2) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Compare two operands for equality </para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="is_iequal"><refmeta><refentrytitle>Struct is_iequal</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::is_iequal</refname><refpurpose>case insensitive version of is_equal </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> is_iequal {
&#xA0;&#xA0;<emphasis>// <link linkend="is_iequalconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id492201-bb">is_iequal</link>(<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());

&#xA0;&#xA0;<emphasis>// <link linkend="id304317-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id319828-bb"><emphasis role="bold">operator</emphasis>()</link>(<emphasis role="bold">const</emphasis> T1 &amp;, <emphasis role="bold">const</emphasis> T2 &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Case insensitive comparison predicate. Comparison is done using specified locales. </para><refsect2><title><anchor id="is_iequalconstruct-copy-destruct"/><computeroutput>is_iequal</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id492201-bb"/>is_iequal(<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</literallayout></para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Loc</term><listitem><para>locales used for comparison </para></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id304317-bb"/><computeroutput>is_iequal</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id319828-bb"/><emphasis role="bold">operator</emphasis>()(<emphasis role="bold">const</emphasis> T1 &amp; Arg1, <emphasis role="bold">const</emphasis> T2 &amp; Arg2) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Compare two operands. Case is ignored. </para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id336627"><title>Header &lt;<ulink url="../../boost/algorithm/string/concept.hpp">boost/algorithm/string/concept.hpp</ulink>&gt;</title><para>Defines concepts used in string_algo library</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> IteratorT&gt; <emphasis role="bold">struct</emphasis> <link linkend="FinderConcept">FinderConcept</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> FormatterT, <emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> IteratorT&gt; 
  &#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="FormatterConcept">FormatterConcept</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="FinderConcept"><refmeta><refentrytitle>Struct template FinderConcept</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::FinderConcept</refname><refpurpose>Finder concept. </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> IteratorT&gt; 
<emphasis role="bold">struct</emphasis> FinderConcept {

&#xA0;&#xA0;<emphasis>// <link linkend="id432848-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id505368-bb">constraints</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Defines the Finder concept. Finder is a functor which selects an arbitrary part of a string. Search is performed on the range specified by starting and ending iterators.</para><para>Result of the find operation must be convertible to iterator_range. </para><refsect2><title><anchor id="id432848-bb"/><computeroutput>FinderConcept</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id505368-bb"/>constraints() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="FormatterConcept"><refmeta><refentrytitle>Struct template FormatterConcept</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::FormatterConcept</refname><refpurpose>Formatter concept. </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> FormatterT, <emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> IteratorT&gt; 
<emphasis role="bold">struct</emphasis> FormatterConcept {

&#xA0;&#xA0;<emphasis>// <link linkend="id459750-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id369690-bb">constraints</link>() ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Defines the Formatter concept. Formatter is a functor, which takes a result from a finder operation and transforms it in a specific way.</para><para>Result must be a container supported by container_traits, or a reference to it. </para><refsect2><title><anchor id="id459750-bb"/><computeroutput>FormatterConcept</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id369690-bb"/>constraints() ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id228929"><title>Header &lt;<ulink url="../../boost/algorithm/string/constants.hpp">boost/algorithm/string/constants.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <link linkend="id502269">token_compress_mode_type</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="id502269"><refmeta><refentrytitle>Type token_compress_mode_type</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::token_compress_mode_type</refname><refpurpose>Token compression mode. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">enum</emphasis> token_compress_mode_type { token_compress_on, token_compress_off };</synopsis></refsynopsisdiv></refentry></section><section id="id236631"><title>Header &lt;<ulink url="../../boost/algorithm/string/erase.hpp">boost/algorithm/string/erase.hpp</ulink>&gt;</title><para>Defines various erase algorithms. Each algorithm removes part(s) of the input according to a searching criteria.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="erase_range_copy">erase_range_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="const_iterator_of">const_iterator_of</link>&lt; CollectionT &gt;::type &gt; &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="erase_range_copy">erase_range_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="const_iterator_of">const_iterator_of</link>&lt; SequenceT &gt;::type &gt; &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="erase_range">erase_range</link>(SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="iterator_of">iterator_of</link>&lt; SequenceT &gt;::type &gt; &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="erase_first_copy">erase_first_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="erase_first_copy">erase_first_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="erase_first">erase_first</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="ierase_first_copy">ierase_first_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="ierase_first_copy">ierase_first_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="ierase_first">ierase_first</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="erase_last_copy">erase_last_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="erase_last_copy">erase_last_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="erase_last">erase_last</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="ierase_last_copy">ierase_last_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="ierase_last_copy">ierase_last_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="ierase_last">ierase_last</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="erase_nth_copy">erase_nth_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="erase_nth_copy">erase_nth_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="erase_nth">erase_nth</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="ierase_nth_copy">ierase_nth_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="ierase_nth_copy">ierase_nth_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="ierase_nth">ierase_nth</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="erase_all_copy">erase_all_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="erase_all_copy">erase_all_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="erase_all">erase_all</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="ierase_all_copy">ierase_all_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="ierase_all_copy">ierase_all_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="ierase_all">ierase_all</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="erase_head_copy">erase_head_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="erase_head_copy">erase_head_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; <type><emphasis role="bold">void</emphasis></type> <link linkend="erase_head">erase_head</link>(SequenceT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="erase_tail_copy">erase_tail_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="erase_tail_copy">erase_tail_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; <type><emphasis role="bold">void</emphasis></type> <link linkend="erase_tail">erase_tail</link>(SequenceT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;}
}</synopsis><refentry id="erase_range_copy"><refmeta><refentrytitle>Function erase_range_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_range_copy</refname><refpurpose>Erase range algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;erase_range_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="const_iterator_of">const_iterator_of</link>&lt; CollectionT &gt;::type &gt; &amp; SearchRange);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> erase_range_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="const_iterator_of">const_iterator_of</link>&lt; SequenceT &gt;::type &gt; &amp; SearchRange);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the given range from the input. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>SearchRange</term><listitem><para>A range in the input to be removed </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_range"><refmeta><refentrytitle>Function template erase_range</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_range</refname><refpurpose>Erase range algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> erase_range(SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="iterator_of">iterator_of</link>&lt; SequenceT &gt;::type &gt; &amp; SearchRange);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the given range from the input. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>SearchRange</term><listitem><para>A range in the input to be removed </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_first_copy"><refmeta><refentrytitle>Function erase_first_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_first_copy</refname><refpurpose>Erase first algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;erase_first_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> erase_first_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Search);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the first occurence of the substring from the input. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_first"><refmeta><refentrytitle>Function template erase_first</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_first</refname><refpurpose>Erase first algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> erase_first(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> CollectionT &amp; Search);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the first occurence of the substring from the input. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ierase_first_copy"><refmeta><refentrytitle>Function ierase_first_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ierase_first_copy</refname><refpurpose>Erase first algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;ierase_first_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> ierase_first_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the first occurence of the substring from the input. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ierase_first"><refmeta><refentrytitle>Function template ierase_first</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ierase_first</refname><refpurpose>Erase first algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> ierase_first(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> CollectionT &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the first occurence of the substring from the input. The input sequence is modified in-place. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_last_copy"><refmeta><refentrytitle>Function erase_last_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_last_copy</refname><refpurpose>Erase last algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;erase_last_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> erase_last_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Search);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the last occurence of the substring from the input. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_last"><refmeta><refentrytitle>Function template erase_last</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_last</refname><refpurpose>Erase last algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> erase_last(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> CollectionT &amp; Search);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the last occurence of the substring from the input. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ierase_last_copy"><refmeta><refentrytitle>Function ierase_last_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ierase_last_copy</refname><refpurpose>Erase last algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;ierase_last_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> ierase_last_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the last occurence of the substring from the input. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ierase_last"><refmeta><refentrytitle>Function template ierase_last</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ierase_last</refname><refpurpose>Erase last algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> ierase_last(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> CollectionT &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the last occurence of the substring from the input. The input sequence is modified in-place. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_nth_copy"><refmeta><refentrytitle>Function erase_nth_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_nth_copy</refname><refpurpose>Erase nth algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;erase_nth_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> erase_nth_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Search, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the Nth occurence of the substring in the input. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Nth</term><listitem><para>An index of the match to be replaced. The index is 0-based. </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_nth"><refmeta><refentrytitle>Function template erase_nth</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_nth</refname><refpurpose>Erase nth algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> erase_nth(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> CollectionT &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the Nth occurence of the substring in the input. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Nth</term><listitem><para>An index of the match to be replaced. The index is 0-based. </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ierase_nth_copy"><refmeta><refentrytitle>Function ierase_nth_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ierase_nth_copy</refname><refpurpose>Erase nth algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;ierase_nth_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> ierase_nth_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Search, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the Nth occurence of the substring in the input. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Nth</term><listitem><para>An index of the match to be replaced. The index is 0-based. </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ierase_nth"><refmeta><refentrytitle>Function template ierase_nth</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ierase_nth</refname><refpurpose>Erase nth algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> ierase_nth(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> CollectionT &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth, <emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the Nth occurence of the substring in the input. The input sequence is modified in-place. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Nth</term><listitem><para>An index of the match to be replaced. The index is 0-based. </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_all_copy"><refmeta><refentrytitle>Function erase_all_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_all_copy</refname><refpurpose>Erase all algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;erase_all_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> erase_all_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Search);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all the occurrences of the string from the input. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_all"><refmeta><refentrytitle>Function template erase_all</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_all</refname><refpurpose>Erase all algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> erase_all(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> CollectionT &amp; Search);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all the occurrences of the string from the input. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ierase_all_copy"><refmeta><refentrytitle>Function ierase_all_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ierase_all_copy</refname><refpurpose>Erase all algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;ierase_all_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> ierase_all_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all the occurrences of the string from the input. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ierase_all"><refmeta><refentrytitle>Function template ierase_all</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ierase_all</refname><refpurpose>Erase all algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> ierase_all(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> CollectionT &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all the occurrences of the string from the input. The input sequence is modified in-place. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_head_copy"><refmeta><refentrytitle>Function erase_head_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_head_copy</refname><refpurpose>Erase head algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;erase_head_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> erase_head_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the head from the input. The head is a prefix of a seqence of given size. If the sequence is shorter then required, the whole string is considered to be the head. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>N</term><listitem><para>Length of the head </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_head"><refmeta><refentrytitle>Function template erase_head</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_head</refname><refpurpose>Erase head algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> erase_head(SequenceT &amp; Input, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the head from the input. The head is a prefix of a seqence of given size. If the sequence is shorter then required, the whole string is considered to be the head. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>N</term><listitem><para>Length of the head </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_tail_copy"><refmeta><refentrytitle>Function erase_tail_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_tail_copy</refname><refpurpose>Erase tail algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;erase_tail_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> erase_tail_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the tail from the input. The tail is a suffix of a seqence of given size. If the sequence is shorter then required, the whole string is considered to be the tail. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>N</term><listitem><para>Length of the head </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_tail"><refmeta><refentrytitle>Function template erase_tail</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_tail</refname><refpurpose>Erase tail algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> erase_tail(SequenceT &amp; Input, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove the tail from the input. The tail is a suffix of a seqence of given size. If the sequence is shorter then required, the whole string is considered to be the tail. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>N</term><listitem><para>Length of the head </para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id448104"><title>Header &lt;<ulink url="../../boost/algorithm/string/find.hpp">boost/algorithm/string/find.hpp</ulink>&gt;</title><para>Defines a set of find algorithms. The algorithms are searching for a substring of the input. The result is given as an <computeroutput>iterator_range</computeroutput>  delimiting the substring.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> FinderT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="find">find</link>(CollectionT &amp;, FinderT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; Collection1T &gt;::type &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="find_first">find_first</link>(Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; Collection1T &gt;::type &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="ifind_first">ifind_first</link>(Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; Collection1T &gt;::type &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="find_last">find_last</link>(Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; Collection1T &gt;::type &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="ifind_last">ifind_last</link>(Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; Collection1T &gt;::type &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="find_nth">find_nth</link>(Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; Collection1T &gt;::type &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="ifind_nth">ifind_nth</link>(Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="find_head">find_head</link>(CollectionT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="find_tail">find_tail</link>(CollectionT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="find_token">find_token</link>(CollectionT &amp;, PredicateT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;token_compress_mode_type = token_compress_off);
&#xA0;&#xA0;}
}</synopsis><refentry id="find"><refmeta><refentrytitle>Function template find</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find</refname><refpurpose>Generic find algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> FinderT&gt; 
&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;find(CollectionT &amp; Input, FinderT Finder);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Search the input using the given finder.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Finder</term><listitem><para>Finder object used for searching. </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>A string which will be searched. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An <computeroutput>iterator_range</computeroutput>  delimiting the match. Returned iterator is either <computeroutput>CollectionT::iterator</computeroutput>  or <computeroutput>CollectionT::const_iterator</computeroutput> , depending on the constness of the input parameter. </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="find_first"><refmeta><refentrytitle>Function template find_first</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_first</refname><refpurpose>Find first algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; Collection1T &gt;::type &gt;</type> 
&#xA0;&#xA0;find_first(Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Search);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Search for the first occurence of the substring in the input.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>A string which will be searched. </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An <computeroutput>iterator_range</computeroutput>  delimiting the match. Returned iterator is either <computeroutput>CollectionT::iterator</computeroutput>  or <computeroutput>CollectionT::const_iterator</computeroutput> , depending on the constness of the input parameter.</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ifind_first"><refmeta><refentrytitle>Function template ifind_first</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ifind_first</refname><refpurpose>Find first algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; Collection1T &gt;::type &gt;</type> 
&#xA0;&#xA0;ifind_first(Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Search for the first occurence of the substring in the input. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>A string which will be searched. </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An <computeroutput>iterator_range</computeroutput>  delimiting the match. Returned iterator is either <computeroutput>Collection1T::iterator</computeroutput>  or <computeroutput>Collection1T::const_iterator</computeroutput> , depending on the constness of the input parameter.</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="find_last"><refmeta><refentrytitle>Function template find_last</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_last</refname><refpurpose>Find last algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; Collection1T &gt;::type &gt;</type> 
&#xA0;&#xA0;find_last(Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Search);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Search for the last occurence of the substring in the input.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>A string which will be searched. </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An <computeroutput>iterator_range</computeroutput>  delimiting the match. Returned iterator is either <computeroutput>Collection1T::iterator</computeroutput>  or <computeroutput>Collection1T::const_iterator</computeroutput> , depending on the constness of the input parameter.</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ifind_last"><refmeta><refentrytitle>Function template ifind_last</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ifind_last</refname><refpurpose>Find last algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; Collection1T &gt;::type &gt;</type> 
&#xA0;&#xA0;ifind_last(Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Search for the last match a string in the input. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>A string which will be searched. </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An <computeroutput>iterator_range</computeroutput>  delimiting the match. Returned iterator is either <computeroutput>Collection1T::iterator</computeroutput>  or <computeroutput>Collection1T::const_iterator</computeroutput> , depending on the constness of the input parameter.</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="find_nth"><refmeta><refentrytitle>Function template find_nth</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_nth</refname><refpurpose>Find n-th algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; Collection1T &gt;::type &gt;</type> 
&#xA0;&#xA0;find_nth(Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Search for the n-th (zero-indexed) occurence of the substring in the input.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>A string which will be searched. </para></listitem></varlistentry><varlistentry><term>Nth</term><listitem><para>An index (zero-indexed) of the match to be found. </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An <computeroutput>iterator_range</computeroutput>  delimiting the match. Returned iterator is either <computeroutput>Collection1T::iterator</computeroutput>  or <computeroutput>Collection1T::const_iterator</computeroutput> , depending on the constness of the input parameter. </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ifind_nth"><refmeta><refentrytitle>Function template ifind_nth</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ifind_nth</refname><refpurpose>Find n-th algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; Collection1T &gt;::type &gt;</type> 
&#xA0;&#xA0;ifind_nth(Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth, <emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Search for the n-th (zero-indexed) occurence of the substring in the input. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>A string which will be searched. </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Nth</term><listitem><para>An index (zero-indexed) of the match to be found. </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An <computeroutput>iterator_range</computeroutput>  delimiting the match. Returned iterator is either <computeroutput>Collection1T::iterator</computeroutput>  or <computeroutput>Collection1T::const_iterator</computeroutput> , depending on the constness of the input parameter.</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="find_head"><refmeta><refentrytitle>Function template find_head</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_head</refname><refpurpose>Find head algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;find_head(CollectionT &amp; Input, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Get the head of the input. Head is a prefix of the string of the given size. If the input is shorter then required, whole input if considered to be the head.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>N</term><listitem><para>Length of the head </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An <computeroutput>iterator_range</computeroutput>  delimiting the match. Returned iterator is either <computeroutput>Collection1T::iterator</computeroutput>  or <computeroutput>Collection1T::const_iterator</computeroutput> , depending on the constness of the input parameter.</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="find_tail"><refmeta><refentrytitle>Function template find_tail</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_tail</refname><refpurpose>Find tail algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;find_tail(CollectionT &amp; Input, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Get the head of the input. Head is a suffix of the string of the given size. If the input is shorter then required, whole input if considered to be the tail.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>N</term><listitem><para>Length of the tail </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An <computeroutput>iterator_range</computeroutput>  delimiting the match. Returned iterator is either <computeroutput>CollectionT::iterator</computeroutput>  or <computeroutput>CollectionT::const_iterator</computeroutput> , depending on the constness of the input parameter.</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="find_token"><refmeta><refentrytitle>Function template find_token</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_token</refname><refpurpose>Find token algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;find_token(CollectionT &amp; Input, PredicateT Pred, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;token_compress_mode_type eCompress = token_compress_off);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Look for a given token in the string. Token is a character that matches the given predicate. If the "token compress mode" is enabled, adjacent tokens are considered to be one match.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>A input string. </para></listitem></varlistentry><varlistentry><term>Pred</term><listitem><para>An unary predicate to identify a token </para></listitem></varlistentry><varlistentry><term>eCompress</term><listitem><para>Enable/Disable compressing of adjacent tokens </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An <computeroutput>iterator_range</computeroutput>  delimiting the match. Returned iterator is either <computeroutput>CollectionT::iterator</computeroutput>  or <computeroutput>CollectionT::const_iterator</computeroutput> , depending on the constness of the input parameter.</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id333397"><title>Header &lt;<ulink url="../../boost/algorithm/string/find_format.hpp">boost/algorithm/string/find_format.hpp</ulink>&gt;</title><para>Defines generic replace algorithms. Each algorithm replaces part(s) of the input. The part to be replaced is looked up using a Finder object. Result of finding is then used by a Formatter object to generate the replacement.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> FinderT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatterT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="find_format_copy">find_format_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, FinderT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;FormatterT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> FormatterT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="find_format_copy">find_format_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, FinderT, FormatterT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> FormatterT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="find_format">find_format</link>(SequenceT &amp;, FinderT, FormatterT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> FinderT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatterT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="find_format_all_copy">find_format_all_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, FinderT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;FormatterT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> FormatterT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="find_format_all_copy">find_format_all_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, FinderT, FormatterT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> FormatterT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="find_format_all">find_format_all</link>(SequenceT &amp;, FinderT, FormatterT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="id363826">regex_finder</link>(<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> TraitsT, <emphasis role="bold">typename</emphasis> AllocT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="id308968">regex_formatter</link>(<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, TraitsT, AllocT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = format_default);
&#xA0;&#xA0;}
}</synopsis><refentry id="find_format_copy"><refmeta><refentrytitle>Function find_format_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_format_copy</refname><refpurpose>Generic replace algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> FinderT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatterT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;find_format_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;FinderT Finder, FormatterT Formatter);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> FormatterT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> find_format_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, FinderT Finder, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;FormatterT Formatter);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Use the Finder to search for a substring. Use the Formatter to format this substring and replace it in the input. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Finder</term><listitem><para>A Finder object used to search for a match to be replaced </para></listitem></varlistentry><varlistentry><term>Formatter</term><listitem><para>A Formatter object used to format a match </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="find_format"><refmeta><refentrytitle>Function template find_format</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_format</refname><refpurpose>Generic replace algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> FormatterT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> find_format(SequenceT &amp; Input, FinderT Finder, FormatterT Formatter);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Use the Finder to search for a substring. Use the Formatter to format this substring and replace it in the input. The input is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Finder</term><listitem><para>A Finder object used to search for a match to be replaced </para></listitem></varlistentry><varlistentry><term>Formatter</term><listitem><para>A Formatter object used to format a match </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="find_format_all_copy"><refmeta><refentrytitle>Function find_format_all_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_format_all_copy</refname><refpurpose>Generic replace all algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> FinderT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatterT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;find_format_all_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;FinderT Finder, FormatterT Formatter);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> FormatterT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> find_format_all_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, FinderT Finder, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;FormatterT Formatter);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Use the Finder to search for a substring. Use the Formatter to format this substring and replace it in the input. Repeat this for all matching substrings. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Finder</term><listitem><para>A Finder object used to search for a match to be replaced </para></listitem></varlistentry><varlistentry><term>Formatter</term><listitem><para>A Formatter object used to format a match </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="find_format_all"><refmeta><refentrytitle>Function template find_format_all</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_format_all</refname><refpurpose>Generic replace all algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> FormatterT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> find_format_all(SequenceT &amp; Input, FinderT Finder, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;FormatterT Formatter);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Use the Finder to search for a substring. Use the Formatter to format this substring and replace it in the input. Repeat this for all matching substrings.The input is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Finder</term><listitem><para>A Finder object used to search for a match to be replaced </para></listitem></varlistentry><varlistentry><term>Formatter</term><listitem><para>A Formatter object used to format a match </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id363826"><refmeta><refentrytitle>Function template regex_finder</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::regex_finder</refname><refpurpose>"Regex" finder </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> regex_finder(<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type MatchFlags = match_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>regex_finder</computeroutput> . Finder uses the regex engine to search for a match. Result is given in <computeroutput>regex_search_result</computeroutput> . This is an extension of the iterator_range. In addition it containes match results from the <computeroutput>regex_search</computeroutput>  algorithm.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>MatchFlags</term><listitem><para>Regex search options </para></listitem></varlistentry><varlistentry><term>Rx</term><listitem><para>A regular expression </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>regex_finder</computeroutput>  object </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id308968"><refmeta><refentrytitle>Function template regex_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::regex_formatter</refname><refpurpose>Regex formatter. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> TraitsT, <emphasis role="bold">typename</emphasis> AllocT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> regex_formatter(<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, TraitsT, AllocT &gt; &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = format_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>regex_formatter</computeroutput> . Regex formatter uses the regex engine to format a match found by the <computeroutput>regex_finder</computeroutput> . This formatted it designed to closely cooperate with <computeroutput>regex_finder</computeroutput> .</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Flags</term><listitem><para>Format flags </para></listitem></varlistentry><varlistentry><term>Format</term><listitem><para>Regex format definition </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>regex_formatter</computeroutput>  functor </para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id254240"><title>Header &lt;<ulink url="../../boost/algorithm/string/find_iterator.hpp">boost/algorithm/string/find_iterator.hpp</ulink>&gt;</title><para>Defines find iterator classes. Find iterator repeatly applies a Finder to the specified input string to search for matches. Dereferencing the iterator yields the current match or a range between the last and the current match depending on the iterator used.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> IteratorT&gt; <emphasis role="bold">class</emphasis> <link linkend="find_iterator">find_iterator</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> IteratorT&gt; <emphasis role="bold">class</emphasis> <link linkend="split_iterator">split_iterator</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> FinderT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="find_iterator">find_iterator</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="make_find_iterator">make_find_iterator</link>(CollectionT &amp;, FinderT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> FinderT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="split_iterator">split_iterator</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="make_split_iterator">make_split_iterator</link>(CollectionT &amp;, FinderT);
&#xA0;&#xA0;}
}</synopsis><refentry id="find_iterator"><refmeta><refentrytitle>Class template find_iterator</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_iterator</refname><refpurpose>find_iterator </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> IteratorT&gt; 
<emphasis role="bold">class</emphasis> find_iterator {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="find_iteratorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id331789-bb">find_iterator</link>();
&#xA0;&#xA0;<link linkend="id256023-bb">find_iterator</link>(<emphasis role="bold">const</emphasis> <link linkend="find_iterator">find_iterator</link> &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> FinderT&gt; <link linkend="id346698-bb">find_iterator</link>(IteratorT, IteratorT, FinderT);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id280028-bb">find_iterator</link>(CollectionT &amp;, FinderT);

&#xA0;&#xA0;<emphasis>// <link linkend="id227806-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id496198-bb">eof</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id426473-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> match_type &amp;</type> <link linkend="id219264-bb">dereference</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id392808-bb">increment</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id285363-bb">equal</link>(<emphasis role="bold">const</emphasis> <link linkend="find_iterator">find_iterator</link> &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Find iterator encapsulates a Finder and allows for incremental searching in a string. Each increment moves the iterator to the next match.</para><para>Find iterator is a readable forward traversal iterator.</para><para>Dereferencing the iterator yields an iterator_range delimiting the current match. </para><refsect2><title><anchor id="find_iteratorconstruct-copy-destruct"/><computeroutput>find_iterator</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id331789-bb"/>find_iterator();</literallayout></para><para>Construct null iterator. All null iterators are equal.</para><para/><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><para>eof()==true </para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id256023-bb"/>find_iterator(<emphasis role="bold">const</emphasis> <link linkend="find_iterator">find_iterator</link> &amp; Other);</literallayout></para><para>Construct a copy of the find_iterator </para></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> FinderT&gt; 
&#xA0;&#xA0;<anchor id="id346698-bb"/>find_iterator(IteratorT Begin, IteratorT End, FinderT Finder);</literallayout></para><para>Construct new find_iterator for a given finder and a range. </para></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<anchor id="id280028-bb"/>find_iterator(CollectionT &amp; Col, FinderT Finder);</literallayout></para><para>Construct new find_iterator for a given finder and a collection. </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id227806-bb"/><computeroutput>find_iterator</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id496198-bb"/>eof() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Check the eof condition. Eof condition means that there is nothing more to be searched i.e. find_iterator is after the last match. </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id426473-bb"/><computeroutput>find_iterator</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> match_type &amp;</type> <anchor id="id219264-bb"/>dereference() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id392808-bb"/>increment() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id285363-bb"/>equal(<emphasis role="bold">const</emphasis> <link linkend="find_iterator">find_iterator</link> &amp; Other) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="split_iterator"><refmeta><refentrytitle>Class template split_iterator</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::split_iterator</refname><refpurpose>split_iterator </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> IteratorT&gt; 
<emphasis role="bold">class</emphasis> split_iterator {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="split_iteratorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id400056-bb">split_iterator</link>();
&#xA0;&#xA0;<link linkend="id327792-bb">split_iterator</link>(<emphasis role="bold">const</emphasis> <link linkend="split_iterator">split_iterator</link> &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> FinderT&gt; <link linkend="id374927-bb">split_iterator</link>(IteratorT, IteratorT, FinderT);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id425469-bb">split_iterator</link>(CollectionT &amp;, FinderT);

&#xA0;&#xA0;<emphasis>// <link linkend="id427406-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id424583-bb">eof</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id421533-bb">private member functions</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> match_type &amp;</type> <link linkend="id369264-bb">dereference</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id349703-bb">increment</link>() ;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id362364-bb">equal</link>(<emphasis role="bold">const</emphasis> <link linkend="split_iterator">split_iterator</link> &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Split iterator encapsulates a Finder and allows for incremental searching in a string. Unlike the find iterator, split iterator iterates through gaps between matches.</para><para>Find iterator is a readable forward traversal iterator.</para><para>Dereferencing the iterator yields an iterator_range delimiting the current match. </para><refsect2><title><anchor id="split_iteratorconstruct-copy-destruct"/><computeroutput>split_iterator</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id400056-bb"/>split_iterator();</literallayout></para><para>Construct null iterator. All null iterators are equal.</para><para/><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><para>eof()==true </para></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id327792-bb"/>split_iterator(<emphasis role="bold">const</emphasis> <link linkend="split_iterator">split_iterator</link> &amp; Other);</literallayout></para><para>Construct a copy of the split_iterator </para></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> FinderT&gt; 
&#xA0;&#xA0;<anchor id="id374927-bb"/>split_iterator(IteratorT Begin, IteratorT End, FinderT Finder);</literallayout></para><para>Construct new split_iterator for a given finder and a range. </para></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> FinderT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<anchor id="id425469-bb"/>split_iterator(CollectionT &amp; Col, FinderT Finder);</literallayout></para><para>Construct new split_iterator for a given finder and a collection. </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id427406-bb"/><computeroutput>split_iterator</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id424583-bb"/>eof() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Check the eof condition. Eof condition means that there is nothing more to be searched i.e. find_iterator is after the last match. </para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id421533-bb"/><computeroutput>split_iterator</computeroutput> private member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> match_type &amp;</type> <anchor id="id369264-bb"/>dereference() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id349703-bb"/>increment() ;</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id362364-bb"/>equal(<emphasis role="bold">const</emphasis> <link linkend="split_iterator">split_iterator</link> &amp; Other) <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="make_find_iterator"><refmeta><refentrytitle>Function template make_find_iterator</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::make_find_iterator</refname><refpurpose>find iterator construction helper </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> FinderT&gt; 
&#xA0;&#xA0;<type><link linkend="find_iterator">find_iterator</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;make_find_iterator(CollectionT &amp; Collection, FinderT Finder);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct a find iterator to iterate through the specified string </para></refsect1></refentry><refentry id="make_split_iterator"><refmeta><refentrytitle>Function template make_split_iterator</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::make_split_iterator</refname><refpurpose>split iterator construction helper </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> FinderT&gt; 
&#xA0;&#xA0;<type><link linkend="split_iterator">split_iterator</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;make_split_iterator(CollectionT &amp; Collection, FinderT Finder);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct a split iterator to iterate through the specified collection </para></refsect1></refentry></section><section id="id383225"><title>Header &lt;<ulink url="../../boost/algorithm/string/finder.hpp">boost/algorithm/string/finder.hpp</ulink>&gt;</title><para>Defines Finder generators. Finder object is a functor which is able to find a substring matching a specific criteria in the input. Finders are used as a pluggable components for replace, find and split facilities. This header contains generator functions for finders provided in this library.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT&gt; <type><emphasis>unspecified</emphasis></type> <link linkend="first_finder">first_finder</link>(<emphasis role="bold">const</emphasis> ContainerT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="first_finder">first_finder</link>(<emphasis role="bold">const</emphasis> ContainerT &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT&gt; <type><emphasis>unspecified</emphasis></type> <link linkend="last_finder">last_finder</link>(<emphasis role="bold">const</emphasis> ContainerT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="last_finder">last_finder</link>(<emphasis role="bold">const</emphasis> ContainerT &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="nth_finder">nth_finder</link>(<emphasis role="bold">const</emphasis> ContainerT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="nth_finder">nth_finder</link>(<emphasis role="bold">const</emphasis> ContainerT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="head_finder">head_finder</link>(<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="tail_finder">tail_finder</link>(<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="token_finder">token_finder</link>(PredicateT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;token_compress_mode_type = token_compress_off);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ForwardIteratorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="range_finder">range_finder</link>(ForwardIteratorT, ForwardIteratorT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ForwardIteratorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="range_finder">range_finder</link>(<link linkend="iterator_range">iterator_range</link>&lt; ForwardIteratorT &gt;);
&#xA0;&#xA0;}
}</synopsis><refentry id="first_finder"><refmeta><refentrytitle>Function first_finder</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::first_finder</refname><refpurpose>"First" finder </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> first_finder(<emphasis role="bold">const</emphasis> ContainerT &amp; Search);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> first_finder(<emphasis role="bold">const</emphasis> ContainerT &amp; Search, PredicateT Comp);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>first_finder</computeroutput> . The finder searches for the first occurrence of the string in a given input. The result is given as an <computeroutput>iterator_range</computeroutput>  delimiting the match.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>first_finder</computeroutput>  object </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="last_finder"><refmeta><refentrytitle>Function last_finder</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::last_finder</refname><refpurpose>"Last" finder </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> last_finder(<emphasis role="bold">const</emphasis> ContainerT &amp; Search);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> last_finder(<emphasis role="bold">const</emphasis> ContainerT &amp; Search, PredicateT Comp);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>last_finder</computeroutput> . The finder searches for the last occurrence of the string in a given input. The result is given as an <computeroutput>iterator_range</computeroutput>  delimiting the match.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>last_finder</computeroutput>  object </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="nth_finder"><refmeta><refentrytitle>Function nth_finder</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::nth_finder</refname><refpurpose>"Nth" finder </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> nth_finder(<emphasis role="bold">const</emphasis> ContainerT &amp; Search, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ContainerT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> nth_finder(<emphasis role="bold">const</emphasis> ContainerT &amp; Search, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;PredicateT Comp);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>nth_finder</computeroutput> . The finder searches for the n-th (zero-indexed) occurrence of the string in a given input. The result is given as an <computeroutput>iterator_range</computeroutput>  delimiting the match.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Nth</term><listitem><para>An index of the match to be find </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>nth_finder</computeroutput>  object </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="head_finder"><refmeta><refentrytitle>Function head_finder</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::head_finder</refname><refpurpose>"Head" finder </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> head_finder(<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>head_finder</computeroutput> . The finder returns a head of a given input. The head is a prefix of a string up to n elements in size. If an input has less then n elements, whole input is considered a head. The result is given as an <computeroutput>iterator_range</computeroutput>  delimiting the match.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>N</term><listitem><para>The size of the head </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>head_finder</computeroutput>  object </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="tail_finder"><refmeta><refentrytitle>Function tail_finder</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::tail_finder</refname><refpurpose>"Tail" finder </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis>unspecified</emphasis></type> tail_finder(<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>tail_finder</computeroutput> . The finder returns a tail of a given input. The tail is a suffix of a string up to n elements in size. If an input has less then n elements, whole input is considered a head. The result is given as an <computeroutput>iterator_range</computeroutput>  delimiting the match.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>N</term><listitem><para>The size of the head </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>tail_finder</computeroutput>  object </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="token_finder"><refmeta><refentrytitle>Function template token_finder</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::token_finder</refname><refpurpose>"Token" finder </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> token_finder(PredicateT Pred, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;token_compress_mode_type eCompress = token_compress_off);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>token_finder</computeroutput> . The finder searches for a token specified by a predicate. It is similar to std::find_if algorithm, with an exception that it return a range of instead of a single iterator.</para><para>If "compress token mode" is enabled, adjacent matching tokens are concatenated into one match. Thus the finder can be used to search for continuous segments of characters satisfying the given predicate.</para><para>The result is given as an <computeroutput>iterator_range</computeroutput>  delimiting the match.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Pred</term><listitem><para>An element selection predicate </para></listitem></varlistentry><varlistentry><term>eCompress</term><listitem><para>Compress flag </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>token_finder</computeroutput>  object </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="range_finder"><refmeta><refentrytitle>Function range_finder</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::range_finder</refname><refpurpose>"Range" finder </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ForwardIteratorT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> range_finder(ForwardIteratorT Begin, ForwardIteratorT End);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ForwardIteratorT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> range_finder(<link linkend="iterator_range">iterator_range</link>&lt; ForwardIteratorT &gt; Range);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>range_finder</computeroutput> . The finder does not perform any operation. It simply returns the given range for any input.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Begin</term><listitem><para>Beginning of the range </para></listitem></varlistentry><varlistentry><term>End</term><listitem><para>End of the range </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>range_finger</computeroutput>  object </para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id267193"><title>Header &lt;<ulink url="../../boost/algorithm/string/formatter.hpp">boost/algorithm/string/formatter.hpp</ulink>&gt;</title><para>Defines Formatter generators. Formatter is a functor which formats a string according to given parameters. A Formatter works in conjunction with a Finder. A Finder can provide additional information for a specific Formatter. An example of such a cooperation is regex_finder and regex_formatter.</para><para>Formatters are used as pluggable components for replace facilities. This header contains generator functions for the Formatters provided in this library.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="const_formatter">const_formatter</link>(<emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT&gt; <type><emphasis>unspecified</emphasis></type> <link linkend="identity_formatter">identity_formatter</link>();
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="empty_formatter">empty_formatter</link>(<emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;}
}</synopsis><refentry id="const_formatter"><refmeta><refentrytitle>Function template const_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::const_formatter</refname><refpurpose>Constant formatter. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> const_formatter(<emphasis role="bold">const</emphasis> CollectionT &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>const_formatter</computeroutput> . Const formatter always returns the same value, regardless of the parameter.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A predefined value used as a result for formating </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>const_formatter</computeroutput>  object. </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="identity_formatter"><refmeta><refentrytitle>Function template identity_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::identity_formatter</refname><refpurpose>Identity formatter. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT&gt; <type><emphasis>unspecified</emphasis></type> identity_formatter();</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>identity_formatter</computeroutput> . Identity formatter always returns the parameter.</para><para/><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>identity_formatter</computeroutput>  object. </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="empty_formatter"><refmeta><refentrytitle>Function template empty_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::empty_formatter</refname><refpurpose>Empty formatter. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> empty_formatter(<emphasis role="bold">const</emphasis> CollectionT &amp; );</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>empty_formatter</computeroutput> . Empty formater always returns an empty sequence.</para><para/><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>empty_formatter</computeroutput>  object. </para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id365349"><title>Header &lt;<ulink url="../../boost/algorithm/string/iterator_range.hpp">boost/algorithm/string/iterator_range.hpp</ulink>&gt;</title><para>Defines the <computeroutput>iterator_class</computeroutput>  and related functions. <computeroutput>iterator_range</computeroutput>  is a simple wrapper of the iterator pair idiom. It provides a rich subset of the Container interface.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> IteratorT&gt; <emphasis role="bold">class</emphasis> <link linkend="iterator_range">iterator_range</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> IteratorT, <emphasis role="bold">typename</emphasis> Elem, <emphasis role="bold">typename</emphasis> Traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; Elem, Traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id282639"><emphasis role="bold">operator</emphasis>&lt;&lt;</link>(std::basic_ostream&lt; Elem, Traits &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; IteratorT &gt; &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> IteratorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; IteratorT &gt;</type> <link linkend="id387885">make_iterator_range</link>(IteratorT, IteratorT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> IteratorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; IteratorT &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id370972">make_iterator_range</link>(<emphasis role="bold">const</emphasis> std::pair&lt; IteratorT, IteratorT &gt; &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SeqT, <emphasis role="bold">typename</emphasis> IteratorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SeqT</type> <link linkend="copy_iterator_range">copy_iterator_range</link>(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; IteratorT &gt; &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SeqT, <emphasis role="bold">typename</emphasis> IteratorT, <emphasis role="bold">typename</emphasis> FuncT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SeqT</type> <link linkend="transform_iterator_range">transform_iterator_range</link>(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; IteratorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;FuncT);
&#xA0;&#xA0;}
}</synopsis><refentry id="iterator_range"><refmeta><refentrytitle>Class template iterator_range</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::iterator_range</refname><refpurpose>iterator_range class </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> IteratorT&gt; 
<emphasis role="bold">class</emphasis> iterator_range {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; IteratorT &gt; type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// this type </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>unspecified</emphasis>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; value_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// Encapsulated value type. </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>unspecified</emphasis>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; reference;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// Reference type. </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>unspecified</emphasis>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; difference_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// Difference type. </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>unspecified</emphasis>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; size_type;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// Size type. </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> IteratorT&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; const_iterator;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// const_iterator type </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> IteratorT&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; iterator;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  <emphasis>// iterator type </emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> iterator(iterator_range::*&#xA0; unspecified_bool_type;  <emphasis>// Safe bool conversion. </emphasis>

&#xA0;&#xA0;<emphasis>// <link linkend="iterator_rangeconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id474291-bb">iterator_range</link>();
&#xA0;&#xA0;<link linkend="id385891-bb">iterator_range</link>(iterator, iterator);
&#xA0;&#xA0;<link linkend="id429521-bb">iterator_range</link>(<emphasis role="bold">const</emphasis> std::pair&lt; IteratorT, IteratorT &gt; &amp;);
&#xA0;&#xA0;<link linkend="id233951-bb">iterator_range</link>(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link> &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OtherItT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id507697-bb">iterator_range</link>(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; OtherItT &gt; &amp;);
&#xA0;&#xA0;iterator_range&amp; <link linkend="id234126-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link> &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OtherItT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;iterator_range&amp; <link linkend="id245568-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; OtherItT &gt; &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id339322-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OtherItT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id403577-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; OtherItT &gt; &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OtherItT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id370894-bb"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; OtherItT &gt; &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>IteratorT</type> <link linkend="id354027-bb">begin</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>IteratorT</type> <link linkend="id427176-bb">end</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id401116-bb">empty</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>difference_type</type> <link linkend="id420698-bb">size</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id430101-bb">swap</link>(<link linkend="iterator_range">iterator_range</link> &amp;) ;
&#xA0;&#xA0;<link linkend="id280232-bb"><emphasis role="bold">operator</emphasis> unspecified_bool_type</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>An <computeroutput>iterator_range</computeroutput>  delimits a range in a sequence by beginning and ending iterators. An iterator_range can be passed to an algorithm which requires a sequence as an input. For example, the <computeroutput>toupper()</computeroutput>  function may most frequently be used on strings, but can also be used on iterator_ranges:</para><para><programlisting>                boost::tolower( find( s, "UPPERCASE STRING" ) );
</programlisting></para><para>Many algorithms working with sequences take a pair of iterators, delimiting a working range, as arguments. The <computeroutput>iterator_range</computeroutput>  class is an encapsulation of a range identified by a pair of iterators. It provides a collection interface, so it is possible to pass an instance to an algorithm requiring a collection as an input. </para><refsect2><title><anchor id="iterator_rangeconstruct-copy-destruct"/><computeroutput>iterator_range</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id474291-bb"/>iterator_range();</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id385891-bb"/>iterator_range(iterator Begin, iterator End);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id429521-bb"/>iterator_range(<emphasis role="bold">const</emphasis> std::pair&lt; IteratorT, IteratorT &gt; &amp; Range);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id233951-bb"/>iterator_range(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link> &amp; Other);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OtherItT&gt; 
&#xA0;&#xA0;<anchor id="id507697-bb"/>iterator_range(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; OtherItT &gt; &amp; Other);</literallayout></para><para>This constructor is provided to allow conversion between const and mutable iterator instances of this class template </para></listitem><listitem><para><literallayout class="monospaced">iterator_range&amp; <anchor id="id234126-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link> &amp; Other);</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OtherItT&gt; 
&#xA0;&#xA0;iterator_range&amp; <anchor id="id245568-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; OtherItT &gt; &amp; Other);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id339322-bb"/><computeroutput>iterator_range</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OtherItT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id403577-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; OtherItT &gt; &amp; Other) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Compare operands for equality </para></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OtherItT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id370894-bb"/><emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; OtherItT &gt; &amp; Other) <emphasis role="bold">const</emphasis>;</literallayout></para><para>Compare operands for non-equality </para></listitem><listitem><para><literallayout class="monospaced"><type>IteratorT</type> <anchor id="id354027-bb"/>begin() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Retrieve the begin iterator </para></listitem><listitem><para><literallayout class="monospaced"><type>IteratorT</type> <anchor id="id427176-bb"/>end() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Retrieve the end iterator </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id401116-bb"/>empty() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Test whether the range is empty </para></listitem><listitem><para><literallayout class="monospaced"><type>difference_type</type> <anchor id="id420698-bb"/>size() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Retrieve the size of the range </para></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id430101-bb"/>swap(<link linkend="iterator_range">iterator_range</link> &amp; Other) ;</literallayout></para><para>Swap two ranges </para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id280232-bb"/><emphasis role="bold">operator</emphasis> unspecified_bool_type() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id282639"><refmeta><refentrytitle>Function template operator&lt;&lt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::operator&lt;&lt;</refname><refpurpose>iterator_range output operator </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> IteratorT, <emphasis role="bold">typename</emphasis> Elem, <emphasis role="bold">typename</emphasis> Traits&gt; 
&#xA0;&#xA0;<type>std::basic_ostream&lt; Elem, Traits &gt; &amp;</type> 
&#xA0;&#xA0;<emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; Elem, Traits &gt; &amp; Os, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; IteratorT &gt; &amp; Range);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Output the range to an ostream. Elements are outputed in a sequence without separators. </para></refsect1></refentry><refentry id="id387885"><refmeta><refentrytitle>Function template make_iterator_range</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::make_iterator_range</refname><refpurpose>iterator_range construct helper </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> IteratorT&gt; 
&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; IteratorT &gt;</type> 
&#xA0;&#xA0;make_iterator_range(IteratorT Begin, IteratorT End);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct an <computeroutput>iterator_range</computeroutput>  from a pair of iterators</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Begin</term><listitem><para>A begin iterator </para></listitem></varlistentry><varlistentry><term>End</term><listitem><para>An end iterator </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>iterator_range object </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id370972"><refmeta><refentrytitle>Function template make_iterator_range</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::make_iterator_range</refname><refpurpose>iterator_range construct helper </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> IteratorT&gt; 
&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; IteratorT &gt;</type> 
&#xA0;&#xA0;make_iterator_range(<emphasis role="bold">const</emphasis> std::pair&lt; IteratorT, IteratorT &gt; &amp; Pair);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct an <computeroutput>iterator_range</computeroutput>  from a <computeroutput>std::pair&lt;&gt;</computeroutput>  containing the begin and end iterators.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Pair</term><listitem><para>A <computeroutput>std::pair&lt;&gt;</computeroutput>  with begin and end iterators </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para><computeroutput>iterator_range</computeroutput>  object </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="copy_iterator_range"><refmeta><refentrytitle>Function template copy_iterator_range</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::copy_iterator_range</refname><refpurpose>copy a range into a sequence </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SeqT, <emphasis role="bold">typename</emphasis> IteratorT&gt; 
&#xA0;&#xA0;<type>SeqT</type> copy_iterator_range(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; IteratorT &gt; &amp; Range);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct a new sequence of the specified type from the elements in the given range</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Range</term><listitem><para>An input range </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>New sequence </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="transform_iterator_range"><refmeta><refentrytitle>Function template transform_iterator_range</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::transform_iterator_range</refname><refpurpose>transform a range into a sequence </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SeqT, <emphasis role="bold">typename</emphasis> IteratorT, <emphasis role="bold">typename</emphasis> FuncT&gt; 
&#xA0;&#xA0;<type>SeqT</type> transform_iterator_range(<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; IteratorT &gt; &amp; Range, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;FuncT Func);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Create a new sequence from the elements in the range, transformed by a function</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Func</term><listitem><para>Transformation function </para></listitem></varlistentry><varlistentry><term>Range</term><listitem><para>An input range </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>New sequence </para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id366812"><title>Header &lt;<ulink url="../../boost/algorithm/string/predicate.hpp">boost/algorithm/string/predicate.hpp</ulink>&gt;</title><para>Defines string-related predicates. The predicates determine whether a substring is contained in the input string under various conditions: a string starts with the substring, ends with the substring, simply contains the substring or if both strings are equal. Additionaly the algorithm <computeroutput>all()</computeroutput>  checks all elements of a container to satisfy a condition.</para><para>All predicates provide the strong exception guarantee.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="starts_with">starts_with</link>(<emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="starts_with">starts_with</link>(<emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="istarts_with">istarts_with</link>(<emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="ends_with">ends_with</link>(<emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="ends_with">ends_with</link>(<emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="iends_with">iends_with</link>(<emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="contains">contains</link>(<emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="contains">contains</link>(<emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="icontains">icontains</link>(<emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="equals">equals</link>(<emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="equals">equals</link>(<emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="iequals">iequals</link>(<emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="all">all</link>(<emphasis role="bold">const</emphasis> CollectionT &amp;, PredicateT);
&#xA0;&#xA0;}
}</synopsis><refentry id="starts_with"><refmeta><refentrytitle>Function starts_with</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::starts_with</refname><refpurpose>'Starts with' predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> starts_with(<emphasis role="bold">const</emphasis> Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Test, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;PredicateT Comp);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> starts_with(<emphasis role="bold">const</emphasis> Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Test);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This predicate holds when the test collection is a prefix of the Input. In other words, if the input starts with the test. When the optional predicate is specified, it is used for character-wise comparison.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Comp</term><listitem><para>An element comparison predicate </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Test</term><listitem><para>A test sequence </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>The result of the test</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="istarts_with"><refmeta><refentrytitle>Function template istarts_with</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::istarts_with</refname><refpurpose>'Starts with' predicate ( case insensitive ) </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> istarts_with(<emphasis role="bold">const</emphasis> Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Test, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This predicate holds when the test container is a prefix of the Input. In other words, if the input starts with the test. Elements are compared case insensitively.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Test</term><listitem><para>A test sequence </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>The result of the test</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ends_with"><refmeta><refentrytitle>Function ends_with</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ends_with</refname><refpurpose>'Ends with' predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> ends_with(<emphasis role="bold">const</emphasis> Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Test, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;PredicateT Comp);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> ends_with(<emphasis role="bold">const</emphasis> Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Test);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This predicate holds when the test container is a suffix of the Input. In other words, if the input ends with the test. When the optional predicate is specified, it is used for character-wise comparison.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Comp</term><listitem><para>An element comparison predicate </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Test</term><listitem><para>A test sequence </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>The result of the test</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="iends_with"><refmeta><refentrytitle>Function template iends_with</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::iends_with</refname><refpurpose>'Ends with' predicate ( case insensitive ) </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> iends_with(<emphasis role="bold">const</emphasis> Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Test, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This predicate holds when the test container is a suffix of the Input. In other words, if the input ends with the test. Elements are compared case insensitively.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Test</term><listitem><para>A test sequence </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>The result of the test</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="contains"><refmeta><refentrytitle>Function contains</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::contains</refname><refpurpose>'Contains' predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> contains(<emphasis role="bold">const</emphasis> Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Test, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;PredicateT Comp);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> contains(<emphasis role="bold">const</emphasis> Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Test);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This predicate holds when the test container is contained in the Input. When the optional predicate is specified, it is used for character-wise comparison.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Comp</term><listitem><para>An element comparison predicate </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Test</term><listitem><para>A test sequence </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>The result of the test</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="icontains"><refmeta><refentrytitle>Function template icontains</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::icontains</refname><refpurpose>'Contains' predicate ( case insensitive ) </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> icontains(<emphasis role="bold">const</emphasis> Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Test, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This predicate holds when the test container is contained in the Input. Elements are compared case insensitively.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Test</term><listitem><para>A test sequence </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>The result of the test</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="equals"><refmeta><refentrytitle>Function equals</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::equals</refname><refpurpose>'Equals' predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> equals(<emphasis role="bold">const</emphasis> Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Test, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;PredicateT Comp);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> equals(<emphasis role="bold">const</emphasis> Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Test);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This predicate holds when the test container is equal to the input container i.e. all elements in both containers are same. When the optional predicate is specified, it is used for character-wise comparison.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Comp</term><listitem><para>An element comparison predicate </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Test</term><listitem><para>A test sequence </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>The result of the test</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This is a two-way version of <computeroutput>std::equal</computeroutput>  algorithm</para><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="iequals"><refmeta><refentrytitle>Function template iequals</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::iequals</refname><refpurpose>'Equals' predicate ( casa insensitive ) </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> iequals(<emphasis role="bold">const</emphasis> Collection1T &amp; Input, <emphasis role="bold">const</emphasis> Collection2T &amp; Test, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This predicate holds when the test container is equal to the input container i.e. all elements in both containers are same. Elements are compared case insensitively.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Test</term><listitem><para>A test sequence </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>The result of the test</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This is a two-way version of <computeroutput>std::equal</computeroutput>  algorithm</para><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="all"><refmeta><refentrytitle>Function template all</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::all</refname><refpurpose>'All' predicate </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> all(<emphasis role="bold">const</emphasis> CollectionT &amp; Input, PredicateT Pred);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This predicate holds it all its elements satisfy a given condition, represented by the predicate.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Pred</term><listitem><para>A predicate </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>The result of the test</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id326535"><title>Header &lt;<ulink url="../../boost/algorithm/string/regex.hpp">boost/algorithm/string/regex.hpp</ulink>&gt;</title><para>Defines regex variants of the algorithms.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="find_regex">find_regex</link>(CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatStringTraitsT, <emphasis role="bold">typename</emphasis> FormatStringAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="replace_regex_copy">replace_regex_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, FormatStringTraitsT, FormatStringAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default|format_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT, <emphasis role="bold">typename</emphasis> FormatStringTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatStringAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="replace_regex_copy">replace_regex_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, FormatStringTraitsT, FormatStringAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default|format_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT, <emphasis role="bold">typename</emphasis> FormatStringTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatStringAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="replace_regex">replace_regex</link>(SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, FormatStringTraitsT, FormatStringAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default|format_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatStringTraitsT, <emphasis role="bold">typename</emphasis> FormatStringAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="replace_all_regex_copy">replace_all_regex_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, FormatStringTraitsT, FormatStringAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default|format_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT, <emphasis role="bold">typename</emphasis> FormatStringTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatStringAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="replace_all_regex_copy">replace_all_regex_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, FormatStringTraitsT, FormatStringAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default|format_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT, <emphasis role="bold">typename</emphasis> FormatStringTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatStringAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="replace_all_regex">replace_all_regex</link>(SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, FormatStringTraitsT, FormatStringAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default|format_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="erase_regex_copy">erase_regex_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="erase_regex_copy">erase_regex_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="erase_regex">erase_regex</link>(SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="erase_all_regex_copy">erase_all_regex_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="erase_all_regex_copy">erase_all_regex_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="erase_all_regex">erase_all_regex</link>(SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceSequenceT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceSequenceT &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="find_all_regex">find_all_regex</link>(SequenceSequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceSequenceT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceSequenceT &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="split_regex">split_regex</link>(SequenceSequenceT &amp;, <emphasis role="bold">const</emphasis> CollectionT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default);
&#xA0;&#xA0;}
}</synopsis><refentry id="find_regex"><refmeta><refentrytitle>Function template find_regex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_regex</refname><refpurpose>Find regex algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;<type><link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="result_iterator_of">result_iterator_of</link>&lt; CollectionT &gt;::type &gt;</type> 
&#xA0;&#xA0;find_regex(CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Search for a substring matching the given regex in the input.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Flags</term><listitem><para>Regex options </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>A container which will be searched. </para></listitem></varlistentry><varlistentry><term>Rx</term><listitem><para>A regular expression </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An <computeroutput>iterator_range</computeroutput>  delimiting the match. Returned iterator is either <computeroutput>InputContainerT::iterator</computeroutput>  or <computeroutput>InputContainerT::const_iterator</computeroutput> , depending on the constness of the input parameter.</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_regex_copy"><refmeta><refentrytitle>Function replace_regex_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_regex_copy</refname><refpurpose>Replace regex algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatStringTraitsT, <emphasis role="bold">typename</emphasis> FormatStringAllocatorT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;replace_regex_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, FormatStringTraitsT, FormatStringAllocatorT &gt; &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default|format_default);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT, <emphasis role="bold">typename</emphasis> FormatStringTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatStringAllocatorT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> replace_regex_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, FormatStringTraitsT, FormatStringAllocatorT &gt; &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default|format_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Search for a substring matching given regex and format it with the specified format. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Flags</term><listitem><para>Regex options </para></listitem></varlistentry><varlistentry><term>Format</term><listitem><para>Regex format definition </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Rx</term><listitem><para>A regular expression </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_regex"><refmeta><refentrytitle>Function template replace_regex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_regex</refname><refpurpose>Replace regex algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT, <emphasis role="bold">typename</emphasis> FormatStringTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatStringAllocatorT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> replace_regex(SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, FormatStringTraitsT, FormatStringAllocatorT &gt; &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default|format_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Search for a substring matching given regex and format it with the specified format. The input string is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Flags</term><listitem><para>Regex options </para></listitem></varlistentry><varlistentry><term>Format</term><listitem><para>Regex format definition </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Rx</term><listitem><para>A regular expression </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_all_regex_copy"><refmeta><refentrytitle>Function replace_all_regex_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_all_regex_copy</refname><refpurpose>Replace all regex algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatStringTraitsT, <emphasis role="bold">typename</emphasis> FormatStringAllocatorT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;replace_all_regex_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, FormatStringTraitsT, FormatStringAllocatorT &gt; &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default|format_default);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT, <emphasis role="bold">typename</emphasis> FormatStringTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatStringAllocatorT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> replace_all_regex_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, FormatStringTraitsT, FormatStringAllocatorT &gt; &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default|format_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Format all substrings, matching given regex, with the specified format. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Flags</term><listitem><para>Regex options </para></listitem></varlistentry><varlistentry><term>Format</term><listitem><para>Regex format definition </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Rx</term><listitem><para>A regular expression </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_all_regex"><refmeta><refentrytitle>Function template replace_all_regex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_all_regex</refname><refpurpose>Replace all regex algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT, <emphasis role="bold">typename</emphasis> FormatStringTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> FormatStringAllocatorT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> replace_all_regex(SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, FormatStringTraitsT, FormatStringAllocatorT &gt; &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default|format_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Format all substrings, matching given regex, with the specified format. The input string is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Flags</term><listitem><para>Regex options </para></listitem></varlistentry><varlistentry><term>Format</term><listitem><para>Regex format definition </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Rx</term><listitem><para>A regular expression </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_regex_copy"><refmeta><refentrytitle>Function erase_regex_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_regex_copy</refname><refpurpose>Erase regex algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;erase_regex_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> erase_regex_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove a substring matching given regex from the input. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Flags</term><listitem><para>Regex options </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Rx</term><listitem><para>A regular expression </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_regex"><refmeta><refentrytitle>Function template erase_regex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_regex</refname><refpurpose>Erase regex algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> erase_regex(SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove a substring matching given regex from the input. The input string is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Flags</term><listitem><para>Regex options </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Rx</term><listitem><para>A regular expression </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_all_regex_copy"><refmeta><refentrytitle>Function erase_all_regex_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_all_regex_copy</refname><refpurpose>Erase all regex algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;erase_all_regex_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> erase_all_regex_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Erase all substrings, matching given regex, from the input. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Flags</term><listitem><para>Regex options </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Rx</term><listitem><para>A regular expression </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="erase_all_regex"><refmeta><refentrytitle>Function template erase_all_regex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::erase_all_regex</refname><refpurpose>Erase all regex algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> erase_all_regex(SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Erase all substrings, matching given regex, from the input. The input string is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Flags</term><listitem><para>Regex options </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Rx</term><listitem><para>A regular expression </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="find_all_regex"><refmeta><refentrytitle>Function template find_all_regex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_all_regex</refname><refpurpose>Find all regex algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceSequenceT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;<type>SequenceSequenceT &amp;</type> 
&#xA0;&#xA0;find_all_regex(SequenceSequenceT &amp; Result, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This algorithm finds all substrings matching the give regex in the input.</para><para>Each part is copied and added as a new element to the output container. Thus the result container must be able to hold copies of the matches (in a compatible structure like std::string) or a reference to it (e.g. using the iterator range class). Examples of such a container are <computeroutput>std::vector&lt;std::string&gt;</computeroutput>  or <computeroutput>std::list&lt;boost::iterator_range&lt;std::string::iterator&gt;&gt;</computeroutput></para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Flags</term><listitem><para>Regex options </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>A container which will be searched. </para></listitem></varlistentry><varlistentry><term>Result</term><listitem><para>A container that can hold copies of references to the substrings. </para></listitem></varlistentry><varlistentry><term>Rx</term><listitem><para>A regular expression </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>A reference to the result</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>Prior content of the result will be overwritten.</para><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="split_regex"><refmeta><refentrytitle>Function template split_regex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::split_regex</refname><refpurpose>Split regex algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceSequenceT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> CharT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;<type>SequenceSequenceT &amp;</type> 
&#xA0;&#xA0;split_regex(SequenceSequenceT &amp; Result, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = match_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Tokenize expression. This function is equivalent to C strtok. Input sequence is split into tokens, separated by separators. Separator is an every match of the given regex. Each part is copied and added as a new element to the output container. Thus the result container must be able to hold copies of the matches (in a compatible structure like std::string) or a reference to it (e.g. using the iterator range class). Examples of such a container are <computeroutput>std::vector&lt;std::string&gt;</computeroutput>  or <computeroutput>std::list&lt;boost::iterator_range&lt;std::string::iterator&gt;&gt;</computeroutput></para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Flags</term><listitem><para>Regex options </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>A container which will be searched. </para></listitem></varlistentry><varlistentry><term>Result</term><listitem><para>A container that can hold copies of references to the substrings. </para></listitem></varlistentry><varlistentry><term>Rx</term><listitem><para>A regular expression </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>A reference to the result</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>Prior content of the result will be overwritten.</para><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id227790"><title>Header &lt;<ulink url="../../boost/algorithm/string/regex_find_format.hpp">boost/algorithm/string/regex_find_format.hpp</ulink>&gt;</title><para>Defines the <computeroutput>regex_finder</computeroutput>  and <computeroutput>regex_formatter</computeroutput>  generators. These two functors are designed to work together. <computeroutput>regex_formatter</computeroutput>  uses additional information about a match contained in the regex_finder search result.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="id333252">regex_finder</link>(<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = match_default);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> TraitsT, <emphasis role="bold">typename</emphasis> AllocT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> <link linkend="id325454">regex_formatter</link>(<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, TraitsT, AllocT &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type = format_default);
&#xA0;&#xA0;}
}</synopsis><refentry id="id333252"><refmeta><refentrytitle>Function template regex_finder</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::regex_finder</refname><refpurpose>"Regex" finder </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> RegexTraitsT, <emphasis role="bold">typename</emphasis> RegexAllocatorT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> regex_finder(<emphasis role="bold">const</emphasis> reg_expression&lt; CharT, RegexTraitsT, RegexAllocatorT &gt; &amp; Rx, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type MatchFlags = match_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>regex_finder</computeroutput> . Finder uses the regex engine to search for a match. Result is given in <computeroutput>regex_search_result</computeroutput> . This is an extension of the iterator_range. In addition it containes match results from the <computeroutput>regex_search</computeroutput>  algorithm.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>MatchFlags</term><listitem><para>Regex search options </para></listitem></varlistentry><varlistentry><term>Rx</term><listitem><para>A regular expression </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>regex_finder</computeroutput>  object </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id325454"><refmeta><refentrytitle>Function template regex_formatter</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::regex_formatter</refname><refpurpose>Regex formatter. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> TraitsT, <emphasis role="bold">typename</emphasis> AllocT&gt; 
&#xA0;&#xA0;<type><emphasis>unspecified</emphasis></type> regex_formatter(<emphasis role="bold">const</emphasis> std::basic_string&lt; CharT, TraitsT, AllocT &gt; &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;match_flag_type Flags = format_default);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Construct the <computeroutput>regex_formatter</computeroutput> . Regex formatter uses the regex engine to format a match found by the <computeroutput>regex_finder</computeroutput> . This formatted it designed to closely cooperate with <computeroutput>regex_finder</computeroutput> .</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Flags</term><listitem><para>Format flags </para></listitem></varlistentry><varlistentry><term>Format</term><listitem><para>Regex format definition </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An instance of the <computeroutput>regex_formatter</computeroutput>  functor </para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id439791"><title>Header &lt;<ulink url="../../boost/algorithm/string/replace.hpp">boost/algorithm/string/replace.hpp</ulink>&gt;</title><para>Defines various replace algorithms. Each algorithm replaces part(s) of the input according to set of searching and replace criteria.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="replace_range_copy">replace_range_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="const_iterator_of">const_iterator_of</link>&lt; Collection1T &gt;::type &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="replace_range_copy">replace_range_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="const_iterator_of">const_iterator_of</link>&lt; SequenceT &gt;::type &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="replace_range">replace_range</link>(SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="iterator_of">iterator_of</link>&lt; SequenceT &gt;::type &gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="replace_first_copy">replace_first_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, <emphasis role="bold">const</emphasis> Collection3T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="replace_first_copy">replace_first_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="replace_first">replace_first</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="ireplace_first_copy">ireplace_first_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, <emphasis role="bold">const</emphasis> Collection3T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection1T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="ireplace_first_copy">ireplace_first_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="ireplace_first">ireplace_first</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="replace_last_copy">replace_last_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, <emphasis role="bold">const</emphasis> Collection3T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="replace_last_copy">replace_last_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="replace_last">replace_last</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="ireplace_last_copy">ireplace_last_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, <emphasis role="bold">const</emphasis> Collection3T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="ireplace_last_copy">ireplace_last_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="ireplace_last">ireplace_last</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="replace_nth_copy">replace_nth_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection3T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="replace_nth_copy">replace_nth_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, <emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="replace_nth">replace_nth</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="ireplace_nth_copy">ireplace_nth_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection3T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="ireplace_nth_copy">ireplace_nth_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, <emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="ireplace_nth">ireplace_nth</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="replace_all_copy">replace_all_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, <emphasis role="bold">const</emphasis> Collection3T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="replace_all_copy">replace_all_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="replace_all">replace_all</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="ireplace_all_copy">ireplace_all_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, <emphasis role="bold">const</emphasis> Collection3T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="ireplace_all_copy">ireplace_all_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="ireplace_all">ireplace_all</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> Collection1T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="replace_head_copy">replace_head_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="replace_head_copy">replace_head_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="replace_head">replace_head</link>(SequenceT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, <emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="replace_tail_copy">replace_tail_copy</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> Collection1T &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="replace_tail_copy">replace_tail_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="replace_tail">replace_tail</link>(SequenceT &amp;, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis>, <emphasis role="bold">const</emphasis> CollectionT &amp;);
&#xA0;&#xA0;}
}</synopsis><refentry id="replace_range_copy"><refmeta><refentrytitle>Function replace_range_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_range_copy</refname><refpurpose>Replace range algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;replace_range_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="const_iterator_of">const_iterator_of</link>&lt; Collection1T &gt;::type &gt; &amp; SearchRange, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> replace_range_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="const_iterator_of">const_iterator_of</link>&lt; SequenceT &gt;::type &gt; &amp; SearchRange, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace the given range in the input string. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>SearchRange</term><listitem><para>A range in the input to be substituted </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_range"><refmeta><refentrytitle>Function template replace_range</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_range</refname><refpurpose>Replace range algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> replace_range(SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="iterator_range">iterator_range</link>&lt; <emphasis role="bold">typename</emphasis> <link linkend="iterator_of">iterator_of</link>&lt; SequenceT &gt;::type &gt; &amp; SearchRange, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace the given range in the input string. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>SearchRange</term><listitem><para>A range in the input to be substituted </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_first_copy"><refmeta><refentrytitle>Function replace_first_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_first_copy</refname><refpurpose>Replace first algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;replace_first_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection3T &amp; Format);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>SequenceT</type> replace_first_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection1T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace the first match of the search substring in the input with the format string. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_first"><refmeta><refentrytitle>Function template replace_first</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_first</refname><refpurpose>Replace first algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> replace_first(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> Collection1T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>replace the first match of the search substring in the input with the format string. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ireplace_first_copy"><refmeta><refentrytitle>Function ireplace_first_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ireplace_first_copy</refname><refpurpose>Replace first algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;ireplace_first_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection3T &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection1T&gt; 
&#xA0;&#xA0;<type>SequenceT</type> ireplace_first_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection1T &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace the first match of the search substring in the input with the format string. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ireplace_first"><refmeta><refentrytitle>Function template ireplace_first</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ireplace_first</refname><refpurpose>Replace first algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> ireplace_first(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> Collection1T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace the first match of the search substring in the input with the format string. Input sequence is modified in-place. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_last_copy"><refmeta><refentrytitle>Function replace_last_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_last_copy</refname><refpurpose>Replace last algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;replace_last_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, <emphasis role="bold">const</emphasis> Collection3T &amp; Format);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>SequenceT</type> replace_last_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection1T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace the last match of the search string in the input with the format string. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_last"><refmeta><refentrytitle>Function template replace_last</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_last</refname><refpurpose>Replace last algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> replace_last(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> Collection1T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace the last match of the search string in the input with the format string. Input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ireplace_last_copy"><refmeta><refentrytitle>Function ireplace_last_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ireplace_last_copy</refname><refpurpose>Replace last algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;ireplace_last_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection3T &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>SequenceT</type> ireplace_last_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection1T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace the last match of the search string in the input with the format string. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ireplace_last"><refmeta><refentrytitle>Function template ireplace_last</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ireplace_last</refname><refpurpose>Replace last algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> ireplace_last(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> Collection1T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace the last match of the search string in the input with the format string.The input sequence is modified in-place. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>A reference to the modified input </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_nth_copy"><refmeta><refentrytitle>Function replace_nth_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_nth_copy</refname><refpurpose>Replace nth algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;replace_nth_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection3T &amp; Format);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>SequenceT</type> replace_nth_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection1T &amp; Search, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace an Nth (zero-indexed) match of the search string in the input with the format string. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Nth</term><listitem><para>An index of the match to be replaced. The index is 0-based. </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_nth"><refmeta><refentrytitle>Function template replace_nth</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_nth</refname><refpurpose>Replace nth algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> replace_nth(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> Collection1T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth, <emphasis role="bold">const</emphasis> Collection2T &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace an Nth (zero-indexed) match of the search string in the input with the format string. Input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Nth</term><listitem><para>An index of the match to be replaced. The index is 0-based. </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ireplace_nth_copy"><refmeta><refentrytitle>Function ireplace_nth_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ireplace_nth_copy</refname><refpurpose>Replace nth algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;ireplace_nth_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection3T &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>SequenceT</type> ireplace_nth_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection1T &amp; Search, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace an Nth (zero-indexed) match of the search string in the input with the format string. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Nth</term><listitem><para>An index of the match to be replaced. The index is 0-based. </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ireplace_nth"><refmeta><refentrytitle>Function template ireplace_nth</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ireplace_nth</refname><refpurpose>Replace nth algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> ireplace_nth(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> Collection1T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> Nth, <emphasis role="bold">const</emphasis> Collection2T &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace an Nth (zero-indexed) match of the search string in the input with the format string. Input sequence is modified in-place. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Nth</term><listitem><para>An index of the match to be replaced. The index is 0-based. </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_all_copy"><refmeta><refentrytitle>Function replace_all_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_all_copy</refname><refpurpose>Replace all algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;replace_all_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, <emphasis role="bold">const</emphasis> Collection3T &amp; Format);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>SequenceT</type> replace_all_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection1T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace all occurrences of the search string in the input with the format string. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_all"><refmeta><refentrytitle>Function template replace_all</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_all</refname><refpurpose>Replace all algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> replace_all(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> Collection1T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace all occurrences of the search string in the input with the format string. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>A reference to the modified input </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ireplace_all_copy"><refmeta><refentrytitle>Function ireplace_all_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ireplace_all_copy</refname><refpurpose>Replace all algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T, <emphasis role="bold">typename</emphasis> Collection3T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;ireplace_all_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, <emphasis role="bold">const</emphasis> Collection3T &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>SequenceT</type> ireplace_all_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection1T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace all occurrences of the search string in the input with the format string. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ireplace_all"><refmeta><refentrytitle>Function template ireplace_all</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ireplace_all</refname><refpurpose>Replace all algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> Collection1T, <emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> ireplace_all(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> Collection1T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Format, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace all occurrences of the search string in the input with the format string.The input sequence is modified in-place. Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_head_copy"><refmeta><refentrytitle>Function replace_head_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_head_copy</refname><refpurpose>Replace head algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;replace_head_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N, <emphasis role="bold">const</emphasis> Collection2T &amp; Format);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> replace_head_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace the head of the input with the given format string. The head is a prefix of a string of given size. If the sequence is shorter then required, whole string if considered to be the head. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>N</term><listitem><para>Length of the head </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_head"><refmeta><refentrytitle>Function template replace_head</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_head</refname><refpurpose>Replace head algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> replace_head(SequenceT &amp; Input, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace the head of the input with the given format string. The head is a prefix of a string of given size. If the sequence is shorter then required, the whole string is considered to be the head. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>N</term><listitem><para>Length of the head </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_tail_copy"><refmeta><refentrytitle>Function replace_tail_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_tail_copy</refname><refpurpose>Replace tail algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;replace_tail_copy(OutputIteratorT Output, <emphasis role="bold">const</emphasis> Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N, <emphasis role="bold">const</emphasis> Collection2T &amp; Format);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> replace_tail_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace the tail of the input with the given format string. The tail is a suffix of a string of given size. If the sequence is shorter then required, whole string is considered to be the tail. The result is a modified copy of the input. It is returned as a sequence or copied to the output iterator.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>N</term><listitem><para>Length of the tail </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a modified copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="replace_tail"><refmeta><refentrytitle>Function template replace_tail</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::replace_tail</refname><refpurpose>Replace tail algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> CollectionT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> replace_tail(SequenceT &amp; Input, <emphasis role="bold">unsigned</emphasis> <emphasis role="bold">int</emphasis> N, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> CollectionT &amp; Format);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Replace the tail of the input with the given format sequence. The tail is a suffix of a string of given size. If the sequence is shorter then required, the whole string is considered to be the tail. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Format</term><listitem><para>A substitute string </para></listitem></varlistentry><varlistentry><term>Input</term><listitem><para>An input string </para></listitem></varlistentry><varlistentry><term>N</term><listitem><para>Length of the tail </para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id264095"><title>Header &lt;<ulink url="../../boost/algorithm/string/sequence_traits.hpp">boost/algorithm/string/sequence_traits.hpp</ulink>&gt;</title><para>Traits defined in this header are used by various algorithms to achieve better performance for specific containers. Traits provide fail-safe defaults. If a container supports some of these features, it is possible to specialize the specific trait for this container. For lacking compilers, it is possible of define an override for a specific tester function.</para><para>Due to a language restriction, it is not currently possible to define specializations for stl containers without including the corresponding header. To decrease the overhead needed by this inclusion, user can selectively include a specialization header for a specific container. They are located in boost/algorithm/string/stl directory. Alternatively she can include boost/algorithm/string/std_collection_traits.hpp header which contains specializations for all stl containers.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <emphasis role="bold">class</emphasis> <link linkend="has_native_replace">has_native_replace</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <emphasis role="bold">class</emphasis> <link linkend="has_stable_iterators">has_stable_iterators</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <emphasis role="bold">class</emphasis> <link linkend="has_const_time_insert">has_const_time_insert</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <emphasis role="bold">class</emphasis> <link linkend="has_const_time_erase">has_const_time_erase</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="has_native_replace"><refmeta><refentrytitle>Class template has_native_replace</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::has_native_replace</refname><refpurpose>Native replace trait. </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; 
<emphasis role="bold">class</emphasis> has_native_replace {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> mpl::bool_&lt; value &gt; type;

&#xA0;&#xA0;<emphasis>// <link linkend="id404694-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type/> <link linkend="id404700-bb">BOOST_STATIC_CONSTANT</link>(<emphasis role="bold">bool</emphasis>, value = false) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This trait specifies that the sequence has <computeroutput>std::string</computeroutput>  like replace method </para><refsect2><title><anchor id="id404694-bb"/><computeroutput>has_native_replace</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type/> <anchor id="id404700-bb"/>BOOST_STATIC_CONSTANT(<emphasis role="bold">bool</emphasis> , value  = false) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="has_stable_iterators"><refmeta><refentrytitle>Class template has_stable_iterators</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::has_stable_iterators</refname><refpurpose>Stable iterators trait. </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; 
<emphasis role="bold">class</emphasis> has_stable_iterators {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> mpl::bool_&lt; value &gt; type;

&#xA0;&#xA0;<emphasis>// <link linkend="id430089-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type/> <link linkend="id299546-bb">BOOST_STATIC_CONSTANT</link>(<emphasis role="bold">bool</emphasis>, value = false) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This trait specifies that the sequence has stable iterators. It means that operations like insert/erase/replace do not invalidate iterators. </para><refsect2><title><anchor id="id430089-bb"/><computeroutput>has_stable_iterators</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type/> <anchor id="id299546-bb"/>BOOST_STATIC_CONSTANT(<emphasis role="bold">bool</emphasis> , value  = false) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="has_const_time_insert"><refmeta><refentrytitle>Class template has_const_time_insert</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::has_const_time_insert</refname><refpurpose>Const time insert trait. </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; 
<emphasis role="bold">class</emphasis> has_const_time_insert {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> mpl::bool_&lt; value &gt; type;

&#xA0;&#xA0;<emphasis>// <link linkend="id502277-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type/> <link linkend="id502283-bb">BOOST_STATIC_CONSTANT</link>(<emphasis role="bold">bool</emphasis>, value = false) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This trait specifies that the sequence's insert method has constant time complexity. </para><refsect2><title><anchor id="id502277-bb"/><computeroutput>has_const_time_insert</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type/> <anchor id="id502283-bb"/>BOOST_STATIC_CONSTANT(<emphasis role="bold">bool</emphasis> , value  = false) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="has_const_time_erase"><refmeta><refentrytitle>Class template has_const_time_erase</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::has_const_time_erase</refname><refpurpose>Const time erase trait. </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; 
<emphasis role="bold">class</emphasis> has_const_time_erase {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> mpl::bool_&lt; value &gt; type;

&#xA0;&#xA0;<emphasis>// <link linkend="id313377-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type/> <link linkend="id463066-bb">BOOST_STATIC_CONSTANT</link>(<emphasis role="bold">bool</emphasis>, value = false) ;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This trait specifies that the sequence's erase method has constant time complexity. </para><refsect2><title><anchor id="id313377-bb"/><computeroutput>has_const_time_erase</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type/> <anchor id="id463066-bb"/>BOOST_STATIC_CONSTANT(<emphasis role="bold">bool</emphasis> , value  = false) ;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id477625"><title>Header &lt;<ulink url="../../boost/algorithm/string/split.hpp">boost/algorithm/string/split.hpp</ulink>&gt;</title><para>Defines basic split algorithms. Split algorithms can be used to divide a string into several parts according to given criteria.</para><para>Each part is copied and added as a new element to the output container. Thus the result container must be able to hold copies of the matches (in a compatible structure like std::string) or a reference to it (e.g. using the iterator range class). Examples of such a container are <computeroutput>std::vector&lt;std::string&gt;</computeroutput>  or <computeroutput>std::list&lt;boost::iterator_range&lt;std::string::iterator&gt;&gt;</computeroutput></para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceSequenceT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceSequenceT &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="find_all">find_all</link>(SequenceSequenceT &amp;, Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceSequenceT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceSequenceT &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="ifind_all">ifind_all</link>(SequenceSequenceT &amp;, Collection1T &amp;, <emphasis role="bold">const</emphasis> Collection2T &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceSequenceT, <emphasis role="bold">typename</emphasis> CollectionT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceSequenceT &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id479732">split</link>(SequenceSequenceT &amp;, CollectionT &amp;, PredicateT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;token_compress_mode_type = token_compress_off);
&#xA0;&#xA0;}
}</synopsis><refentry id="find_all"><refmeta><refentrytitle>Function template find_all</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::find_all</refname><refpurpose>Find all algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceSequenceT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>SequenceSequenceT &amp;</type> 
&#xA0;&#xA0;find_all(SequenceSequenceT &amp; Result, Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This algorithm finds all occurrences of the search string in the input.</para><para>Each part is copied and added as a new element to the output container. Thus the result container must be able to hold copies of the matches (in a compatible structure like std::string) or a reference to it (e.g. using the iterator range class). Examples of such a container are <computeroutput>std::vector&lt;std::string&gt;</computeroutput>  or <computeroutput>std::list&lt;boost::iterator_range&lt;std::string::iterator&gt;&gt;</computeroutput></para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>A container which will be searched. </para></listitem></varlistentry><varlistentry><term>Result</term><listitem><para>A container that can hold copies of references to the substrings </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>A reference the result</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>Prior content of the result will be overwritten.</para><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="ifind_all"><refmeta><refentrytitle>Function template ifind_all</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::ifind_all</refname><refpurpose>Find all algorithm ( case insensitive ). </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceSequenceT, <emphasis role="bold">typename</emphasis> Collection1T, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> Collection2T&gt; 
&#xA0;&#xA0;<type>SequenceSequenceT &amp;</type> 
&#xA0;&#xA0;ifind_all(SequenceSequenceT &amp; Result, Collection1T &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> Collection2T &amp; Search, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This algorithm finds all occurrences of the search string in the input. Each part is copied and added as a new element to the output container. Thus the result container must be able to hold copies of the matches (in a compatible structure like std::string) or a reference to it (e.g. using the iterator range class). Examples of such a container are <computeroutput>std::vector&lt;std::string&gt;</computeroutput>  or <computeroutput>std::list&lt;boost::iterator_range&lt;std::string::iterator&gt;&gt;</computeroutput></para><para>Searching is case insensitive.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>A container which will be searched. </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for case insensitive comparison </para></listitem></varlistentry><varlistentry><term>Result</term><listitem><para>A container that can hold copies of references to the substrings </para></listitem></varlistentry><varlistentry><term>Search</term><listitem><para>A substring to be searched for. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>A reference the result</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>Prior content of the result will be overwritten.</para><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id479732"><refmeta><refentrytitle>Function template split</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::split</refname><refpurpose>Split algorithm. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceSequenceT, <emphasis role="bold">typename</emphasis> CollectionT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type>SequenceSequenceT &amp;</type> 
&#xA0;&#xA0;split(SequenceSequenceT &amp; Result, CollectionT &amp; Input, PredicateT Pred, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;token_compress_mode_type eCompress = token_compress_off);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Tokenize expression. This function is equivalent to C strtok. Input sequence is split into tokens, separated by separators. Separators are given by means of the predicate.</para><para>Each part is copied and added as a new element to the output container. Thus the result container must be able to hold copies of the matches (in a compatible structure like std::string) or a reference to it (e.g. using the iterator range class). Examples of such a container are <computeroutput>std::vector&lt;std::string&gt;</computeroutput>  or <computeroutput>std::list&lt;boost::iterator_range&lt;std::string::iterator&gt;&gt;</computeroutput></para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>A container which will be searched. </para></listitem></varlistentry><varlistentry><term>Pred</term><listitem><para>A predicate to identify separators. This predicate is supposed to return true if a given element is a separator. </para></listitem></varlistentry><varlistentry><term>Result</term><listitem><para>A container that can hold copies of references to the substrings </para></listitem></varlistentry><varlistentry><term>eCompress</term><listitem><para>If eCompress argument is set to token_compress_on, adjacent separators are merged together. Otherwise, every two separators delimit a token. </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>A reference the result</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>Prior content of the result will be overwritten.</para><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id349546"><title>Header &lt;<ulink url="../../boost/algorithm/string/std_containers_traits.hpp">boost/algorithm/string/std_containers_traits.hpp</ulink>&gt;</title><para>This file includes sequence traits for stl containers.</para></section><section id="id299529"><title>Header &lt;<ulink url="../../boost/algorithm/string.hpp">boost/algorithm/string.hpp</ulink>&gt;</title><para>Cumulative include for string_algo library</para></section><section id="id263316"><title>Header &lt;<ulink url="../../boost/algorithm/string_regex.hpp">boost/algorithm/string_regex.hpp</ulink>&gt;</title><para>Cumulative include for string_algo library. In addtion to string.hpp contains also regex-related stuff.</para></section><section id="id263327"><title>Header &lt;<ulink url="../../boost/algorithm/string/trim.hpp">boost/algorithm/string/trim.hpp</ulink>&gt;</title><para>Defines trim algorithms. Trim algorithms are used to remove trailing and leading spaces from a sequence (string). Space is recognized using given locales.</para><para>Parametric (<computeroutput>_if</computeroutput> ) variants use a predicate (functor) to select which characters are to be trimmed.. Functions take a selection predicate as a parameter, which is used to determine whether a character is a space. Common predicates are provided in classification.hpp header.</para><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> algorithm {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="trim_left_copy_if">trim_left_copy_if</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="trim_left_copy_if">trim_left_copy_if</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="trim_left_copy">trim_left_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="trim_left_if">trim_left_if</link>(SequenceT &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="trim_left">trim_left</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="trim_right_copy_if">trim_right_copy_if</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="trim_right_copy_if">trim_right_copy_if</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="trim_right_copy">trim_right_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="trim_right_if">trim_right_if</link>(SequenceT &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="trim_right">trim_right</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="trim_copy_if">trim_copy_if</link>(OutputIteratorT, <emphasis role="bold">const</emphasis> CollectionT &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="trim_copy_if">trim_copy_if</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>SequenceT</type> <link linkend="trim_copy">trim_copy</link>(<emphasis role="bold">const</emphasis> SequenceT &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="trim_if">trim_if</link>(SequenceT &amp;, PredicateT);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="trim">trim</link>(SequenceT &amp;, <emphasis role="bold">const</emphasis> std::locale &amp; = std::locale());
&#xA0;&#xA0;}
}</synopsis><refentry id="trim_left_copy_if"><refmeta><refentrytitle>Function trim_left_copy_if</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::trim_left_copy_if</refname><refpurpose>Left trim - parametric. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;trim_left_copy_if(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;PredicateT IsSpace);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> trim_left_copy_if(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, PredicateT IsSpace);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all leading spaces from the input. The supplied predicate is used to determine which characters are considered spaces. The result is a trimmed copy of the input. It is returned as a sequence or copied to the output iterator</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input collection </para></listitem></varlistentry><varlistentry><term>IsSpace</term><listitem><para>An unary predicate identifying spaces </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="trim_left_copy"><refmeta><refentrytitle>Function template trim_left_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::trim_left_copy</refname><refpurpose>Left trim - parametric. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> trim_left_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all leading spaces from the input. The result is a trimmed copy of the input.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>a locale used for 'space' classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>A trimmed copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="trim_left_if"><refmeta><refentrytitle>Function template trim_left_if</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::trim_left_if</refname><refpurpose>Left trim. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> trim_left_if(SequenceT &amp; Input, PredicateT IsSpace);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all leading spaces from the input. The supplied predicate is used to determine which characters are considered spaces. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>IsSpace</term><listitem><para>An unary predicate identifying spaces </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="trim_left"><refmeta><refentrytitle>Function template trim_left</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::trim_left</refname><refpurpose>Left trim. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> trim_left(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all leading spaces from the input. The Input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for 'space' classification </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="trim_right_copy_if"><refmeta><refentrytitle>Function trim_right_copy_if</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::trim_right_copy_if</refname><refpurpose>Right trim - parametric. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;trim_right_copy_if(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;PredicateT IsSpace);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> trim_right_copy_if(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, PredicateT IsSpace);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all trailing spaces from the input. The supplied predicate is used to determine which characters are considered spaces. The result is a trimmed copy of the input. It is returned as a sequence or copied to the output iterator</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input collection </para></listitem></varlistentry><varlistentry><term>IsSpace</term><listitem><para>An unary predicate identifying spaces </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="trim_right_copy"><refmeta><refentrytitle>Function template trim_right_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::trim_right_copy</refname><refpurpose>Right trim. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> trim_right_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all trailing spaces from the input. The result is a trimmed copy of the input</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for 'space' classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>A trimmed copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="trim_right_if"><refmeta><refentrytitle>Function template trim_right_if</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::trim_right_if</refname><refpurpose>Right trim - parametric. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> trim_right_if(SequenceT &amp; Input, PredicateT IsSpace);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all trailing spaces from the input. The supplied predicate is used to determine which characters are considered spaces. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>IsSpace</term><listitem><para>An unary predicate identifying spaces </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="trim_right"><refmeta><refentrytitle>Function template trim_right</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::trim_right</refname><refpurpose>Right trim. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> trim_right(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all trailing spaces from the input. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for 'space' classification </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="trim_copy_if"><refmeta><refentrytitle>Function trim_copy_if</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::trim_copy_if</refname><refpurpose>Trim - parametric. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> OutputIteratorT, <emphasis role="bold">typename</emphasis> CollectionT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type>OutputIteratorT</type> 
&#xA0;&#xA0;trim_copy_if(OutputIteratorT Output, <emphasis role="bold">const</emphasis> CollectionT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;PredicateT IsSpace);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> trim_copy_if(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, PredicateT IsSpace);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all trailing and leading spaces from the input. The supplied predicate is used to determine which characters are considered spaces. The result is a trimmed copy of the input. It is returned as a sequence or copied to the output iterator</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input collection </para></listitem></varlistentry><varlistentry><term>IsSpace</term><listitem><para>An unary predicate identifying spaces </para></listitem></varlistentry><varlistentry><term>Output</term><listitem><para>An output iterator to which the result will be copied </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>An output iterator pointing just after the last inserted character or a copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>The second variant of this function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="trim_copy"><refmeta><refentrytitle>Function template trim_copy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::trim_copy</refname><refpurpose>Trim. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type>SequenceT</type> trim_copy(<emphasis role="bold">const</emphasis> SequenceT &amp; Input, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all leading and trailing spaces from the input. The result is a trimmed copy of the input</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for 'space' classification </para></listitem></varlistentry></variablelist><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>A trimmed copy of the input</para></listitem></varlistentry><varlistentry><term>Notes</term><listitem><para>This function provides the strong exception-safety guarantee </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="trim_if"><refmeta><refentrytitle>Function template trim_if</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::trim_if</refname><refpurpose>Trim. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT, <emphasis role="bold">typename</emphasis> PredicateT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> trim_if(SequenceT &amp; Input, PredicateT IsSpace);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all leading and trailing spaces from the input. The supplied predicate is used to determine which characters are considered spaces. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>IsSpace</term><listitem><para>An unary predicate identifying spaces </para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="trim"><refmeta><refentrytitle>Function template trim</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::algorithm::trim</refname><refpurpose>Trim. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> SequenceT&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> trim(SequenceT &amp; Input, <emphasis role="bold">const</emphasis> std::locale &amp; Loc = std::locale());</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Remove all leading and trailing spaces from the input. The input sequence is modified in-place.</para><para/><variablelist spacing="compact"><title>Parameters</title><varlistentry><term>Input</term><listitem><para>An input sequence </para></listitem></varlistentry><varlistentry><term>Loc</term><listitem><para>A locale used for 'space' classification </para></listitem></varlistentry></variablelist></refsect1></refentry></section></section><section id="string_algo.rationale" rev:last-revision="$Date: 2004/07/16 09:06:39 $" xml:base="../libs/algorithm/string/doc/rationale.xml"><title>Rationale</title><section it="string_algo.locale"><title>Locales</title><para>
            Locales have a very close relation to string processing. They contain information about
            the character sets and are used, for example, to change the case of characters and 
            to classify the characters. 
        </para><para>
            C++ allows to work with multiple different instances of locales at once. If an algorithm
            manipulates some data in a way that requires the usage of locales, there must be a way
            to specify them. However, one instance of locales is sufficient for most of the applications,
            and for a user it could be very tedious to specify which locales to use at every place 
            where it is needed. 
        </para><para>
            Fortunately, the C++ standard allows to specify the <emphasis>global</emphasis> locales (using static member
            function <computeroutput>std:locale::global()</computeroutput>). When instantiating an
            <computeroutput>std::locale</computeroutput> class without explicit information, the instance will 
            be initialized with the <emphasis>global</emphasis> locale. This implies, that if an algorithm needs a locale,
            it should have an <computeroutput>std::locale</computeroutput> parameter defaulting to  <computeroutput>std::locale()</computeroutput>.
            If a user needs to specify locales explicitly, she can do so. Otherwise the <emphasis>global</emphasis>
            locales are used.
        </para></section><section id="string_algo.regex"><title>Regular Expressions</title><para>
            Regular expressions are an essential part of text processing. For this reason, the library 
            also provides regex variants of some algorithms. The library does not attempt to replace
            Boost.Regex; it merely wraps its functionality in a new interface.
            As a part of this library, regex algorithms integrate smoothly with other components, which 
            brings additional value.
        </para></section></section><section id="string_algo.env" rev:last-revision="$Date: 2004/07/15 21:47:21 $" xml:base="../libs/algorithm/string/doc/environment.xml"><title>Environment</title><section><title>Build</title><para>
            The whole library is provided in headers. Regex variants of some algorithms, 
            however, are dependent on the Boost.Regex library. All such algorithms are
            separated in <link linkend="id263316">boost/algorithm/string_regex.hpp</link>. 
            If this header is used, the application must be linked with the Boost.Regex 
            library. 
        </para></section><section><title>Examples</title><para>
            Examples showing the basic usage of the library can be found in the libs/algorithm/string/example
            directory. There is a separate file for the each part of the library. Please follow the boost
            build guidelines to build examples using the bjam. To successfully build regex examples 
            the Boost.Regex library is required. 
        </para></section><section><title>Tests</title><para>
            A full set of test cases for the library is located in the libs/algorithm/string/test directory. 
            The test cases can be executed using the boost build system. For the tests of regular 
            expression variants of algorithms, the Boost.Regex library is required. 
        </para></section><section><title>Portability</title><para>
            The library has been successfully compiled and tested with the following compilers:
            
            <itemizedlist><listitem>Microsoft Visual C++ 7.0</listitem><listitem>Microsoft Visual C++ 7.1</listitem><listitem>GCC 3.2</listitem><listitem>GCC 3.3.1</listitem></itemizedlist>

            See <ulink url="http://boost.sourceforge.net/regression-logs/">Boost regression tables</ulink>
            for additional info for a particular compiler.
        </para><para>
            There are known limitation on platforms not supporting partial template specialization. 
            Library depends on correctly implemented <computeroutput>std::iterator_traits</computeroutput> class. 
            If a standard library provided with compiler is broken, the String Algorithm Library 
            cannot function properly. Usually it implies that primitive pointer iterators are not 
            working with the library functions. 
        </para></section></section><section id="string_algo.credits" rev:last-revision="$Date: 2004/08/03 17:28:02 $" xml:base="../libs/algorithm/string/doc/credits.xml"><title>Credits</title><section id="string_algo.ack"><title>Acknowledgments</title><para>
            The author would like to thank everybody who gave suggestions and comments. Especially valuable
            were the contributions of Thorsten Ottosen, Jeff Garland and the other boost members who participated
            in the review process, namely David Abrahams, Daniel Frey, Beman Dawes, John Maddock, David B.Held, Pavel Vozenilek
            and many other.
        </para><para>
            Additional thanks go to Stefan Slapeta and Toon Knapen, who have been very resourceful in solving various
            portability issues.
        </para></section></section></chapter><chapter xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="threads" rev:last-revision="$Date: 2004/07/17 04:33:59 $"><chapterinfo><author><firstname>William</firstname><othername>E.</othername><surname>Kempf</surname></author><copyright><year>2001</year><year>2002</year><year>2003</year><holder>William E. Kempf</holder></copyright><legalnotice><para>Permission to use, copy, modify, distribute and sell this
      software and its documentation for any purpose is hereby granted
      without fee, provided that the above copyright notice appear in all
      copies and that both that copyright notice and this permission notice
      appear in supporting documentation. William E. Kempf makes no
      representations about the suitability of this software for any purpose.
      It is provided "as is" without express or implied warranty.</para></legalnotice></chapterinfo><title><emphasis role="bold">Boost.Threads</emphasis></title><section id="threads.overview" rev:last-revision="$Date: 2004/07/17 04:33:59 $" xml:base="../libs/thread/doc/overview.xml"><title>Overview</title><section id="threads.introduction"><title>Introduction</title><para><emphasis role="bold">Boost.Threads</emphasis> allows C++ programs to execute as multiple,
    asynchronous, independent threads-of-execution. Each thread has its own
    machine state including program instruction counter and registers. Programs
    which execute as multiple threads are called multithreaded programs to
    distinguish them from traditional single-threaded programs. The <link linkend="threads.glossary">glossary</link> gives a more complete description
	of the multithreading execution environment.</para><para>Multithreading provides several advantages:
    <itemizedlist><listitem><para>Programs which would otherwise block waiting for some external
        event can continue to respond if the blocking operation is placed in a
        separate thread. Multithreading is usually an absolute requirement for
        these programs.</para></listitem><listitem><para>Well-designed multithreaded programs may execute faster than
        single-threaded programs, particularly on multiprocessor hardware.
        Note, however, that poorly-designed multithreaded programs are often
        slower than single-threaded programs.</para></listitem><listitem><para>Some program designs may be easier to formulate using a
        multithreaded approach. After all, the real world is
        asynchronous!</para></listitem></itemizedlist></para></section><section><title>Dangers</title><section><title>General considerations</title><para>Beyond the errors which can occur in single-threaded programs,
    multithreaded programs are subject to additional errors:
    <itemizedlist><listitem><para><link linkend="threads.glossary.race-condition">Race
	    conditions</link></para></listitem><listitem><para><link linkend="threads.glossary.deadlock">Deadlock</link>
        (sometimes called "deadly embrace")</para></listitem><listitem><para><link linkend="threads.glossary.priority-failure">Priority
        failures</link> (priority inversion, infinite overtaking, starvation,
		etc.)</para></listitem></itemizedlist></para><para>Every multithreaded program must be designed carefully to avoid these
	errors. These aren't rare or exotic failures - they are virtually guaranteed
	to occur unless multithreaded code is designed to avoid them. Priority
	failures are somewhat less common, but are nonetheless serious.</para><para>The <link linkend="threads.design"><emphasis role="bold">Boost.Threads</emphasis> design</link>
    attempts to minimize these errors, but they will still occur unless the
    programmer proactively designs to avoid them.</para><note>Please also see <xref linkend="threads.implementation_notes"/>
	for additional, implementation-specific considerations.</note></section><section><title>Testing and debugging considerations</title><para>Multithreaded programs are non-deterministic. In other words, the
      same program with the same input data may follow different execution
      paths each time it is invoked. That can make testing and debugging a
      nightmare:
      <itemizedlist><listitem><para>Failures are often not repeatable.</para></listitem><listitem><para>Probe effect causes debuggers to produce very different results
          from non-debug uses.</para></listitem><listitem><para>Debuggers require special support to show thread state.</para></listitem><listitem><para>Tests on a single processor system may give no indication of
          serious errors which would appear on multiprocessor systems, and visa
          versa. Thus test cases should include a varying number of
          processors.</para></listitem><listitem><para>For programs which create a varying number of threads according
          to workload, tests which don't span the full range of possibilities
          may miss serious errors.</para></listitem></itemizedlist></para></section><section><title>Getting a head start</title><para>Although it might appear that multithreaded programs are inherently
      unreliable, many reliable multithreaded programs do exist. Multithreading
      techniques are known which lead to reliable programs.</para><para>Design patterns for reliable multithreaded programs, including the
      important <emphasis>monitor</emphasis> pattern, are presented in 
      <emphasis>Pattern-Oriented Software Architecture Volume 2 - Patterns for
      Concurrent and Networked Objects</emphasis><citation><xref linkend="threads.bib.SchmidtStalRohnertBuschmann" endterm="threads.bib.SchmidtStalRohnertBuschmann.abbrev"/></citation>. Many important multithreading programming
	  considerations (independent of threading library) are discussed in
	  <emphasis>Programming with POSIX Threads</emphasis><citation><xref linkend="threads.bib.Butenhof97" endterm="threads.bib.Butenhof97.abbrev"/></citation>.</para><para>Doing some reading before attempting multithreaded designs will
      give you a head start toward reliable multithreaded programs.</para></section></section><section><title>C++ Standard Library usage in multithreaded programs</title><section><title>Runtime libraries</title><para><emphasis role="bold">Warning:</emphasis> Multithreaded programs such as
	  those using <emphasis role="bold">Boost.Threads</emphasis> must link to <link linkend="threads.glossary.thread-safe">thread-safe</link> versions of
	  all runtime libraries used by the program, including the runtime library
	  for the C++ Standard Library. Failure to do so will cause <link linkend="threads.glossary.race-condition">race conditions</link> to occur
	  when multiple threads simultaneously execute runtime library functions for
	  <computeroutput>new</computeroutput>, <computeroutput>delete</computeroutput>, or other language features which
	  imply shared state.</para></section><section><title>Potentially non-thread-safe functions</title><para>Certain C++ Standard Library functions inherited from C are
      particular problems because they hold internal state between
      calls:
      <itemizedlist><listitem><para><computeroutput>rand</computeroutput></para></listitem><listitem><para><computeroutput>strtok</computeroutput></para></listitem><listitem><para><computeroutput>asctime</computeroutput></para></listitem><listitem><para><computeroutput>ctime</computeroutput></para></listitem><listitem><para><computeroutput>gmtime</computeroutput></para></listitem><listitem><para><computeroutput>localtime</computeroutput></para></listitem></itemizedlist></para><para>It is possible to write thread-safe implementations of these by
      using thread specific storage (see
	  <link linkend="thread_specific_ptr">boost::thread_specific_ptr</link>), and several C++ 
	  compiler vendors do just that. The technique is well-know and is explained
	  in <citation><xref linkend="threads.bib.Butenhof97" endterm="threads.bib.Butenhof97.abbrev"/></citation>.</para><para>But at least one vendor (HP-UX) does not provide thread-safe
      implementations of the above functions in their otherwise thread-safe
      runtime library. Instead they provide replacement functions with
      different names and arguments.</para><para><emphasis role="bold">Recommendation:</emphasis> For the most
	  portable, yet thread-safe code, use Boost replacements for the problem
	  functions. See the Boost Random Number Library
	  and Boost Tokenizer Library.</para></section></section><section><title>Common guarantees for all <emphasis role="bold">Boost.Threads</emphasis> components</title><section><title>Exceptions</title><para><emphasis role="bold">Boost.Threads</emphasis> destructors never
	  throw exceptions. Unless otherwise specified, other
	  <emphasis role="bold">Boost.Threads</emphasis> functions that do not have
	  an exception-specification may throw implementation-defined
	  exceptions.</para><para>In particular, <emphasis role="bold">Boost.Threads</emphasis>
	  reports failure to allocate storage by throwing an exception of type
	  <computeroutput>std::bad_alloc</computeroutput> or a class derived from
	  <computeroutput>std::bad_alloc</computeroutput>, failure to obtain thread resources other than
	  memory by throwing an exception of type
	  <link linkend="thread_resource_error">boost::thread_resource_error</link>, and certain lock
	  related failures by throwing an exception of type
	  <link linkend="lock_error">boost::lock_error</link>.</para><para><emphasis role="bold">Rationale:</emphasis> Follows the C++ Standard
	  Library practice of allowing all functions except destructors or other
	  specified functions to throw exceptions on errors.</para></section><section><title>NonCopyable requirement</title><para><emphasis role="bold">Boost.Threads</emphasis> classes documented as
	  meeting the NonCopyable requirement disallow copy construction and copy
	  assignment. For the sake of exposition, the synopsis of such classes show
	  private derivation from boost::noncopyable. Users
	  should not depend on this derivation, however, as implementations are free
	  to meet the NonCopyable requirement in other ways.</para></section></section></section><section id="threads.design" rev:last-revision="$Date: 2004/07/17 04:33:59 $" xml:base="../libs/thread/doc/design.xml"><title>Design</title><para>With client/server and three-tier architectures becoming common place
  in today's world, it's becoming increasingly important for programs to be
  able to handle parallel processing. Modern day operating systems usually
  provide some support for this through native thread APIs. Unfortunately,
  writing portable code that makes use of parallel processing in C++ is made
  very difficult by a lack of a standard interface for these native APIs.
  Further, these APIs are almost universally C APIs and fail to take
  advantage of C++'s strengths, or to address concepts unique to C++, such as
  exceptions.</para><para>The <emphasis role="bold">Boost.Threads</emphasis> library is an attempt to define a portable interface
  for writing parallel processes in C++.</para><section id="threads.design.goals"><title>Goals</title><para>The <emphasis role="bold">Boost.Threads</emphasis> library has several goals that should help to set
	it apart from other solutions. These goals are listed in order of precedence
	with full descriptions below.
    <variablelist><varlistentry><term>Portability</term><listitem><para><emphasis role="bold">Boost.Threads</emphasis> was designed to be highly portable. The goal is
		  for the interface to be easily implemented on any platform that
		  supports threads, and possibly even on platforms without native thread
		  support.</para></listitem></varlistentry><varlistentry><term>Safety</term><listitem><para><emphasis role="bold">Boost.Threads</emphasis> was designed to be as safe as possible. Writing
		  <link linkend="threads.glossary.thread-safe">thread-safe</link>
		  code is very difficult and successful libraries must strive to
		  insulate the programmer from dangerous constructs as much as
		  possible. This is accomplished in several ways:
          <itemizedlist><listitem><para>C++ language features are used to make correct usage easy
			  (if possible) and error-prone usage impossible or at least more
			  difficult. For example, see the <link linkend="threads.concepts.Mutex">Mutex</link> and <link linkend="threads.concepts.Lock">Lock</link> designs, and note
			  how they interact.</para></listitem><listitem><para>Certain traditional concurrent programming features are
			  considered so error-prone that they are not provided at all. For
			  example, see <xref linkend="threads.rationale.events"/>.</para></listitem><listitem><para>Dangerous features, or features which may be misused, are
              identified as such in the documentation to make users aware of
              potential pitfalls.</para></listitem></itemizedlist></para></listitem></varlistentry><varlistentry><term>Flexibility</term><listitem><para><emphasis role="bold">Boost.Threads</emphasis> was designed to be flexible. This goal is often
		  at odds with <emphasis>safety</emphasis>. When functionality might be
		  compromised by the desire to keep the interface safe, <emphasis role="bold">Boost.Threads</emphasis>
		  has been designed to provide the functionality, but to make it's use
		  prohibitive for general use. In other words, the interfaces have been
		  designed such that it's usually obvious when something is unsafe, and
		  the documentation is written to explain why.</para></listitem></varlistentry><varlistentry><term>Efficiency</term><listitem><para><emphasis role="bold">Boost.Threads</emphasis> was designed to be as efficient as
		  possible. When building a library on top of another library there is
		  always a danger that the result will be so much slower than the
		  "native" API that programmers are inclined to ignore the higher level
		  API. <emphasis role="bold">Boost.Threads</emphasis> was designed to minimize the chances of this
		  occurring. The interfaces have been crafted to allow an implementation
		  the greatest chance of being as efficient as possible. This goal is
		  often at odds with the goal for <emphasis>safety</emphasis>. Every
		  effort was made to ensure efficient implementations, but when in
		  conflict <emphasis>safety</emphasis> has always taken
		  precedence.</para></listitem></varlistentry></variablelist></para></section><section><title>Iterative Phases</title><para>Another goal of <emphasis role="bold">Boost.Threads</emphasis> was to take a dynamic, iterative
	approach in its development. The computing industry is still exploring the
	concepts of parallel programming. Most thread libraries supply only simple
	primitive concepts for thread synchronization. These concepts are very
	simple, but it is very difficult to use them safely or to provide formal
	proofs for constructs built on top of them. There has been a lot of research
	into other concepts, such as in "Communicating Sequential Processes."
	<emphasis role="bold">Boost.Threads</emphasis> was designed in iterative steps, with each step providing 
	the building blocks necessary for the next step and giving the researcher 
	the tools necessary to explore new concepts in a portable manner.</para><para>Given the goal of following a dynamic, iterative approach
	<emphasis role="bold">Boost.Threads</emphasis> shall go through several growth cycles. Each phase in its
	development shall be roughly documented here.</para></section><section><title>Phase 1, Synchronization Primitives</title><para>Boost is all about providing high quality libraries with
	implementations for many platforms. Unfortunately, there's a big problem
	faced by developers wishing to supply such high quality libraries, namely
	thread-safety. The C++ standard doesn't address threads at all, but real
	world programs often make use of native threading support. A portable
	library that doesn't address the issue of thread-safety is therefore not
	much help to a programmer who wants to use the library in his multithreaded
	application. So there's a very great need for portable primitives that will
	allow the library developer to create <link linkend="threads.glossary.thread-safe">thread-safe</link>
	implementations. This need far out weighs the need for portable methods to
	create and manage threads.</para><para>Because of this need, the first phase of <emphasis role="bold">Boost.Threads</emphasis> focuses
	solely on providing portable primitive concepts for thread
	synchronization. Types provided in this phase include the
	<link linkend="mutex">boost::mutex</link>, 
	<link linkend="try_mutex">boost::try_mutex</link>,
	<link linkend="timed_mutex">boost::timed_mutex</link>, 
	<link linkend="recursive_mutex">boost::recursive_mutex</link>,
	<link linkend="recursive_try_mutex">boost::recursive_try_mutex</link>,
	<link linkend="recursive_timed_mutex">boost::recursive_timed_mutex</link>, and
	<link linkend="lock_error">boost::lock_error</link>. These are considered the "core"
	synchronization primitives, though there are others that will be added in
	later phases.</para></section><section id="threads.design.phase2"><title>Phase 2, Thread Management and Thread Specific Storage</title><para>This phase addresses the creation and management of threads and
    provides a mechanism for thread specific storage (data associated with a
    thread instance). Thread management is a tricky issue in C++, so this
    phase addresses only the basic needs of multithreaded program. Later
    phases are likely to add additional functionality in this area. This
    phase of <emphasis role="bold">Boost.Threads</emphasis> adds the <link linkend="thread">boost::thread</link> and
	<link linkend="thread_specific_ptr">boost::thread_specific_ptr</link> types. With these
	additions the <emphasis role="bold">Boost.Threads</emphasis> library can be considered minimal but
	complete.</para></section><section><title>The Next Phase</title><para>The next phase will address more advanced synchronization concepts,
    such as read/write mutexes and barriers.</para></section></section><section id="threads.concepts" rev:last-revision="$Date: 2004/11/18 23:55:33 $" xml:base="../libs/thread/doc/concepts.xml"><title>Concepts</title><para><emphasis role="bold">Boost.Threads</emphasis> currently supports two types of mutex concepts:
	ordinary <link linkend="threads.concepts.mutexes">Mutexes</link>,
	which allow only one thread at a time to access a resource, and
	<link linkend="threads.concepts.read-write-mutexes">Read/Write Mutexes</link>,
	which allow only one thread at a time to access a resource when it is
	being modified (the "Write" part of Read/Write), but allows multiple threads
	to access a resource when it is only being referenced (the "Read" part of
	Read/Write).</para><section id="threads.concepts.mutexes"><title>Mutexes</title><note>Certain changes to the mutexes and lock concepts are
		currently under discussion. In particular, the combination of
		the multiple lock concepts into a single lock concept
		is likely, and the combination of the multiple mutex
		concepts into a single mutex concept is also possible.</note><para>A mutex (short for mutual-exclusion) object is used to serialize
		access to a resource shared between multiple threads. The
		<link linkend="threads.concepts.Mutex">Mutex</link> concept, with
		<link linkend="threads.concepts.TryMutex">TryMutex</link> and
		<link linkend="threads.concepts.TimedMutex">TimedMutex</link> refinements,
		formalize the requirements. A model that implements Mutex and its
		refinements has two states: <emphasis role="bold">locked</emphasis> and
		<emphasis role="bold">unlocked</emphasis>. Before using a shared resource, a
		thread locks a <emphasis role="bold">Boost.Threads</emphasis> mutex object
		(an object whose type is a model of
		<link linkend="threads.concepts.Mutex">Mutex</link> or one of it's
		refinements), ensuring
		<link linkend="threads.glossary.thread-safe">thread-safe</link> access to
		the shared resource. When use of the shared resource is complete, the thread
		unlocks the mutex object, allowing another thread to acquire the lock and
		use the shared resource.</para><para>Traditional C thread APIs, like POSIX threads or the Windows thread
		APIs, expose functions to lock and unlock a mutex object. This is dangerous
		since it's easy to forget to unlock a locked mutex. When the flow of control
		is complex, with multiple return points, the likelihood of forgetting to
		unlock a mutex object becomes even greater. When exceptions are thrown,
		it becomes nearly impossible to ensure that the mutex object is unlocked
		properly when using these traditional API's. The result is
		<link linkend="threads.glossary.deadlock">deadlock</link>.</para><para>Many C++ threading libraries use a pattern known as <emphasis>Scoped
		Locking</emphasis><citation><xref linkend="threads.bib.SchmidtStalRohnertBuschmann" endterm="threads.bib.SchmidtStalRohnertBuschmann.abbrev"/></citation> to free the programmer from
		the need to explicitly lock and unlock mutex objects. With this pattern, a
		<link linkend="threads.concepts.lock-concepts">Lock</link> concept is employed where
		the lock object's constructor locks the associated mutex object and the
		destructor automatically does the unlocking. The
		<emphasis role="bold">Boost.Threads</emphasis> library takes this pattern to
		the extreme in that Lock concepts are the only way to lock and unlock a
		mutex object: lock and unlock functions are not exposed by any
		<emphasis role="bold">Boost.Threads</emphasis> mutex objects. This helps to
		ensure safe usage patterns, especially when code throws exceptions.</para><section id="threads.concepts.locking-strategies"><title>Locking Strategies</title><para>Every mutex object follows one of several locking strategies. These
			strategies define the semantics for the locking operation when the calling
			thread already owns a lock on the mutex object.</para><section id="threads.concepts.recursive-locking-strategy"><title>Recursive Locking Strategy</title><para>With a recursive locking strategy, when a thread attempts to acquire
				a lock on the mutex object for which it already owns a lock, the operation
				is successful. Note the distinction between a thread, which may have
				multiple locks outstanding on a recursive mutex object, and a lock object,
				which even for a recursive mutex object cannot have any of its lock
				functions called multiple times without first calling unlock.</para><para>Internally a lock count is maintained and the owning thread must
				unlock the mutex object the same number of times that it locked it before
				the mutex object's state returns to unlocked. Since mutex objects in
				<emphasis role="bold">Boost.Threads</emphasis> expose locking
				functionality only through lock concepts, a thread will always unlock a
				mutex object the same number of times that it locked it. This helps to
				eliminate a whole set of errors typically found in traditional C style
				thread APIs.</para><para>Classes <link linkend="recursive_mutex">boost::recursive_mutex</link>,
				<link linkend="recursive_try_mutex">boost::recursive_try_mutex</link> and
				<link linkend="recursive_timed_mutex">boost::recursive_timed_mutex</link> use this locking
				strategy.</para></section><section id="threads.concepts.checked-locking-strategy"><title>Checked Locking Strategy</title><para>With a checked locking strategy, when a thread attempts to acquire a
				lock on the mutex object for which the thread already owns a lock, the
				operation will fail with some sort of error indication. Further, attempts
				by a thread to unlock a mutex object that was not locked by the thread
				will also return some sort of error indication. In
				<emphasis role="bold">Boost.Threads</emphasis>, an exception of type
				<link linkend="lock_error">boost::lock_error</link> 
				would be thrown in these cases.</para><para><emphasis role="bold">Boost.Threads</emphasis> does not currently
				provide any mutex objects that use this strategy.</para></section><section id="threads.concepts.unchecked-locking-strategy"><title>Unchecked Locking Strategy</title><para>With an unchecked locking strategy, when a thread attempts to acquire
				a lock on a mutex object for which the thread already owns a lock the
				operation will
				<link linkend="threads.glossary.deadlock">deadlock</link>. In general
				this locking strategy is less safe than a checked or recursive strategy,
				but it's also a faster strategy and so is employed by many libraries.</para><para><emphasis role="bold">Boost.Threads</emphasis> does not currently
				provide any mutex objects that use this strategy.</para></section><section id="threads.concepts.unspecified-locking-strategy"><title>Unspecified Locking Strategy</title><para>With an unspecified locking strategy, when a thread attempts to
				acquire a lock on a mutex object for which the thread already owns a lock
				the operation results in 
				<link linkend="threads.glossary.undefined-behavior">undefined behavior</link>.
				</para><para>In general a mutex object with an unspecified locking strategy is
				unsafe, and it requires programmer discipline to use the mutex object
				properly. However, this strategy allows an implementation to be as fast as
				possible with no restrictions on its implementation. This is especially
				true for portable implementations that wrap the native threading support
				of a platform. For this reason, the classes
				<link linkend="mutex">boost::mutex</link>,
				<link linkend="try_mutex">boost::try_mutex</link> and
				<link linkend="timed_mutex">boost::timed_mutex</link> use this locking strategy
				despite the lack of safety.</para></section></section><section id="threads.concepts.sheduling-policies"><title>Scheduling Policies</title><para>Every mutex object follows one of several scheduling policies. These
			policies define the semantics when the mutex object is unlocked and there is
			more than one thread waiting to acquire a lock. In other words, the policy
			defines which waiting thread shall acquire the lock.</para><section id="threads.concepts.FIFO-scheduling-policy"><title>FIFO Scheduling Policy</title><para>With a FIFO ("First In First Out") scheduling policy, threads waiting 
				for the lock will acquire it in a first-come-first-served order.
				This can help prevent a high priority thread from starving lower priority
				threads that are also waiting on the mutex object's lock.</para></section><section id="threads.concepts.priority-driven-scheduling-policy"><title>Priority Driven Policy</title><para>With a Priority Driven scheduling policy, the thread with the
				highest priority acquires the lock. Note that this means that low-priority
				threads may never acquire the lock if the mutex object has high contention
				and there is always at least one high-priority thread waiting. This is
				known as thread starvation. When multiple threads of the same priority are
				waiting on the mutex object's lock one of the other scheduling priorities
				will determine which thread shall acquire the lock.</para></section><section id="threads.concepts.unspecified-scheduling-policy"><title>Unspecified Policy</title><para>The mutex object does not specify a scheduling policy. In order to
				ensure portability, all <emphasis role="bold">Boost.Threads</emphasis>
				mutex objects use an unspecified scheduling policy.</para></section></section><section id="threads.concepts.mutex-concepts"><title>Mutex Concepts</title><section id="threads.concepts.Mutex"><title>Mutex Concept</title><para>A Mutex object has two states: locked and unlocked. Mutex object
				state can only be determined by a lock object meeting the
				appropriate lock concept requirements
				and constructed for the Mutex object.</para><para>A Mutex is
				<ulink url="../../libs/utility/utility.htm#Class%20noncopyable">
				NonCopyable</ulink>.</para><para>For a Mutex type <computeroutput>M</computeroutput>
				and an object <computeroutput>m</computeroutput> of that type, 
				the following expressions must be well-formed
				and have the indicated effects.</para><table><title>Mutex Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry>M m;</entry><entry><para>Constructs a mutex object m.</para><para>Postcondition: m is unlocked.</para></entry></row><row><entry>(&amp;m)-&gt;~M();</entry><entry>Precondition: m is unlocked. Destroys a mutex object
								m.</entry></row><row><entry>M::scoped_lock</entry><entry>A model of
								<link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry></row></tbody></tgroup></table></section><section id="threads.concepts.TryMutex"><title>TryMutex Concept</title><para>A TryMutex is a refinement of
				<link linkend="threads.concepts.Mutex">Mutex</link>. 
				For a TryMutex type <computeroutput>M</computeroutput>
				and an object <computeroutput>m</computeroutput> of that type, 
				the following expressions must be well-formed 
				and have the indicated effects.</para><table><title>TryMutex Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry>M::scoped_try_lock</entry><entry>A model of
								<link linkend="threads.concepts.ScopedTryLock">ScopedTryLock</link></entry></row></tbody></tgroup></table></section><section id="threads.concepts.TimedMutex"><title>TimedMutex Concept</title><para>A TimedMutex is a refinement of
				<link linkend="threads.concepts.TryMutex">TryMutex</link>. 
				For a TimedMutex type <computeroutput>M</computeroutput>
				and an object <computeroutput>m</computeroutput> of that type, 
				the following expressions must be well-formed
				and have the indicated effects.</para><table><title>TimedMutex Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry>M::scoped_timed_lock</entry><entry>A model of
								<link linkend="threads.concepts.ScopedTimedLock">ScopedTimedLock</link></entry></row></tbody></tgroup></table></section></section><section id="threads.concepts.mutex-models"><title>Mutex Models</title><para><emphasis role="bold">Boost.Threads</emphasis> currently supplies six models of
			<link linkend="threads.concepts.Mutex">Mutex</link>
			and its refinements.</para><table><title>Mutex Models</title><tgroup cols="3"><thead><row><entry>Concept</entry><entry>Refines</entry><entry>Models</entry></row></thead><tbody><row><entry><link linkend="threads.concepts.Mutex">Mutex</link></entry><entry/><entry><para><link linkend="mutex">boost::mutex</link></para><para><link linkend="recursive_mutex">boost::recursive_mutex</link></para></entry></row><row><entry><link linkend="threads.concepts.TryMutex">TryMutex</link></entry><entry><link linkend="threads.concepts.Mutex">Mutex</link></entry><entry><para><link linkend="try_mutex">boost::try_mutex</link></para><para><link linkend="recursive_try_mutex">boost::recursive_try_mutex</link></para></entry></row><row><entry><link linkend="threads.concepts.TimedMutex">TimedMutex</link></entry><entry><link linkend="threads.concepts.TryMutex">TryMutex</link></entry><entry><para><link linkend="timed_mutex">boost::timed_mutex</link></para><para><link linkend="recursive_timed_mutex">boost::recursive_timed_mutex</link></para></entry></row></tbody></tgroup></table></section><section id="threads.concepts.lock-concepts"><title>Lock Concepts</title><para>A lock object provides a safe means for locking and unlocking a mutex
			object (an object whose type is a model of <link linkend="threads.concepts.Mutex">Mutex</link> or one of its refinements). In
			other words they are an implementation of the <emphasis>Scoped
			Locking</emphasis><citation><xref linkend="threads.bib.SchmidtStalRohnertBuschmann" endterm="threads.bib.SchmidtStalRohnertBuschmann.abbrev"/></citation> pattern. The <link linkend="threads.concepts.ScopedLock">ScopedLock</link>,
			<link linkend="threads.concepts.ScopedTryLock">ScopedTryLock</link>, and 
			<link linkend="threads.concepts.ScopedTimedLock">ScopedTimedLock</link>
			concepts formalize the requirements.</para><para>Lock objects are constructed with a reference to a mutex object and
			typically acquire ownership of the mutex object by setting its state to
			locked. They also ensure ownership is relinquished in the destructor. Lock
			objects also expose functions to query the lock status and to manually lock
			and unlock the mutex object.</para><para>Lock objects are meant to be short lived, expected to be used at block
			scope only. The lock objects are not <link linkend="threads.glossary.thread-safe">thread-safe</link>. Lock objects must
			maintain state to indicate whether or not they've been locked and this state
			is not protected by any synchronization concepts. For this reason a lock
			object should never be shared between multiple threads.</para><section id="threads.concepts.Lock"><title>Lock Concept</title><para>For a Lock type <computeroutput>L</computeroutput> 
				and an object <computeroutput>lk</computeroutput> 
				and const object <computeroutput>clk</computeroutput> of that type, 
				the following expressions must be well-formed
				and have the indicated effects.</para><table><title>Lock Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>(&amp;lk)-&gt;~L();</computeroutput></entry><entry><computeroutput>if (locked()) unlock();</computeroutput></entry></row><row><entry><computeroutput>(&amp;clk)-&gt;operator const void*()</computeroutput></entry><entry>Returns type void*, non-zero if the associated mutex
								object has been locked by <computeroutput>clk</computeroutput>, otherwise 0.</entry></row><row><entry><computeroutput>clk.locked()</computeroutput></entry><entry>Returns a <computeroutput>bool</computeroutput>, <computeroutput>(&amp;clk)-&gt;operator
								const void*() != 0</computeroutput></entry></row><row><entry><computeroutput>lk.lock()</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if <computeroutput>locked()</computeroutput>.</para><para>If the associated mutex object is
									already locked by some other thread, places the current thread in the 
									<link linkend="threads.glossary.thread-state">Blocked</link> state until
									the associated mutex is unlocked, after which the current thread
									is placed in the <link linkend="threads.glossary.thread-state">Ready</link> state,
									eventually to be returned to the <link linkend="threads.glossary.thread-state">Running</link> state. If
									the associated mutex object is already locked by the same thread
									the behavior is dependent on the <link linkend="threads.concepts.locking-strategies">locking
									strategy</link> of the associated mutex object.</para><para>Postcondition: <computeroutput>locked() == true</computeroutput></para></entry></row><row><entry><computeroutput>lk.unlock()</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if <computeroutput>!locked()</computeroutput>.</para><para>Unlocks the associated mutex.</para><para>Postcondition: <computeroutput>!locked()</computeroutput></para></entry></row></tbody></tgroup></table></section><section id="threads.concepts.ScopedLock"><title>ScopedLock Concept</title><para>A ScopedLock is a refinement of <link linkend="threads.concepts.Lock">Lock</link>. 
				For a ScopedLock type <computeroutput>L</computeroutput> 
				and an object <computeroutput>lk</computeroutput> of that type, 
				and an object <computeroutput>m</computeroutput> of a type meeting the 
				<link linkend="threads.concepts.Mutex">Mutex</link> requirements, 
				and an object <computeroutput>b</computeroutput> of type <computeroutput>bool</computeroutput>, 
				the following expressions must be well-formed 
				and have the indicated effects.</para><table><title>ScopedLock Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>L lk(m);</computeroutput></entry><entry>Constructs an object <computeroutput>lk</computeroutput>, and associates mutex
								object <computeroutput>m</computeroutput> with it, then calls
								<computeroutput>lock()</computeroutput></entry></row><row><entry><computeroutput>L lk(m,b);</computeroutput></entry><entry>Constructs an object <computeroutput>lk</computeroutput>, and associates mutex
								object <computeroutput>m</computeroutput> with it, then if <computeroutput>b</computeroutput>, calls
								<computeroutput>lock()</computeroutput></entry></row></tbody></tgroup></table></section><section id="threads.concepts.TryLock"><title>TryLock Concept</title><para>A TryLock is a refinement of <link linkend="threads.concepts.Lock">Lock</link>. 
				For a TryLock type <computeroutput>L</computeroutput> 
				and an object <computeroutput>lk</computeroutput> of that type, 
				the following expressions must be well-formed 
				and have the indicated effects.</para><table><title>TryLock Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>lk.try_lock()</computeroutput></entry><entry><para>Throws  <link linkend="lock_error">boost::lock_error</link>
									if locked().</para><para>Makes a
									non-blocking attempt to lock the associated mutex object,
									returning <computeroutput>true</computeroutput> if the lock attempt is successful,
									otherwise <computeroutput>false</computeroutput>. If the associated mutex object is
									already locked by the same thread the behavior is dependent on the
									<link linkend="threads.concepts.locking-strategies">locking
									strategy</link> of the associated mutex object.</para></entry></row></tbody></tgroup></table></section><section id="threads.concepts.ScopedTryLock"><title>ScopedTryLock Concept</title><para>A ScopedTryLock is a refinement of <link linkend="threads.concepts.TryLock">TryLock</link>. 
				For a ScopedTryLock type <computeroutput>L</computeroutput> 
				and an object <computeroutput>lk</computeroutput> of that type, 
				and an object <computeroutput>m</computeroutput> of a type meeting the 
				<link linkend="threads.concepts.TryMutex">TryMutex</link> requirements, 
				and an object <computeroutput>b</computeroutput> of type <computeroutput>bool</computeroutput>, 
				the following expressions must be well-formed 
				and have the indicated effects.</para><table><title>ScopedTryLock Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>L lk(m);</computeroutput></entry><entry>Constructs an object <computeroutput>lk</computeroutput>, and associates mutex
								object <computeroutput>m</computeroutput> with it, then calls
								<computeroutput>try_lock()</computeroutput></entry></row><row><entry><computeroutput>L lk(m,b);</computeroutput></entry><entry>Constructs an object <computeroutput>lk</computeroutput>, and associates mutex
								object <computeroutput>m</computeroutput> with it, then if <computeroutput>b</computeroutput>, calls
								<computeroutput>lock()</computeroutput></entry></row></tbody></tgroup></table></section><section id="threads.concepts.TimedLock"><title>TimedLock Concept</title><para>A TimedLock is a refinement of <link linkend="threads.concepts.TryLock">TryLock</link>. 
				For a TimedLock type <computeroutput>L</computeroutput> 
				and an object <computeroutput>lk</computeroutput> of that type, 
				and an object <computeroutput>t</computeroutput> of type <link linkend="xtime">boost::xtime</link>, 
				the following expressions must be well-formed 
				and have the indicated effects.</para><table><title>TimedLock Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>lk.timed_lock(t)</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if locked().</para><para>Makes a blocking attempt
									to lock the associated mutex object, and returns <computeroutput>true</computeroutput>
									if successful within the specified time <computeroutput>t</computeroutput>, otherwise
									<computeroutput>false</computeroutput>. If the associated mutex object is already
									locked by the same thread the behavior is dependent on the <link linkend="threads.concepts.locking-strategies">locking
									strategy</link> of the associated mutex object.</para></entry></row></tbody></tgroup></table></section><section id="threads.concepts.ScopedTimedLock"><title>ScopedTimedLock Concept</title><para>A ScopedTimedLock is a refinement of <link linkend="threads.concepts.TimedLock">TimedLock</link>. 
				For a ScopedTimedLock type <computeroutput>L</computeroutput> 
				and an object <computeroutput>lk</computeroutput> of that type, 
				and an object <computeroutput>m</computeroutput> of a type meeting the 
				<link linkend="threads.concepts.TimedMutex">TimedMutex</link> requirements, 
				and an object <computeroutput>b</computeroutput> of type <computeroutput>bool</computeroutput>, 
				and an object <computeroutput>t</computeroutput> of type <link linkend="xtime">boost::xtime</link>, 
				the following expressions must be well-formed 
				and have the indicated effects.</para><table><title>ScopedTimedLock Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>L lk(m,t);</computeroutput></entry><entry>Constructs an object <computeroutput>lk</computeroutput>, and associates mutex
								object <computeroutput>m</computeroutput> with it, then calls
								<computeroutput>timed_lock(t)</computeroutput></entry></row><row><entry><computeroutput>L lk(m,b);</computeroutput></entry><entry>Constructs an object <computeroutput>lk</computeroutput>, and associates mutex
								object <computeroutput>m</computeroutput> with it, then if <computeroutput>b</computeroutput>, calls
								<computeroutput>lock()</computeroutput></entry></row></tbody></tgroup></table></section></section><section id="threads.concepts.lock-models"><title>Lock Models</title><para><emphasis role="bold">Boost.Threads</emphasis> currently supplies twelve models of
			<link linkend="threads.concepts.Lock">Lock</link>
			and its refinements.</para><table><title>Lock Models</title><tgroup cols="3"><thead><row><entry>Concept</entry><entry>Refines</entry><entry>Models</entry></row></thead><tbody><row><entry><link linkend="threads.concepts.Lock">Lock</link></entry><entry/><entry/></row><row><entry><link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry><entry><link linkend="threads.concepts.Lock">Lock</link></entry><entry><para>boost::mutex::scoped_lock</para><para>boost::recursive_mutex::scoped_lock</para><para>boost::try_mutex::scoped_lock</para><para>boost::recursive_try_mutex::scoped_lock</para><para>boost::timed_mutex::scoped_lock</para><para>boost::recursive_timed_mutex::scoped_lock</para></entry></row><row><entry><link linkend="threads.concepts.TryLock">TryLock</link></entry><entry><link linkend="threads.concepts.Lock">Lock</link></entry><entry/></row><row><entry><link linkend="threads.concepts.ScopedTryLock">ScopedTryLock</link></entry><entry><link linkend="threads.concepts.TryLock">TryLock</link></entry><entry><para>boost::try_mutex::scoped_try_lock</para><para>boost::recursive_try_mutex::scoped_try_lock</para><para>boost::timed_mutex::scoped_try_lock</para><para>boost::recursive_timed_mutex::scoped_try_lock</para></entry></row><row><entry><link linkend="threads.concepts.TimedLock">TimedLock</link></entry><entry><link linkend="threads.concepts.TryLock">TryLock</link></entry><entry/></row><row><entry><link linkend="threads.concepts.ScopedTimedLock">ScopedTimedLock</link></entry><entry><link linkend="threads.concepts.TimedLock">TimedLock</link></entry><entry><para>boost::timed_mutex::scoped_timed_lock</para><para>boost::recursive_timed_mutex::scoped_timed_lock</para></entry></row></tbody></tgroup></table></section></section><section id="threads.concepts.read-write-mutexes"><title>Read/Write Mutexes</title><note>Since the read/write mutex and related classes are new,
		both interface and implementation are liable to change
		in future releases of <emphasis role="bold">Boost.Threads</emphasis>.
		The lock concepts and lock promotion and demotion in particular 
		are still under discussion and very likely to change.</note><para>A read/write mutex (short for reader/writer mutual-exclusion) object
		is used to serialize access to a resource shared between multiple 
		threads, where multiple "readers" can share simultaneous access, but 
		"writers" require exclusive access. The
		<link linkend="threads.concepts.ReadWriteMutex">ReadWriteMutex</link> concept, with 
		<link linkend="threads.concepts.TryReadWriteMutex">TryReadWriteMutex</link> and 
		<link linkend="threads.concepts.TimedReadWriteMutex"> TimedReadWriteMutex</link>
		refinements formalize the requirements. A model that implements 
		ReadWriteMutex and its refinements has three states: 
		<emphasis role="bold">read-locked</emphasis>,
		<emphasis role="bold">write-locked</emphasis>, and 
		<emphasis role="bold">unlocked</emphasis>.
		Before reading from a shared resource, a thread 
		<emphasis role="bold">read-locks</emphasis> 
		a <emphasis role="bold">Boost.Threads</emphasis> read/write mutex object
		(an object whose type is a model of
		<link linkend="threads.concepts.ReadWriteMutex">ReadWriteMutex</link>
		or one of it's refinements), ensuring 
		<link linkend="threads.glossary.thread-safe">thread-safe</link>
		access for reading from the shared resource. Before writing 
		to a shared resource, a thread 
		<emphasis role="bold">write-locks</emphasis> a <emphasis role="bold">Boost.Threads</emphasis> 
		read/write mutex object
		(an object whose type is a model of
		<link linkend="threads.concepts.ReadWriteMutex">ReadWriteMutex</link>
		or one of it's refinements), ensuring 
		<link linkend="threads.glossary.thread-safe">thread-safe</link>
		access for altering the shared resource. When use of the shared 
		resource is complete, the thread unlocks the mutex object, 
		allowing another thread to acquire the lock and use the shared 
		resource.</para><para>Traditional C thread APIs that provide read/write mutex
		primitives (like POSIX threads) expose functions to lock and unlock a
		mutex object. This is dangerous since it's easy to forget to unlock a
		locked mutex. When the flow of control is complex, with multiple
		return points, the likelihood of forgetting to unlock a mutex object
		becomes even greater. When exceptions are thrown, it becomes nearly
		impossible to ensure that the mutex object is unlocked
		properly when using these traditional API's. The result is
		<link linkend="threads.glossary.deadlock">deadlock</link>.</para><para>Many C++ threading libraries use a pattern known as <emphasis>Scoped
		Locking</emphasis><citation><xref linkend="threads.bib.SchmidtStalRohnertBuschmann" endterm="threads.bib.SchmidtStalRohnertBuschmann.abbrev"/></citation> to free the
		programmer from the need to explicitly lock and unlock
		read/write mutex objects. With this  pattern, a 
		<link linkend="threads.concepts.read-write-lock-concepts">Read/Write Lock</link>
		concept is employed where the lock object's constructor locks
		the associated read/write mutex object
		and the destructor automatically does the unlocking. The
		<emphasis role="bold">Boost.Threads</emphasis> library takes this pattern to
		the extreme in that 
		<link linkend="threads.concepts.read-write-lock-concepts">Read/Write Lock</link>
		concepts are the only way to lock and unlock a read/write mutex
		object: lock and unlock functions are not exposed by any
		<emphasis role="bold">Boost.Threads</emphasis> read/write mutex objects. This helps to
		ensure safe usage patterns, especially when code throws exceptions.</para><section id="threads.concepts.read-write-locking-strategies"><title>Locking Strategies</title><para>Every read/write mutex object follows one of several locking
			strategies. These strategies define the semantics for the locking
			operation when the calling thread already owns a lock on the 
			read/write mutex object.</para><section id="threads.concepts.read-write-locking-strategies.recursive"><title>Recursive Locking Strategy</title><para>With a recursive locking strategy, when a thread attempts
				to acquire a lock on a read/write mutex object
				for which it already owns a lock, the operation is successful,
				except in the case where a thread holding a read-lock 
				attempts to obtain a write lock, in which case a
				<link linkend="lock_error">boost::lock_error</link> exception will
				be thrown. Note the distinction between a thread, which may have
				multiple locks outstanding on a recursive read/write mutex object,
				and a lock object, which even for a recursive read/write mutex
				object cannot have any of its lock functions called multiple
				times without first calling unlock.</para><informaltable><tgroup cols="3"><thead><row><entry>Lock Type Held</entry><entry>Lock Type Requested</entry><entry>Action</entry></row></thead><tbody><row><entry>read-lock</entry><entry>read-lock</entry><entry>Grant the read-lock immediately</entry></row><row><entry>read-lock</entry><entry>write-lock</entry><entry>If this thread is the only holder of the read-lock,
								grants the write lock immediately. Otherwise throws a
								<link linkend="lock_error">boost::lock_error</link> exception.</entry></row><row><entry>write-locked</entry><entry>read-lock</entry><entry>Grants the (additional) read-lock immediately.</entry></row><row><entry>write-locked</entry><entry>write-lock</entry><entry> Grant the write-lock immediately</entry></row></tbody></tgroup></informaltable><para>Internally a lock count is maintained and the owning
				thread must unlock the mutex object the same number of times
				that it locked it before the mutex object's state returns
				to unlocked. Since mutex objects in <emphasis role="bold">Boost.Threads</emphasis> expose
				locking functionality only through lock concepts, a thread
				will always unlock a mutex object the same number of times
				that it locked it. This helps to eliminate a whole set of
				errors typically found in traditional C style thread APIs.
				</para><para><emphasis role="bold">Boost.Threads</emphasis> does not currently provide any read/write mutex objects 
				that use this strategy.  A successful implementation of this locking strategy
				may require
				<link linkend="threads.concepts.read-write-locking-strategies.thread-identification">thread identification</link>.
				</para></section><section id="threads.concepts.read-write-locking-strategies.checked"><title>Checked Locking Strategy</title><para>With a checked locking strategy, when a thread attempts
				to acquire a lock on the mutex object for which the thread
				already owns a lock, the operation will fail with some sort of
				error indication, except in the case of multiple read-lock 
				acquisition which is a normal operation for ANY ReadWriteMutex.
				Further, attempts by a thread to unlock a mutex that was not
				locked by the thread will also return some sort of error
				indication. In <emphasis role="bold">Boost.Threads</emphasis>, an exception of type 
				<link linkend="lock_error">boost::lock_error</link> would be thrown in
				these cases.</para><informaltable><tgroup cols="3"><thead><row><entry>Lock Type Held</entry><entry>Lock Type Requested</entry><entry>Action</entry></row></thead><tbody><row><entry>read-lock</entry><entry>read-lock</entry><entry>Grant the read-lock immediately</entry></row><row><entry>read-lock</entry><entry>write-lock</entry><entry>Throw <link linkend="lock_error">boost::lock_error</link></entry></row><row><entry>write-locked</entry><entry>read-lock</entry><entry>Throw <link linkend="lock_error">boost::lock_error</link></entry></row><row><entry>write-locked</entry><entry>write-lock</entry><entry> Throw <link linkend="lock_error">boost::lock_error</link></entry></row></tbody></tgroup></informaltable><para><emphasis role="bold">Boost.Threads</emphasis> does not currently provide any read/write mutex objects 
				that use this strategy.  A successful implementation of this locking strategy
				may require
				<link linkend="threads.concepts.read-write-locking-strategies.thread-identification">thread identification</link>.
				</para></section><section id="threads.concepts.read-write-locking-strategies.unchecked"><title>Unchecked Locking Strategy</title><para>With an unchecked locking strategy, when a thread
				attempts to acquire a lock on the read/write mutex object
				for which the thread already owns a lock, the operation 
				will <link linkend="threads.glossary.deadlock">deadlock</link>.
				In general this locking strategy is less safe than a checked
				or recursive strategy, but it can be a faster strategy and so
				is employed by many libraries.</para><informaltable><tgroup cols="3"><thead><row><entry>Lock Type Held</entry><entry>Lock Type Requested</entry><entry>Action</entry></row></thead><tbody><row><entry>read-lock</entry><entry>read-lock</entry><entry>Grant the read-lock immediately</entry></row><row><entry>read-lock</entry><entry>write-lock</entry><entry><link linkend="threads.glossary.deadlock">Deadlock</link></entry></row><row><entry>write-locked</entry><entry>read-lock</entry><entry><link linkend="threads.glossary.deadlock">Deadlock</link></entry></row><row><entry>write-locked</entry><entry>write-lock</entry><entry><link linkend="threads.glossary.deadlock">Deadlock</link></entry></row></tbody></tgroup></informaltable><para><emphasis role="bold">Boost.Threads</emphasis> does not currently provide any mutex
				objects that use this strategy.  For ReadWriteMutexes on
				platforms that contain natively recursive synchronization
				primitives, implementing a guaranteed-deadlock can actually
				involve extra work, and would likely require 
				<link linkend="threads.concepts.read-write-locking-strategies.thread-identification">thread identification</link>.
				</para></section><section id="threads.concepts.read-write-locking-strategies.unspecified"><title>Unspecified Locking Strategy</title><para>With an unspecified locking strategy, when a thread
				attempts to acquire a lock on a read/write mutex object for
				which the thread already owns a lock, the operation results 
				in <link linkend="threads.glossary.undefined-behavior">undefined behavior</link>.
				When a read/write mutex object has an unspecified locking 
				strategy the programmer must assume that the read/write mutex
				object instead uses an unchecked strategy as the worse case,
				although some platforms may exhibit a mix of unchecked and
				recursive behavior.</para><informaltable><tgroup cols="3"><thead><row><entry>Lock Type Held</entry><entry>Lock Type Requested</entry><entry>Action</entry></row></thead><tbody><row><entry>read-lock</entry><entry>read-lock</entry><entry>Grant the read-lock immediately</entry></row><row><entry>read-lock</entry><entry>write-lock</entry><entry><link linkend="threads.glossary.undefined-behavior">Undefined</link>, but generally <link linkend="threads.glossary.deadlock">deadlock</link></entry></row><row><entry>write-locked</entry><entry>read-lock</entry><entry><link linkend="threads.glossary.undefined-behavior">Undefined</link>, but generally <link linkend="threads.glossary.deadlock">deadlock</link></entry></row><row><entry>write-locked</entry><entry>write-lock</entry><entry><link linkend="threads.glossary.undefined-behavior">Undefined</link>, but generally <link linkend="threads.glossary.deadlock">deadlock</link></entry></row></tbody></tgroup></informaltable><para>In general a read/write mutex object with an unspecified
				locking strategy is unsafe, and it requires programmer discipline
				to use the read/write mutex object properly. However, this strategy
				allows an implementation to be as fast as possible with no restrictions 
				on its implementation. This is especially true for portable implementations
				that wrap the native threading support of a platform. For this reason, the
				classes 
				read_write_mutex,
				try_read_write_mutex, and
				timed_read_write_mutex
				use this locking strategy despite the lack of safety.</para></section><section id="threads.concepts.read-write-locking-strategies.thread-identification"><title>Thread Identification</title><para>ReadWriteMutexes can support specific Locking Strategies 
				(recursive and checked) which help to detect and protect against
				self-deadlock.  Self-deadlock can occur when a holder of a locked
				ReadWriteMutex attempts to obtain another lock.  Given an
				implemention <emphasis>I</emphasis> which is susceptible to
				self-deadlock but otherwise correct and efficient, a recursive or
				checked implementation <emphasis>Ir</emphasis> or 
				<emphasis>Ic</emphasis> can use the same basic implementation,
				but make special checks against self-deadlock by tracking the
				identities of thread(s) currently holding locks.  This approach 
				makes deadlock detection othrogonal to the basic ReadWriteMutex
				implementaion.</para><para>Alternatively, a different basic implementation for 
				ReadWriteMutex concepts, 
				<emphasis>I'</emphasis> (I-Prime) may exist which uses recursive
				or checked versions of synchronization primitives to produce
				a recursive or checked ReadWriteMutex while still providing
				flexibility in terms of Scheduling Policies. </para><para>Please refer to the <emphasis role="bold">Boost.Threads</emphasis><link linkend="threads.concepts.read-write-mutex-concepts">read/write mutex concept</link> 
				documentation for a discussion of locking strategies.
				The read/write mutex supports only the
				<link linkend="threads.concepts.read-write-locking-strategies.unspecified">unspecified</link>
				locking strategy. ReadWriteMutexes are parameterized on a
				Mutex type which they use to control write-locking 
				and access to internal state.</para></section><section id="threads.concepts.read-write-locking-strategies.promotion"><title>Lock Promotion</title><para>ReadWriteMutexes can support lock promotion, where a
				mutex which is in the read-locked state transitions to a
				write-locked state without releasing the lock. Lock
				promotion can be tricky to implement; for instance,
				extra care must be taken to ensure that only one thread holding a
				read-lock can block awaiting promotion at any given time.  If
				more than one read-lock holder is allowed to enter a blocked
				state while waiting to be promoted, deadlock will result since
				both threads will be waiting for the other to release their read-lock.
				</para><para>Currently, <emphasis role="bold">Boost.Threads</emphasis> supports lock promotion
				through <computeroutput>promote()</computeroutput>, <computeroutput>try_promote()</computeroutput>,
				and <computeroutput>timed_promote()</computeroutput> operations.</para></section><section id="threads.concepts.read-write-locking-strategies.demotion"><title>Lock Demotion</title><para>ReadWriteMutexes can support lock demotion, where a
				mutex which is in the write-locked state transitions to a
				read-locked state without releasing the lock.
				Since by definition only one thread at a time may hold
				a write-lock, the problem with deadlock that can occur
				during lock promotion is not a problem for lock
				demotion.</para><para>Currently, <emphasis role="bold">Boost.Threads</emphasis> supports lock demotion
				through <computeroutput>demote()</computeroutput>, <computeroutput>try_demote()</computeroutput>,
				and <computeroutput>timed_demote()</computeroutput> operations.</para></section></section><section id="threads.concepts.read-write-scheduling-policies"><title>Scheduling Policies</title><para>Every read/write mutex object follows one of several scheduling
			policies. These policies define the semantics when the mutex object
			is unlocked and there is more than one thread waiting to acquire a
			lock. In other words, the policy defines which waiting thread shall
			acquire the lock. For a read/write mutex, it is particularly important
			to define the behavior when threads are requesting both read and
			write access simultaneously. This will be referred to as "inter-class 
			scheduling" because it describes the scheduling between two
			classes of threads (those waiting for a read lock and those
			waiting for a write lock).</para><para>For some types of inter-class scheduling, an "intra-class"
			scheduling policy can also be defined that will describe the order
			in which waiting threads of the same class (i.e., those
			waiting for the same type of lock) will acquire the thread.
			</para><section id="threads.concepts.read-write-scheduling-policies.inter-class"><title>Inter-Class Scheduling Policies</title><section id="threads.concepts.read-write-scheduling-policies.reader-priority"><title>ReaderPriority</title><para>With ReaderPriority scheduling, any pending request for
					a read-lock will have priority over a pending request for a
					write-lock, irrespective of the current lock state of the 
					read/write mutex, and irrespective of the relative order
					that the pending requests arrive.</para><informaltable><tgroup cols="3"><thead><row><entry>Current mutex state</entry><entry>Request Type</entry><entry>Action</entry></row></thead><tbody><row><entry>unlocked</entry><entry>read-lock</entry><entry>Grant the read-lock immediately</entry></row><row><entry>read-locked</entry><entry>read-lock</entry><entry>Grant the additional read-lock immediately.</entry></row><row><entry>write-locked</entry><entry>read-lock</entry><entry>Wait to acquire the lock until the thread
									holding the write-lock releases its lock (or until
									the specified time, if any). A
									read-lock will be granted to all pending readers 
									before any other thread can acquire a write-lock.
									<para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>unlocked</entry><entry>write-lock</entry><entry>Grant the write-lock immediately, if and
									only if there are no pending read-lock requests.
									<para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>read-locked</entry><entry>write-lock</entry><entry> Wait to acquire the lock until all
									threads holding read-locks release their locks 
									<emphasis role="bold">AND</emphasis> no requests
									for read-locks exist. If other write-lock
									requests exist, the lock is granted in accordance
									with the intra-class scheduling policy.
									<para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>write-locked</entry><entry>write-lock</entry><entry>Wait to acquire the lock until the thread
									holding the write-lock releases its lock
									<emphasis role="bold">AND</emphasis> no requests
									for read-locks exist. If other write-lock
									requests exist, the lock is granted in accordance
									with the intra-class scheduling policy.
									<para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>read-locked</entry><entry>promote</entry><entry><para>TODO</para></entry></row><row><entry>write-locked</entry><entry>demote</entry><entry><para>TODO</para></entry></row></tbody></tgroup></informaltable></section><section id="threads.concepts.read-write-scheduling-policies.writer-priority"><title>WriterPriority</title><para>With WriterPriority scheduling, any pending request
					for a write-lock will have priority over a pending request
					for a read-lock, irrespective of the current lock state 
					of the read/write mutex, and irrespective of the relative
					order that the pending requests arrive.</para><informaltable><tgroup cols="3"><thead><row><entry>Current mutex state</entry><entry>Request Type</entry><entry>Action</entry></row></thead><tbody><row><entry>unlocked</entry><entry>read-lock</entry><entry>Grant the read-lock immediately.</entry></row><row><entry>read-locked</entry><entry>read-lock</entry><entry>Grant the additional read-lock immediately, 
									<emphasis role="bold">IF</emphasis> no outstanding
									requests for a write-lock exist; otherwise TODO.
									<para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>write-locked</entry><entry>read-lock</entry><entry> Wait to acquire the lock until the
									thread holding the write-lock 
									releases its lock. The read lock will be granted
									once no other outstanding write-lock requests
									exist.
									<para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>unlocked</entry><entry>write-lock</entry><entry>Grant the write-lock immediately.</entry></row><row><entry>read-locked</entry><entry>write-lock</entry><entry>Wait to acquire the lock until all
									threads holding read-locks release their locks.
									If other write-lock requests exist, the lock
									is granted in accordance with the intra-class
									scheduling policy. This request will be granted
									before any new read-lock requests are granted.
									<para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>write-locked</entry><entry>write-lock</entry><entry>Wait to acquire the lock until the thread
									holding the write-lock releases its lock. If
									other write-lock requests exist, the lock is
									granted in accordance with the intra-class
									scheduling policy. This request will be granted
									before any new read-lock requests are granted.
									<para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>read-locked</entry><entry>promote</entry><entry><para>TODO</para></entry></row><row><entry>write-locked</entry><entry>demote</entry><entry><para>TODO</para></entry></row></tbody></tgroup></informaltable></section><section id="threads.concepts.read-write-scheduling-policies.alternating-many-reads"><title>AlternatingPriority/ManyReads</title><para>With AlternatingPriority/ManyReads scheduling, reader
					or writer starvation is avoided by alternatively granting read
					or write access when pending requests exist for both types of
					locks. Outstanding read-lock requests are treated as a group
					when it is the "readers' turn"</para><informaltable><tgroup cols="3"><thead><row><entry>Current mutex state</entry><entry>Request Type</entry><entry>Action</entry></row></thead><tbody><row><entry>unlocked</entry><entry>read-lock</entry><entry>Grant the read-lock immediately.</entry></row><row><entry>read-locked</entry><entry>read-lock</entry><entry>Grant the additional read-lock immediately,
									<emphasis role="bold">IF</emphasis> no outstanding 
									requests for a write-lock exist. If outstanding
									write-lock requests exist, this lock will not
									be granted until at least one of the 
									write-locks is granted and released. If other
									read-lock requests exist, all read-locks will be
									granted as a group.
									<para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>write-locked</entry><entry>read-lock</entry><entry> Wait to acquire the lock until the thread
									holding the write-lock releases its lock. If other
									outstanding write-lock requests exist, they will
									have to wait until all current read-lock requests
									are serviced.
									<para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>unlocked</entry><entry>write-lock</entry><entry>Grant the write-lock immediately.</entry></row><row><entry>read-locked</entry><entry>write-lock</entry><entry><para>Wait to acquire the lock until all threads
									holding read-locks release their locks.</para><para>If other write-lock requests exist, this
									lock will be granted to one of them in accordance
									with the intra-class scheduling policy.</para><para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>write-locked</entry><entry>write-lock</entry><entry>Wait to acquire the lock until the thread
									holding the write-lock releases its lock.  If
									other outstanding read-lock requests exist, this
									lock will not be granted until all of the
									currently waiting read-locks are granted and
									released. If other write-lock requests exist,
									this lock will be granted in accordance with the
									intra-class scheduling policy.
									<para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>read-locked</entry><entry>promote</entry><entry><para>TODO</para></entry></row><row><entry>write-locked</entry><entry>demote</entry><entry><para>TODO</para></entry></row></tbody></tgroup></informaltable></section><section id="threads.concepts.read-write-scheduling-policies.alternating-single-read"><title>AlternatingPriority/SingleRead</title><para>With AlternatingPriority/SingleRead scheduling, reader
					or writer starvation is avoided by alternatively granting read
					or write access when pending requests exist for both types of
					locks. Outstanding read-lock requests are services one at a
					time when it is the "readers' turn"</para><informaltable><tgroup cols="3"><thead><row><entry>Current mutex state</entry><entry>Request Type</entry><entry>Action</entry></row></thead><tbody><row><entry>unlocked</entry><entry>read-lock</entry><entry>Grant the read-lock immediately.</entry></row><row><entry>read-locked</entry><entry>read-lock</entry><entry>Grant the additional read-lock immediately,
									<emphasis role="bold">IF</emphasis> no outstanding 
									requests for a write-lock exist. If outstanding
									write-lock requests exist, this lock will not
									be granted until at least one of the write-locks
									is granted and released.
									<para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>write-locked</entry><entry>read-lock</entry><entry><para>Wait to acquire the lock until the thread
									holding the write-lock releases its lock.</para><para>If other outstanding write-lock requests
									exist, exactly one read-lock request will be
									granted before the next write-lock is granted.
									</para><para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>unlocked</entry><entry>write-lock</entry><entry>Grant the write-lock immediately.</entry></row><row><entry>read-locked</entry><entry>write-lock</entry><entry><para>Wait to acquire the lock until all
									threads holding read-locks release their 
									locks.</para><para>If other write-lock requests exist,
									this lock will be granted to one of them
									in accordance with the intra-class
									scheduling policy.</para></entry><para>TODO: try-lock, timed-lock.</para></row><row><entry>write-locked</entry><entry>write-lock</entry><entry>Wait to acquire the lock until the
									thread holding the write-lock releases its
									lock.  If other outstanding read-lock requests
									exist, this lock can not be granted until
									exactly one read-lock request is granted and
									released. If other write-lock requests exist,
									this lock will be granted in accordance with
									the intra-class scheduling policy.
									<para>TODO: try-lock, timed-lock.</para></entry></row><row><entry>read-locked</entry><entry>promote</entry><entry><para>TODO</para></entry></row><row><entry>write-locked</entry><entry>demote</entry><entry><para>TODO</para></entry></row></tbody></tgroup></informaltable></section></section><section id="threads.concepts.read-write-scheduling-policies.intra-class"><title>Intra-Class Scheduling Policies</title><para>Please refer to 
				<xref linkend="threads.concepts.sheduling-policies"/>
				for a discussion of mutex scheduling policies, which are identical to 
				read/write mutex intra-class scheduling policies.</para><para>For threads waiting to obtain write-locks, the read/write mutex
				supports only the 
				<link linkend="threads.concepts.unspecified-scheduling-policy">Unspecified</link>
				intra-class scheduling policy. That is, given a set of threads
				waiting for write-locks, the order, relative to one another, in
				which they receive the write-lock is unspecified.</para><para>For threads waiting to obtain read-locks, the read/write mutex
				supports only the 
				<link linkend="threads.concepts.unspecified-scheduling-policy">Unspecified</link>
				intra-class scheduling policy. That is, given a set of threads
				waiting for read-locks, the order, relative to one another, in
				which they receive the read-lock is unspecified.</para></section></section><section id="threads.concepts.read-write-mutex-concepts"><title>Mutex Concepts</title><section id="threads.concepts.ReadWriteMutex"><title>ReadWriteMutex Concept</title><para>A ReadWriteMutex object has three states: read-locked,
				write-locked, and unlocked. ReadWriteMutex object state can
				only be determined by a lock object meeting the appropriate lock concept
				requirements and constructed for the ReadWriteMutex object.</para><para>A ReadWriteMutex is 
				<ulink url="../../libs/utility/utility.htm#Class%20noncopyable">NonCopyable</ulink>.
				</para><para>For a ReadWriteMutex type <computeroutput>M</computeroutput>, 
				and an object <computeroutput>m</computeroutput> of that type, 
				the following expressions must be well-formed 
				and have the indicated effects.</para><table><title>ReadWriteMutex Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>M m;</computeroutput></entry><entry>Constructs a read/write mutex object <computeroutput>m</computeroutput>.
								Post-condition: <computeroutput>m</computeroutput> is unlocked.</entry></row><row><entry><computeroutput>(&amp;m)-&gt;~M();</computeroutput></entry><entry>Precondition: <computeroutput>m</computeroutput> is unlocked. 
								Destroys a read/write mutex object <computeroutput>m</computeroutput>.
								</entry></row><row><entry><computeroutput>M::scoped_read_write_lock</computeroutput></entry><entry>A type meeting the 
								<link linkend="threads.concepts.ScopedReadWriteLock">ScopedReadWriteLock</link>
								requirements. </entry></row><row><entry><computeroutput>M::scoped_read_lock</computeroutput></entry><entry>A type meeting the 
								<link linkend="threads.concepts.ScopedLock">ScopedLock</link>
								requirements. </entry></row><row><entry><computeroutput>M::scoped_write_lock</computeroutput></entry><entry>A type meeting the 
								<link linkend="threads.concepts.ScopedLock">ScopedLock</link>
								requirements. </entry></row></tbody></tgroup></table></section><section id="threads.concepts.TryReadWriteMutex"><title>TryReadWriteMutex Concept</title><para>A TryReadWriteMutex is a refinement of
				<link linkend="threads.concepts.ReadWriteMutex">ReadWriteMutex</link>.
				For a TryReadWriteMutex type <computeroutput>M</computeroutput> 
				and an object <computeroutput>m</computeroutput> of that type,
				the following expressions must be well-formed 
				and have the indicated effects.</para><table><title>TryReadWriteMutex Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>M::scoped_try_read_write_lock</computeroutput></entry><entry>A type meeting the 
								<link linkend="threads.concepts.ScopedTryReadWriteLock">ScopedTryReadWriteLock</link>
								requirements.</entry></row><row><entry><computeroutput>M::scoped_try_read_lock</computeroutput></entry><entry>A type meeting the 
								<link linkend="threads.concepts.ScopedTryLock">ScopedTryLock</link>
								requirements.</entry></row><row><entry><computeroutput>M::scoped_try_write_lock</computeroutput></entry><entry>A type meeting the 
								<link linkend="threads.concepts.ScopedTryLock">ScopedTryLock</link>
								requirements.</entry></row></tbody></tgroup></table></section><section id="threads.concepts.TimedReadWriteMutex"><title>TimedReadWriteMutex Concept</title><para>A TimedReadWriteMutex is a refinement of
				<link linkend="threads.concepts.TryReadWriteMutex">TryReadWriteMutex</link>.
				For a TimedReadWriteMutex type <computeroutput>M</computeroutput> 
				and an object <computeroutput>m</computeroutput> of that type
				the following expressions must be well-formed 
				and have the indicated effects.</para><table><title>TimedReadWriteMutex Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>M::scoped_timed_read_write_lock</computeroutput></entry><entry>A type meeting the 
								<link linkend="threads.concepts.ScopedTimedReadWriteLock">ScopedTimedReadWriteLock</link> 
								requirements.</entry></row><row><entry><computeroutput>M::scoped_timed_read_lock</computeroutput></entry><entry>A type meeting the 
								<link linkend="threads.concepts.ScopedTimedLock">ScopedTimedLock</link> 
								requirements.</entry></row><row><entry><computeroutput>M::scoped_timed_write_lock</computeroutput></entry><entry>A type meeting the 
								<link linkend="threads.concepts.ScopedTimedLock">ScopedTimedLock</link> 
								requirements.</entry></row></tbody></tgroup></table></section></section><section id="threads.concepts.read-write-mutex-models"><title>Mutex Models</title><para><emphasis role="bold">Boost.Threads</emphasis> currently supplies three models of
			<link linkend="threads.concepts.ReadWriteMutex">ReadWriteMutex</link>
			and its refinements.</para><table><title>Mutex Models</title><tgroup cols="3"><thead><row><entry>Concept</entry><entry>Refines</entry><entry>Models</entry></row></thead><tbody><row><entry><link linkend="threads.concepts.ReadWriteMutex">ReadWriteMutex</link></entry><entry/><entry><link linkend="read_write_mutex">boost::read_write_mutex</link></entry></row><row><entry><link linkend="threads.concepts.TryReadWriteMutex">TryReadWriteMutex</link></entry><entry><link linkend="threads.concepts.ReadWriteMutex">ReadWriteMutex</link></entry><entry><link linkend="try_read_write_mutex">boost::try_read_write_mutex</link></entry></row><row><entry><link linkend="threads.concepts.TimedReadWriteMutex">TimedReadWriteMutex</link></entry><entry><link linkend="threads.concepts.TryReadWriteMutex">TryReadWriteMutex</link></entry><entry><link linkend="timed_read_write_mutex">boost::timed_read_write_mutex</link></entry></row></tbody></tgroup></table></section><section id="threads.concepts.read-write-lock-concepts"><title>Lock Concepts</title><para>A read/write lock object provides a safe means for locking
			and unlocking a read/write mutex object (an object whose type is
			a model of 
			<link linkend="threads.concepts.ReadWriteMutex">ReadWriteMutex</link> 
			or one of its refinements). In other words they are an
			implementation of the <emphasis>Scoped Locking</emphasis><citation><xref linkend="threads.bib.SchmidtStalRohnertBuschmann" endterm="threads.bib.SchmidtStalRohnertBuschmann.abbrev"/></citation> pattern. The 
			<link linkend="threads.concepts.ScopedReadWriteLock">ScopedReadWriteLock</link>, 
			<link linkend="threads.concepts.ScopedTryReadWriteLock">ScopedTryReadWriteLock</link>, and 
			<link linkend="threads.concepts.ScopedTimedReadWriteLock">ScopedTimedReadWriteLock</link>
			concepts formalize the requirements.</para><para>Read/write lock objects are constructed with a reference to a
			read/write mutex object and typically acquire ownership of the 
			read/write mutex object by setting its state to locked. They also
			ensure ownership is relinquished in the destructor. Lock objects
			also expose functions to query the lock status and to manually lock
			and unlock the read/write mutex object.</para><para>Read/write lock objects are meant to be short lived, expected
			to be used at block scope only. The read/write lock objects are not 
			<link linkend="threads.glossary.thread-safe">thread-safe</link>.
			Read/write lock objects must maintain state to indicate whether or
			not they've been locked and this state is not protected by any
			synchronization concepts. For this reason a read/write lock object
			should never be shared between multiple threads.</para><section id="threads.concepts.ReadWriteLock"><title>ReadWriteLock Concept</title><para>For a read/write lock type <computeroutput>L</computeroutput>
				and an object <computeroutput>lk</computeroutput> 
				and const object <computeroutput>clk</computeroutput> of that type,
				the following expressions must be well-formed
				and have the indicated effects.</para><table><title>ReadWriteLock Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>(&amp;lk)-&gt;~L();</computeroutput></entry><entry><computeroutput>if (locked()) unlock();</computeroutput></entry></row><row><entry><computeroutput>(&amp;clk)-&gt;operator const void*()</computeroutput></entry><entry>Returns type void*, non-zero if the associated read/write
								mutex object has been either read-locked or write-locked by 
								<computeroutput>clk</computeroutput>, otherwise 0.</entry></row><row><entry><computeroutput>clk.locked()</computeroutput></entry><entry>Returns a <computeroutput>bool</computeroutput>, <computeroutput>(&amp;clk)-&gt;operator
								const void*() != 0</computeroutput></entry></row><row><entry><computeroutput>clk.state()</computeroutput></entry><entry>Returns an enumeration constant of type <computeroutput>read_write_lock_state</computeroutput>:
								<computeroutput>read_write_lock_state::read_locked</computeroutput> if the associated read/write mutex object has been
								read-locked by <computeroutput>clk</computeroutput>, <computeroutput>read_write_lock_state::write_locked</computeroutput> if it
								has been write-locked by <computeroutput>clk</computeroutput>, and <computeroutput>read_write_lock_state::unlocked</computeroutput>
								if has not been locked by <computeroutput>clk</computeroutput>.</entry></row><row><entry><computeroutput>clk.read_locked()</computeroutput></entry><entry>Returns a <computeroutput>bool</computeroutput>, <computeroutput>(&amp;clk)-&gt;state() == read_write_lock_state::read_locked</computeroutput>.</entry></row><row><entry><computeroutput>clk.write_locked()</computeroutput></entry><entry>Returns a <computeroutput>bool</computeroutput>, <computeroutput>(&amp;clk)-&gt;state() == read_write_lock_state::write_locked</computeroutput>.</entry></row><row><entry><computeroutput>lk.read_lock()</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link> 
									if <computeroutput>locked()</computeroutput>.</para><para>If the associated read/write mutex
									object is already read-locked by some other
									thread, the effect depends on the
									<link linkend="threads.concepts.read-write-scheduling-policies.inter-class">inter-class scheduling policy</link>
									of the associated read/write mutex:
									either immediately obtains an additional
									read-lock on the associated read/write
									mutex, or places the current thread in the
									<link linkend="threads.glossary.thread-state">Blocked</link>
									state until the associated read/write mutex
									is unlocked, after which the current thread
									is placed in the 
									<link linkend="threads.glossary.thread-state">Ready</link>
									state, eventually to be returned to the 
									<link linkend="threads.glossary.thread-state">Running</link>
									state.</para><para>If the associated read/write mutex
									object is already write-locked by some other
									thread, places the current thread in the
									<link linkend="threads.glossary.thread-state">Blocked</link>
									state until the associated read/write mutex
									is unlocked, after which the current thread
									is placed in the 
									<link linkend="threads.glossary.thread-state">Ready</link>
									state, eventually to be returned to the
									<link linkend="threads.glossary.thread-state">Running</link>
									state.</para><para>If the associated read/write mutex
									object is already locked by the same thread
									the behavior is dependent on the
									<link linkend="threads.concepts.read-write-locking-strategies">locking strategy</link>
									of the associated read/write mutex object.
									</para><para>Postcondition: <computeroutput>state() == read_write_lock_state::read_locked</computeroutput></para></entry></row><row><entry><computeroutput>lk.write_lock()</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link> 
									if <computeroutput>locked()</computeroutput>.</para><para>If the associated read/write mutex
									object is already locked by some other
									thread, places the current thread in the
									<link linkend="threads.glossary.thread-state">Blocked</link>
									state until the associated read/write mutex
									is unlocked, after which the current thread
									is placed in the 
									<link linkend="threads.glossary.thread-state">Ready</link>
									state, eventually to be returned to the
									<link linkend="threads.glossary.thread-state">Running</link>
									state.</para><para>If the associated read/write mutex
									object is already locked by the same thread
									the behavior is dependent on the
									<link linkend="threads.concepts.read-write-locking-strategies">locking strategy</link>
									of the associated read/write mutex object.
									</para><para>Postcondition: <computeroutput>state() == read_write_lock_state::write_locked</computeroutput></para></entry></row><row><entry><computeroutput>lk.demote()</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if <computeroutput>state() != read_write_lock_state::write_locked</computeroutput>.</para><para>Converts the lock held on the associated read/write mutex
									object from a write-lock to a read-lock without releasing
									the lock.</para><para>Postcondition: <computeroutput>state() == read_write_lock_state::read_locked</computeroutput></para></entry></row><row><entry><computeroutput>lk.promote()</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if <computeroutput>state() != read_write_lock_state::read_locked</computeroutput>
									or if the lock cannot be promoted because another lock
									on the same mutex is already waiting to be promoted.</para><para>Makes a blocking attempt to convert the lock held on the associated
									read/write mutex object from a read-lock to a write-lock without releasing
									the lock.</para></entry></row><row><entry><computeroutput>lk.unlock()</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if <computeroutput>!locked()</computeroutput>.</para><para>Unlocks the associated read/write mutex.</para><para>Postcondition: <computeroutput>!locked()</computeroutput></para></entry></row></tbody></tgroup></table></section><section id="threads.concepts.ScopedReadWriteLock"><title>ScopedReadWriteLock Concept</title><para>A ScopedReadWriteLock is a refinement of 
				<link linkend="threads.concepts.ReadWriteLock">ReadWriteLock</link>. 
				For a ScopedReadWriteLock type <computeroutput>L</computeroutput> 
				and an object <computeroutput>lk</computeroutput> of that type,
				and an object <computeroutput>m</computeroutput> of a type meeting the 
				<link linkend="threads.concepts.ReadWriteMutex">ReadWriteMutex</link> requirements,
				and an object <computeroutput>s</computeroutput> of type <computeroutput>read_write_lock_state</computeroutput>,
				the following expressions must be well-formed 
				and have the indicated effects.</para><table><title>ScopedReadWriteLock Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>L lk(m,s);</computeroutput></entry><entry>Constructs an object <computeroutput>lk</computeroutput> and associates read/write mutex
								object <computeroutput>m</computeroutput> with it, then: if <computeroutput>s == read_write_lock_state::read_locked</computeroutput>, calls
								<computeroutput>read_lock()</computeroutput>; if <computeroutput>s==read_write_lock_state::write_locked</computeroutput>,
								calls <computeroutput>write_lock()</computeroutput>.</entry></row></tbody></tgroup></table></section><section id="threads.concepts.TryReadWriteLock"><title>TryReadWriteLock Expressions</title><para>A TryReadWriteLock is a refinement of 
				<link linkend="threads.concepts.ReadWriteLock">ReadWriteLock</link>.
				For a TryReadWriteLock type <computeroutput>L</computeroutput>
				and an object <computeroutput>lk</computeroutput> of that type,
				the following expressions must be well-formed
				and have the indicated effects.</para><table><title>TryReadWriteLock Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>lk.try_read_lock()</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if locked().</para><para>Makes a non-blocking attempt to read-lock the associated read/write
									mutex object, returning <computeroutput>true</computeroutput> if the attempt is successful,
									otherwise <computeroutput>false</computeroutput>. If the associated read/write mutex object is
									already locked by the same thread the behavior is dependent on the
									<link linkend="threads.concepts.locking-strategies">locking
									strategy</link> of the associated read/write mutex object.</para></entry></row><row><entry><computeroutput>lk.try_write_lock()</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if locked().</para><para>Makes a non-blocking attempt to write-lock the associated read/write
									mutex object, returning <computeroutput>true</computeroutput> if the attempt is successful,
									otherwise <computeroutput>false</computeroutput>. If the associated read/write mutex object is
									already locked by the same thread the behavior is dependent on the
									<link linkend="threads.concepts.locking-strategies">locking
									strategy</link> of the associated read/write mutex object.</para></entry></row><row><entry><computeroutput>lk.try_demote()</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if <computeroutput>state() != read_write_lock_state::write_locked</computeroutput>.</para><para>Makes a non-blocking attempt to convert the lock held on the associated
									read/write mutex object from a write-lock to a read-lock without releasing
									the lock, returning <computeroutput>true</computeroutput> if the attempt is successful,
									otherwise <computeroutput>false</computeroutput>.</para></entry></row><row><entry><computeroutput>lk.try_promote()</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if <computeroutput>state() != read_write_lock_state::read_locked</computeroutput>.</para><para>Makes a non-blocking attempt to convert the lock held on the associated
									read/write mutex object from a read-lock to a write-lock without releasing
									the lock, returning <computeroutput>true</computeroutput> if the attempt is successful,
									otherwise <computeroutput>false</computeroutput>.</para></entry></row></tbody></tgroup></table></section><section id="threads.concepts.ScopedTryReadWriteLock"><title>ScopedTryReadWriteLock Expressions</title><para>A ScopedTryReadWriteLock is a refinement of 
				<link linkend="threads.concepts.TryReadWriteLock">TryReadWriteLock</link>.
				For a ScopedTryReadWriteLock type <computeroutput>L</computeroutput>
				and an object <computeroutput>lk</computeroutput> of that type,
				and an object <computeroutput>m</computeroutput> of a type meeting the
				<link linkend="threads.concepts.TryMutex">TryReadWriteMutex</link> requirements,
				and an object <computeroutput>s</computeroutput> of type <computeroutput>read_write_lock_state</computeroutput>,
				and an object <computeroutput>b</computeroutput> of type <computeroutput>blocking_mode</computeroutput>, 
				the following expressions must be well-formed
				and have the indicated effects.</para><table><title>ScopedTryReadWriteLock Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>L lk(m,s,b);</computeroutput></entry><entry>Constructs an object <computeroutput>lk</computeroutput> and associates read/write mutex
								object <computeroutput>m</computeroutput> with it, then: if <computeroutput>s == read_write_lock_state::read_locked</computeroutput>, calls
								<computeroutput>read_lock()</computeroutput> if <computeroutput>b</computeroutput>, otherwise <computeroutput>try_read_lock()</computeroutput>;
								if <computeroutput>s==read_write_lock_state::write_locked</computeroutput>, calls <computeroutput>write_lock()</computeroutput> if <computeroutput>b</computeroutput>,
								otherwise <computeroutput>try_write_lock</computeroutput>.</entry></row></tbody></tgroup></table></section><section id="threads.concepts.TimedReadWriteLock"><title>TimedReadWriteLock Concept</title><para>A TimedReadWriteLock is a refinement of 
				<link linkend="threads.concepts.TryReadWriteLock">TryReadWriteLock</link>. 
				For a TimedReadWriteLock type <computeroutput>L</computeroutput>
				and an object <computeroutput>lk</computeroutput> of that type,
				and an object <computeroutput>t</computeroutput> of type <link linkend="xtime">boost::xtime</link>, 
				the following expressions must be well-formed
				and have the indicated effects.</para><table><title>TimedReadWriteLock Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>lk.timed_read_lock(t)</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if locked().</para><para>Makes a blocking attempt to read-lock the associated read/write mutex object,
									and returns <computeroutput>true</computeroutput> if successful within the specified time <computeroutput>t</computeroutput>,
									otherwise <computeroutput>false</computeroutput>. If the associated read/write mutex object is already
									locked by the same thread the behavior is dependent on the <link linkend="threads.concepts.locking-strategies">locking
									strategy</link> of the associated read/write mutex object.</para></entry></row><row><entry><computeroutput>lk.timed_write_lock(t)</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if locked().</para><para>Makes a blocking attempt to write-lock the associated read/write mutex object, 
									and returns <computeroutput>true</computeroutput> if successful within the specified time <computeroutput>t</computeroutput>,
									otherwise <computeroutput>false</computeroutput>. If the associated read/write mutex object is already
									locked by the same thread the behavior is dependent on the <link linkend="threads.concepts.locking-strategies">locking
									strategy</link> of the associated read/write mutex object.</para></entry></row><row><entry><computeroutput>lk.timed_demote(t)</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if <computeroutput>state() != read_write_lock_state::write_locked</computeroutput>.</para><para>Makes a blocking attempt to convert the lock held on the associated
									read/write mutex object from a write-lock to a read-lock without releasing
									the lock, returning <computeroutput>true</computeroutput> if the attempt is successful
									in the specified time <computeroutput>t</computeroutput>, otherwise <computeroutput>false</computeroutput>.</para></entry></row><row><entry><computeroutput>lk.timed_promote(t)</computeroutput></entry><entry><para>Throws <link linkend="lock_error">boost::lock_error</link>
									if <computeroutput>state() != read_write_lock_state::read_locked</computeroutput>.</para><para>Makes a blocking attempt to convert the lock held on the associated
									read/write mutex object from a read-lock to a write-lock without releasing
									the lock, returning <computeroutput>true</computeroutput> if the attempt is successful
									in the specified time <computeroutput>t</computeroutput>, otherwise <computeroutput>false</computeroutput>.</para></entry></row></tbody></tgroup></table></section><section id="threads.concepts.ScopedTimedReadWriteLock"><title>ScopedTimedReadWriteLock Concept</title><para>A ScopedTimedReadWriteLock is a refinement of 
				<link linkend="threads.concepts.TimedReadWriteLock">TimedReadWriteLock</link>. 
				For a ScopedTimedReadWriteLock type <computeroutput>L</computeroutput>
				and an object <computeroutput>lk</computeroutput> of that type,
				and an object <computeroutput>m</computeroutput> of a type meeting the 
				<link linkend="threads.concepts.TimedReadWriteMutex">TimedReadWriteMutex</link> requirements,
				and an object <computeroutput>s</computeroutput> of type <computeroutput>read_write_lock_state</computeroutput>,
				and an object <computeroutput>t</computeroutput> of type <link linkend="xtime">boost::xtime</link>, 
				and an object <computeroutput>b</computeroutput> of type <computeroutput>blocking_mode</computeroutput>, 
				the following expressions must be well-formed and have the
				indicated effects.</para><table><title>ScopedTimedReadWriteLock Expressions</title><tgroup cols="2"><thead><row><entry>Expression</entry><entry>Effects</entry></row></thead><tbody><row><entry><computeroutput>L lk(m,s,b);</computeroutput></entry><entry>Constructs an object <computeroutput>lk</computeroutput> and associates read/write mutex
								object <computeroutput>m</computeroutput> with it, then: if <computeroutput>s == read_write_lock_state::read_locked</computeroutput>, calls
								<computeroutput>read_lock()</computeroutput> if <computeroutput>b</computeroutput>, otherwise <computeroutput>try_read_lock()</computeroutput>;
								if <computeroutput>s==read_write_lock_state::write_locked</computeroutput>, calls <computeroutput>write_lock()</computeroutput> if <computeroutput>b</computeroutput>,
								otherwise <computeroutput>try_write_lock</computeroutput>.</entry></row><row><entry><computeroutput>L lk(m,s,t);</computeroutput></entry><entry>Constructs an object <computeroutput>lk</computeroutput> and associates read/write mutex
								object <computeroutput>m</computeroutput> with it, then: if <computeroutput>s == read_write_lock_state::read_locked</computeroutput>, calls
								<computeroutput>timed_read_lock(t)</computeroutput>; if <computeroutput>s==read_write_lock_state::write_locked</computeroutput>,
								calls <computeroutput>timed_write_lock(t)</computeroutput>.</entry></row></tbody></tgroup></table></section></section><section id="threads.concepts.read-write-lock-models"><title>Lock Models</title><para><emphasis role="bold">Boost.Threads</emphasis> currently supplies six models of
			<link linkend="threads.concepts.ReadWriteLock">ReadWriteLock</link>
			and its refinements.</para><table><title>Lock Models</title><tgroup cols="3"><thead><row><entry>Concept</entry><entry>Refines</entry><entry>Models</entry></row></thead><tbody><row><entry><link linkend="threads.concepts.ReadWriteLock">ReadWriteLock</link></entry><entry/><entry/></row><row><entry><link linkend="threads.concepts.ScopedReadWriteLock">ScopedReadWriteLock</link></entry><entry><link linkend="threads.concepts.ReadWriteLock">ReadWriteLock</link></entry><entry><para>boost::read_write_mutex::scoped_read_write_lock</para><para>boost::try_read_write_mutex::scoped_read_write_lock</para><para>boost::timed_read_write_mutex::scoped_read_write_lock</para></entry></row><row><entry><link linkend="threads.concepts.TryReadWriteLock">TryReadWriteLock</link></entry><entry><link linkend="threads.concepts.ReadWriteLock">ReadWriteLock</link></entry><entry/></row><row><entry><link linkend="threads.concepts.ScopedTryReadWriteLock">ScopedTryReadWriteLock</link></entry><entry><link linkend="threads.concepts.TryReadWriteLock">TryReadWriteLock</link></entry><entry><para>boost::try_read_write_mutex::scoped_try_read_write_lock</para><para>boost::timed_read_write_mutex::scoped_try_read_write_lock</para></entry></row><row><entry><link linkend="threads.concepts.TimedReadWriteLock">TimedReadWriteLock</link></entry><entry><link linkend="threads.concepts.TryReadWriteLock">TryReadWriteLock</link></entry><entry/></row><row><entry><link linkend="threads.concepts.ScopedTimedReadWriteLock">ScopedTimedReadWriteLock</link></entry><entry><link linkend="threads.concepts.TimedReadWriteLock">TimedReadWriteLock</link></entry><entry><para>boost::timed_read_write_mutex::scoped_timed_read_write_lock</para></entry></row></tbody></tgroup></table></section></section></section><section id="threads.rationale" rev:last-revision="$Date: 2004/07/17 04:33:59 $" xml:base="../libs/thread/doc/rationale.xml"><title>Rationale</title><para>This page explains the rationale behind various design decisions in the
  <emphasis role="bold">Boost.Threads</emphasis> library. Having the rationale documented here should explain
  how we arrived at the current design as well as prevent future rehashing of
  discussions and thought processes that have already occurred. It can also give
  users a lot of insight into the design process required for this
  library.</para><section id="threads.rationale.Boost.Threads"><title>Rationale for the Creation of <emphasis role="bold">Boost.Threads</emphasis></title><para>Processes often have a degree of "potential parallelism" and it can
	often be more intuitive to design systems with this in mind. Further, these
	parallel processes can result in more responsive programs. The benefits for
	multithreaded programming are quite well known to most modern programmers,
	yet the C++ language doesn't directly support this concept.</para><para>Many platforms support multithreaded programming despite the fact that
	the language doesn't support it. They do this through external libraries,
	which are, unfortunately, platform specific. POSIX has tried to address this
	problem through the standardization of a "pthread" library. However, this is
	a standard only on POSIX platforms, so its portability is limited.</para><para>Another problem with POSIX and other platform specific thread
	libraries is that they are almost universally C based libraries. This leaves
	several C++ specific issues unresolved, such as what happens when an
	exception is thrown in a thread. Further, there are some C++ concepts, such
	as destructors, that can make usage much easier than what's available in a C
	library.</para><para>What's truly needed is C++ language support for threads. However, the
	C++ standards committee needs existing practice or a good proposal as a
	starting point for adding this to the standard.</para><para>The <emphasis role="bold">Boost.Threads</emphasis> library was developed to provide a C++ developer
	with a portable interface for writing multithreaded programs on numerous
	platforms. There's a hope that the library can be the basis for a more
	detailed proposal for the C++ standards committee to consider for inclusion
	in the next C++ standard.</para></section><section id="threads.rationale.primitives"><title>Rationale for the Low Level Primitives Supported in <emphasis role="bold">Boost.Threads</emphasis></title><para>The <emphasis role="bold">Boost.Threads</emphasis> library supplies a set of low level primitives for
	writing multithreaded programs, such as mutexes and condition variables. In
	fact, the first release of <emphasis role="bold">Boost.Threads</emphasis> supports only these low level
	primitives. However, computer science research has shown that use of these
	primitives is difficult since it's difficult to mathematically prove that a
	usage pattern is correct, meaning it doesn't result in race conditions or
	deadlocks. There are several algebras (such as CSP, CCS and Join calculus)
	that have been developed to help write provably correct parallel
	processes. In order to prove the correctness these processes must be coded
	using higher level abstractions. So why does <emphasis role="bold">Boost.Threads</emphasis> support the
	lower level concepts?</para><para>The reason is simple: the higher level concepts need to be implemented
	using at least some of the lower level concepts. So having portable lower
	level concepts makes it easier to develop the higher level concepts and will
	allow researchers to experiment with various techniques.</para><para>Beyond this theoretical application of higher level concepts, however,
	the fact remains that many multithreaded programs are written using only the
	lower level concepts, so they are useful in and of themselves, even if it's
	hard to prove that their usage is correct. Since many users will be familiar
	with these lower level concepts but unfamiliar with any of the higher
	level concepts, supporting the lower level concepts provides
	greater accessibility.</para></section><section id="threads.rationale.locks"><title>Rationale for the Lock Design</title><para>Programmers who are used to multithreaded programming issues will
	quickly note that the <emphasis role="bold">Boost.Threads</emphasis> design for mutex lock concepts is not
	<link linkend="threads.glossary.thread-safe">thread-safe</link> (this is
	clearly documented as well). At first this may seem like a serious design
	flaw. Why have a multithreading primitive that's not thread-safe
	itself?</para><para>A lock object is not a synchronization primitive. A lock object's sole
	responsibility is to ensure that a mutex is both locked and unlocked in a
	manner that won't result in the common error of locking a mutex and then
	forgetting to unlock it. This means that instances of a lock object are only
	going to be created, at least in theory, within block scope and won't be
	shared between threads. Only the mutex objects will be created outside of
	block scope and/or shared between threads. Though it's possible to create a
	lock object outside of block scope and to share it between threads, to do so
	would not be a typical usage (in fact, to do so would likely be an
	error). Nor are there any cases when such usage would be required.</para><para>Lock objects must maintain some state information. In order to allow a
	program to determine if a try_lock or timed_lock was successful the lock
	object must retain state indicating the success or failure of the call made
	in its constructor. If a lock object were to have such state and remain
	thread-safe it would need to synchronize access to the state information
	which would result in roughly doubling the time of most operations. Worse,
	since checking the state can occur only by a call after construction, we'd
	have a race condition if the lock object were shared between threads.</para><para>So, to avoid the overhead of synchronizing access to the state
	information and to avoid the race condition, the <emphasis role="bold">Boost.Threads</emphasis> library
	simply does nothing to make lock objects thread-safe. Instead, sharing a
	lock object between threads results in undefined behavior. Since the only
	proper usage of lock objects is within block scope this isn't a problem, and
	so long as the lock object is properly used there's no danger of any
	multithreading issues.</para></section><section id="threads.rationale.non-copyable"><title>Rationale for NonCopyable Thread Type</title><para>Programmers who are used to C libraries for multithreaded programming
	are likely to wonder why <emphasis role="bold">Boost.Threads</emphasis> uses a noncopyable design for
	<link linkend="thread">boost::thread</link>. After all, the C thread types are
	copyable, and you often have a need for copying them within user
	code. However, careful comparison of C designs to C++ designs shows a flaw
	in this logic.</para><para>All C types are copyable. It is, in fact, not possible to make a
	noncopyable type in C. For this reason types that represent system resources
	in C are often designed to behave very similarly to a pointer to dynamic
	memory. There's an API for acquiring the resource and an API for releasing
	the resource. For memory we have pointers as the type and alloc/free for
	the acquisition and release APIs. For files we have FILE* as the type and
	fopen/fclose for the acquisition and release APIs. You can freely copy
	instances of the types but must manually manage the lifetime of the actual
	resource through the acquisition and release APIs.</para><para>C++ designs recognize that the acquisition and release APIs are error
	prone and try to eliminate possible errors by acquiring the resource in the
	constructor and releasing it in the destructor. The best example of such a
	design is the std::iostream set of classes which can represent the same
	resource as the FILE* type in C. A file is opened in the std::fstream's
	constructor and closed in its destructor. However, if an iostream were
	copyable it could lead to a file being closed twice, an obvious error, so
	the std::iostream types are noncopyable by design. This is the same design
	used by boost::thread, which is a simple and easy to understand design
	that's consistent with other C++ standard types.</para><para>During the design of boost::thread it was pointed out that it would be
	possible to allow it to be a copyable type if some form of "reference
	management" were used, such as ref-counting or ref-lists, and many argued
	for a boost::thread_ref design instead. The reasoning was that copying
	"thread" objects was a typical need in the C libraries, and so presumably
	would be in the C++ libraries as well. It was also thought that
	implementations could provide more efficient reference management than
	wrappers (such as boost::shared_ptr) around a noncopyable thread
	concept. Analysis of whether or not these arguments would hold true doesn't
	appear to bear them out. To illustrate the analysis we'll first provide
	pseudo-code illustrating the six typical usage patterns of a thread
	object.</para><section id="threads.rationale.non-copyable.simple"><title>1. Use case: Simple creation of a thread.</title><programlisting>
      void foo()
      {
         create_thread(&amp;bar);
      }
      </programlisting></section><section id="threads.rationale.non-copyable.joined"><title>2. Use case: Creation of a thread that's later joined.</title><programlisting>
      void foo()
      {
         thread = create_thread(&amp;bar);
         join(thread);
      }
      </programlisting></section><section id="threads.rationale.non-copyable.loop"><title>3. Use case: Simple creation of several threads in a loop.</title><programlisting>
      void foo()
      {
         for (int i=0; i&lt;NUM_THREADS; ++i)
            create_thread(&amp;bar);
      }
      </programlisting></section><section id="threads.rationale.non-copyable.loop-join"><title>4. Use case: Creation of several threads in a loop which are later joined.</title><programlisting>
      void foo()
      {
         for (int i=0; i&lt;NUM_THREADS; ++i)
            threads[i] = create_thread(&amp;bar);
         for (int i=0; i&lt;NUM_THREADS; ++i)
            threads[i].join();
      }
      </programlisting></section><section id="threads.rationale.non-copyable.pass"><title>5. Use case: Creation of a thread whose ownership is passed to another object/method.</title><programlisting>
      void foo()
      {
         thread = create_thread(&amp;bar);
         manager.owns(thread);
      }
      </programlisting></section><section id="threads.rationale.non-copyable.shared"><title>6. Use case: Creation of a thread whose ownership is shared between multiple
	  objects.</title><programlisting>
      void foo()
      {
         thread = create_thread(&amp;bar);
         manager1.add(thread);
         manager2.add(thread);
      }
      </programlisting></section><para>Of these usage patterns there's only one that requires reference
	management (number 6). Hopefully it's fairly obvious that this usage pattern
	simply won't occur as often as the other usage patterns. So there really
	isn't a "typical need" for a thread concept, though there is some
	need.</para><para>Since the need isn't typical we must use different criteria for
	deciding on either a thread_ref or thread design. Possible criteria include
	ease of use and performance. So let's analyze both of these
	carefully.</para><para>With ease of use we can look at existing experience. The standard C++
	objects that represent a system resource, such as std::iostream, are
	noncopyable, so we know that C++ programmers must at least be experienced
	with this design. Most C++ developers are also used to smart pointers such
	as boost::shared_ptr, so we know they can at least adapt to a thread_ref
	concept with little effort. So existing experience isn't going to lead us to
	a choice.</para><para>The other thing we can look at is how difficult it is to use both
	types for the six usage patterns above. If we find it overly difficult to
	use a concept for any of the usage patterns there would be a good argument
	for choosing the other design. So we'll code all six usage patterns using
	both designs.</para><section id="threads.rationale_comparison.non-copyable.simple"><title>1. Comparison: simple creation of a thread.</title><programlisting>
      void foo()
      {
         thread thrd(&amp;bar);
      }
      void foo()
      {
         thread_ref thrd = create_thread(&amp;bar);
      }
      </programlisting></section><section id="threads.rationale_comparison.non-copyable.joined"><title>2. Comparison: creation of a thread that's later joined.</title><programlisting>
      void foo()
      {
         thread thrd(&amp;bar);
         thrd.join();
      }
      void foo()
      {
         thread_ref thrd =
         create_thread(&amp;bar);thrd-&gt;join();
      }
      </programlisting></section><section id="threads.rationale_comparison.non-copyable.loop"><title>3. Comparison: simple creation of several threads in a loop.</title><programlisting>
      void foo()
      {
         for (int i=0; i&lt;NUM_THREADS; ++i)
            thread thrd(&amp;bar);
      }
      void foo()
      {
         for (int i=0; i&lt;NUM_THREADS; ++i)
            thread_ref thrd = create_thread(&amp;bar);
      }
      </programlisting></section><section id="threads.rationale_comparison.non-copyable.loop-join"><title>4. Comparison: creation of several threads in a loop which are later joined.</title><programlisting>
      void foo()
      {
         std::auto_ptr&lt;thread&gt; threads[NUM_THREADS];
         for (int i=0; i&lt;NUM_THREADS; ++i)
            threads[i] = std::auto_ptr&lt;thread&gt;(new thread(&amp;bar));
         for (int i= 0; i&lt;NUM_THREADS;
             ++i)threads[i]-&gt;join();
      }
      void foo()
      {
         thread_ref threads[NUM_THREADS];
         for (int i=0; i&lt;NUM_THREADS; ++i)
            threads[i] = create_thread(&amp;bar);
         for (int i= 0; i&lt;NUM_THREADS;
            ++i)threads[i]-&gt;join();
      }
      </programlisting></section><section id="threads.rationale_comparison.non-copyable.pass"><title>5. Comparison: creation of a thread whose ownership is passed to another object/method.</title><programlisting>
      void foo()
      {
         thread thrd* = new thread(&amp;bar);
         manager.owns(thread);
      }
      void foo()
      {
         thread_ref thrd = create_thread(&amp;bar);
         manager.owns(thrd);
      }
      </programlisting></section><section id="threads.rationale_comparison.non-copyable.shared"><title>6. Comparison: creation of a thread whose ownership is shared 
	  between multiple objects.</title><programlisting>
      void foo()
      {
         boost::shared_ptr&lt;thread&gt; thrd(new thread(&amp;bar));
         manager1.add(thrd);
         manager2.add(thrd);
      }
      void foo()
      {
         thread_ref thrd = create_thread(&amp;bar);
         manager1.add(thrd);
         manager2.add(thrd);
      }
      </programlisting></section><para>This shows the usage patterns being nearly identical in complexity for
	both designs. The only actual added complexity occurs because of the use of
	operator new in 
	<link linkend="threads.rationale_comparison.non-copyable.loop-join">(4)</link>,
	<link linkend="threads.rationale_comparison.non-copyable.pass">(5)</link>, and
	<link linkend="threads.rationale_comparison.non-copyable.shared">(6)</link>;
	and the use of std::auto_ptr and boost::shared_ptr in 
	<link linkend="threads.rationale_comparison.non-copyable.loop-join">(4)</link> and 
	<link linkend="threads.rationale_comparison.non-copyable.shared">(6)</link>
	respectively. However, that's not really
	much added complexity, and C++ programmers are used to using these idioms
	anyway. Some may dislike the presence of operator new in user code, but
	this can be eliminated by proper design of higher level concepts, such as
	the boost::thread_group class that simplifies example 
	<link linkend="threads.rationale_comparison.non-copyable.loop-join">(4)</link>
	down to:</para><programlisting>
    void foo()
    {
       thread_group threads;
       for (int i=0; i&lt;NUM_THREADS; ++i)
          threads.create_thread(&amp;bar);
       threads.join_all();
    }
    </programlisting><para>So ease of use is really a wash and not much help in picking a
	design.</para><para>So what about performance? Looking at the above code examples, 
    we can analyze the theoretical impact to performance that both designs
	have. For <link linkend="threads.rationale_comparison.non-copyable.simple">(1)</link>
	we can see that platforms that don't have a ref-counted native
	thread type (POSIX, for instance) will be impacted by a thread_ref
	design. Even if the native thread type is ref-counted there may be an impact
	if more state information has to be maintained for concepts foreign to the
	native API, such as clean up stacks for Win32 implementations. 
	For <link linkend="threads.rationale_comparison.non-copyable.joined">(2)</link>
	and <link linkend="threads.rationale_comparison.non-copyable.loop">(3)</link>
	the performance impact will be identical to
	<link linkend="threads.rationale_comparison.non-copyable.simple">(1)</link>.
	For <link linkend="threads.rationale_comparison.non-copyable.loop-join">(4)</link>
	things get a little more interesting and we find that theoretically at least
	the thread_ref may perform faster since the thread design requires dynamic
	memory allocation/deallocation. However, in practice there may be dynamic
	allocation for the thread_ref design as well, it will just be hidden from
	the user. As long as the implementation has to do dynamic allocations the
	thread_ref loses again because of the reference management. For 
	<link linkend="threads.rationale_comparison.non-copyable.pass">(5)</link> we see
	the same impact as we do for 
	<link linkend="threads.rationale_comparison.non-copyable.loop-join">(4)</link>.
	For <link linkend="threads.rationale_comparison.non-copyable.shared">(6)</link>
	we still have a possible impact to
	the thread design because of dynamic allocation but thread_ref no longer
	suffers because of its reference management, and in fact, theoretically at
	least, the thread_ref may do a better job of managing the references. All of
	this indicates that thread wins for 
	<link linkend="threads.rationale_comparison.non-copyable.simple">(1)</link>, 
	<link linkend="threads.rationale_comparison.non-copyable.joined">(2)</link> and 
	<link linkend="threads.rationale_comparison.non-copyable.loop">(3)</link>; with 
	<link linkend="threads.rationale_comparison.non-copyable.loop-join">(4)</link>
	and <link linkend="threads.rationale_comparison.non-copyable.pass">(5)</link> the
	winner depending on the implementation and the platform but with the thread design
	probably having a better chance; and with 
	<link linkend="threads.rationale_comparison.non-copyable.shared">(6)</link> 
	it will again depend on the
	implementation and platform but this time we favor thread_ref
	slightly. Given all of this it's a narrow margin, but the thread design
	prevails.</para><para>Given this analysis, and the fact that noncopyable objects for system
	resources are the normal designs that C++ programmers are used to dealing
	with, the <emphasis role="bold">Boost.Threads</emphasis> library has gone with a noncopyable design.</para></section><section id="threads.rationale.events"><title>Rationale for not providing <emphasis>Event Variables</emphasis></title><para><emphasis>Event variables</emphasis> are simply far too
	error-prone. <link linkend="condition">boost::condition</link> variables are a much safer
	alternative. [Note that Graphical User Interface <emphasis>events</emphasis> are 
	a different concept, and are not what is being discussed here.]</para><para>Event variables were one of the first synchronization primitives. They
	are still used today, for example, in the native Windows multithreading
	API. Yet both respected computer science researchers and experienced
	multithreading practitioners believe event variables are so inherently
	error-prone that they should never be used, and thus should not be part of a
	multithreading library.</para><para>Per Brinch Hansen <citation><xref linkend="threads.bib.Hansen73" endterm="threads.bib.Hansen73.abbrev"/></citation> analyzed event variables in some
	detail, pointing out [emphasis his] that "<emphasis>event operations force
	the programmer to be aware of the relative speeds of the sending and
	receiving processes</emphasis>". His summary:</para><blockquote><para>We must therefore conclude that event variables of the previous type
	  are impractical for system design. <emphasis>The effect of an interaction
	  between two processes must be independent of the speed at which it is
	  carried out.</emphasis></para></blockquote><para>Experienced programmers using the Windows platform today report that
	event variables are a continuing source of errors, even after previous bad
	experiences caused them to be very careful in their use of event
	variables. Overt problems can be avoided, for example, by teaming the event
	variable with a mutex, but that may just convert a <link linkend="threads.glossary.race-condition">race condition</link> into another
	problem, such as excessive resource use. One of the most distressing aspects
	of the experience reports is the claim that many defects are latent. That
	is, the programs appear to work correctly, but contain hidden timing
	dependencies which will cause them to fail when environmental factors or
	usage patterns change, altering relative thread timings.</para><para>The decision to exclude event variables from <emphasis role="bold">Boost.Threads</emphasis> has been
	surprising to some Windows programmers. They have written programs which
	work using event variables, and wonder what the problem is. It seems similar
	to the "goto considered harmful" controversy of 30 years ago. It isn't that
	events, like gotos, can't be made to work, but rather that virtually all
	programs using alternatives will be easier to write, debug, read, maintain,
	and will be less likely to contain latent defects.</para><para>[Rationale provided by Beman Dawes]</para></section></section><section id="threads.reference"><title>Reference</title><section id="id470450"><title>Header &lt;<ulink url="../../boost/thread/barrier.hpp">boost/thread/barrier.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="barrier">barrier</link>;
}</synopsis><refentry id="barrier"><refmeta><refentrytitle>Class barrier</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::barrier</refname><refpurpose><para>An object of class <link linkend="barrier">barrier</link> is a synchronization 
        primitive used  to cause a set of threads to wait until they each perform a 
        certain function or each reach a particular point in their execution.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> barrier : <emphasis role="bold">private</emphasis> boost::noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="barrierconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id330360-bb">barrier</link>(size_t);
&#xA0;&#xA0;<link linkend="id262518-bb">~barrier</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id480142-bb">waiting</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id262511-bb">wait</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>When a barrier is created, it is initialized with a thread count N.
		The first N-1 calls to <computeroutput>wait()</computeroutput> will all cause their threads to be blocked. 
		The Nth call to <computeroutput>wait()</computeroutput> will allow all  of the waiting threads, including 
		the Nth thread, to be placed in a ready state.  The Nth call will also "reset"
		the barrier such that, if an additional N+1th call is made to <computeroutput>wait()</computeroutput>, 
		it will be as though this were the first call to <computeroutput>wait()</computeroutput>; in other
		words, the N+1th to 2N-1th calls to <computeroutput>wait()</computeroutput> will cause their
		threads to be blocked, and the 2Nth call to <computeroutput>wait()</computeroutput> will allow all of 
		the waiting threads, including the 2Nth thread, to be placed in a ready state
		and reset the barrier. This functionality allows the same set of N threads to re-use 
		a barrier object to  synchronize their execution at multiple points during their 
		execution.</para><para>See <xref linkend="threads.glossary"/> for definitions of thread 
		states <link linkend="threads.glossary.thread-state">blocked</link>
		and <link linkend="threads.glossary.thread-state">ready</link>.
		Note that "waiting" is a synonym for blocked.</para><refsect2><title><anchor id="barrierconstruct-copy-destruct"/><computeroutput>barrier</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id330360-bb"/>barrier(size_t count);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Constructs a <link linkend="barrier">barrier</link> object that 
        will cause <computeroutput>count</computeroutput> threads to block on a call to <computeroutput>wait()</computeroutput>.
        </simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id262518-bb"/>~barrier();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Destroys <computeroutput>*this</computeroutput>. If threads are still executing 
		their <computeroutput>wait()</computeroutput> operations, the behavior for these threads is undefined.
		</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id480142-bb"/><computeroutput>barrier</computeroutput> waiting</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id262511-bb"/>wait();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Wait until N threads call <computeroutput>wait()</computeroutput>, where
          N equals the <computeroutput>count</computeroutput> provided to the constructor for the 
          barrier object.</simpara><simpara><emphasis role="bold">Note</emphasis> that if the barrier is 
          destroyed before <computeroutput>wait()</computeroutput> can return, the behavior is 
          undefined.</simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem>Exactly one of the N threads will receive a return value
		  of <computeroutput>true</computeroutput>, the others will receive a value of <computeroutput>false</computeroutput>. 
		  Precisely which thread receives the return value of <computeroutput>true</computeroutput> will 
		  be implementation-defined. Applications can use this value to designate one 
		  thread as a leader that will take a certain action, and the other threads 
		  emerging from the barrier can wait for that action to take place.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id525796"><title>Header &lt;<ulink url="../../boost/thread/condition.hpp">boost/thread/condition.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="condition">condition</link>;
}</synopsis><refentry id="condition"><refmeta><refentrytitle>Class condition</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::condition</refname><refpurpose><para>An object of class <link linkend="condition">condition</link> is a
          synchronization primitive used to cause a thread to wait until a
          particular shared-data condition (or time) is met.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> condition : <emphasis role="bold">private</emphasis> boost::noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="conditionconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id405345-bb">condition</link>();
&#xA0;&#xA0;<link linkend="id447365-bb">~condition</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id457659-bb">notification</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id478884-bb">notify_one</link>();
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id508299-bb">notify_all</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id439939-bb">waiting</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ScopedLock&gt; <type><emphasis role="bold">void</emphasis></type> <link linkend="id231704-bb">wait</link>(ScopedLock&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ScopedLock, <emphasis role="bold">typename</emphasis> Pred&gt; <type><emphasis role="bold">void</emphasis></type> <link linkend="id555106-bb">wait</link>(ScopedLock&amp;, Pred);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ScopedLock&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id414344-bb">timed_wait</link>(ScopedLock&amp;, <emphasis role="bold">const</emphasis> <link linkend="xtime">boost::xtime</link>&amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ScopedLock, <emphasis role="bold">typename</emphasis> Pred&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id336133-bb">timed_wait</link>(ScopedLock&amp;, Pred);
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>A <link linkend="condition">condition</link> object is always used in
          conjunction with a <link linkend="threads.concepts.mutexes">mutex</link>
          object (an object whose type is a model of a <link linkend="threads.concepts.Mutex">Mutex</link> or one of its
          refinements). The mutex object must be locked prior to waiting on the
          condition, which is verified by passing a lock object (an object whose
          type is a model of <link linkend="threads.concepts.Lock">Lock</link> or
          one of its refinements) to the <link linkend="condition">condition</link> object's
          wait functions. Upon blocking on the <link linkend="condition">condition</link>
          object, the thread unlocks the mutex object. When the thread returns
          from a call to one of the <link linkend="condition">condition</link> object's wait
          functions the mutex object is again locked. The tricky unlock/lock
          sequence is performed automatically by the
          <link linkend="condition">condition</link> object's wait functions.</para><para>The <link linkend="condition">condition</link> type is often used to
          implement the Monitor Object and other important patterns (see
          <citation><xref linkend="threads.bib.SchmidtStalRohnertBuschmann" endterm="threads.bib.SchmidtStalRohnertBuschmann.abbrev"/></citation> and <citation><xref linkend="threads.bib.Hoare74" endterm="threads.bib.Hoare74.abbrev"/></citation>). Monitors are one
          of the most important patterns for creating reliable multithreaded
          programs.</para><para>See <xref linkend="threads.glossary"/> for definitions of <link linkend="threads.glossary.thread-state">thread states</link>
          blocked and ready. Note that "waiting" is a synonym for blocked.</para><refsect2><title><anchor id="conditionconstruct-copy-destruct"/><computeroutput>condition</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id405345-bb"/>condition();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Constructs a <link linkend="condition">condition</link>
            object.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id447365-bb"/>~condition();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Destroys <computeroutput>*this</computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id457659-bb"/><computeroutput>condition</computeroutput> notification</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id478884-bb"/>notify_one();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>If there is a thread waiting on <computeroutput>*this</computeroutput>,
              change that thread's state to ready. Otherwise there is no
              effect.</simpara></listitem></varlistentry><varlistentry><term>Notes</term><listitem><simpara>If more than one thread is waiting on <computeroutput>*this</computeroutput>,
              it is unspecified which is made ready. After returning to a ready
              state the notified thread must still acquire the mutex again (which
              occurs within the call to one of the <link linkend="condition">condition</link>
              object's wait functions.)</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id508299-bb"/>notify_all();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Change the state of all threads waiting on
              <computeroutput>*this</computeroutput> to ready. If there are no waiting threads,
              <computeroutput>notify_all()</computeroutput> has no effect.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id439939-bb"/><computeroutput>condition</computeroutput> waiting</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ScopedLock&gt; <type><emphasis role="bold">void</emphasis></type> <anchor id="id231704-bb"/>wait(ScopedLock&amp; lock);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara><computeroutput>ScopedLock</computeroutput> meets the <link linkend="threads.concepts.ScopedLock">ScopedLock</link>
              requirements.</simpara></listitem></varlistentry><varlistentry><term>Effects</term><listitem><simpara>Releases the lock on the <link linkend="threads.concepts.mutexes">mutex object</link>
              associated with <computeroutput>lock</computeroutput>, blocks the current thread of execution
              until readied by a call to <computeroutput>this-&gt;notify_one()</computeroutput>
              or<computeroutput> this-&gt;notify_all()</computeroutput>, and then reacquires the
              lock.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara><link linkend="lock_error">lock_error</link> if
              <computeroutput>!lock.locked()</computeroutput></simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ScopedLock, <emphasis role="bold">typename</emphasis> Pred&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <anchor id="id555106-bb"/>wait(ScopedLock&amp; lock, Pred pred);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara><computeroutput>ScopedLock</computeroutput> meets the <link linkend="threads.concepts.ScopedLock">ScopedLock</link>
              requirements and the return from <computeroutput>pred()</computeroutput> is
              convertible to <computeroutput>bool</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Effects</term><listitem><simpara>As if: <computeroutput>while (!pred())
                wait(lock)</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara><link linkend="lock_error">lock_error</link> if
              <computeroutput>!lock.locked()</computeroutput></simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ScopedLock&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id414344-bb"/>timed_wait(ScopedLock&amp; lock, <emphasis role="bold">const</emphasis> <link linkend="xtime">boost::xtime</link>&amp; xt);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara><computeroutput>ScopedLock</computeroutput> meets the <link linkend="threads.concepts.ScopedLock">ScopedLock</link>
              requirements.</simpara></listitem></varlistentry><varlistentry><term>Effects</term><listitem><simpara>Releases the lock on the <link linkend="threads.concepts.mutexes">mutex object</link>
              associated with <computeroutput>lock</computeroutput>, blocks the current thread of execution
              until readied by a call to <computeroutput>this-&gt;notify_one()</computeroutput>
              or<computeroutput> this-&gt;notify_all()</computeroutput>, or until time <computeroutput>xt</computeroutput> 
              is reached, and then reacquires the lock.</simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara><computeroutput>false</computeroutput> if time <computeroutput>xt</computeroutput> is reached,
              otherwise <computeroutput>true</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara><link linkend="lock_error">lock_error</link> if
              <computeroutput>!lock.locked()</computeroutput></simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ScopedLock, <emphasis role="bold">typename</emphasis> Pred&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <anchor id="id336133-bb"/>timed_wait(ScopedLock&amp; lock, Pred pred);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara><computeroutput>ScopedLock</computeroutput> meets the <link linkend="threads.concepts.ScopedLock">ScopedLock</link>
              requirements and the return from <computeroutput>pred()</computeroutput> is
              convertible to <computeroutput>bool</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Effects</term><listitem><simpara>As if: <computeroutput>while (!pred()) { if (!timed_wait(lock,
                xt)) return false; } return true;</computeroutput></simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara><computeroutput>false</computeroutput> if <computeroutput>xt</computeroutput> is reached,
              otherwise <computeroutput>true</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara><link linkend="lock_error">lock_error</link> if
              <computeroutput>!lock.locked()</computeroutput></simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id417361"><title>Header &lt;<ulink url="../../boost/thread/exceptions.hpp">boost/thread/exceptions.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="lock_error">lock_error</link>;
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="thread_resource_error">thread_resource_error</link>;
}</synopsis><refentry id="lock_error"><refmeta><refentrytitle>Class lock_error</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::lock_error</refname><refpurpose><simpara>The lock_error class defines an exception type thrown
			to indicate a locking related error has been detected.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> lock_error : <emphasis role="bold">public</emphasis> <type>std::logical_error</type> {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="lock_errorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id421939-bb">lock_error</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara>Examples of errors indicated by a lock_error exception 
			include a lock operation which can be determined to result in a 
			deadlock, or unlock operations attempted by a thread that does 
			not own the lock.</simpara><refsect2><title><anchor id="lock_errorconstruct-copy-destruct"/><computeroutput>lock_error</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id421939-bb"/>lock_error();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Constructs a <computeroutput>lock_error</computeroutput> object.
			</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="thread_resource_error"><refmeta><refentrytitle>Class thread_resource_error</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::thread_resource_error</refname><refpurpose><simpara>The <link linkend="thread_resource_error">thread_resource_error</link> class
			defines an exception type that is thrown by constructors in the
			<emphasis role="bold">Boost.Threads</emphasis> library when thread-related resources can not be 
			acquired.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> thread_resource_error : <emphasis role="bold">public</emphasis> <type>std::runtime_error</type> {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="thread_resource_errorconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id220271-bb">thread_resource_error</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara><link linkend="thread_resource_error">thread_resource_error</link> is used
			only when thread-related resources cannot be acquired; memory
			allocation failures are indicated by 
			std::bad_alloc.</simpara><refsect2><title><anchor id="thread_resource_errorconstruct-copy-destruct"/><computeroutput>thread_resource_error</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id220271-bb"/>thread_resource_error();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Constructs a <computeroutput>thread_resource_error</computeroutput>
			object.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id405534"><title>Header &lt;<ulink url="../../boost/thread/mutex.hpp">boost/thread/mutex.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="mutex">mutex</link>;
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="try_mutex">try_mutex</link>;
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="timed_mutex">timed_mutex</link>;
}</synopsis><refentry id="mutex"><refmeta><refentrytitle>Class mutex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::mutex</refname><refpurpose><para>The <link linkend="mutex">mutex</link> class is a model of the 
			<link linkend="threads.concepts.Mutex">Mutex</link> concept.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> mutex : <emphasis role="bold">private</emphasis> boost::noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_lock;

&#xA0;&#xA0;<emphasis>// <link linkend="mutexconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id327644-bb">mutex</link>();
&#xA0;&#xA0;<link linkend="id441803-bb">~mutex</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <link linkend="mutex">mutex</link> class is a model of the 
			<link linkend="threads.concepts.Mutex">Mutex</link> concept. 
			It should be used to synchronize access to shared resources using
			<link linkend="threads.concepts.unspecified-locking-strategy">Unspecified</link>
			locking mechanics.</para><para>For classes that model related mutex concepts, see 
			<link linkend="try_mutex">try_mutex</link> and <link linkend="timed_mutex">timed_mutex</link>.</para><para>For <link linkend="threads.concepts.recursive-locking-strategy">Recursive</link>
			locking mechanics, see <link linkend="recursive_mutex">recursive_mutex</link>,
			<link linkend="recursive_try_mutex">recursive_try_mutex</link>, and <link linkend="recursive_timed_mutex">recursive_timed_mutex</link>.
			</para><para>The <link linkend="mutex">mutex</link> class supplies the following typedef,
			which <link linkend="threads.concepts.lock-models">models</link>
			the specified locking strategy:

			<informaltable><tgroup cols="2" align="left"><thead><row><entry>Lock Name</entry><entry>Lock Concept</entry></row></thead><tbody><row><entry>scoped_lock</entry><entry><link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry></row></tbody></tgroup></informaltable></para><para>The <link linkend="mutex">mutex</link> class uses an 
			<link linkend="threads.concepts.unspecified-locking-strategy">Unspecified</link>
			locking strategy, so attempts to recursively lock a <link linkend="mutex">mutex</link>
			object or attempts to unlock one by threads that don't own a lock on it result in
			<emphasis role="bold">undefined behavior</emphasis>.
			This strategy allows implementations to be as efficient as possible
			on any given platform. It is, however, recommended that
			implementations include debugging support to detect misuse when
			<computeroutput>NDEBUG</computeroutput> is not defined.</para><para>Like all
			<link linkend="threads.concepts.mutex-models">mutex models</link>
			in <emphasis role="bold">Boost.Threads</emphasis>, <link linkend="mutex">mutex</link> leaves the 
			<link linkend="threads.concepts.sheduling-policies">scheduling policy</link>
			as <link linkend="threads.concepts.unspecified-scheduling-policy">Unspecified</link>. 
			Programmers should make no assumptions about the order in which
			waiting threads acquire a lock.</para><refsect2><title><anchor id="mutexconstruct-copy-destruct"/><computeroutput>mutex</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id327644-bb"/>mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Constructs a <link linkend="mutex">mutex</link> object.
			</listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.
			</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id441803-bb"/>~mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Destroys a <link linkend="mutex">mutex</link> object.</listitem></varlistentry><varlistentry><term>Requires</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.</listitem></varlistentry><varlistentry><term>Notes</term><listitem><emphasis role="bold">Danger:</emphasis> Destruction of a
			locked mutex is a serious programming error resulting in undefined
			behavior such as a program crash.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="try_mutex"><refmeta><refentrytitle>Class try_mutex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::try_mutex</refname><refpurpose><para>The <link linkend="try_mutex">try_mutex</link> class is a model of the 
			<link linkend="threads.concepts.TryMutex">TryMutex</link> concept.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> try_mutex : <emphasis role="bold">private</emphasis> boost::noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_lock;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_try_lock;

&#xA0;&#xA0;<emphasis>// <link linkend="try_mutexconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id339968-bb">try_mutex</link>();
&#xA0;&#xA0;<link linkend="id246386-bb">~try_mutex</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <link linkend="try_mutex">try_mutex</link> class is a model of the 
			<link linkend="threads.concepts.TryMutex">TryMutex</link> concept. 
			It should be used to synchronize access to shared resources using
			<link linkend="threads.concepts.unspecified-locking-strategy">Unspecified</link>
			locking mechanics.</para><para>For classes that model related mutex concepts, see 
			<link linkend="mutex">mutex</link> and <link linkend="timed_mutex">timed_mutex</link>.</para><para>For <link linkend="threads.concepts.recursive-locking-strategy">Recursive</link>
			locking mechanics, see <link linkend="recursive_mutex">recursive_mutex</link>,
			<link linkend="recursive_try_mutex">recursive_try_mutex</link>, and <link linkend="recursive_timed_mutex">recursive_timed_mutex</link>.
			</para><para>The <link linkend="try_mutex">try_mutex</link> class supplies the following typedefs,
			which <link linkend="threads.concepts.lock-models">model</link>
			the specified locking strategies:

			<informaltable><tgroup cols="2" align="left"><thead><row><entry>Lock Name</entry><entry>Lock Concept</entry></row></thead><tbody><row><entry>scoped_lock</entry><entry><link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry></row><row><entry>scoped_try_lock</entry><entry><link linkend="threads.concepts.ScopedTryLock">ScopedTryLock</link></entry></row></tbody></tgroup></informaltable></para><para>The <link linkend="try_mutex">try_mutex</link> class uses an 
			<link linkend="threads.concepts.unspecified-locking-strategy">Unspecified</link>
			locking strategy, so attempts to recursively lock a <link linkend="try_mutex">try_mutex</link>
			object or attempts to unlock one by threads that don't own a lock on it result in
			<emphasis role="bold">undefined behavior</emphasis>.
			This strategy allows implementations to be as efficient as possible
			on any given platform. It is, however, recommended that
			implementations include debugging support to detect misuse when
			<computeroutput>NDEBUG</computeroutput> is not defined.</para><para>Like all
			<link linkend="threads.concepts.mutex-models">mutex models</link>
			in <emphasis role="bold">Boost.Threads</emphasis>, <link linkend="try_mutex">try_mutex</link> leaves the 
			<link linkend="threads.concepts.sheduling-policies">scheduling policy</link>
			as <link linkend="threads.concepts.unspecified-scheduling-policy">Unspecified</link>. 
			Programmers should make no assumptions about the order in which
			waiting threads acquire a lock.</para><refsect2><title><anchor id="try_mutexconstruct-copy-destruct"/><computeroutput>try_mutex</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id339968-bb"/>try_mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Constructs a <link linkend="try_mutex">try_mutex</link> object.
			</listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.
			</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id246386-bb"/>~try_mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Destroys a <link linkend="try_mutex">try_mutex</link> object.
			</listitem></varlistentry><varlistentry><term>Requires</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.</listitem></varlistentry><varlistentry><term>Notes</term><listitem><emphasis role="bold">Danger:</emphasis> Destruction of a
			locked mutex is a serious programming error resulting in undefined
			behavior such as a program crash.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="timed_mutex"><refmeta><refentrytitle>Class timed_mutex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::timed_mutex</refname><refpurpose><para>The <link linkend="timed_mutex">timed_mutex</link> class is a model of the 
			<link linkend="threads.concepts.TimedMutex">TimedMutex</link> concept.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> timed_mutex : <emphasis role="bold">private</emphasis> boost::noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_try_lock;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_timed_lock;

&#xA0;&#xA0;<emphasis>// <link linkend="timed_mutexconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id551651-bb">timed_mutex</link>();
&#xA0;&#xA0;<link linkend="id234091-bb">~timed_mutex</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <link linkend="timed_mutex">timed_mutex</link> class is a model of the 
			<link linkend="threads.concepts.TimedMutex">TimedMutex</link> concept. 
			It should be used to synchronize access to shared resources using
			<link linkend="threads.concepts.unspecified-locking-strategy">Unspecified</link>
			locking mechanics.</para><para>For classes that model related mutex concepts, see 
			<link linkend="mutex">mutex</link> and <link linkend="try_mutex">try_mutex</link>.</para><para>For <link linkend="threads.concepts.recursive-locking-strategy">Recursive</link>
			locking mechanics, see <link linkend="recursive_mutex">recursive_mutex</link>,
			<link linkend="recursive_try_mutex">recursive_try_mutex</link>, and <link linkend="recursive_timed_mutex">recursive_timed_mutex</link>.
			</para><para>The <link linkend="timed_mutex">timed_mutex</link> class supplies the following typedefs,
			which <link linkend="threads.concepts.lock-models">model</link>
			the specified locking strategies:

			<informaltable><tgroup cols="2" align="left"><thead><row><entry>Lock Name</entry><entry>Lock Concept</entry></row></thead><tbody><row><entry>scoped_lock</entry><entry><link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry></row><row><entry>scoped_try_lock</entry><entry><link linkend="threads.concepts.ScopedTryLock">ScopedTryLock</link></entry></row><row><entry>scoped_timed_lock</entry><entry><link linkend="threads.concepts.ScopedTimedLock">ScopedTimedLock</link></entry></row></tbody></tgroup></informaltable></para><para>The <link linkend="timed_mutex">timed_mutex</link> class uses an 
			<link linkend="threads.concepts.unspecified-locking-strategy">Unspecified</link>
			locking strategy, so attempts to recursively lock a <link linkend="timed_mutex">timed_mutex</link>
			object or attempts to unlock one by threads that don't own a lock on it result in
			<emphasis role="bold">undefined behavior</emphasis>.
			This strategy allows implementations to be as efficient as possible
			on any given platform. It is, however, recommended that
			implementations include debugging support to detect misuse when
			<computeroutput>NDEBUG</computeroutput> is not defined.</para><para>Like all 
			<link linkend="threads.concepts.mutex-models">mutex models</link>
			in  <emphasis role="bold">Boost.Threads</emphasis>, <link linkend="timed_mutex">timed_mutex</link> leaves the 
			<link linkend="threads.concepts.sheduling-policies">scheduling policy</link>
			as <link linkend="threads.concepts.unspecified-scheduling-policy">Unspecified</link>. 
			Programmers should make no assumptions about the order in which
			waiting threads acquire a lock.</para><refsect2><title><anchor id="timed_mutexconstruct-copy-destruct"/><computeroutput>timed_mutex</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id551651-bb"/>timed_mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Constructs a <link linkend="timed_mutex">timed_mutex</link> object.
			</listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.
			</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id234091-bb"/>~timed_mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Destroys a <link linkend="timed_mutex">timed_mutex</link> object.</listitem></varlistentry><varlistentry><term>Requires</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.</listitem></varlistentry><varlistentry><term>Notes</term><listitem><emphasis role="bold">Danger:</emphasis> Destruction of a
			locked mutex is a serious programming error resulting in undefined
			behavior such as a program crash.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id485587"><title>Header &lt;<ulink url="../../boost/thread/once.hpp">boost/thread/once.hpp</ulink>&gt;</title><synopsis>

<link linkend="BOOST_ONCE_INIT">BOOST_ONCE_INIT</link></synopsis><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> once_flag;  <emphasis>// The <link linkend="call_once">call_once</link> function and
			<computeroutput>once_flag</computeroutput> type (statically initialized to 
			<link linkend="BOOST_ONCE_INIT">BOOST_ONCE_INIT</link>) can be used to run a
			routine exactly once. This can be used to initialize data in a
			<link linkend="threads.glossary.thread-safe">thread-safe</link>
			manner.</emphasis>
&#xA0;&#xA0; <link linkend="call_once">call_once</link>(<emphasis role="bold">void</emphasis> (*func)(), once_flag&amp;);
}</synopsis><refentry id="BOOST_ONCE_INIT"><refmeta><refentrytitle>Macro BOOST_ONCE_INIT</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>BOOST_ONCE_INIT</refname><refpurpose>The call_once function and
		<computeroutput>once_flag</computeroutput> type (statically initialized to 
		<link linkend="BOOST_ONCE_INIT">BOOST_ONCE_INIT</link>) can be used to run a
		routine exactly once. This can be used to initialize data in a
		<link linkend="threads.glossary.thread-safe">thread-safe</link>
		manner.</refpurpose></refnamediv><refsynopsisdiv><synopsis>BOOST_ONCE_INIT</synopsis></refsynopsisdiv><refsect1><title>Description</title>The implementation-defined macro 
		<link linkend="BOOST_ONCE_INIT">BOOST_ONCE_INIT</link> is a constant value used to 
		initialize <computeroutput>once_flag</computeroutput> instances to indicate that the 
		logically associated routine has not been run yet. See 
		call_once for more details.</refsect1></refentry><refentry id="call_once"><refmeta><refentrytitle>Function call_once</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::call_once</refname><refpurpose>The <link linkend="call_once">call_once</link> function and
			<computeroutput>once_flag</computeroutput> type (statically initialized to 
			<link linkend="BOOST_ONCE_INIT">BOOST_ONCE_INIT</link>) can be used to run a
			routine exactly once. This can be used to initialize data in a
			<link linkend="threads.glossary.thread-safe">thread-safe</link>
			manner.</refpurpose></refnamediv><refsynopsisdiv><synopsis>
 call_once(<emphasis role="bold">void</emphasis> (*func)() func, once_flag&amp; flag);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Example usage is as follows:</para><para><programlisting>//Example usage:
boost::once_flag once = BOOST_ONCE_INIT;

void init()
{
    //...
}

void thread_proc()
{
    boost::call_once(&amp;init, once);
}</programlisting></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem>The function <computeroutput>func</computeroutput> shall not throw
			exceptions.</listitem></varlistentry><varlistentry><term>Effects</term><listitem>As if (in an atomic fashion): 
			<computeroutput>if (flag == BOOST_ONCE_INIT) func();</computeroutput></listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><computeroutput>flag != BOOST_ONCE_INIT</computeroutput></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id462943"><title>Header &lt;<ulink url="../../boost/thread/recursive_mutex.hpp">boost/thread/recursive_mutex.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="recursive_mutex">recursive_mutex</link>;
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="recursive_try_mutex">recursive_try_mutex</link>;
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="recursive_timed_mutex">recursive_timed_mutex</link>;
}</synopsis><refentry id="recursive_mutex"><refmeta><refentrytitle>Class recursive_mutex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::recursive_mutex</refname><refpurpose><para>The <link linkend="recursive_mutex">recursive_mutex</link> class is a model of the 
			<link linkend="threads.concepts.Mutex">Mutex</link> concept.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> recursive_mutex : <emphasis role="bold">private</emphasis> boost::noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_lock;

&#xA0;&#xA0;<emphasis>// <link linkend="recursive_mutexconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id425611-bb">recursive_mutex</link>();
&#xA0;&#xA0;<link linkend="id292688-bb">~recursive_mutex</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <link linkend="recursive_mutex">recursive_mutex</link> class is a model of the 
			<link linkend="threads.concepts.Mutex">Mutex</link> concept. 
			It should be used to synchronize access to shared resources using
			<link linkend="threads.concepts.recursive-locking-strategy">Recursive</link>
			locking mechanics.</para><para>For classes that model related mutex concepts, see 
			<link linkend="recursive_try_mutex">recursive_try_mutex</link> and <link linkend="recursive_timed_mutex">recursive_timed_mutex</link>.</para><para>For <link linkend="threads.concepts.unspecified-locking-strategy">Unspecified</link>
			locking mechanics, see <link linkend="mutex">mutex</link>,
			<link linkend="try_mutex">try_mutex</link>, and <link linkend="timed_mutex">timed_mutex</link>.
			</para><para>The <link linkend="recursive_mutex">recursive_mutex</link> class supplies the following typedef,
			which models the specified locking strategy:

			<table><title>Supported Lock Types</title><tgroup cols="2" align="left"><thead><row><entry>Lock Name</entry><entry>Lock Concept</entry></row></thead><tbody><row><entry>scoped_lock</entry><entry><link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry></row></tbody></tgroup></table></para><para>The <link linkend="recursive_mutex">recursive_mutex</link> class uses a
			<link linkend="threads.concepts.recursive-locking-strategy">Recursive</link>
			locking strategy, so attempts to recursively lock a 
			<link linkend="recursive_mutex">recursive_mutex</link> object
			succeed and an internal "lock count" is maintained. 
			Attempts to unlock a <link linkend="recursive_mutex">recursive_mutex</link> object
			by threads that don't own a lock on it result in
			<emphasis role="bold">undefined behavior</emphasis>.</para><para>Like all
			<link linkend="threads.concepts.mutex-models">mutex models</link>
			in <emphasis role="bold">Boost.Threads</emphasis>, <link linkend="recursive_mutex">recursive_mutex</link> leaves the 
			<link linkend="threads.concepts.sheduling-policies">scheduling policy</link>
			as <link linkend="threads.concepts.unspecified-scheduling-policy">Unspecified</link>. 
			Programmers should make no assumptions about the order in which
			waiting threads acquire a lock.</para><refsect2><title><anchor id="recursive_mutexconstruct-copy-destruct"/><computeroutput>recursive_mutex</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id425611-bb"/>recursive_mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Constructs a <link linkend="recursive_mutex">recursive_mutex</link> object.
			</listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.
			</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id292688-bb"/>~recursive_mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Destroys a <link linkend="recursive_mutex">recursive_mutex</link> object.</listitem></varlistentry><varlistentry><term>Requires</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.</listitem></varlistentry><varlistentry><term>Notes</term><listitem><emphasis role="bold">Danger:</emphasis> Destruction of a
			locked mutex is a serious programming error resulting in undefined
			behavior such as a program crash.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="recursive_try_mutex"><refmeta><refentrytitle>Class recursive_try_mutex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::recursive_try_mutex</refname><refpurpose><para>The <link linkend="recursive_try_mutex">recursive_try_mutex</link> class is a model of the 
			<link linkend="threads.concepts.TryMutex">TryMutex</link> concept.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> recursive_try_mutex : <emphasis role="bold">private</emphasis> boost::noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_lock;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_try_lock;

&#xA0;&#xA0;<emphasis>// <link linkend="recursive_try_mutexconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id489606-bb">recursive_try_mutex</link>();
&#xA0;&#xA0;<link linkend="id353219-bb">~recursive_try_mutex</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <link linkend="recursive_try_mutex">recursive_try_mutex</link> class is a model of the 
			<link linkend="threads.concepts.TryMutex">TryMutex</link> concept. 
			It should be used to synchronize access to shared resources using
			<link linkend="threads.concepts.recursive-locking-strategy">Recursive</link>
			locking mechanics.</para><para>For classes that model related mutex concepts, see 
			<link linkend="recursive_mutex">recursive_mutex</link> and <link linkend="recursive_timed_mutex">recursive_timed_mutex</link>.</para><para>For <link linkend="threads.concepts.unspecified-locking-strategy">Unspecified</link>
			locking mechanics, see <link linkend="mutex">mutex</link>,
			<link linkend="try_mutex">try_mutex</link>, and <link linkend="timed_mutex">timed_mutex</link>.
			</para><para>The <link linkend="recursive_try_mutex">recursive_try_mutex</link> class supplies the following typedefs,
			which model the specified locking strategies:

			<table><title>Supported Lock Types</title><tgroup cols="2" align="left"><thead><row><entry>Lock Name</entry><entry>Lock Concept</entry></row></thead><tbody><row><entry>scoped_lock</entry><entry><link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry></row><row><entry>scoped_try_lock</entry><entry><link linkend="threads.concepts.ScopedTryLock">ScopedTryLock</link></entry></row></tbody></tgroup></table></para><para>The <link linkend="recursive_try_mutex">recursive_try_mutex</link> class uses a
			<link linkend="threads.concepts.recursive-locking-strategy">Recursive</link>
			locking strategy, so attempts to recursively lock a 
			<link linkend="recursive_try_mutex">recursive_try_mutex</link> object
			succeed and an internal "lock count" is maintained. 
			Attempts to unlock a <link linkend="recursive_mutex">recursive_mutex</link> object
			by threads that don't own a lock on it result in
			<emphasis role="bold">undefined behavior</emphasis>.</para><para>Like all
			<link linkend="threads.concepts.mutex-models">mutex models</link>
			in <emphasis role="bold">Boost.Threads</emphasis>, <link linkend="recursive_try_mutex">recursive_try_mutex</link> leaves the 
			<link linkend="threads.concepts.sheduling-policies">scheduling policy</link>
			as <link linkend="threads.concepts.unspecified-scheduling-policy">Unspecified</link>. 
			Programmers should make no assumptions about the order in which
			waiting threads acquire a lock.</para><refsect2><title><anchor id="recursive_try_mutexconstruct-copy-destruct"/><computeroutput>recursive_try_mutex</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id489606-bb"/>recursive_try_mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Constructs a <link linkend="recursive_try_mutex">recursive_try_mutex</link> object.
			</listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.
			</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id353219-bb"/>~recursive_try_mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Destroys a <link linkend="recursive_try_mutex">recursive_try_mutex</link> object.
			</listitem></varlistentry><varlistentry><term>Requires</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.</listitem></varlistentry><varlistentry><term>Notes</term><listitem><emphasis role="bold">Danger:</emphasis> Destruction of a
			locked mutex is a serious programming error resulting in undefined
			behavior such as a program crash.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="recursive_timed_mutex"><refmeta><refentrytitle>Class recursive_timed_mutex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::recursive_timed_mutex</refname><refpurpose><para>The <link linkend="recursive_timed_mutex">recursive_timed_mutex</link> class is a model of the 
			<link linkend="threads.concepts.TimedMutex">TimedMutex</link> concept.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> recursive_timed_mutex : <emphasis role="bold">private</emphasis> boost::noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_try_lock;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_timed_lock;

&#xA0;&#xA0;<emphasis>// <link linkend="recursive_timed_mutexconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id378769-bb">recursive_timed_mutex</link>();
&#xA0;&#xA0;<link linkend="id304305-bb">~recursive_timed_mutex</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <link linkend="recursive_timed_mutex">recursive_timed_mutex</link> class is a model of the 
			<link linkend="threads.concepts.TimedMutex">TimedMutex</link> concept. 
			It should be used to synchronize access to shared resources using
			<link linkend="threads.concepts.recursive-locking-strategy">Recursive</link>
			locking mechanics.</para><para>For classes that model related mutex concepts, see 
			<link linkend="recursive_mutex">recursive_mutex</link> and <link linkend="recursive_try_mutex">recursive_try_mutex</link>.</para><para>For <link linkend="threads.concepts.unspecified-locking-strategy">Unspecified</link>
			locking mechanics, see <link linkend="mutex">mutex</link>,
			<link linkend="try_mutex">try_mutex</link>, and <link linkend="timed_mutex">timed_mutex</link>.
			</para><para>The <link linkend="recursive_timed_mutex">recursive_timed_mutex</link> class supplies the following typedefs,
			which model the specified locking strategies:

			<table><title>Supported Lock Types</title><tgroup cols="2" align="left"><thead><row><entry>Lock Name</entry><entry>Lock Concept</entry></row></thead><tbody><row><entry>scoped_lock</entry><entry><link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry></row><row><entry>scoped_try_lock</entry><entry><link linkend="threads.concepts.ScopedTryLock">ScopedTryLock</link></entry></row><row><entry>scoped_timed_lock</entry><entry><link linkend="threads.concepts.ScopedTimedLock">ScopedTimedLock</link></entry></row></tbody></tgroup></table></para><para>The <link linkend="recursive_timed_mutex">recursive_timed_mutex</link> class uses a
			<link linkend="threads.concepts.recursive-locking-strategy">Recursive</link>
			locking strategy, so attempts to recursively lock a 
			<link linkend="recursive_timed_mutex">recursive_timed_mutex</link> object
			succeed and an internal "lock count" is maintained. 
			Attempts to unlock a <link linkend="recursive_mutex">recursive_mutex</link> object
			by threads that don't own a lock on it result in
			<emphasis role="bold">undefined behavior</emphasis>.</para><para>Like all 
			<link linkend="threads.concepts.mutex-models">mutex models</link>
			in  <emphasis role="bold">Boost.Threads</emphasis>, <link linkend="recursive_timed_mutex">recursive_timed_mutex</link> leaves the 
			<link linkend="threads.concepts.sheduling-policies">scheduling policy</link>
			as <link linkend="threads.concepts.unspecified-scheduling-policy">Unspecified</link>. 
			Programmers should make no assumptions about the order in which
			waiting threads acquire a lock.</para><refsect2><title><anchor id="recursive_timed_mutexconstruct-copy-destruct"/><computeroutput>recursive_timed_mutex</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id378769-bb"/>recursive_timed_mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Constructs a <link linkend="recursive_timed_mutex">recursive_timed_mutex</link> object.
			</listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.
			</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id304305-bb"/>~recursive_timed_mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Destroys a <link linkend="recursive_timed_mutex">recursive_timed_mutex</link> object.</listitem></varlistentry><varlistentry><term>Requires</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.</listitem></varlistentry><varlistentry><term>Notes</term><listitem><emphasis role="bold">Danger:</emphasis> Destruction of a
			locked mutex is a serious programming error resulting in undefined
			behavior such as a program crash.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id283850"><title>Header &lt;<ulink url="../../boost/thread/read_write_mutex.hpp">boost/thread/read_write_mutex.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="read_write_mutex">read_write_mutex</link>;
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="try_read_write_mutex">try_read_write_mutex</link>;
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="timed_read_write_mutex">timed_read_write_mutex</link>;
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> read_write_scheduling_policy {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <link linkend="id285973">read_write_scheduling_policy</link>;
&#xA0;&#xA0;}
}</synopsis><refentry id="id285973"><refmeta><refentrytitle>Type read_write_scheduling_policy</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::read_write_scheduling_policy::read_write_scheduling_policy</refname><refpurpose><para>Specifies the 
				<link linkend="threads.concepts.read-write-scheduling-policies.inter-class">inter-class sheduling policy</link>
				to use when a set of threads try to obtain different types of
				locks simultaneously.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">enum</emphasis> read_write_scheduling_policy { writer_priority, reader_priority, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;alternating_many_reads, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;alternating_single_read };</synopsis></refsynopsisdiv></refentry><refentry id="read_write_mutex"><refmeta><refentrytitle>Class read_write_mutex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::read_write_mutex</refname><refpurpose><para>The <link linkend="read_write_mutex">read_write_mutex</link> class is a model of the 
			<link linkend="threads.concepts.ReadWriteMutex">ReadWriteMutex</link> concept.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> read_write_mutex : <emphasis role="bold">private</emphasis> boost::noncopyable,  <emphasis>// Exposition only</emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">private</emphasis> boost::noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_read_write_lock;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_read_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_write_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="read_write_mutexconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id418786-bb">read_write_mutex</link>(boost::read_write_scheduling_policy);
&#xA0;&#xA0;<link linkend="id502846-bb">~read_write_mutex</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <link linkend="read_write_mutex">read_write_mutex</link> class is a model of the 
			<link linkend="threads.concepts.ReadWriteMutex">ReadWriteMutex</link> concept. 
			It should be used to synchronize access to shared resources using
			<link linkend="threads.concepts.read-write-locking-strategies.unspecified">Unspecified</link>
			locking mechanics.</para><para>For classes that model related mutex concepts, see 
			<link linkend="try_read_write_mutex">try_read_write_mutex</link> and <link linkend="timed_read_write_mutex">timed_read_write_mutex</link>.</para><para>The <link linkend="read_write_mutex">read_write_mutex</link> class supplies the following typedefs,
			which <link linkend="threads.concepts.read-write-lock-models">model</link>
			the specified locking strategies:

			<informaltable><tgroup cols="2" align="left"><thead><row><entry>Lock Name</entry><entry>Lock Concept</entry></row></thead><tbody><row><entry>scoped_read_write_lock</entry><entry><link linkend="threads.concepts.ScopedReadWriteLock">ScopedReadWriteLock</link></entry></row><row><entry>scoped_read_lock</entry><entry><link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry></row><row><entry>scoped_write_lock</entry><entry><link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry></row></tbody></tgroup></informaltable></para><para>The <link linkend="read_write_mutex">read_write_mutex</link> class uses an 
			<link linkend="threads.concepts.read-write-locking-strategies.unspecified">Unspecified</link>
			locking strategy, so attempts to recursively lock a <link linkend="read_write_mutex">read_write_mutex</link>
			object or attempts to unlock one by threads that don't own a lock on it result in
			<emphasis role="bold">undefined behavior</emphasis>.
			This strategy allows implementations to be as efficient as possible
			on any given platform. It is, however, recommended that
			implementations include debugging support to detect misuse when
			<computeroutput>NDEBUG</computeroutput> is not defined.</para><para>Like all
			<link linkend="threads.concepts.read-write-mutex-models">read/write mutex models</link>
			in <emphasis role="bold">Boost.Threads</emphasis>, <link linkend="read_write_mutex">read_write_mutex</link> has two types of
			<link linkend="threads.concepts.read-write-scheduling-policies">scheduling policies</link>, an 
			<link linkend="threads.concepts.read-write-scheduling-policies.inter-class">inter-class sheduling policy</link>
			between threads trying to obtain different types of locks and an
			<link linkend="threads.concepts.read-write-scheduling-policies.intra-class">intra-class sheduling policy</link>
			between threads trying to obtain the same type of lock.
			The <link linkend="read_write_mutex">read_write_mutex</link> class allows the
			programmer to choose what
			<link linkend="threads.concepts.read-write-scheduling-policies.inter-class">inter-class sheduling policy</link>
			will be used; however, like all read/write mutex models, 
			<link linkend="read_write_mutex">read_write_mutex</link> leaves the 
			<link linkend="threads.concepts.read-write-scheduling-policies.intra-class">intra-class sheduling policy</link> as 
			<link linkend="threads.concepts.read-write-locking-strategies.unspecified">Unspecified</link>.			
			</para><note>Self-deadlock is virtually guaranteed if a thread tries to
			lock the same <link linkend="read_write_mutex">read_write_mutex</link> multiple times
			unless all locks are read-locks (but see below)</note><refsect2><title><anchor id="read_write_mutexconstruct-copy-destruct"/><computeroutput>read_write_mutex</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id418786-bb"/>read_write_mutex(boost::read_write_scheduling_policy count);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Constructs a <link linkend="read_write_mutex">read_write_mutex</link> object.
			</listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.
			</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id502846-bb"/>~read_write_mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Destroys a <link linkend="read_write_mutex">read_write_mutex</link> object.</listitem></varlistentry><varlistentry><term>Requires</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.</listitem></varlistentry><varlistentry><term>Notes</term><listitem><emphasis role="bold">Danger:</emphasis> Destruction of a
			locked mutex is a serious programming error resulting in undefined
			behavior such as a program crash.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="try_read_write_mutex"><refmeta><refentrytitle>Class try_read_write_mutex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::try_read_write_mutex</refname><refpurpose><para>The <link linkend="try_read_write_mutex">try_read_write_mutex</link> class is a model of the 
			<link linkend="threads.concepts.TryReadWriteMutex">TryReadWriteMutex</link> concept.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> try_read_write_mutex : <emphasis role="bold">private</emphasis> boost::noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_read_write_lock;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_try_read_write_lock;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_read_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_try_read_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_write_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_try_write_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="try_read_write_mutexconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id338115-bb">try_read_write_mutex</link>(boost::read_write_scheduling_policy);
&#xA0;&#xA0;<link linkend="id219377-bb">~try_read_write_mutex</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <link linkend="try_read_write_mutex">try_read_write_mutex</link> class is a model of the 
			<link linkend="threads.concepts.TryReadWriteMutex">TryReadWriteMutex</link> concept. 
			It should be used to synchronize access to shared resources using
			<link linkend="threads.concepts.read-write-locking-strategies.unspecified">Unspecified</link>
			locking mechanics.</para><para>For classes that model related mutex concepts, see 
			<link linkend="read_write_mutex">read_write_mutex</link> and <link linkend="timed_read_write_mutex">timed_read_write_mutex</link>.</para><para>The <link linkend="try_read_write_mutex">try_read_write_mutex</link> class supplies the following typedefs,
			which <link linkend="threads.concepts.read-write-lock-models">model</link>
			the specified locking strategies:

			<informaltable><tgroup cols="2" align="left"><thead><row><entry>Lock Name</entry><entry>Lock Concept</entry></row></thead><tbody><row><entry>scoped_read_write_lock</entry><entry><link linkend="threads.concepts.ScopedReadWriteLock">ScopedReadWriteLock</link></entry></row><row><entry>scoped_try_read_write_lock</entry><entry><link linkend="threads.concepts.ScopedTryReadWriteLock">ScopedTryReadWriteLock</link></entry></row><row><entry>scoped_read_lock</entry><entry><link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry></row><row><entry>scoped_try_read_lock</entry><entry><link linkend="threads.concepts.ScopedTryLock">ScopedTryLock</link></entry></row><row><entry>scoped_write_lock</entry><entry><link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry></row><row><entry>scoped_try_write_lock</entry><entry><link linkend="threads.concepts.ScopedTryLock">ScopedTryLock</link></entry></row></tbody></tgroup></informaltable></para><para>The <link linkend="try_read_write_mutex">try_read_write_mutex</link> class uses an 
			<link linkend="threads.concepts.read-write-locking-strategies.unspecified">Unspecified</link>
			locking strategy, so attempts to recursively lock a <link linkend="try_read_write_mutex">try_read_write_mutex</link>
			object or attempts to unlock one by threads that don't own a lock on it result in
			<emphasis role="bold">undefined behavior</emphasis>.
			This strategy allows implementations to be as efficient as possible
			on any given platform. It is, however, recommended that
			implementations include debugging support to detect misuse when
			<computeroutput>NDEBUG</computeroutput> is not defined.</para><para>Like all
			<link linkend="threads.concepts.read-write-mutex-models">read/write mutex models</link>
			in <emphasis role="bold">Boost.Threads</emphasis>, <link linkend="try_read_write_mutex">try_read_write_mutex</link> has two types of
			<link linkend="threads.concepts.read-write-scheduling-policies">scheduling policies</link>, an 
			<link linkend="threads.concepts.read-write-scheduling-policies.inter-class">inter-class sheduling policy</link>
			between threads trying to obtain different types of locks and an
			<link linkend="threads.concepts.read-write-scheduling-policies.intra-class">intra-class sheduling policy</link>
			between threads trying to obtain the same type of lock.
			The <link linkend="try_read_write_mutex">try_read_write_mutex</link> class allows the
			programmer to choose what
			<link linkend="threads.concepts.read-write-scheduling-policies.inter-class">inter-class sheduling policy</link>
			will be used; however, like all read/write mutex models, 
			<link linkend="try_read_write_mutex">try_read_write_mutex</link> leaves the 
			<link linkend="threads.concepts.read-write-scheduling-policies.intra-class">intra-class sheduling policy</link> as 
			<link linkend="threads.concepts.unspecified-scheduling-policy">Unspecified</link>.			
			</para><note>Self-deadlock is virtually guaranteed if a thread tries to
			lock the same <link linkend="try_read_write_mutex">try_read_write_mutex</link> multiple times
			unless all locks are read-locks (but see below)</note><refsect2><title><anchor id="try_read_write_mutexconstruct-copy-destruct"/><computeroutput>try_read_write_mutex</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id338115-bb"/>try_read_write_mutex(boost::read_write_scheduling_policy count);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Constructs a <link linkend="try_read_write_mutex">try_read_write_mutex</link> object.
			</listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.
			</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id219377-bb"/>~try_read_write_mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Destroys a <link linkend="try_read_write_mutex">try_read_write_mutex</link> object.</listitem></varlistentry><varlistentry><term>Requires</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.</listitem></varlistentry><varlistentry><term>Notes</term><listitem><emphasis role="bold">Danger:</emphasis> Destruction of a
			locked mutex is a serious programming error resulting in undefined
			behavior such as a program crash.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="timed_read_write_mutex"><refmeta><refentrytitle>Class timed_read_write_mutex</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::timed_read_write_mutex</refname><refpurpose><para>The <link linkend="timed_read_write_mutex">timed_read_write_mutex</link> class is a model of the 
			<link linkend="threads.concepts.TimedReadWriteMutex">TimedReadWriteMutex</link> concept.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> timed_read_write_mutex {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_read_write_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_try_read_write_lock;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_timed_read_write_lock;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_read_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_try_read_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_timed_read_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_write_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_try_write_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>implementation-defined</emphasis> scoped_timed_write_lock;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;

&#xA0;&#xA0;<emphasis>// <link linkend="timed_read_write_mutexconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id462287-bb">timed_read_write_mutex</link>(boost::read_write_scheduling_policy);
&#xA0;&#xA0;<link linkend="id536502-bb">~timed_read_write_mutex</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <link linkend="timed_read_write_mutex">timed_read_write_mutex</link> class is a model of the 
			<link linkend="threads.concepts.TimedReadWriteMutex">TimedReadWriteMutex</link> concept. 
			It should be used to synchronize access to shared resources using
			<link linkend="threads.concepts.read-write-locking-strategies.unspecified">Unspecified</link>
			locking mechanics.</para><para>For classes that model related mutex concepts, see 
			<link linkend="read_write_mutex">read_write_mutex</link> and <link linkend="try_read_write_mutex">try_read_write_mutex</link>.</para><para>The <link linkend="timed_read_write_mutex">timed_read_write_mutex</link> class supplies the following typedefs,
			which <link linkend="threads.concepts.read-write-lock-models">model</link>
			the specified locking strategies:

			<informaltable><tgroup cols="2" align="left"><thead><row><entry>Lock Name</entry><entry>Lock Concept</entry></row></thead><tbody><row><entry>scoped_read_write_lock</entry><entry><link linkend="threads.concepts.ScopedReadWriteLock">ScopedReadWriteLock</link></entry></row><row><entry>scoped_try_read_write_lock</entry><entry><link linkend="threads.concepts.ScopedTryReadWriteLock">ScopedTryReadWriteLock</link></entry></row><row><entry>scoped_timed_read_write_lock</entry><entry><link linkend="threads.concepts.ScopedTimedReadWriteLock">ScopedTimedReadWriteLock</link></entry></row><row><entry>scoped_read_lock</entry><entry><link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry></row><row><entry>scoped_try_read_lock</entry><entry><link linkend="threads.concepts.ScopedTryLock">ScopedTryLock</link></entry></row><row><entry>scoped_timed_read_lock</entry><entry><link linkend="threads.concepts.ScopedTimedLock">ScopedTimedLock</link></entry></row><row><entry>scoped_write_lock</entry><entry><link linkend="threads.concepts.ScopedLock">ScopedLock</link></entry></row><row><entry>scoped_try_write_lock</entry><entry><link linkend="threads.concepts.ScopedTryLock">ScopedTryLock</link></entry></row><row><entry>scoped_timed_write_lock</entry><entry><link linkend="threads.concepts.ScopedTimedLock">ScopedTimedLock</link></entry></row></tbody></tgroup></informaltable></para><para>The <link linkend="timed_read_write_mutex">timed_read_write_mutex</link> class uses an 
			<link linkend="threads.concepts.read-write-locking-strategies.unspecified">Unspecified</link>
			locking strategy, so attempts to recursively lock a <link linkend="timed_read_write_mutex">timed_read_write_mutex</link>
			object or attempts to unlock one by threads that don't own a lock on it result in
			<emphasis role="bold">undefined behavior</emphasis>.
			This strategy allows implementations to be as efficient as possible
			on any given platform. It is, however, recommended that
			implementations include debugging support to detect misuse when
			<computeroutput>NDEBUG</computeroutput> is not defined.</para><para>Like all
			<link linkend="threads.concepts.read-write-mutex-models">read/write mutex models</link>
			in <emphasis role="bold">Boost.Threads</emphasis>, <link linkend="timed_read_write_mutex">timed_read_write_mutex</link> has two types of
			<link linkend="threads.concepts.read-write-scheduling-policies">scheduling policies</link>, an 
			<link linkend="threads.concepts.read-write-scheduling-policies.inter-class">inter-class sheduling policy</link>
			between threads trying to obtain different types of locks and an
			<link linkend="threads.concepts.read-write-scheduling-policies.intra-class">intra-class sheduling policy</link>
			between threads trying to obtain the same type of lock.
			The <link linkend="timed_read_write_mutex">timed_read_write_mutex</link> class allows the
			programmer to choose what
			<link linkend="threads.concepts.read-write-scheduling-policies.inter-class">inter-class sheduling policy</link>
			will be used; however, like all read/write mutex models, 
			<link linkend="timed_read_write_mutex">timed_read_write_mutex</link> leaves the 
			<link linkend="threads.concepts.read-write-scheduling-policies.intra-class">intra-class sheduling policy</link> as 
			<link linkend="threads.concepts.unspecified-scheduling-policy">Unspecified</link>.			
			</para><note>Self-deadlock is virtually guaranteed if a thread tries to
			lock the same <link linkend="timed_read_write_mutex">timed_read_write_mutex</link> multiple times
			unless all locks are read-locks (but see below)</note><refsect2><title><anchor id="timed_read_write_mutexconstruct-copy-destruct"/><computeroutput>timed_read_write_mutex</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id462287-bb"/>timed_read_write_mutex(boost::read_write_scheduling_policy count);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Constructs a <link linkend="timed_read_write_mutex">timed_read_write_mutex</link> object.
			</listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.
			</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id536502-bb"/>~timed_read_write_mutex();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Destroys a <link linkend="timed_read_write_mutex">timed_read_write_mutex</link> object.</listitem></varlistentry><varlistentry><term>Requires</term><listitem><computeroutput>*this</computeroutput> is in an unlocked state.</listitem></varlistentry><varlistentry><term>Notes</term><listitem><emphasis role="bold">Danger:</emphasis> Destruction of a
			locked mutex is a serious programming error resulting in undefined
			behavior such as a program crash.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id277856"><title>Header &lt;<ulink url="../../boost/thread/thread.hpp">boost/thread/thread.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="thread">thread</link>;
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="thread_group">thread_group</link>;
}</synopsis><refentry id="thread"><refmeta><refentrytitle>Class thread</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::thread</refname><refpurpose><para>The <link linkend="thread">thread</link> class represents threads of
			execution, and provides the functionality to create and manage 
			threads within the <emphasis role="bold">Boost.Threads</emphasis> library. See 
			<xref linkend="threads.glossary"/> for a precise description of 
			<link linkend="threads.glossary.thread">thread of execution</link>,
			and for definitions of threading-related terms and of thread states such as 
			<link linkend="threads.glossary.thread-state">blocked</link>.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> thread : <emphasis role="bold">private</emphasis> boost::noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="threadconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id401409-bb">thread</link>();
&#xA0;&#xA0;<emphasis role="bold">explicit</emphasis> <link linkend="id238497-bb">thread</link>(<emphasis role="bold">const</emphasis> boost::function0&lt;<emphasis role="bold">void</emphasis>&gt;&amp;);
&#xA0;&#xA0;<link linkend="id485614-bb">~thread</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id437199-bb">comparison</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id415233-bb"><emphasis role="bold">operator</emphasis>==</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id453854-bb"><emphasis role="bold">operator</emphasis>!=</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id471479-bb">modifier</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id479493-bb">join</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id413185-bb">static</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">static</emphasis> <type><emphasis role="bold">void</emphasis></type> <link linkend="id490506-bb">sleep</link>(<emphasis role="bold">const</emphasis> <link linkend="xtime">xtime</link>&amp;);
&#xA0;&#xA0;<emphasis role="bold">static</emphasis> <type><emphasis role="bold">void</emphasis></type> <link linkend="id455757-bb">yield</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>A <link linkend="threads.glossary.thread">thread of execution</link>
			has an initial function. For the program's initial thread, the initial 
			function is <computeroutput>main()</computeroutput>. For other threads, the initial 
			function is <computeroutput>operator()</computeroutput> of the function object passed to
			the <link linkend="thread">thread</link> object's constructor.</para><para>A thread of execution  is said to be "finished" 
			or to have "finished execution" when its initial function returns or 
			is terminated. This includes completion of all thread cleanup 
			handlers, and completion of the normal C++ function return behaviors,
			such as destruction of automatic storage (stack) objects and releasing 
			any associated implementation resources.</para><para>A thread object has an associated state which is either
			"joinable" or "non-joinable".</para><para>Except as described below, the policy used by an implementation
			of <emphasis role="bold">Boost.Threads</emphasis> to schedule transitions between thread states is 
			unspecified.</para><para><note>Just as the lifetime of a file may be different from the
			lifetime of an <computeroutput>iostream</computeroutput> object which represents the file, the lifetime
			of a thread of execution may be different from the 
			<link linkend="thread">thread</link> object which represents the thread of 
			execution. In particular, after a call to <computeroutput>join()</computeroutput>,
			the thread of execution will no longer exist even though the 
			<link linkend="thread">thread</link> object continues to exist until the 
			end of its normal lifetime. The converse is also possible; if 
			a <link linkend="thread">thread</link> object is destroyed without 
			<computeroutput>join()</computeroutput> first having been called, the thread of execution 
			continues until its initial function completes.</note></para><refsect2><title><anchor id="threadconstruct-copy-destruct"/><computeroutput>thread</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id401409-bb"/>thread();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Constructs a <link linkend="thread">thread</link> object 
			representing the current thread of execution.</listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><computeroutput>*this</computeroutput> is non-joinable.</listitem></varlistentry><varlistentry><term>Notes</term><listitem><emphasis role="bold">Danger:</emphasis><computeroutput>*this</computeroutput> is valid only within the current thread.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">explicit</emphasis> <anchor id="id238497-bb"/>thread(<emphasis role="bold">const</emphasis> boost::function0&lt;<emphasis role="bold">void</emphasis>&gt;&amp; threadfunc);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>
				Starts a new thread of execution and constructs a 
				<link linkend="thread">thread</link> object representing it. 
				Copies <computeroutput>threadfunc</computeroutput> (which in turn copies
				the function object wrapped by <computeroutput>threadfunc</computeroutput>) 
				to an internal location which persists for the lifetime 
				of the new thread of execution. Calls <computeroutput>operator()</computeroutput>
				on the copy of the <computeroutput>threadfunc</computeroutput> function object 
				in the new thread of execution.
			</listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><computeroutput>*this</computeroutput> is joinable.</listitem></varlistentry><varlistentry><term>Throws</term><listitem><computeroutput>boost::thread_resource_error</computeroutput> if a new thread
			of execution cannot be started.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id485614-bb"/>~thread();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Destroys <computeroutput>*this</computeroutput>. The actual thread of 
			execution may continue to execute after the 
			<link linkend="thread">thread</link> object has been destroyed.
			</listitem></varlistentry><varlistentry><term>Notes</term><listitem>If <computeroutput>*this</computeroutput> is joinable the actual thread 
			of execution becomes "detached". Any resources used 
			by the thread will be reclaimed when the thread of execution 
			completes. To ensure such a thread of execution runs to completion
			before the <link linkend="thread">thread</link> object is destroyed, call
			<computeroutput>join()</computeroutput>.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id437199-bb"/><computeroutput>thread</computeroutput> comparison</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id415233-bb"/><emphasis role="bold">operator</emphasis>==( rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem>The thread is non-terminated or <computeroutput>*this</computeroutput>
				is joinable.</listitem></varlistentry><varlistentry><term>Returns</term><listitem><computeroutput>true</computeroutput> if <computeroutput>*this</computeroutput> and 
				<computeroutput>rhs</computeroutput> represent the same thread of 
				execution.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id453854-bb"/><emphasis role="bold">operator</emphasis>!=( rhs) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem>The thread is non-terminated or <computeroutput>*this</computeroutput>
				is joinable.</listitem></varlistentry><varlistentry><term>Returns</term><listitem><computeroutput>!(*this==rhs)</computeroutput>.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id471479-bb"/><computeroutput>thread</computeroutput> modifier</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id479493-bb"/>join();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><computeroutput>*this</computeroutput> is joinable.</listitem></varlistentry><varlistentry><term>Effects</term><listitem>The current thread of execution blocks until the 
				initial function of the thread of execution represented by 
				<computeroutput>*this</computeroutput> finishes and all resources are 
				reclaimed.</listitem></varlistentry><varlistentry><term>Notes</term><listitem>If <computeroutput>*this == thread()</computeroutput> the result is 
				implementation-defined. If the implementation doesn't
				detect this the result will be 
				<link linkend="threads.glossary.deadlock">deadlock</link>.
				</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id413185-bb"/><computeroutput>thread</computeroutput> static</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">static</emphasis> <type><emphasis role="bold">void</emphasis></type> <anchor id="id490506-bb"/>sleep(<emphasis role="bold">const</emphasis> <link linkend="xtime">xtime</link>&amp; xt);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>The current thread of execution blocks until 
				<computeroutput>xt</computeroutput> is reached.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">static</emphasis> <type><emphasis role="bold">void</emphasis></type> <anchor id="id455757-bb"/>yield();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>The current thread of execution is placed in the
				<link linkend="threads.glossary.thread-state">ready</link> 
				state.</listitem></varlistentry><varlistentry><term>Notes</term><listitem><simpara>Allow the current thread to give up the rest of its 
					time slice (or other scheduling quota) to another thread. 
					Particularly useful in non-preemptive implementations.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="thread_group"><refmeta><refentrytitle>Class thread_group</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::thread_group</refname><refpurpose>
			The <link linkend="thread_group">thread_group</link> class provides a container
			for easy grouping of threads to simplify several common thread 
			creation and management idioms.
		</refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> thread_group : <emphasis role="bold">private</emphasis> boost::noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="thread_groupconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id529728-bb">thread_group</link>();
&#xA0;&#xA0;<link linkend="id445605-bb">~thread_group</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id223199-bb">modifier</link></emphasis>
&#xA0;&#xA0;<type><link linkend="thread">thread</link>*</type> <link linkend="id397277-bb">create_thread</link>(<emphasis role="bold">const</emphasis> boost::function0&lt;<emphasis role="bold">void</emphasis>&gt;&amp;);
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id406849-bb">add_thread</link>(<link linkend="thread">thread</link>* thrd);
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id487039-bb">remove_thread</link>(<link linkend="thread">thread</link>* thrd);
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id318007-bb">join_all</link>();
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><refsect2><title><anchor id="thread_groupconstruct-copy-destruct"/><computeroutput>thread_group</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id529728-bb"/>thread_group();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Constructs an empty <link linkend="thread_group">thread_group</link>
			container.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id445605-bb"/>~thread_group();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Destroys each contained thread object. Destroys <computeroutput>*this</computeroutput>.</listitem></varlistentry><varlistentry><term>Notes</term><listitem>Behavior is undefined if another thread references 
			<computeroutput>*this </computeroutput> during the execution of the destructor.
			</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id223199-bb"/><computeroutput>thread_group</computeroutput> modifier</title><orderedlist><listitem><para><literallayout class="monospaced"><type><link linkend="thread">thread</link>*</type> <anchor id="id397277-bb"/>create_thread(<emphasis role="bold">const</emphasis> boost::function0&lt;<emphasis role="bold">void</emphasis>&gt;&amp; threadfunc);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Creates a new <link linkend="thread">thread</link> object 
				that executes <computeroutput>threadfunc</computeroutput> and adds it to the 
				<computeroutput>thread_group</computeroutput> container object's list of managed
				<link linkend="thread">thread</link> objects.</listitem></varlistentry><varlistentry><term>Returns</term><listitem>Pointer to the newly created 
				<link linkend="thread">thread</link> object.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id406849-bb"/>add_thread(<link linkend="thread">thread</link>* thrd thrd);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Adds <computeroutput>thrd</computeroutput> to the 
				<link linkend="thread_group">thread_group</link> object's list of managed 
				<link linkend="thread">thread</link> objects. The <computeroutput>thrd</computeroutput> 
				object must have been allocated via <computeroutput>operator new</computeroutput> and will 
				be deleted when the group is destroyed.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id487039-bb"/>remove_thread(<link linkend="thread">thread</link>* thrd thrd);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Removes <computeroutput>thread</computeroutput> from <computeroutput>*this</computeroutput>'s
				list of managed <link linkend="thread">thread</link> objects.</listitem></varlistentry><varlistentry><term>Throws</term><listitem><emphasis role="bold">???</emphasis> if 
				<computeroutput>thrd</computeroutput> is not in <computeroutput>*this</computeroutput>'s list
				of managed <link linkend="thread">thread</link> objects.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id318007-bb"/>join_all();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Calls <computeroutput>join()</computeroutput> on each of the managed 
				<link linkend="thread">thread</link> objects.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id479200"><title>Header &lt;<ulink url="../../boost/thread/tss.hpp">boost/thread/tss.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="thread_specific_ptr">thread_specific_ptr</link>;
}</synopsis><refentry id="thread_specific_ptr"><refmeta><refentrytitle>Class thread_specific_ptr</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::thread_specific_ptr</refname><refpurpose>
				The <link linkend="thread_specific_ptr">thread_specific_ptr</link> class defines 
				an interface for using thread specific storage.
			</refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> thread_specific_ptr : <emphasis role="bold">private</emphasis> boost::noncopyable   <emphasis>// Exposition only</emphasis>
{
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="thread_specific_ptrconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id342861-bb">thread_specific_ptr</link>();
&#xA0;&#xA0;<link linkend="id468382-bb">thread_specific_ptr</link>(<emphasis role="bold">void</emphasis> (*cleanup)(<emphasis role="bold">void</emphasis>*));
&#xA0;&#xA0;<link linkend="id418172-bb">~thread_specific_ptr</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id459347-bb">modifier functions</link></emphasis>
&#xA0;&#xA0;<type>T*</type> <link linkend="id302786-bb">release</link>();
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id276165-bb">reset</link>(T* = 0);

&#xA0;&#xA0;<emphasis>// <link linkend="id353265-bb">observer functions</link></emphasis>
&#xA0;&#xA0;<type>T*</type> <link linkend="id498383-bb">get</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>T*</type> <link linkend="id283399-bb"><emphasis role="bold">operator</emphasis>-&gt;</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>T&amp;</type> <link linkend="id230286-bb"><emphasis role="bold">operator</emphasis>*()</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Thread specific storage is data associated with 
				individual threads and is often used to make operations
				that rely on global data 
				<link linkend="threads.glossary.thread-safe">thread-safe</link>.
				</para><para>Template <link linkend="thread_specific_ptr">thread_specific_ptr</link> 
				stores a pointer to an object obtained on a thread-by-thread
				basis and calls a specified cleanup handler on the contained
				pointer when the thread terminates. The cleanup handlers are
				called in the reverse order of construction of the 
				<link linkend="thread_specific_ptr">thread_specific_ptr</link>s, and for the 
				initial thread are called by the destructor, providing the 
				same ordering guarantees as for normal declarations. Each
				thread initially stores the null pointer in each
				<link linkend="thread_specific_ptr">thread_specific_ptr</link> instance.</para><para>The template <link linkend="thread_specific_ptr">thread_specific_ptr</link>
				is useful in the following cases:
					<itemizedlist><listitem>An interface was originally written assuming 
						a single thread of control and it is being ported to a
						multithreaded environment.</listitem><listitem>Each thread of control invokes sequences of
						methods that share data that are physically unique
						for each thread, but must be logically accessed
						through a globally visible access point instead of 
						being explicitly passed.</listitem></itemizedlist></para><refsect2><title><anchor id="thread_specific_ptrconstruct-copy-destruct"/><computeroutput>thread_specific_ptr</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id342861-bb"/>thread_specific_ptr();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem>The expression <computeroutput>delete get()</computeroutput> is well
				formed.</listitem></varlistentry><varlistentry><term>Effects</term><listitem>A thread-specific data key is allocated and visible to
				all threads in the process. Upon creation, the value 
				<computeroutput>NULL</computeroutput> will be associated with the new key in all 
				active threads. A cleanup method is registered with the key 
				that will call <computeroutput>delete</computeroutput> on the value associated 
				with the key for a thread when it exits. When a thread exits,
				if a key has a registered cleanup method and the thread has a
				non-<computeroutput>NULL</computeroutput> value associated with that key, the value
				of the key is set to <computeroutput>NULL</computeroutput> and then the cleanup 
				method is called with the previously associated value as its 
				sole argument. The order in which registered cleanup methods 
				are called when a thread exits is undefined. If after all the
				cleanup methods have been called for all non-<computeroutput>NULL</computeroutput>
				values, there are still some non-<computeroutput>NULL</computeroutput> values
				with associated cleanup handlers the result is undefined
				behavior.</listitem></varlistentry><varlistentry><term>Throws</term><listitem><link linkend="thread_resource_error">boost::thread_resource_error</link> if
				the necessary resources can not be obtained.</listitem></varlistentry><varlistentry><term>Notes</term><listitem>There may be an implementation specific limit to the 
				number of thread specific storage objects that can be created,
				and this limit may be small.</listitem></varlistentry><varlistentry><term>Rationale</term><listitem>The most common need for cleanup will be to call 
				<computeroutput>delete</computeroutput> on the associated value. If other forms
				of cleanup are required the overloaded constructor should be
				called instead.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id468382-bb"/>thread_specific_ptr(<emphasis role="bold">void</emphasis> (*cleanup)(<emphasis role="bold">void</emphasis>*) cleanup);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>A thread-specific data key is allocated and visible to
				all threads in the process. Upon creation, the value 
				<computeroutput>NULL</computeroutput> will be associated with the new key in all 
				active threads. The <computeroutput>cleanup</computeroutput> method is registered
				with the key and will be called for a thread with the value 
				associated with the key for that thread when it exits. When a
				thread exits, if a key has a registered cleanup method and the
				thread has a non-<computeroutput>NULL</computeroutput> value associated with that
				key, the value of the key is set to <computeroutput>NULL</computeroutput> and then
				the cleanup method is called with the previously associated
				value as its sole argument. The order in which registered
				cleanup methods are called when a thread exits is undefined.
				If after all the cleanup methods have been called for all 
				non-<computeroutput>NULL</computeroutput> values, there are still some 
				non-<computeroutput>NULL</computeroutput> values with associated cleanup handlers
				the result is undefined behavior.</listitem></varlistentry><varlistentry><term>Throws</term><listitem><link linkend="thread_resource_error">boost::thread_resource_error</link> if
				the necessary resources can not be obtained.</listitem></varlistentry><varlistentry><term>Notes</term><listitem>There may be an implementation specific limit to the 
				number of thread specific storage objects that can be created,
				 and this limit may be small.</listitem></varlistentry><varlistentry><term>Rationale</term><listitem>There is the occasional need to register 
				 specialized cleanup methods, or to register no cleanup method
				 at all (done by passing <computeroutput>NULL</computeroutput> to this constructor.
				 </listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id418172-bb"/>~thread_specific_ptr();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>Deletes the thread-specific data key allocated by the
				constructor. The thread-specific data values associated with
				the key need not be <computeroutput>NULL</computeroutput>. It is the responsibility
				of the application to perform any cleanup actions for data
				associated with the key.</listitem></varlistentry><varlistentry><term>Notes</term><listitem>Does not destroy any data that may be stored in any
				thread's thread specific storage. For this reason you should
				not destroy a <link linkend="thread_specific_ptr">thread_specific_ptr</link> object
				until you are certain there are no threads running that have
				made use of its thread specific storage.</listitem></varlistentry><varlistentry><term>Rationale</term><listitem>Associated data is not cleaned up because registered
				cleanup methods need to be run in the thread that allocated the
				associated data to be guarranteed to work correctly. There's no
				safe way to inject the call into another thread's execution
				path, making it impossible to call the cleanup methods safely.
				</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id459347-bb"/><computeroutput>thread_specific_ptr</computeroutput> modifier functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>T*</type> <anchor id="id302786-bb"/>release();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><computeroutput>*this</computeroutput> holds the null pointer
					for the current thread.</listitem></varlistentry><varlistentry><term>Returns</term><listitem><computeroutput>this-&gt;get()</computeroutput> prior to the call.</listitem></varlistentry><varlistentry><term>Rationale</term><listitem>This method provides a mechanism for the user to
					relinquish control of the data associated with the 
					thread-specific key.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id276165-bb"/>reset(T* p = 0);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem>If <computeroutput>this-&gt;get() != p &amp;&amp; 
					this-&gt;get() != NULL</computeroutput> then call the 
					associated cleanup function.</listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><computeroutput>*this</computeroutput> holds the pointer 
					<computeroutput>p</computeroutput> for the current thread.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id353265-bb"/><computeroutput>thread_specific_ptr</computeroutput> observer functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>T*</type> <anchor id="id498383-bb"/>get() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem>The object stored in thread specific storage for
					the current thread for <computeroutput>*this</computeroutput>.</listitem></varlistentry><varlistentry><term>Notes</term><listitem>Each thread initially returns 0.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>T*</type> <anchor id="id283399-bb"/><emphasis role="bold">operator</emphasis>-&gt;() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><computeroutput>this-&gt;get()</computeroutput>.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>T&amp;</type> <anchor id="id230286-bb"/><emphasis role="bold">operator</emphasis>*()() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><computeroutput>this-&gt;get() != 0</computeroutput></listitem></varlistentry><varlistentry><term>Returns</term><listitem><computeroutput>this-&gt;get()</computeroutput>.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section><section id="id253046"><title>Header &lt;<ulink url="../../boost/thread/xtime.hpp">boost/thread/xtime.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">enum</emphasis> <link linkend="id451827">xtime_clock_types</link>;

&#xA0;&#xA0;<emphasis role="bold">struct</emphasis> <link linkend="xtime">xtime</link>;
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="xtime_get">xtime_get</link>(<link linkend="xtime">xtime</link>*, <emphasis role="bold">int</emphasis>);
}</synopsis><refentry id="id451827"><refmeta><refentrytitle>Type xtime_clock_types</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::xtime_clock_types</refname><refpurpose><para>Specifies the clock type to use when creating
			an object of type <link linkend="xtime">xtime</link>.</para></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">enum</emphasis> xtime_clock_types { TIME_UTC };</synopsis></refsynopsisdiv></refentry><refentry id="xtime"><refmeta><refentrytitle>Struct xtime</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::xtime</refname><refpurpose><simpara>An object of type <link linkend="xtime">xtime</link>
			defines a time that is used to perform high-resolution time operations.
			This is a temporary solution that will be replaced by a more robust time 
			library once available in Boost.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">struct</emphasis> xtime {

&#xA0;&#xA0;<emphasis>platform-specific-type</emphasis> sec;
};

<emphasis>// <link linkend="id484380-bb">creation</link></emphasis>
<type><emphasis role="bold">int</emphasis></type> <link linkend="xtime_get">xtime_get</link>(<link linkend="xtime">xtime</link>*, <emphasis role="bold">int</emphasis>);</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara>The <link linkend="xtime">xtime</link> type is used to represent a point on 
			some time scale or a duration in time. This type may be proposed for the C standard by 
			Markus Kuhn. <emphasis role="bold">Boost.Threads</emphasis> provides only a very minimal implementation of this
			proposal; it is expected that a full implementation (or some other time
			library) will be provided in Boost as a separate library, at which time <emphasis role="bold">Boost.Threads</emphasis>
			will deprecate its own implementation.</simpara><simpara><emphasis role="bold">Note</emphasis> that the resolution is 
			implementation specific. For many implementations the best resolution 
			of time is far more than one nanosecond, and even when the resolution 
			is reasonably good, the latency of a call to <computeroutput>xtime_get()</computeroutput>
			may be significant. For maximum portability, avoid durations of less than
			one second.</simpara><refsect2><title><anchor id="id484380-bb"/><computeroutput>xtime</computeroutput> creation</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="xtime_get"/>xtime_get(<link linkend="xtime">xtime</link>* xtp, <emphasis role="bold">int</emphasis> clock_type);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><simpara><computeroutput>xtp</computeroutput> represents the current point in
					time as a duration since the epoch specified by
					<computeroutput>clock_type</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara><computeroutput>clock_type</computeroutput> if successful, otherwise 0.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry></section></section><section id="threads.faq" rev:last-revision="$Date: 2004/07/17 04:33:59 $" xml:base="../libs/thread/doc/faq.xml"><title>Frequently Asked Questions</title><qandaset><qandaentry><question><para>Are lock objects <link linkend="threads.glossary.thread-safe">thread safe</link>?</para></question><answer><para><emphasis role="bold">No!</emphasis> Lock objects are not meant to
		be shared between threads. They are meant to be short-lived objects
		created on automatic storage within a code block. Any other usage is
		just likely to lead to errors and won't really be of actual benefit anyway.
		Share <link linkend="threads.concepts.mutexes">Mutexes</link>, not
		Locks. For more information see the <link linkend="threads.rationale.locks">rationale</link> behind the
		design for lock objects.</para></answer></qandaentry><qandaentry><question><para>Why was <emphasis role="bold">Boost.Threads</emphasis> modeled after (specific library
		name)?</para></question><answer><para>It wasn't. <emphasis role="bold">Boost.Threads</emphasis> was designed from scratch. Extensive
		design discussions involved numerous people representing a wide range of
		experience across many platforms. To ensure portability, the initial
		implements were done in parallel using POSIX Threads and the Win32
		threading API. But the <emphasis role="bold">Boost.Threads</emphasis> design is very much in the spirit
		of C++, and thus doesn't model such C based APIs.</para></answer></qandaentry><qandaentry><question><para>Why wasn't <emphasis role="bold">Boost.Threads</emphasis> modeled after (specific library
	    name)?</para></question><answer><para>Existing C++ libraries either seemed dangerous (often failing to
		take advantage of prior art to reduce errors) or had excessive
		dependencies on library components unrelated to threading. Existing C
		libraries couldn't meet our C++ requirements, and were also missing
		certain features. For instance, the WIN32 thread API lacks condition
		variables, even though these are critical for the important Monitor
		pattern <citation><xref linkend="threads.bib.SchmidtStalRohnertBuschmann" endterm="threads.bib.SchmidtStalRohnertBuschmann.abbrev"/></citation>.</para></answer></qandaentry><qandaentry><question><para>Why do <link linkend="threads.concepts.mutexes">Mutexes</link>
		have noncopyable semantics?</para></question><answer><para>To ensure that <link linkend="threads.glossary.deadlock">deadlocks</link> don't occur. The
		only logical form of copy would be to use some sort of shallow copy
		semantics in which multiple mutex objects could refer to the same mutex
		state. This means that if ObjA has a mutex object as part of its state
		and ObjB is copy constructed from it, then when ObjB::foo() locks the
		mutex it has effectively locked ObjA as well. This behavior can result
		in deadlock. Other copy semantics result in similar problems (if you
		think you can prove this to be wrong then supply us with an alternative
		and we'll reconsider).</para></answer></qandaentry><qandaentry><question><para>How can you prevent <link linkend="threads.glossary.deadlock">deadlock</link> from occurring when
		a thread must lock multiple mutexes?</para></question><answer><para>Always lock them in the same order. One easy way of doing this is
		to use each mutex's address to determine the order in which they are
		locked. A future <emphasis role="bold">Boost.Threads</emphasis> concept may wrap this pattern up in a
		reusable class.</para></answer></qandaentry><qandaentry><question><para>Don't noncopyable <link linkend="threads.concepts.mutexes">Mutex</link> semantics mean that a
		class with a mutex member will be noncopyable as well?</para></question><answer><para>No, but what it does mean is that the compiler can't generate a
		copy constructor and assignment operator, so they will have to be coded
		explicitly. This is a <emphasis role="bold">good thing</emphasis>,
		however, since the compiler generated operations would not be <link linkend="threads.glossary.thread-safe">thread-safe</link>. The following
		is a simple example of a class with copyable semantics and internal
        synchronization through a mutex member.</para><programlisting>
class counter
{
public:
   // Doesn't need synchronization since there can be no references to *this
   // until after it's constructed!
   explicit counter(int initial_value)
      : m_value(initial_value)
   {
   }
   // We only need to synchronize other for the same reason we don't have to
   // synchronize on construction!
   counter(const counter&amp; other)
   {
      boost::mutex::scoped_lock scoped_lock(other.m_mutex);
      m_value = other.m_value;
   }
   // For assignment we need to synchronize both objects!
   const counter&amp; operator=(const counter&amp; other)
   {
      if (this == &amp;other)
         return *this;
      boost::mutex::scoped_lock lock1(&amp;m_mutex &lt; &amp;other.m_mutex ? m_mutex : other.m_mutex);
      boost::mutex::scoped_lock lock2(&amp;m_mutex &gt; &amp;other.m_mutex ? m_mutex : other.m_mutex);
      m_value = other.m_value;
      return *this;
   }
   int value() const
   {
      boost::mutex::scoped_lock scoped_lock(m_mutex);
      return m_value;
   }
   int increment()
   {
      boost::mutex::scoped_lock scoped_lock(m_mutex);
      return ++m_value;
   }
private:
   mutable boost::mutex m_mutex;
   int m_value;
};
</programlisting></answer></qandaentry><qandaentry><question><para>How can you lock a <link linkend="threads.concepts.mutexes">Mutex</link> member in a const member
		function, in order to implement the Monitor Pattern?</para></question><answer><para>The Monitor Pattern <citation><xref linkend="threads.bib.SchmidtStalRohnertBuschmann" endterm="threads.bib.SchmidtStalRohnertBuschmann.abbrev"/></citation> mutex
		should simply be declared as mutable. See the example code above. The
		internal state of mutex types could have been made mutable, with all
		lock calls made via const functions, but this does a poor job of
		documenting the actual semantics (and in fact would be incorrect since
		the logical state of a locked mutex clearly differs from the logical
		state of an unlocked mutex). Declaring a mutex member as mutable clearly
		documents the intended semantics.</para></answer></qandaentry><qandaentry><question><para>Why supply <link linkend="condition">boost::condition</link> variables rather than
		event variables?</para></question><answer><para>Condition variables result in user code much less prone to <link linkend="threads.glossary.race-condition">race conditions</link> than
		event variables. See <xref linkend="threads.rationale.events"/> 
		for analysis. Also see <citation><xref linkend="threads.bib.Hoare74" endterm="threads.bib.Hoare74.abbrev"/></citation> and <citation><xref linkend="threads.bib.SchmidtStalRohnertBuschmann" endterm="threads.bib.SchmidtStalRohnertBuschmann.abbrev"/></citation>.
		</para></answer></qandaentry><qandaentry><question><para>Why isn't thread cancellation or termination provided?</para></question><answer><para>There's a valid need for thread termination, so at some point
		<emphasis role="bold">Boost.Threads</emphasis> probably will include it, but only after we can find a
		truly safe (and portable) mechanism for this concept.</para></answer></qandaentry><qandaentry><question><para>Is it safe for threads to share automatic storage duration (stack)
		objects via pointers or references?</para></question><answer><para>Only if you can guarantee that the lifetime of the stack object
		will not end while other threads might still access the object. Thus the
		safest practice is to avoid sharing stack objects, particularly in
		designs where threads are created and destroyed dynamically. Restrict
		sharing of stack objects to simple designs with very clear and
		unchanging function and thread lifetimes. (Suggested by Darryl
		Green).</para></answer></qandaentry><qandaentry><question><para>Why has class semaphore disappeared?</para></question><answer><para>Semaphore was removed as too error prone. The same effect can be
		achieved with greater safety by the combination of a mutex and a
		condition variable.</para></answer></qandaentry></qandaset></section><section id="thread.configuration" rev:last-revision="$Date: 2004/07/17 04:33:59 $" xml:base="../libs/thread/doc/configuration.xml"><title>Configuration</title><para><emphasis role="bold">Boost.Threads</emphasis> uses several configuration macros in &lt;boost/config.hpp&gt;,
	as well as configuration macros meant to be supplied by the application. These
	macros are documented here.
	</para><section id="thread.configuration.public"><title>Library Defined Public Macros</title><para>
	These macros are defined by <emphasis role="bold">Boost.Threads</emphasis> but are expected to be used
	by application code.
		</para><informaltable><tgroup cols="2"><thead><row><entry>Macro</entry><entry>Meaning</entry></row></thead><tbody><row><entry>BOOST_HAS_THREADS</entry><entry>
	Indicates that threading support is available. This means both that there
	is a platform specific implementation for <emphasis role="bold">Boost.Threads</emphasis> and that
	threading support has been enabled in a platform specific manner. For instance,
	on the Win32 platform there's an implementation for <emphasis role="bold">Boost.Threads</emphasis>
	but unless the program is compiled against one of the multithreading runtimes
	(often determined by the compiler predefining the macro _MT) the BOOST_HAS_THREADS
	macro remains undefined.
						</entry></row></tbody></tgroup></informaltable></section><section id="thread.configuration.implementation"><title>Library Defined Implementation Macros</title><para>
	These macros are defined by <emphasis role="bold">Boost.Threads</emphasis> and are implementation details
	of interest only to implementors.
		</para><informaltable><tgroup cols="2"><thead><row><entry>Macro</entry><entry>Meaning</entry></row></thead><tbody><row><entry>BOOST_HAS_WINTHREADS</entry><entry>
	Indicates that the platform has the Microsoft Win32 threading libraries,
	and that they should be used to implement <emphasis role="bold">Boost.Threads</emphasis>.
			            </entry></row><row><entry>BOOST_HAS_PTHREADS</entry><entry>
	Indicates that the platform has the POSIX pthreads libraries, and that
	they should be used to implement <emphasis role="bold">Boost.Threads</emphasis>.
						</entry></row><row><entry>BOOST_HAS_FTIME</entry><entry>
	Indicates that the implementation should use GetSystemTimeAsFileTime()
	and the FILETIME type to calculate the current time. This is an implementation
	detail used by boost::detail::getcurtime().
						</entry></row><row><entry>BOOST_HAS_GETTTIMEOFDAY</entry><entry>
	Indicates that the implementation should use gettimeofday() to calculate
	the current time. This is an implementation detail used by boost::detail::getcurtime().
						</entry></row></tbody></tgroup></informaltable></section></section><section id="thread.build" rev:last-revision="$Date: 2004/07/17 04:33:59 $" xml:base="../libs/thread/doc/build.xml"><title>Build</title><para>
	How you build the <emphasis role="bold">Boost.Threads</emphasis> libraries, and how you build your own applications
	that use those libraries, are some of the most frequently asked questions. Build
	processes are difficult to deal with in a portable manner. That's one reason
	why <emphasis role="bold">Boost.Threads</emphasis> makes use of <emphasis role="bold">Boost.Build</emphasis>.
	In general you should refer to the documentation for <emphasis role="bold">Boost.Build</emphasis>.
	This document will only supply you with some simple usage examples for how to
	use <emphasis>bjam</emphasis> to build and test <emphasis role="bold">Boost.Threads</emphasis>. In addition, this document
	will try to explain the build requirements so that users may create their own
	build processes (for instance, create an IDE specific project), both for building
	and testing <emphasis role="bold">Boost.Threads</emphasis>, as well as for building their own projects using
	<emphasis role="bold">Boost.Threads</emphasis>.
	</para><section id="thread.build.building"><title>Building the <emphasis role="bold">Boost.Threads</emphasis> Libraries</title><para>
	To build the <emphasis role="bold">Boost.Threads</emphasis> libraries using <emphasis role="bold">Boost.Build</emphasis>, simply change to the
	directory <emphasis>boost_root</emphasis>/libs/thread/build and execute the command:
		<programlisting>bjam -sTOOLS=<emphasis>toolset</emphasis></programlisting>
	This will create the debug and the release builds of the <emphasis role="bold">Boost.Threads</emphasis> library.
	<note>Invoking the above command in <emphasis>boost_root</emphasis> will build all of 
	the Boost distribution, including <emphasis role="bold">Boost.Threads</emphasis>.</note></para><para>
	The Jamfile supplied with <emphasis role="bold">Boost.Threads</emphasis> produces a dynamic link library named
	<emphasis>boost_thread{build-specific-tags}.{extension}</emphasis>, where the build-specific
	tags indicate the toolset used to build the library, whether it's a debug or release
	build, what version of Boost was used, etc.; and the extension is the appropriate extension
	for a dynamic link library for the platform for which <emphasis role="bold">Boost.Threads</emphasis> is being built.
	For instance, a debug library built for Win32 with VC++ 7.1 using Boost 1.31 would
	be named <emphasis>boost_thread-vc71-mt-gd-1_31.dll</emphasis>.
		</para><para>
	The source files that are used to create the <emphasis role="bold">Boost.Threads</emphasis> library
	are all of the *.cpp files found in <emphasis>boost_root</emphasis>/libs/thread/src.
	These need to be built with the compiler's and linker's multi-threading support enabled.
	If you want to create your own build solution you'll have to follow these same
	guidelines. One of the most frequently reported problems when trying to do this
	occurs from not enabling the compiler's and linker's support for multi-threading.
		</para></section><section id="thread.build.testing"><title>Testing the <emphasis role="bold">Boost.Threads</emphasis> Libraries</title><para>
	To test the <emphasis role="bold">Boost.Threads</emphasis> libraries using <emphasis role="bold">Boost.Build</emphasis>, simply change to the
	directory <emphasis>boost_root</emphasis>/libs/thread/test and execute the command:
			<programlisting>bjam -sTOOLS=<emphasis>toolset</emphasis> test</programlisting></para></section></section><section id="threads.implementation_notes" rev:last-revision="$Date: 2004/07/17 04:33:59 $" xml:base="../libs/thread/doc/implementation_notes.xml"><title>Implementation Notes</title><section id="threads.implementation_notes.win32"><title>Win32</title><para>
			In the current Win32 implementation, creating a boost::thread object
			during dll initialization will result in deadlock because the thread 
			class constructor causes the current thread to wait on the thread that 
			is being created until it signals that it has finished its initialization, 
			and, as stated in the
			<ulink url="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/dllmain.asp">MSDN Library, "DllMain" article, "Remarks" section</ulink>,
			"Because DLL notifications are serialized, entry-point functions should not
			attempt to communicate with other threads or processes. Deadlocks may occur as a result."
			(Also see <ulink url="http://www.microsoft.com/msj/archive/S220.aspx">"Under the Hood", January 1996</ulink> 
			for a more detailed discussion of this issue).
		</para><para>
			The following non-exhaustive list details some of the situations that
			should be avoided until this issue can be addressed:
			<itemizedlist><listitem>Creating a boost::thread object in DllMain() or in any function called by it.</listitem><listitem>Creating a boost::thread object in the constructor of a global static object or in any function called by one.</listitem><listitem>Creating a boost::thread object in MFC's CWinApp::InitInstance() function or in any function called by it.</listitem><listitem>Creating a boost::thread object in the function pointed to by MFC's _pRawDllMain function pointer or in any function called by it.</listitem></itemizedlist></para></section></section><section id="threads.release_notes" rev:last-revision="$Date: 2004/08/05 18:07:20 $" xml:base="../libs/thread/doc/release_notes.xml"><title>Release Notes</title><section id="threads.release_notes.boost_1_32_0"><title>Boost 1.32.0</title><section id="threads.release_notes.boost_1_32_0.change_log.documentation"><title>Documentation converted to BoostBook</title><para>The documentation was converted to BoostBook format,
			and a number of errors and inconsistencies were
			fixed in the process.
			Since this was a fairly large task, there are likely to be 
			more errors and inconsistencies remaining. If you find any,
			please report them!</para></section><section id="threads.release_notes.boost_1_32_0.change_log.static_link"><title>Statically-link build option added</title><para>The option to link <emphasis role="bold">Boost.Threads</emphasis> as a static
			library has been added (with some limitations on Win32 platforms).
			This feature was originally removed from an earlier version
			of Boost because <link linkend="thread_specific_ptr">boost::thread_specific_ptr</link>
			required that <emphasis role="bold">Boost.Threads</emphasis> be dynamically linked in order
			for its cleanup functionality to work on Win32 platforms.
			Because this limitation never applied to non-Win32 platforms,
			because significant progress has been made in removing
			the limitation on Win32 platforms (many thanks to
			Aaron LaFramboise and Roland Scwarz!), and because the lack
			of static linking is one of the most common complaints of
			<emphasis role="bold">Boost.Threads</emphasis> users, this decision was reversed.</para><para>On non-Win32 platforms: 
			To choose the dynamically linked version of <emphasis role="bold">Boost.Threads</emphasis> 
			using Boost's auto-linking feature, #define BOOST_THREAD_USE_DLL;
			to choose the statically linked version, 
			#define BOOST_THREAD_USE_LIB. 
			If neither symbols is #defined, the default will be chosen.
			Currently the default is the statically linked version.</para><para>On Win32 platforms using VC++: 
			Use the same #defines as for non-Win32 platforms 
			(BOOST_THREAD_USE_DLL and BOOST_THREAD_USE_LIB).
			If neither is #defined, the default will be chosen. 
			Currently the default is the statically linked version
			if the VC++ run-time library is set to
			"Multi-threaded" or "Multi-threaded Debug", and
			the dynamically linked version
			if the VC++ run-time library is set to 
			"Multi-threaded DLL" or "Multi-threaded Debug DLL".</para><para>On Win32 platforms using compilers other than VC++:
			Use the same #defines as for non-Win32 platforms 
			(BOOST_THREAD_USE_DLL and BOOST_THREAD_USE_LIB).
			If neither is #defined, the default will be chosen. 
			Currently the default is the dynamically linked version
			because it has not yet been possible to implement automatic
			tss cleanup in the statically linked version for compilers
			other than VC++, although it is hoped that this will be
			possible in a future version of <emphasis role="bold">Boost.Threads</emphasis>.
			
			Note for advanced users: <emphasis role="bold">Boost.Threads</emphasis> provides several "hook"
			functions to allow users to experiment with the statically
			linked version on Win32 with compilers other than VC++.
			These functions are on_process_enter(), on_process_exit(),
			on_thread_enter(), and on_thread_exit(), and are defined
			in tls_hooks.cpp. See the comments in that file for more
			information.</para></section><section id="threads.release_notes.boost_1_32_0.change_log.barrier"><title>Barrier functionality added</title><para>A new class, <link linkend="barrier">boost::barrier</link>, was added.</para></section><section id="threads.release_notes.boost_1_32_0.change_log.read_write_mutex"><title>Read/write mutex functionality added</title><para>New classes, 
			<link linkend="read_write_mutex">boost::read_write_mutex</link>,
			<link linkend="try_read_write_mutex">boost::try_read_write_mutex</link>, and
			<link linkend="timed_read_write_mutex">boost::timed_read_write_mutex</link>
			were added.
			
			<note>Since the read/write mutex and related classes are new,
			both interface and implementation are liable to change
			in future releases of <emphasis role="bold">Boost.Threads</emphasis>.
			The lock concepts and lock promotion in particular are
			still under discussion and very likely to change.</note></para></section><section id="threads.release_notes.boost_1_32_0.change_log.thread_specific_ptr"><title>Thread-specific pointer functionality changed</title><para>The <link linkend="thread_specific_ptr">boost::thread_specific_ptr</link> 
			constructor now takes an optional pointer to a cleanup function that
			is called to release the thread-specific data that is being pointed
			to by <link linkend="thread_specific_ptr">boost::thread_specific_ptr</link> objects.</para><para>Fixed: the number of available thread-specific storage "slots"
			is too small on some platforms.</para><para>Fixed: thread_specific_ptr::reset()
			doesn't check error returned by tss::set()
			(the tss::set() function now throws
			if it fails instead of returning an error code).</para><para>Fixed: calling 
			boost::thread_specific_ptr::reset() or 
			boost::thread_specific_ptr::release()
			causes double-delete: once when 
			boost::thread_specific_ptr::reset() or
			boost::thread_specific_ptr::release() 
			is called and once when 
			boost::thread_specific_ptr::~thread_specific_ptr()
			is called.</para></section><section id="threads.release_notes.boost_1_32_0.change_log.mutex"><title>Mutex implementation changed for Win32</title><para>On Win32, <link linkend="mutex">boost::mutex</link>, 
			<link linkend="try_mutex">boost::try_mutex</link>, <link linkend="recursive_mutex">boost::recursive_mutex</link>,
			and <link linkend="recursive_try_mutex">boost::recursive_try_mutex</link> now use a Win32 critical section 
			whenever possible; otherwise they use a Win32 mutex. As before, 
			<link linkend="timed_mutex">boost::timed_mutex</link> and 
			<link linkend="recursive_timed_mutex">boost::recursive_timed_mutex</link> use a Win32 mutex.</para></section><section id="threads.release_notes.boost_1_32_0.change_log.wince"><title>Windows CE support improved</title><para>Minor changes were made to make Boost.Threads work on Windows CE.</para></section></section></section><glossary id="threads.glossary" rev:last-revision="$Date: 2004/07/17 04:33:59 $" xml:base="../libs/thread/doc/glossary.xml"><title>Glossary</title><para>Definitions are given in terms of the C++ Standard
  <citation><xref linkend="threads.bib.ISO98" endterm="threads.bib.ISO98.abbrev"/></citation>. References to the standard are in the form [1.2.3/4], which
  represents the section number, with the paragraph number following the
  "/".</para><para>Because the definitions are written in something akin to "standardese",
  they can be difficult to understand. The intent isn't to confuse, but rather
  to clarify the additional requirements <emphasis role="bold">Boost.Threads</emphasis> places on a C++
  implementation as defined by the C++ Standard.</para><glossentry id="threads.glossary.thread"><glossterm>Thread</glossterm><glossdef><para>Thread is short for "thread of execution". A thread of execution is
	  an execution environment [1.9/7] within the execution environment of a C++
	  program [1.9]. The main() function [3.6.1] of the program is the initial
	  function of the initial thread. A program in a multithreading environment
	  always has an initial thread even if the program explicitly creates no
	  additional threads.</para><para>Unless otherwise specified, each thread shares all aspects of its
	  execution environment with other threads in the program. Shared aspects of
	  the execution environment include, but are not limited to, the
	  following:</para><itemizedlist><listitem><para>Static storage duration (static, extern) objects
		[3.7.1].</para></listitem><listitem><para>Dynamic storage duration (heap) objects [3.7.3]. Thus
		each memory allocation will return a unique addresses, regardless of the
		thread making the allocation request.</para></listitem><listitem><para>Automatic storage duration (stack) objects [3.7.2]
		accessed via pointer or reference from another thread.</para></listitem><listitem><para>Resources provided by the operating system. For example,
		files.</para></listitem><listitem><para>The program itself. In other words, each thread is
		executing some function of the same program, not a totally different
		program.</para></listitem></itemizedlist><para>Each thread has its own:</para><itemizedlist><listitem><para>Registers and current execution sequence (program
		counter) [1.9/5].</para></listitem><listitem><para>Automatic storage duration (stack) objects
		[3.7.2].</para></listitem></itemizedlist></glossdef></glossentry><glossentry id="threads.glossary.thread-safe"><glossterm>Thread-safe</glossterm><glossdef><para>A program is thread-safe if it has no <link linkend="threads.glossary.race-condition">race conditions</link>, does
	  not <link linkend="threads.glossary.deadlock">deadlock</link>, and has
	  no <link linkend="threads.glossary.priority-failure">priority
	  failures</link>.</para><para>Note that thread-safety does not necessarily imply efficiency, and
	  than while some thread-safety violations can be determined statically at
	  compile time, many thread-safety errors can only only be detected at
	  runtime.</para></glossdef></glossentry><glossentry id="threads.glossary.thread-state"><glossterm>Thread State</glossterm><glossdef><para>During the lifetime of a thread, it shall be in one of the following
	  states:</para><table><title>Thread States</title><tgroup cols="2" align="left"><thead><row><entry>State</entry><entry>Description</entry></row></thead><tbody><row><entry>Ready</entry><entry>Ready to run, but waiting for a processor.</entry></row><row><entry>Running</entry><entry>Currently executing on a processor. Zero or more threads
					may be running at any time, with a maximum equal to the number of
					processors.</entry></row><row><entry>Blocked</entry><entry>Waiting for some resource other than a processor which is
					not currently available, or for the completion of calls to library
					functions [1.9/6]. The term "waiting" is synonymous with
					"blocked"</entry></row><row><entry>Terminated</entry><entry>Finished execution but not yet detached or joined.</entry></row></tbody></tgroup></table><para>Thread state transitions shall occur only as specified:</para><table><title>Thread States Transitions</title><tgroup cols="3" align="left"><thead><row><entry>From</entry><entry>To</entry><entry>Cause</entry></row></thead><tbody><row><entry>[none]</entry><entry>Ready</entry><entry><para>Thread is created by a call to a library function. 
					In the case of the initial thread, creation is implicit and 
					occurs during the startup of the main() function [3.6.1].</para></entry></row><row><entry>Ready</entry><entry>Running</entry><entry><para>Processor becomes available.</para></entry></row><row><entry>Running</entry><entry>Ready</entry><entry>Thread preempted.</entry></row><row><entry>Running</entry><entry>Blocked</entry><entry>Thread calls a library function which waits for a resource or
					for the completion of I/O.</entry></row><row><entry>Running</entry><entry>Terminated</entry><entry>Thread returns from its initial function, calls a thread
					termination library function, or is canceled by some other thread
					calling a thread termination library function.</entry></row><row><entry>Blocked</entry><entry>Ready</entry><entry>The resource being waited for becomes available, or the
					blocking library function completes.</entry></row><row><entry>Terminated</entry><entry>[none]</entry><entry>Thread is detached or joined by some other thread calling the
					appropriate library function, or by program termination
					[3.6.3].</entry></row></tbody></tgroup></table><para>[Note: if a suspend() function is added to the threading library,
	  additional transitions to the blocked state will have to be added to the
	  above table.]</para></glossdef></glossentry><glossentry id="threads.glossary.race-condition"><glossterm>Race Condition</glossterm><glossdef><para>A race condition is what occurs when multiple threads read from and write
	  to the same memory without proper synchronization, resulting in an incorrect
	  value being read or written. The result of a race condition may be a bit
	  pattern which isn't even a valid value for the data type. A race condition
	  results in undefined behavior [1.3.12].</para><para>Race conditions can be prevented by serializing memory access using
	  the tools provided by <emphasis role="bold">Boost.Threads</emphasis>.</para></glossdef></glossentry><glossentry id="threads.glossary.deadlock"><glossterm>Deadlock</glossterm><glossdef><para>Deadlock is an execution state where for some set of threads, each
	  thread in the set is blocked waiting for some action by one of the other
	  threads in the set. Since each is waiting on the others, none will ever
	  become ready again.</para></glossdef></glossentry><glossentry id="threads.glossary.starvation"><glossterm>Starvation</glossterm><glossdef><para>The condition in which a thread is not making sufficient progress in
	  its work during a given time interval.</para></glossdef></glossentry><glossentry id="threads.glossary.priority-failure"><glossterm>Priority Failure</glossterm><glossdef><para>A priority failure (such as priority inversion or infinite overtaking)
	  occurs when threads are executed in such a sequence that required work is not
	  performed in time to be useful.</para></glossdef></glossentry><glossentry id="threads.glossary.undefined-behavior"><glossterm>Undefined Behavior</glossterm><glossdef><para>The result of certain operations in <emphasis role="bold">Boost.Threads</emphasis> is undefined;
	  this means that those operations can invoke almost any behavior when
	  they are executed.</para><para>An operation whose behavior is undefined can work "correctly"
	  in some implementations (i.e., do what the programmer thought it
	  would do), while in other implementations it may exhibit almost
	  any "incorrect" behavior--such as returning an invalid value,
	  throwing an exception, generating an access violation, or terminating 
	  the process.</para><para>Executing a statement whose behavior is undefined is a
	  programming error.</para></glossdef></glossentry><glossentry id="threads.glossary.memory-visibility"><glossterm>Memory Visibility</glossterm><glossdef><para>An address [1.7] shall always point to the same memory byte,
	  regardless of the thread or processor dereferencing the address.</para><para>An object [1.8, 1.9] is accessible from multiple threads if it is of
	  static storage duration (static, extern) [3.7.1], or if a pointer or
	  reference to it is explicitly or implicitly dereferenced in multiple
	  threads.</para><para>For an object accessible from multiple threads, the value of the
	  object accessed from one thread may be indeterminate or different from the
	  value accessed from another thread, except under the conditions specified in
	  the following table. For the same row of the table, the value of an object
	  accessible at the indicated sequence point in thread A will be determinate
	  and the same if accessed at or after the indicated sequence point in thread
	  B, provided the object is not otherwise modified. In the table, the
	  "sequence point at a call" is the sequence point after the evaluation of all
	  function arguments [1.9/17], while the "sequence point after a call" is the
	  sequence point after the copying of the returned value... [1.9/17].</para><table><title>Memory Visibility</title><tgroup cols="2"><thead><row><entry>Thread A</entry><entry>Thread B</entry></row></thead><tbody><row><entry>The sequence point at a call to a library thread-creation
					function.</entry><entry>The first sequence point of the initial function in the new
					thread created by the Thread A call.</entry></row><row><entry>The sequence point at a call to a library function which
					locks a mutex, directly or by waiting for a condition
					variable.</entry><entry>The sequence point after a call to a library function which
					unlocks the same mutex.</entry></row><row><entry>The last sequence point before thread termination.</entry><entry>The sequence point after a call to a library function which
					joins the terminated thread.</entry></row><row><entry>The sequence point at a call to a library function which
					signals or broadcasts a condition variable.</entry><entry>The sequence point after the call to the library function
					which was waiting on that same condition variable or signal.</entry></row></tbody></tgroup></table><para>The architecture of the execution environment and the observable
	  behavior of the abstract machine [1.9] shall be the same on all
	  processors.</para><para>The latitude granted by the C++ standard for an implementation to
	  alter the definition of observable behavior of the abstract machine to
	  include additional library I/O functions [1.9/6] is extended to include
	  threading library functions.</para><para>When an exception is thrown and there is no matching exception handler
	  in the same thread, behavior is undefined. The preferred behavior is the
	  same as when there is no matching exception handler in a program
	  [15.3/9]. That is, terminate() is called, and it is implementation-defined
	  whether or not the stack is unwound.</para></glossdef></glossentry><section><title>Acknowledgements</title><para>This document was originally written by Beman Dawes, and then much
	improved by the incorporation of comments from William Kempf, who now
	maintains the contents.</para><para>The visibility rules are based on <citation><xref linkend="threads.bib.Butenhof97" endterm="threads.bib.Butenhof97.abbrev"/></citation>.</para></section></glossary><section id="thread.acknowledgements" rev:last-revision="$Date: 2004/07/17 04:33:59 $" xml:base="../libs/thread/doc/acknowledgements.xml"><title>Acknowledgements</title><para>William E. Kempf was the architect, designer, and implementor of 
  <emphasis role="bold">Boost.Threads</emphasis>.</para><para>Mac OS Carbon implementation written by Mac Murrett.</para><para>Dave Moore provided initial submissions and further comments on the 
  <computeroutput>barrier</computeroutput>
  , 
  <computeroutput>thread_pool</computeroutput>
  , 
  <computeroutput>read_write_mutex</computeroutput>
  , 
  <computeroutput>read_write_try_mutex</computeroutput>
  and 
  <computeroutput>read_write_timed_mutex</computeroutput>
  classes.</para><para>Important contributions were also made by Jeremy Siek (lots of input
  on the design and on the implementation), Alexander Terekhov (lots of input
  on the Win32 implementation, especially in regards to boost::condition, as
  well as a lot of explanation of POSIX behavior), Greg Colvin (lots of input
  on the design), Paul Mclachlan, Thomas Matelich and Iain Hanson (for help
  in trying to get the build to work on other platforms), and Kevin S. Van
  Horn (for several updates/corrections to the documentation).</para><para>Mike Glassford finished changes to <emphasis role="bold">Boost.Threads</emphasis> that were begun
  by William Kempf and moved them into the main CVS branch.
  He also addressed a number of issues that were brought up on the Boost
  developer's mailing list and provided some additions and changes to the 
  read_write_mutex and related classes.</para><para>The documentation was written by William E. Kempf. Beman Dawes
  provided additional documentation material and editing.
  Mike Glassford finished William Kempf's conversion of the documentation to 
  BoostBook format and added a number of new sections.</para><para>Discussions on the boost.org mailing list were essential in the
  development of <emphasis role="bold">Boost.Threads</emphasis>
  . As of August 1, 2001, participants included Alan Griffiths, Albrecht
  Fritzsche, Aleksey Gurtovoy, Alexander Terekhov, Andrew Green, Andy Sawyer,
  Asger Alstrup Nielsen, Beman Dawes, Bill Klein, Bill Rutiser, Bill Wade,
  Branko &#xE8;ibej, Brent Verner, Craig Henderson, Csaba Szepesvari,
  Dale Peakall, Damian Dixon, Dan Nuffer, Darryl Green, Daryle Walker, David
  Abrahams, David Allan Finch, Dejan Jelovic, Dietmar Kuehl, Douglas Gregor,
  Duncan Harris, Ed Brey, Eric Swanson, Eugene Karpachov, Fabrice Truillot,
  Frank Gerlach, Gary Powell, Gernot Neppert, Geurt Vos, Ghazi Ramadan, Greg
  Colvin, Gregory Seidman, HYS, Iain Hanson, Ian Bruntlett, J Panzer, Jeff
  Garland, Jeff Paquette, Jens Maurer, Jeremy Siek, Jesse Jones, Joe Gottman,
  John (EBo) David, John Bandela, John Maddock, John Max Skaller, John
  Panzer, Jon Jagger , Karl Nelson, Kevlin Henney, KG Chandrasekhar, Levente
  Farkas, Lie-Quan Lee, Lois Goldthwaite, Luis Pedro Coelho, Marc Girod, Mark
  A. Borgerding, Mark Rodgers, Marshall Clow, Matthew Austern, Matthew Hurd,
  Michael D. Crawford, Michael H. Cox , Mike Haller, Miki Jovanovic, Nathan
  Myers, Paul Moore, Pavel Cisler, Peter Dimov, Petr Kocmid, Philip Nash,
  Rainer Deyke, Reid Sweatman, Ross Smith, Scott McCaskill, Shalom Reich,
  Steve Cleary, Steven Kirk, Thomas Holenstein, Thomas Matelich, Trevor
  Perrin, Valentin Bonnard, Vesa Karvonen, Wayne Miller, and William
  Kempf.</para><para>Apologies for anyone inadvertently missed.</para></section><bibliography id="threads.bibliography" rev:last-revision="$Date: 2004/07/17 04:33:59 $" xml:base="../libs/thread/doc/bibliography.xml"><title>Bibliography</title><biblioentry id="threads.bib.AndrewsSchneider83"><abbrev id="threads.bib.AndrewsSchneider83.abbrev">AndrewsSchnieder83</abbrev><biblioset relation="journal"><title>ACM Computing Surveys</title><volumenum>Vol. 15</volumenum><issuenum>No. 1</issuenum><date>March, 1983</date></biblioset><biblioset relation="article"><authorgroup><author><firstname>Gregory</firstname><othername>R.</othername><surname>Andrews</surname></author><author><firstname>Fred</firstname><othername>B.</othername><surname>Schneider</surname></author></authorgroup><title><ulink url="http://www.acm.org/pubs/citations/journals/surveys/1983-15-1/p3-andrews/">Concepts and Notations for Concurrent Programming</ulink></title></biblioset><para>Good general background reading. Includes descriptions of Path
    Expressions, Message Passing, and Remote Procedure Call in addition to the
    basics</para></biblioentry><biblioentry id="threads.bib.Boost"><abbrev id="threads.bib.Boost.abbrev">Boost</abbrev><bibliomisc>The <emphasis>Boost</emphasis> world wide web site.
	<ulink url="http:/www.boost.org">http://www.boost.org</ulink></bibliomisc><para><emphasis role="bold">Boost.Threads</emphasis> is one of many Boost libraries. The Boost web
    site includes a great deal of documentation and general information which
    applies to all Boost libraries. Current copies of the libraries including
    documentation and test programs may be downloaded from the web
    site.</para></biblioentry><biblioentry id="threads.bib.Hansen73"><abbrev id="threads.bib.Hansen73.abbrev">Hansen73</abbrev><biblioset relation="journal"><title>ACM Computing Surveys</title><volumenum>Vol. 5</volumenum><issuenum>No. 4</issuenum><date>December, 1983</date></biblioset><biblioset relation="article"><author>0-201-63392-2 
        <firstname>Per Brinch</firstname><lastname>Hansen</lastname></author><title><ulink url="http://www.acm.org/pubs/articles/journals/surveys/1973-5-4/p223-hansen/">Concurrent Programming Concepts</ulink></title></biblioset><para>"This paper describes the evolution of language features for
    multiprogramming from event queues and semaphores to critical regions and
    monitors." Includes analysis of why events are considered error-prone. Also
    noteworthy because of an introductory quotation from Christopher Alexander;
    Brinch Hansen was years ahead of others in recognizing pattern concepts
    applied to software, too.</para></biblioentry><biblioentry id="threads.bib.Butenhof97"><abbrev id="threads.bib.Butenhof97.abbrev">Butenhof97</abbrev><title><ulink url="http://cseng.aw.com/book/0,3828,0201633922,00.html">Programming with POSIX Threads </ulink></title><author><firstname>David</firstname><othername>R.</othername><surname>Butenhof</surname></author><publisher>Addison-Wesley</publisher><copyright><year>1997</year></copyright><isbn>ISNB: 0-201-63392-2</isbn><para>This is a very readable explanation of threads and how to use
	them. Many of the insights given apply to all multithreaded programming, not
	just POSIX Threads</para></biblioentry><biblioentry id="threads.bib.Hoare74"><abbrev id="threads.bib.Hoare74.abbrev">Hoare74</abbrev><biblioset relation="journal"><title>Communications of the ACM</title><volumenum>Vol. 17</volumenum><issuenum>No. 10</issuenum><date>October, 1974</date></biblioset><biblioset relation="article"><title><ulink url=" http://www.acm.org/classics/feb96/">Monitors: An Operating System Structuring Concept</ulink></title><author><firstname>C.A.R.</firstname><surname>Hoare</surname></author><pagenums>549-557</pagenums></biblioset><para>Hoare and Brinch Hansen's work on Monitors is the basis for reliable
	multithreading patterns. This is one of the most often referenced papers in
	all of computer science, and with good reason.</para></biblioentry><biblioentry id="threads.bib.ISO98"><abbrev id="threads.bib.ISO98.abbrev">ISO98</abbrev><title><ulink url="http://www.ansi.org">Programming Language C++</ulink></title><orgname>ISO/IEC</orgname><releaseinfo>14882:1998(E)</releaseinfo><para>This is the official C++ Standards document. Available from the ANSI
	(American National Standards Institute) Electronic Standards Store.</para></biblioentry><biblioentry id="threads.bib.McDowellHelmbold89"><abbrev id="threads.bib.McDowellHelmbold89.abbrev">McDowellHelmbold89</abbrev><biblioset relation="journal"><title>Communications of the ACM</title><volumenum>Vol. 21</volumenum><issuenum>No. 2</issuenum><date>December, 1989</date></biblioset><biblioset><author><firstname>Charles</firstname><othername>E.</othername><surname>McDowell</surname></author><author><firstname>David</firstname><othername>P.</othername><surname>Helmbold</surname></author><title><ulink url="http://www.acm.org/pubs/citations/journals/surveys/1989-21-4/p593-mcdowell/">Debugging Concurrent Programs</ulink></title></biblioset><para>Identifies many of the unique failure modes and debugging difficulties
	associated with concurrent programs.</para></biblioentry><biblioentry id="threads.bib.SchmidtPyarali"><abbrev id="threads.bib.SchmidtPyarali.abbrev">SchmidtPyarali</abbrev><title><ulink url="http://www.cs.wustl.edu/~schmidt/win32-cv-1.html8">Strategies for Implementing POSIX Condition Variables on Win32</ulink></title><authorgroup><author><firstname>Douglas</firstname><othername>C.</othername><surname>Schmidt</surname></author><author><firstname>Irfan</firstname><surname>Pyarali</surname></author></authorgroup><orgname>Department of Computer Science, Washington University, St. Louis,
	Missouri</orgname><para>Rationale for understanding <emphasis role="bold">Boost.Threads</emphasis> condition
	variables. Note that Alexander Terekhov found some bugs in the
	implementation given in this article, so pthreads-win32 and <emphasis role="bold">Boost.Threads</emphasis>
	are even more complicated yet.</para></biblioentry><biblioentry id="threads.bib.SchmidtStalRohnertBuschmann"><abbrev id="threads.bib.SchmidtStalRohnertBuschmann.abbrev">SchmidtStalRohnertBuschmann</abbrev><title><ulink url="http://www.wiley.com/Corporate/Website/Objects/Products/0,9049,104671,00.html">Pattern-Oriented Architecture Volume 2</ulink></title><subtitle>Patterns for Concurrent and Networked Objects</subtitle><titleabbrev>POSA2</titleabbrev><authorgroup><author><firstname>Douglas</firstname><othername>C.</othername><surname>Schmidt</surname></author><author><firstname>Michael</firstname><lastname>Stal</lastname></author><author><firstname>Hans</firstname><surname>Rohnert</surname></author><author><firstname>Frank</firstname><surname>Buschmann</surname></author></authorgroup><publisher>Wiley</publisher><copyright><year>2000</year></copyright><para>This is a very good explanation of how to apply several patterns
	useful for concurrent programming. Among the patterns documented is the
	Monitor Pattern mentioned frequently in the <emphasis role="bold">Boost.Threads</emphasis>
	documentation.</para></biblioentry><biblioentry id="threads.bib.Stroustrup"><abbrev id="threads.bib.Stroustrup.abbrev">Stroustrup</abbrev><title><ulink url="http://cseng.aw.com/book/0,3828,0201700735,00.html">The C++ Programming Language</ulink></title><edition>Special Edition</edition><publisher>Addison-Wesley</publisher><copyright><year>2000</year></copyright><isbn>ISBN: 0-201-70073-5</isbn><para>The first book a C++ programmer should own. Note that the 3rd edition
	(and subsequent editions like the Special Edition) has been rewritten to
	cover the ISO standard language and library.</para></biblioentry></bibliography></chapter><chapter xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="tribool" rev:last-revision="$Date: 2004/07/25 03:01:38 $"><chapterinfo><author><firstname>Douglas</firstname><surname>Gregor</surname><email>dgregor -at- cs.indiana.edu</email></author><copyright><year>2002</year><year>2003</year><year>2004</year><holder>Douglas Gregor</holder></copyright><legalnotice><para>Use, modification and distribution is subject to the Boost
    Software License, Version 1.0. (See accompanying file
    <filename>LICENSE_1_0.txt</filename> or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)</para></legalnotice></chapterinfo><title>Boost.Tribool</title><section id="tribool.introduction"><title>Introduction</title><para>The 3-state boolean library contains a single class,
    <computeroutput><link linkend="boost.logic.tribool">boost::logic::tribool</link></computeroutput>, along with
    support functions and operator overloads that implement 3-state
    boolean logic. </para></section><section id="tribool.tutorial"><title>Tutorial</title><section><title>Basic usage</title><para> The <computeroutput><link linkend="boost.logic.tribool">tribool</link></computeroutput> class acts
    like the built-in <computeroutput>bool</computeroutput> type, but for 3-state boolean
    logic. The three states are <computeroutput>true</computeroutput>, <computeroutput>false</computeroutput>,
    and <computeroutput><link linkend="indeterminate">indeterminate</link></computeroutput>, where
    the first two states are equivalent to those of the C++
    <computeroutput>bool</computeroutput> type and the last state represents an unknown
    boolean value (that may be <computeroutput>true</computeroutput> or
    <computeroutput>false</computeroutput>, we don't know).</para><para> The <computeroutput><link linkend="boost.logic.tribool">tribool</link></computeroutput> class
    supports conversion from <computeroutput>bool</computeroutput> values and literals
    along with its own
    <computeroutput><link linkend="indeterminate">indeterminate</link></computeroutput>
    keyword:</para><programlisting><link linkend="boost.logic.tribool">tribool</link> b(true);
b = false;
b = <link linkend="indeterminate">indeterminate</link>;
<link linkend="boost.logic.tribool">tribool</link> b2(b);</programlisting><para><computeroutput><link linkend="boost.logic.tribool">tribool</link></computeroutput> supports
    conversions to <computeroutput>bool</computeroutput> for use in conditional
    statements. The conversion to <computeroutput>bool</computeroutput> will be
    <computeroutput>true</computeroutput> when the value of the
    <computeroutput><link linkend="boost.logic.tribool">tribool</link></computeroutput> is always true, and
    <computeroutput>false</computeroutput> otherwise. Consequently, the following idiom
    may be used to determine which of the three states a
    <computeroutput><link linkend="boost.logic.tribool">tribool</link></computeroutput> currently
    holds:</para><programlisting><link linkend="boost.logic.tribool">tribool</link> b = some_operation();
if (b) {
  // b is true
}
else if (!b) {
  // b is false
}
else {
  // b is indeterminate
}</programlisting><para><computeroutput><link linkend="boost.logic.tribool">tribool</link></computeroutput> supports the
  3-state logic operators <computeroutput>!</computeroutput> (negation),
  <computeroutput>&amp;&amp;</computeroutput> (AND), and <computeroutput>||</computeroutput> (OR), with
  <computeroutput>bool</computeroutput> and <computeroutput><link linkend="boost.logic.tribool">tribool</link></computeroutput>
  values. For instance:</para><programlisting><link linkend="boost.logic.tribool">tribool</link> x = some_op();
<link linkend="boost.logic.tribool">tribool</link> y = some_other_op();
if (x &amp;&amp; y) {
  // both x and y are true
}
else if (!(x &amp;&amp; y)) {
  // either x or y is false
}
else {
  // neither x nor y is false, but we don't know that both are true

  if (x || y) {
    // either x or y is true
  }
}</programlisting><para> Similarly, <computeroutput><link linkend="boost.logic.tribool">tribool</link></computeroutput>
  supports 3-state equality comparisons via the operators
  <computeroutput>==</computeroutput> and <computeroutput>!=</computeroutput>. These operators differ from
  "normal" equality operators in C++ because they return a
  <computeroutput><link linkend="boost.logic.tribool">tribool</link></computeroutput>, because potentially we
  might not know the result of a comparison (try to compare
  <computeroutput>true</computeroutput> and
  <computeroutput><link linkend="indeterminate">indeterminate</link></computeroutput>). For
  instance:</para><programlisting><link linkend="boost.logic.tribool">tribool</link> x(true);
<link linkend="boost.logic.tribool">tribool</link> y(<link linkend="indeterminate">indeterminate</link>);

assert(x == x); // okay, x == x returns true
assert(x == true); // okay, can compare <link linkend="boost.logic.tribool">tribool</link>s and bools</programlisting><para> The <computeroutput><link linkend="indeterminate">indeterminate</link></computeroutput> keyword (representing the
  <link linkend="indeterminate">indeterminate</link>&#xA0;<computeroutput><link linkend="boost.logic.tribool">tribool</link></computeroutput> value)
  doubles as a function to check if the value of a
  <computeroutput><link linkend="boost.logic.tribool">tribool</link></computeroutput> is indeterminate,
  e.g.,</para><programlisting><link linkend="boost.logic.tribool">tribool</link> x = try_to_do_something_tricky();
if (<link linkend="indeterminate">indeterminate</link>(x)) {
  // value of x is indeterminate
}
else {
  // report success or failure of x
}</programlisting></section><section><title>Renaming the indeterminate state</title><para> Users may introduce additional keywords for the indeterminate
  value in addition to the implementation-supplied
  <computeroutput><link linkend="indeterminate">indeterminate</link></computeroutput> using the
  <computeroutput><link linkend="BOOST_TRIBOOL_THIRD_STATE">BOOST_TRIBOOL_THIRD_STATE</link></computeroutput>
  macro. For instance, the following macro instantiation (at the
  global scope) will introduce the keyword <computeroutput>maybe</computeroutput> as a
  synonym for <computeroutput><link linkend="indeterminate">indeterminate</link></computeroutput>
  (also residing in the <computeroutput>boost</computeroutput> namespace):</para><programlisting><link linkend="BOOST_TRIBOOL_THIRD_STATE">BOOST_TRIBOOL_THIRD_STATE</link>(maybe)
<link linkend="boost.logic.tribool">tribool</link> x = maybe;
if (maybe(x)) { /* ... */ }</programlisting></section><section><title><computeroutput>tribool</computeroutput> input/output</title><para><computeroutput><link linkend="boost.logic.tribool">tribool</link></computeroutput> objects may be
  read from and written to streams by including the
  <link linkend="id267011">boost/logic/tribool_io.hpp</link> header in a
  manner very similar to <computeroutput>bool</computeroutput> values. When the
  <computeroutput>boolalpha</computeroutput> flag is not set on the input/output stream,
  the integral values 0, 1, and 2 correspond to <computeroutput>tribool</computeroutput>
  values <computeroutput>false</computeroutput>, <computeroutput>true</computeroutput>, and
  <computeroutput>indeterminate</computeroutput>, respectively. When
  <computeroutput>boolalpha</computeroutput> is set on the stream, arbitrary strings can
  be used to represent the three values, the default being "false",
  "true", and "indeterminate". For instance:</para><programlisting><link linkend="boost.logic.tribool">tribool</link> x;
cin &gt;&gt; x; // Type "0", "1", or "2" to get false, true, or indeterminate
cout &lt;&lt; boolalpha &lt;&lt; x; // Produces "false", "true", or "indeterminate"</programlisting><para><computeroutput><link linkend="boost.logic.tribool">tribool</link></computeroutput> input and output
  is sensitive to the stream's current locale. The strings associated
  with false and true values are contained in the standard
  <computeroutput>std::numpunct</computeroutput> facet, and the
  string naming the indeterminate type is contained in the
  <computeroutput><link linkend="indeterminate_name">indeterminate_name</link></computeroutput> facet. To
  replace the name of the indeterminate state, you need to imbue your
  stream with a local containing a
  <computeroutput><link linkend="indeterminate_name">indeterminate_name</link></computeroutput> facet, e.g.:</para><programlisting><link linkend="BOOST_TRIBOOL_THIRD_STATE">BOOST_TRIBOOL_THIRD_STATE</link>(maybe)
locale global;
locale test_locale(global, new <link linkend="indeterminate_name">indeterminate_name</link>&lt;char&gt;("maybe"));
cout.imbue(test_locale);
<link linkend="boost.logic.tribool">tribool</link> x(maybe);
cout &lt;&lt; boolalpha &lt;&lt; x &lt;&lt; endl; // Prints "maybe"</programlisting><para>If you C++ standard library implementation does not support
  locales, <computeroutput>tribool</computeroutput> input/output will still work, but you
  will be unable to customize the strings printed/parsed when
  <computeroutput>boolalpha</computeroutput> is set.</para></section></section><section id="tribool.reference"><title>Reference</title><section id="id442636"><title>Header &lt;<ulink url="../../boost/logic/tribool.hpp">boost/logic/tribool.hpp</ulink>&gt;</title><synopsis>

<link linkend="BOOST_TRIBOOL_THIRD_STATE">BOOST_TRIBOOL_THIRD_STATE</link>(Name)</synopsis><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> logic {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="boost.logic.tribool">tribool</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="indeterminate">indeterminate</link>(<link linkend="boost.logic.tribool">tribool</link>, <emphasis>unspecified</emphasis> = <emphasis>unspecified</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id268158"><emphasis role="bold">operator</emphasis>!</link>(<link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id217301"><emphasis role="bold">operator</emphasis>&amp;&amp;</link>(<link linkend="boost.logic.tribool">tribool</link>, <link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id217301"><emphasis role="bold">operator</emphasis>&amp;&amp;</link>(<link linkend="boost.logic.tribool">tribool</link>, <emphasis role="bold">bool</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id217301"><emphasis role="bold">operator</emphasis>&amp;&amp;</link>(<emphasis role="bold">bool</emphasis>, <link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id217301"><emphasis role="bold">operator</emphasis>&amp;&amp;</link>(indeterminate_keyword_t, <link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id217301"><emphasis role="bold">operator</emphasis>&amp;&amp;</link>(<link linkend="boost.logic.tribool">tribool</link>, indeterminate_keyword_t);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id346259"><emphasis role="bold">operator</emphasis>||</link>(<link linkend="boost.logic.tribool">tribool</link>, <link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id346259"><emphasis role="bold">operator</emphasis>||</link>(<link linkend="boost.logic.tribool">tribool</link>, <emphasis role="bold">bool</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id346259"><emphasis role="bold">operator</emphasis>||</link>(<emphasis role="bold">bool</emphasis>, <link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id346259"><emphasis role="bold">operator</emphasis>||</link>(indeterminate_keyword_t, <link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id346259"><emphasis role="bold">operator</emphasis>||</link>(<link linkend="boost.logic.tribool">tribool</link>, indeterminate_keyword_t);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id391666"><emphasis role="bold">operator</emphasis>==</link>(<link linkend="boost.logic.tribool">tribool</link>, <link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id391666"><emphasis role="bold">operator</emphasis>==</link>(<link linkend="boost.logic.tribool">tribool</link>, <emphasis role="bold">bool</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id391666"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">bool</emphasis>, <link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id391666"><emphasis role="bold">operator</emphasis>==</link>(indeterminate_keyword_t, <link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id391666"><emphasis role="bold">operator</emphasis>==</link>(<link linkend="boost.logic.tribool">tribool</link>, indeterminate_keyword_t);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id380697"><emphasis role="bold">operator</emphasis>!=</link>(<link linkend="boost.logic.tribool">tribool</link>, <link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id380697"><emphasis role="bold">operator</emphasis>!=</link>(<link linkend="boost.logic.tribool">tribool</link>, <emphasis role="bold">bool</emphasis>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id380697"><emphasis role="bold">operator</emphasis>!=</link>(<emphasis role="bold">bool</emphasis>, <link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id380697"><emphasis role="bold">operator</emphasis>!=</link>(indeterminate_keyword_t, <link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="boost.logic.tribool">tribool</link></type> <link linkend="id380697"><emphasis role="bold">operator</emphasis>!=</link>(<link linkend="boost.logic.tribool">tribool</link>, indeterminate_keyword_t);
&#xA0;&#xA0;}
}</synopsis><refentry id="boost.logic.tribool"><refmeta><refentrytitle>Class tribool</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::logic::tribool</refname><refpurpose>A 3-state boolean type. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> tribool {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="boost.logic.triboolconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id503060-bb">tribool</link>();
&#xA0;&#xA0;<link linkend="id445956-bb">tribool</link>(<emphasis role="bold">bool</emphasis>);
&#xA0;&#xA0;<link linkend="id459033-bb">tribool</link>(indeterminate_keyword_t);

&#xA0;&#xA0;<emphasis>// <link linkend="id468832-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<link linkend="id468836-bb"><emphasis role="bold">operator</emphasis> safe_bool</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;enum boost::logic::tribool::@0 value;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>3-state boolean values are either true, false, or indeterminate. </para><refsect2><title><anchor id="boost.logic.triboolconstruct-copy-destruct"/><computeroutput>tribool</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id503060-bb"/>tribool();</literallayout></para><para>Construct a new 3-state boolean value with the value 'false'.</para><para/><variablelist spacing="boost"><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id445956-bb"/>tribool(<emphasis role="bold">bool</emphasis> value);</literallayout></para><para>Construct a new 3-state boolean value with the given boolean value, which may be <computeroutput>true</computeroutput>  or <computeroutput>false</computeroutput> .</para><para/><variablelist spacing="boost"><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id459033-bb"/>tribool(indeterminate_keyword_t );</literallayout></para><para>Construct a new 3-state boolean value with an indeterminate value.</para><para/><variablelist spacing="boost"><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id468832-bb"/><computeroutput>tribool</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id468836-bb"/><emphasis role="bold">operator</emphasis> safe_bool() <emphasis role="bold">const</emphasis>;</literallayout></para><para>Use a 3-state boolean in a boolean context. Will evaluate true in a boolean context only when the 3-state boolean is definitely true.</para><para/><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>true if the 3-state boolean is true, false otherwise </para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="indeterminate"><refmeta><refentrytitle>Function indeterminate</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::logic::indeterminate</refname><refpurpose>Keyword and test function for the indeterminate tribool value. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><emphasis role="bold">bool</emphasis></type> indeterminate(<link linkend="boost.logic.tribool">tribool</link> x, <emphasis>unspecified</emphasis> dummy = <emphasis>unspecified</emphasis>);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The <computeroutput>indeterminate</computeroutput>  function has a dual role. It's first role is as a unary function that tells whether the tribool value is in the "indeterminate" state. It's second role is as a keyword representing the indeterminate (just like "true" and "false" represent the true and false states). If you do not like the name "indeterminate", and would prefer to use a different name, see the macro <computeroutput>BOOST_TRIBOOL_THIRD_STATE</computeroutput> .</para><para/><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para><computeroutput>x.value == tribool::indeterminate_value</computeroutput></para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id268158"><refmeta><refentrytitle>Function operator!</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::logic::operator!</refname><refpurpose>Computes the logical negation of a tribool. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>!(<link linkend="boost.logic.tribool">tribool</link> x);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para/><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>the logical negation of the tribool, according to the table: <informaltable><tgroup cols="2"><tbody><row><entry valign="middle" align="center"><emphasis role="bold"><computeroutput>!</computeroutput></emphasis></entry></row><row><entry valign="middle" align="center"><emphasis role="bold">false</emphasis></entry><entry valign="middle" align="center">true</entry></row><row><entry valign="middle" align="center"><emphasis role="bold">true</emphasis></entry><entry valign="middle" align="center">false</entry></row><row><entry valign="middle" align="center"><emphasis role="bold">indeterminate</emphasis></entry><entry valign="middle" align="center">indeterminate</entry></row></tbody></tgroup></informaltable></para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id217301"><refmeta><refentrytitle>Function operator&amp;&amp;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::logic::operator&amp;&amp;</refname><refpurpose>Computes the logical conjuction of two tribools. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>&amp;&amp;(<link linkend="boost.logic.tribool">tribool</link> x, <link linkend="boost.logic.tribool">tribool</link> y);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>&amp;&amp;(<link linkend="boost.logic.tribool">tribool</link> x, <emphasis role="bold">bool</emphasis> y);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>&amp;&amp;(<emphasis role="bold">bool</emphasis> x, <link linkend="boost.logic.tribool">tribool</link> y);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>&amp;&amp;(indeterminate_keyword_t , <link linkend="boost.logic.tribool">tribool</link> x);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>&amp;&amp;(<link linkend="boost.logic.tribool">tribool</link> x, indeterminate_keyword_t );</synopsis></refsynopsisdiv><refsect1><title>Description</title><para/><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>the result of logically ANDing the two tribool values, according to the following table: <informaltable><tgroup cols="4"><tbody><row><entry valign="middle" align="center"><emphasis role="bold"><computeroutput>&amp;&amp;</computeroutput></emphasis></entry><entry valign="middle" align="center"><emphasis role="bold">false</emphasis></entry><entry valign="middle" align="center"><emphasis role="bold">true</emphasis></entry><entry valign="middle" align="center"><emphasis role="bold">indeterminate</emphasis></entry></row><row><entry valign="middle" align="center"><emphasis role="bold">false</emphasis></entry><entry valign="middle" align="center">false</entry><entry valign="middle" align="center">false</entry><entry valign="middle" align="center">false</entry></row><row><entry valign="middle" align="center"><emphasis role="bold">true</emphasis></entry><entry valign="middle" align="center">false</entry><entry valign="middle" align="center">true</entry><entry valign="middle" align="center">indeterminate</entry></row><row><entry valign="middle" align="center"><emphasis role="bold">indeterminate</emphasis></entry><entry valign="middle" align="center">false</entry><entry valign="middle" align="center">indeterminate</entry><entry valign="middle" align="center">indeterminate</entry></row></tbody></tgroup></informaltable></para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id346259"><refmeta><refentrytitle>Function operator||</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::logic::operator||</refname><refpurpose>Computes the logical disjunction of two tribools. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>||(<link linkend="boost.logic.tribool">tribool</link> x, <link linkend="boost.logic.tribool">tribool</link> y);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>||(<link linkend="boost.logic.tribool">tribool</link> x, <emphasis role="bold">bool</emphasis> y);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>||(<emphasis role="bold">bool</emphasis> x, <link linkend="boost.logic.tribool">tribool</link> y);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>||(indeterminate_keyword_t , <link linkend="boost.logic.tribool">tribool</link> x);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>||(<link linkend="boost.logic.tribool">tribool</link> x, indeterminate_keyword_t );</synopsis></refsynopsisdiv><refsect1><title>Description</title><para/><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>the result of logically ORing the two tribool values, according to the following table: <informaltable><tgroup cols="4"><tbody><row><entry valign="middle" align="center"><emphasis role="bold"><computeroutput>||</computeroutput></emphasis></entry><entry valign="middle" align="center"><emphasis role="bold">false</emphasis></entry><entry valign="middle" align="center"><emphasis role="bold">true</emphasis></entry><entry valign="middle" align="center"><emphasis role="bold">indeterminate</emphasis></entry></row><row><entry valign="middle" align="center"><emphasis role="bold">false</emphasis></entry><entry valign="middle" align="center">false</entry><entry valign="middle" align="center">true</entry><entry valign="middle" align="center">indeterminate</entry></row><row><entry valign="middle" align="center"><emphasis role="bold">true</emphasis></entry><entry valign="middle" align="center">true</entry><entry valign="middle" align="center">true</entry><entry valign="middle" align="center">true</entry></row><row><entry valign="middle" align="center"><emphasis role="bold">indeterminate</emphasis></entry><entry valign="middle" align="center">indeterminate</entry><entry valign="middle" align="center">true</entry><entry valign="middle" align="center">indeterminate</entry></row></tbody></tgroup></informaltable></para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id391666"><refmeta><refentrytitle>Function operator==</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::logic::operator==</refname><refpurpose>Compare tribools for equality. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>==(<link linkend="boost.logic.tribool">tribool</link> x, <link linkend="boost.logic.tribool">tribool</link> y);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>==(<link linkend="boost.logic.tribool">tribool</link> x, <emphasis role="bold">bool</emphasis> y);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>==(<emphasis role="bold">bool</emphasis> x, <link linkend="boost.logic.tribool">tribool</link> y);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>==(indeterminate_keyword_t , <link linkend="boost.logic.tribool">tribool</link> x);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>==(<link linkend="boost.logic.tribool">tribool</link> x, indeterminate_keyword_t );</synopsis></refsynopsisdiv><refsect1><title>Description</title><para/><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>the result of comparing two tribool values, according to the following table: <informaltable><tgroup cols="4"><tbody><row><entry valign="middle" align="center"><emphasis role="bold"><computeroutput>==</computeroutput></emphasis></entry><entry valign="middle" align="center"><emphasis role="bold">false</emphasis></entry><entry valign="middle" align="center"><emphasis role="bold">true</emphasis></entry><entry valign="middle" align="center"><emphasis role="bold">indeterminate</emphasis></entry></row><row><entry valign="middle" align="center"><emphasis role="bold">false</emphasis></entry><entry valign="middle" align="center">true</entry><entry valign="middle" align="center">false</entry><entry valign="middle" align="center">indeterminate</entry></row><row><entry valign="middle" align="center"><emphasis role="bold">true</emphasis></entry><entry valign="middle" align="center">false</entry><entry valign="middle" align="center">true</entry><entry valign="middle" align="center">indeterminate</entry></row><row><entry valign="middle" align="center"><emphasis role="bold">indeterminate</emphasis></entry><entry valign="middle" align="center">indeterminate</entry><entry valign="middle" align="center">indeterminate</entry><entry valign="middle" align="center">indeterminate</entry></row></tbody></tgroup></informaltable></para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id380697"><refmeta><refentrytitle>Function operator!=</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::logic::operator!=</refname><refpurpose>Compare tribools for inequality. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>!=(<link linkend="boost.logic.tribool">tribool</link> x, <link linkend="boost.logic.tribool">tribool</link> y);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>!=(<link linkend="boost.logic.tribool">tribool</link> x, <emphasis role="bold">bool</emphasis> y);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>!=(<emphasis role="bold">bool</emphasis> x, <link linkend="boost.logic.tribool">tribool</link> y);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>!=(indeterminate_keyword_t , <link linkend="boost.logic.tribool">tribool</link> x);
<type><link linkend="boost.logic.tribool">tribool</link></type> <emphasis role="bold">operator</emphasis>!=(<link linkend="boost.logic.tribool">tribool</link> x, indeterminate_keyword_t );</synopsis></refsynopsisdiv><refsect1><title>Description</title><para/><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para>the result of comparing two tribool values for inequality, according to the following table: <informaltable><tgroup cols="4"><tbody><row><entry valign="middle" align="center"><emphasis role="bold"><computeroutput>!=</computeroutput></emphasis></entry><entry valign="middle" align="center"><emphasis role="bold">false</emphasis></entry><entry valign="middle" align="center"><emphasis role="bold">true</emphasis></entry><entry valign="middle" align="center"><emphasis role="bold">indeterminate</emphasis></entry></row><row><entry valign="middle" align="center"><emphasis role="bold">false</emphasis></entry><entry valign="middle" align="center">false</entry><entry valign="middle" align="center">true</entry><entry valign="middle" align="center">indeterminate</entry></row><row><entry valign="middle" align="center"><emphasis role="bold">true</emphasis></entry><entry valign="middle" align="center">true</entry><entry valign="middle" align="center">false</entry><entry valign="middle" align="center">indeterminate</entry></row><row><entry valign="middle" align="center"><emphasis role="bold">indeterminate</emphasis></entry><entry valign="middle" align="center">indeterminate</entry><entry valign="middle" align="center">indeterminate</entry><entry valign="middle" align="center">indeterminate</entry></row></tbody></tgroup></informaltable></para></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw.</simpara></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="BOOST_TRIBOOL_THIRD_STATE"><refmeta><refentrytitle>Macro BOOST_TRIBOOL_THIRD_STATE</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>BOOST_TRIBOOL_THIRD_STATE</refname><refpurpose>Declare a new name for the third state of a tribool. </refpurpose></refnamediv><refsynopsisdiv><synopsis>BOOST_TRIBOOL_THIRD_STATE(Name)</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Use this macro to declare a new name for the third state of a tribool. This state can have any number of new names (in addition to <computeroutput>indeterminate</computeroutput> ), all of which will be equivalent. The new name will be placed in the namespace in which the macro is expanded.</para><para>Example: BOOST_TRIBOOL_THIRD_STATE(true_or_false)</para><para>tribool x(true_or_false); // potentially set x if (true_or_false(x)) { // don't know what x is } </para></refsect1></refentry></section><section id="id506430"><title>Header &lt;<ulink url="../../boost/logic/tribool_fwd.hpp">boost/logic/tribool_fwd.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> logic {
&#xA0;&#xA0;}
}</synopsis></section><section id="id267011"><title>Header &lt;<ulink url="../../boost/logic/tribool_io.hpp">boost/logic/tribool_io.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">namespace</emphasis> logic {
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT&gt; <emphasis role="bold">class</emphasis> <link linkend="indeterminate_name">indeterminate_name</link>;
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; T &gt;</type> <link linkend="id224510">get_default_indeterminate_name</link>();

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Returns the character string "indeterminate". </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; <emphasis role="bold">char</emphasis> &gt;</type> <anchor id="id257124"/>get_default_indeterminate_name&lt;<emphasis role="bold">char</emphasis> &gt;();

&#xA0;&#xA0;&#xA0;&#xA0;<emphasis>// Returns the wide character string L"indeterminate". </emphasis>
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_string&lt; <emphasis role="bold">wchar_t</emphasis> &gt;</type> <anchor id="id474173"/>get_default_indeterminate_name&lt;<emphasis role="bold">wchar_t</emphasis> &gt;();
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> Traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt; CharT, Traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id495324"><emphasis role="bold">operator</emphasis>&lt;&lt;</link>(std::basic_ostream&lt; CharT, Traits &gt; &amp;, <link linkend="boost.logic.tribool">tribool</link>);
&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> Traits&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_istream&lt; CharT, Traits &gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id269271"><emphasis role="bold">operator</emphasis>&gt;&gt;</link>(std::basic_istream&lt; CharT, Traits &gt; &amp;, <link linkend="boost.logic.tribool">tribool</link> &amp;);
&#xA0;&#xA0;}
}</synopsis><refentry id="indeterminate_name"><refmeta><refentrytitle>Class template indeterminate_name</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::logic::indeterminate_name</refname><refpurpose>A locale facet specifying the name of the indeterminate value of a tribool. </refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT&gt; 
<emphasis role="bold">class</emphasis> indeterminate_name {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> CharT&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; char_type;&#xA0;&#xA0;
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> std::basic_string&lt; CharT &gt; string_type;

&#xA0;&#xA0;<emphasis>// <link linkend="indeterminate_nameconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id248385-bb">indeterminate_name</link>();
&#xA0;&#xA0;<link linkend="id303423-bb">indeterminate_name</link>(<emphasis role="bold">const</emphasis> string_type &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id282868-bb">public member functions</link></emphasis>
&#xA0;&#xA0;<type>string_type</type> <link linkend="id415705-bb">name</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis role="bold">static</emphasis> std::locale::id id;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>The facet is used to perform I/O on tribool values when <computeroutput>std::boolalpha</computeroutput>  has been specified. This class template is only available if the C++ standard library implementation supports locales. </para><refsect2><title><anchor id="indeterminate_nameconstruct-copy-destruct"/><computeroutput>indeterminate_name</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id248385-bb"/>indeterminate_name();</literallayout></para></listitem><listitem><para><literallayout class="monospaced"><anchor id="id303423-bb"/>indeterminate_name(<emphasis role="bold">const</emphasis> string_type &amp; name);</literallayout></para></listitem></orderedlist></refsect2><refsect2><title><anchor id="id282868-bb"/><computeroutput>indeterminate_name</computeroutput> public member functions</title><orderedlist><listitem><para><literallayout class="monospaced"><type>string_type</type> <anchor id="id415705-bb"/>name() <emphasis role="bold">const</emphasis>;</literallayout></para></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id224510"><refmeta><refentrytitle>Function template get_default_indeterminate_name</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::logic::get_default_indeterminate_name</refname><refpurpose>Returns a string containing the default name for the indeterminate value of a tribool with the given character type T. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type>std::basic_string&lt; T &gt;</type> get_default_indeterminate_name();</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>This routine is used by the input and output streaming operators for tribool when there is no locale support or the stream's locale does not contain the indeterminate_name facet. </para></refsect1></refentry><refentry id="id495324"><refmeta><refentrytitle>Function template operator&lt;&lt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::logic::operator&lt;&lt;</refname><refpurpose>Writes the value of a tribool to a stream. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> Traits&gt; 
&#xA0;&#xA0;<type>std::basic_ostream&lt; CharT, Traits &gt; &amp;</type> 
&#xA0;&#xA0;<emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt; CharT, Traits &gt; &amp; out, <link linkend="boost.logic.tribool">tribool</link> x);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>When the value of <computeroutput>x</computeroutput>  is either <computeroutput>true</computeroutput>  or <computeroutput>false</computeroutput> , this routine is semantically equivalent to: <programlisting> out &lt;&lt; static_cast&lt;bool&gt;(x); 
</programlisting></para><para>When <computeroutput>x</computeroutput>  has an indeterminate value, it outputs either the integer value 2 (if <computeroutput>(out.flags() &amp; std::ios_base::boolalpha) == 0</computeroutput> ) or the name of the indeterminate value. The name of the indeterminate value comes from the indeterminate_name facet (if it is defined in the output stream's locale), or from the get_default_indeterminate_name function (if it is not defined in the locale or if the C++ standard library implementation does not support locales).</para><para/><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para><computeroutput>out</computeroutput></para></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id269271"><refmeta><refentrytitle>Function template operator&gt;&gt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::logic::operator&gt;&gt;</refname><refpurpose>Reads a tribool value from a stream. </refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> CharT, <emphasis role="bold">typename</emphasis> Traits&gt; 
&#xA0;&#xA0;<type>std::basic_istream&lt; CharT, Traits &gt; &amp;</type> 
&#xA0;&#xA0;<emphasis role="bold">operator</emphasis>&gt;&gt;(std::basic_istream&lt; CharT, Traits &gt; &amp; in, <link linkend="boost.logic.tribool">tribool</link> &amp; x);</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>When <computeroutput>(out.flags() &amp; std::ios_base::boolalpha) == 0</computeroutput> , this function reads a <computeroutput>long</computeroutput>  value from the input stream <computeroutput>in</computeroutput>  and converts that value to a tribool. If that value is 0, <computeroutput>x</computeroutput>  becomes <computeroutput>false</computeroutput> ; if it is 1, <computeroutput>x</computeroutput>  becomes <computeroutput>true</computeroutput> ; if it is 2, <computeroutput>becomes</computeroutput><computeroutput>indetermine</computeroutput> ; otherwise, the operation fails (and the fail bit is set on the input stream <computeroutput>in</computeroutput> ).</para><para>When <computeroutput>(out.flags() &amp; std::ios_base::boolalpha) != 0</computeroutput> , this function first determines the names of the false, true, and indeterminate values. The false and true names are extracted from the <computeroutput>std::numpunct</computeroutput>  facet of the input stream's locale (if the C++ standard library implementation supports locales), or from the <computeroutput>default_false_name</computeroutput>  and <computeroutput>default_true_name</computeroutput>  functions (if there is no locale support). The indeterminate name is extracted from the appropriate <computeroutput>indeterminate_name</computeroutput>  facet (if it is available in the input stream's locale), or from the <computeroutput>get_default_indeterminate_name</computeroutput>  function (if the C++ standard library implementation does not support locales, or the <computeroutput>indeterminate_name</computeroutput>  facet is not specified for this locale object). The input is then matched to each of these names, and the tribool <computeroutput>x</computeroutput>  is assigned the value corresponding to the longest name that matched. If no name is matched or all names are empty, the operation fails (and the fail bit is set on the input stream <computeroutput>in</computeroutput> ).</para><para/><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><para><computeroutput>in</computeroutput></para></listitem></varlistentry></variablelist></refsect1></refentry></section></section><section id="tribool.tests"><title>Testsuite</title><section id="tribool.tests.acceptance"><title>Acceptance tests</title><informaltable><tgroup cols="3"><colspec colnum="2" colwidth="1in"/><thead><row><entry>Test</entry><entry>Type</entry><entry>Description</entry><entry>If failing...</entry></row></thead><tbody><row><entry><simpara><ulink url="../../libs/logic/test/tribool_test.cpp">tribool_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test all features of the
      <computeroutput><link linkend="boost.logic.tribool">boost::logic::tribool</link></computeroutput>
      class.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/logic/test/tribool_rename_test.cpp">tribool_rename_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test the use of the
      <computeroutput><link linkend="BOOST_TRIBOOL_THIRD_STATE">BOOST_TRIBOOL_THIRD_STATE</link></computeroutput>
      macro.</para></entry><entry/></row><row><entry><simpara><ulink url="../../libs/logic/test/tribool_io_test.cpp">tribool_io_test.cpp</ulink></simpara></entry><entry><simpara>run</simpara></entry><entry><para>Test tribool input/output.</para></entry><entry/></row></tbody></tgroup></informaltable></section></section></chapter><chapter id="variant"><chapterinfo><author><firstname>Eric</firstname><surname>Friedman</surname></author><author><firstname>Itay</firstname><surname>Maman</surname></author><copyright><year>2002</year><year>2003</year><holder>Eric Friedman</holder><holder>Itay Maman</holder></copyright><legalnotice><para>Permission to copy, use, sell and distribute this software
    is granted provided this copyright notice appears in all copies.
    Permission to modify the code and to distribute modified code is
    granted provided this copyright notice appears in all copies, and
    a notice that the code was modified is included with the copyright
    notice.</para><para> This software is provided "as is" without express or
    implied warranty, and with no claim as to its suitability for any
    purpose.</para></legalnotice></chapterinfo><title>Boost.Variant</title><section id="variant.intro" xml:base="../libs/variant/doc/introduction.xml"><title>Introduction</title><section id="variant.abstract"><title>Abstract</title><para>The <computeroutput>variant</computeroutput> class template is a safe, generic, stack-based
discriminated union container, offering a simple solution for manipulating an
object from a heterogeneous set of types in a uniform manner. Whereas
standard containers such as <computeroutput>std::vector</computeroutput> may be thought of as
"<emphasis role="bold">multi-value, single type</emphasis>,"
<computeroutput>variant</computeroutput> is "<emphasis role="bold">multi-type,
single value</emphasis>."</para><para>Notable features of <computeroutput><link linkend="boost.variant">boost::variant</link></computeroutput>
include:</para><itemizedlist><listitem>Full value semantics, including adherence to standard
    overload resolution rules for conversion operations.</listitem><listitem>Compile-time type-safe value visitation via
    <computeroutput><link linkend="apply_visitor">boost::apply_visitor</link></computeroutput>.</listitem><listitem>Run-time checked explicit value retrieval via
    <computeroutput><link linkend="get">boost::get</link></computeroutput>.</listitem><listitem>Support for recursive variant types via both
    <computeroutput><link linkend="make_recursive_variant">boost::make_recursive_variant</link></computeroutput> and
    <computeroutput><link linkend="recursive_wrapper">boost::recursive_wrapper</link></computeroutput>.</listitem><listitem>Efficient implementation -- stack-based when possible (see
    <xref linkend="variant.design.never-empty"/> for more details).</listitem></itemizedlist></section><section id="variant.motivation"><title>Motivation</title><section id="variant.motivation.problem"><title>Problem</title><para>Many times, during the development of a C++ program, the
programmer finds himself in need of manipulating several distinct
types in a uniform manner. Indeed, C++ features direct language
support for such types through its <computeroutput>union</computeroutput> 
keyword:</para><programlisting>union { int i; double d; } u;
u.d = 3.14;
u.i = 3; // overwrites u.d (OK: u.d is a POD type)</programlisting><para>C++'s <computeroutput>union</computeroutput> construct, however, is nearly
useless in an object-oriented environment. The construct entered
the language primarily as a means for preserving compatibility with
C, which supports only POD (Plain Old Data) types, and so does not
accept types exhibiting non-trivial construction or
destruction:</para><programlisting>union {
  int i;
  std::string s; // illegal: std::string is not a POD type!
} u;</programlisting><para>Clearly another approach is required. Typical solutions
feature the dynamic-allocation of objects, which are subsequently
manipulated through a common base type (often a virtual base class
    [<link linkend="variant.refs.hen01">Hen01</link>]
or, more dangerously, a <computeroutput>void*</computeroutput>). Objects of
concrete type may be then retrieved by way of a polymorphic downcast
construct (e.g., <computeroutput>dynamic_cast</computeroutput>,
<computeroutput><link linkend="any_cast">boost::any_cast</link></computeroutput>, etc.).</para><para>However, solutions of this sort are highly error-prone, due
to the following:</para><itemizedlist><listitem><emphasis>Downcast errors cannot be detected at
    compile-time.</emphasis> Thus, incorrect usage of downcast
    constructs will lead to bugs detectable only at run-time.</listitem><listitem><emphasis>Addition of new concrete types may be 
    ignored.</emphasis> If a new concrete type is added to the
    hierarchy, existing downcast code will continue to work as-is,
    wholly ignoring the new type. Consequently, the programmer must
    manually locate and modify code at numerous locations, which often
    results in run-time errors that are difficult to find.</listitem></itemizedlist><para>Furthermore, even when properly implemented, these solutions tend
to incur a relatively significant abstraction penalty due to the use of
the heap, virtual function calls, and polymorphic downcasts.</para></section><section id="variant.motivation.solution"><title>Solution: A Motivating Example</title><para>The <computeroutput><link linkend="boost.variant">boost::variant</link></computeroutput> class template
addresses these issues in a safe, straightforward, and efficient manner. The
following example demonstrates how the class can be used:</para><programlisting>#include "boost/variant.hpp"
#include &lt;iostream&gt;

class my_visitor : public <link linkend="static_visitor">boost::static_visitor</link>&lt;int&gt;
{
public:
    int operator()(int i) const
    {
        return i;
    }
    
    int operator()(const std::string &amp; str) const
    {
        return str.length();
    }
};

int main()
{
    <link linkend="boost.variant">boost::variant</link>&lt; int, std::string &gt; u("hello world");
    std::cout &lt;&lt; u; // output: hello world

    int result = <link linkend="apply_visitor">boost::apply_visitor</link>( my_visitor(), u );
    std::cout &lt;&lt; result; // output: 11 (i.e., length of "hello world")
}
</programlisting></section></section></section><section id="variant.tutorial" xml:base="../libs/variant/doc/tutorial/tutorial.xml"><title>Tutorial</title><section id="variant.tutorial.basic" xml:base="../libs/variant/doc/tutorial/basic.xml"><title>Basic Usage</title><para>A discriminated union container on some set of types is defined by
  instantiating the <computeroutput><link linkend="boost.variant">boost::variant</link></computeroutput> class
  template with the desired types. These types are called
  <emphasis role="bold">bounded types</emphasis> and are subject to the
  requirements of the
  <link linkend="variant.concepts.bounded-type"><emphasis>BoundedType</emphasis></link>
  concept. Any number of bounded types may be specified, up to some
  implementation-defined limit (see 
  <computeroutput><link linkend="BOOST_VARIANT_LIMIT_TYPES">BOOST_VARIANT_LIMIT_TYPES</link></computeroutput>).</para><para>For example, the following declares a discriminated union container on
  <computeroutput>int</computeroutput> and <computeroutput>std::string</computeroutput>:

<programlisting><link linkend="boost.variant">boost::variant</link>&lt; int, std::string &gt; v;</programlisting></para><para>By default, a <computeroutput>variant</computeroutput> default-constructs its first
  bounded type, so <computeroutput>v</computeroutput> initially contains <computeroutput>int(0)</computeroutput>. If
  this is not desired, or if the first bounded type is not
  default-constructible, a <computeroutput>variant</computeroutput> can be constructed
  directly from any value convertible to one of its bounded types. Similarly,
  a <computeroutput>variant</computeroutput> can be assigned any value convertible to one of its
  bounded types, as demonstrated in the following:

<programlisting>v = "hello";</programlisting></para><para>Now <computeroutput>v</computeroutput> contains a <computeroutput>std::string</computeroutput> equal to
  <computeroutput>"hello"</computeroutput>. We can demonstrate this by
  <emphasis role="bold">streaming</emphasis>&#xA0;<computeroutput>v</computeroutput> to standard
  output:

<programlisting>std::cout &lt;&lt; v &lt;&lt; std::endl;</programlisting></para><para>Usually though, we would like to do more with the content of a
  <computeroutput>variant</computeroutput> than streaming. Thus, we need some way to access the
  contained value. There are two ways to accomplish this:
  <computeroutput><link linkend="apply_visitor">apply_visitor</link></computeroutput>, which is safest
  and very powerful, and
  <computeroutput><link linkend="get">get</link>&lt;T&gt;</computeroutput>, which is
  sometimes more convenient to use.</para><para>For instance, suppose we wanted to concatenate to the string contained
  in <computeroutput>v</computeroutput>. With <emphasis role="bold">value retrieval</emphasis>
  by <computeroutput><link linkend="get">get</link></computeroutput>, this may be accomplished
  quite simply, as seen in the following:

<programlisting>std::string&amp; str = <link linkend="get">boost::get</link>&lt;std::string&gt;(v);
str += " world! ";</programlisting></para><para>As desired, the <computeroutput>std::string</computeroutput> contained by <computeroutput>v</computeroutput> now
  is equal to <computeroutput>"hello world! "</computeroutput>. Again, we can demonstrate this by
  streaming <computeroutput>v</computeroutput> to standard output:

<programlisting>std::cout &lt;&lt; v &lt;&lt; std::endl;</programlisting></para><para>While use of <computeroutput>get</computeroutput> is perfectly acceptable in this trivial
  example, <computeroutput>get</computeroutput> generally suffers from several significant
  shortcomings. For instance, if we were to write a function accepting a
  <computeroutput>variant&lt;int, std::string&gt;</computeroutput>, we would not know whether
  the passed <computeroutput>variant</computeroutput> contained an <computeroutput>int</computeroutput> or a
  <computeroutput>std::string</computeroutput>. If we insisted upon continued use of
  <computeroutput>get</computeroutput>, we would need to query the <computeroutput>variant</computeroutput> for its
  contained type. The following function, which "doubles" the
  content of the given <computeroutput>variant</computeroutput>, demonstrates this approach:

<programlisting>void times_two( boost::variant&lt; int, std::string &gt; &amp; operand )
{
    if ( int* pi = <link linkend="get">boost::get</link>&lt;int&gt;( &amp;v ) )
        *pi *= 2;
    else if ( std::string* pstr = <link linkend="get">boost::get</link>&lt;std::string&gt;( &amp;v ) )
        *pstr += *pstr;
}</programlisting></para><para>However, such code is quite brittle, and without careful attention will
  likely lead to the introduction of subtle logical errors detectable only at
  runtime. For instance, consider if we wished to extend
  <computeroutput>times_two</computeroutput> to operate on a <computeroutput>variant</computeroutput> with additional
  bounded types. Specifically, let's add
  <computeroutput>std::complex&lt;double&gt;</computeroutput> to the set. Clearly, we would need
  to at least change the function declaration:

<programlisting>void times_two( boost::variant&lt; int, std::string, std::complex&lt;double&gt; &gt; &amp; operand )
{
    // as above...?
}</programlisting></para><para>Of course, additional changes are required, for currently if the passed
  <computeroutput>variant</computeroutput> in fact contained a <computeroutput>std::complex</computeroutput> value,
  <computeroutput>times_two</computeroutput> would silently return -- without any of the desired
  side-effects and without any error. In this case, the fix is obvious. But in
  more complicated programs, it could take considerable time to identify and
  locate the error in the first place.</para><para>Thus, real-world use of <computeroutput>variant</computeroutput> typically demands an access
  mechanism more robust than <computeroutput>get</computeroutput>. For this reason,
  <computeroutput>variant</computeroutput> supports compile-time checked
  <emphasis role="bold">visitation</emphasis> via
  <computeroutput><link linkend="apply_visitor">apply_visitor</link></computeroutput>. Visitation requires
  that the programmer explicitly handle (or ignore) each bounded type. Failure
  to do so results in a compile-time error.</para><para>Visitation of a <computeroutput>variant</computeroutput> requires a visitor object. The
  following demonstrates one such implementation of a visitor implementating
  behavior identical to <computeroutput>times_two</computeroutput>:

<programlisting>class times_two_visitor
    : public <link linkend="static_visitor">boost::static_visitor</link>&lt;&gt;
{
public:

    void operator()(int &amp; i) const
    {
        i *= 2;
    }

    void operator()(std::string &amp; str) const
    {
        str += str;
    }

};</programlisting></para><para>With the implementation of the above visitor, we can then apply it to
  <computeroutput>v</computeroutput>, as seen in the following:

<programlisting><link linkend="apply_visitor">boost::apply_visitor</link>( times_two_visitor(), v );</programlisting></para><para>As expected, the content of <computeroutput>v</computeroutput> is now a
  <computeroutput>std::string</computeroutput> equal to <computeroutput>"hello world! hello world! "</computeroutput>.
  (We'll skip the verification this time.)</para><para>In addition to enhanced robustness, visitation provides another
  important advantage over <computeroutput>get</computeroutput>: the ability to write generic
  visitors. For instance, the following visitor will "double" the
  content of <emphasis>any</emphasis>&#xA0;<computeroutput>variant</computeroutput> (provided its
  bounded types each support operator+=):

<programlisting>class times_two_generic
    : public <link linkend="static_visitor">boost::static_visitor</link>&lt;&gt;
{
public:

    template &lt;typename T&gt;
    void operator()( T &amp; operand ) const
    {
        operand += operand;
    }

};</programlisting></para><para>Again, <computeroutput>apply_visitor</computeroutput> sets the wheels in motion:

<programlisting><link linkend="apply_visitor">boost::apply_visitor</link>( times_two_generic(), v );</programlisting></para><para>While the initial setup costs of visitation may exceed that required for
  <computeroutput>get</computeroutput>, the benefits quickly become significant. Before concluding
  this section, we should explore one last benefit of visitation with
  <computeroutput>apply_visitor</computeroutput>:
  <emphasis role="bold">delayed visitation</emphasis>. Namely, a special form
  of <computeroutput>apply_visitor</computeroutput> is available that does not immediately apply
  the given visitor to any <computeroutput>variant</computeroutput> but rather returns a function
  object that operates on any <computeroutput>variant</computeroutput> given to it. This behavior
  is particularly useful when operating on sequences of <computeroutput>variant</computeroutput>
  type, as the following demonstrates:

<programlisting>std::vector&lt; <link linkend="boost.variant">boost::variant</link>&lt;int, std::string&gt; &gt; vec;
vec.push_back( 21 );
vec.push_back( "hello " );

times_two_generic visitor;
std::for_each(
      vec.begin(), vec.end()
   , <link linkend="apply_visitor">boost::apply_visitor</link>(visitor)
   );</programlisting></para></section><section id="variant.tutorial.advanced" xml:base="../libs/variant/doc/tutorial/advanced.xml"><title>Advanced Topics</title><para>This section discusses several features of the library often required
  for advanced uses of <computeroutput>variant</computeroutput>. Unlike in the above section, each
  feature presented below is largely independent of the others. Accordingly,
  this section is not necessarily intended to be read linearly or in its
  entirety.</para><section id="variant.tutorial.preprocessor"><title>Preprocessor macros</title><para>While the <computeroutput>variant</computeroutput> class template's variadic parameter
    list greatly simplifies use for specific instantiations of the template,
    it significantly complicates use for generic instantiations. For instance,
    while it is immediately clear how one might write a function accepting a
    specific <computeroutput>variant</computeroutput> instantiation, say
    <computeroutput>variant&lt;int, std::string&gt;</computeroutput>, it is less clear how one
    might write a function accepting any given <computeroutput>variant</computeroutput>.</para><para>Due to the lack of support for true variadic template parameter lists
    in the C++98 standard, the preprocessor is needed. While the
    <ulink url="../../libs/preprocessor/index.html">Preprocessor</ulink> library provides a general and
    powerful solution, the need to repeat
    <computeroutput><link linkend="BOOST_VARIANT_LIMIT_TYPES">BOOST_VARIANT_LIMIT_TYPES</link></computeroutput>
    unnecessarily clutters otherwise simple code. Therefore, for common
    use-cases, this library provides its own macro
    <computeroutput><emphasis role="bold"><link linkend="BOOST_VARIANT_ENUM_PARAMS">BOOST_VARIANT_ENUM_PARAMS</link></emphasis></computeroutput>.</para><para>This macro simplifies for the user the process of declaring 
    <computeroutput>variant</computeroutput> types in function templates or explicit partial
    specializations of class templates, as shown in the following:

<programlisting>// general cases
template &lt;typename T&gt; void some_func(const T &amp;);
template &lt;typename T&gt; class some_class;

// function template overload
template &lt;<link linkend="BOOST_VARIANT_ENUM_PARAMS">BOOST_VARIANT_ENUM_PARAMS</link>(typename T)&gt;
void some_func(const <link linkend="boost.variant">boost::variant</link>&lt;<link linkend="BOOST_VARIANT_ENUM_PARAMS">BOOST_VARIANT_ENUM_PARAMS</link>(T)&gt; &amp;);

// explicit partial specialization
template &lt;<link linkend="BOOST_VARIANT_ENUM_PARAMS">BOOST_VARIANT_ENUM_PARAMS</link>(typename T)&gt;
class some_class&lt; <link linkend="boost.variant">boost::variant</link>&lt;<link linkend="BOOST_VARIANT_ENUM_PARAMS">BOOST_VARIANT_ENUM_PARAMS</link>(T)&gt; &gt;;</programlisting></para></section><section id="variant.tutorial.over-sequence"><title>Using a type sequence to specify bounded types</title><para>While convenient for typical uses, the <computeroutput>variant</computeroutput> class
    template's variadic template parameter list is limiting in two significant
    dimensions. First, due to the lack of support for true variadic template 
    parameter lists in C++, the number of parameters must be limited to some
    implementation-defined maximum (namely,
    <computeroutput><link linkend="BOOST_VARIANT_LIMIT_TYPES">BOOST_VARIANT_LIMIT_TYPES</link></computeroutput>).
    Second, the nature of parameter lists in general makes compile-time
    manipulation of the lists excessively difficult.</para><para>To solve these problems,
    <computeroutput>make_variant_over&lt; <emphasis>Sequence</emphasis> &gt;</computeroutput>
    exposes a <computeroutput>variant</computeroutput> whose bounded types are the elements of
    <computeroutput>Sequence</computeroutput> (where <computeroutput>Sequence</computeroutput> is any type fulfilling
    the requirements of <ulink url="../../libs/mpl/index.html">MPL</ulink>'s
    <emphasis>Sequence</emphasis> concept). For instance,

<programlisting>typedef mpl::vector&lt; std::string &gt; types_initial;
typedef mpl::push_front&lt; types_initial, int &gt;::type types;

<link linkend="make_variant_over">boost::make_variant_over</link>&lt; types &gt;::type v1;</programlisting>

    behaves equivalently to

<programlisting><link linkend="boost.variant">boost::variant</link>&lt; int, std::string &gt; v2;</programlisting></para><para><emphasis role="bold">Portability</emphasis>: Unfortunately, due to
    standard conformance issues in several compilers,
    <computeroutput>make_variant_over</computeroutput> is not universally available. On these
    compilers the library indicates its lack of support for the syntax via the
    definition of the preprocessor symbol
    <computeroutput><link linkend="id544182">BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT</link></computeroutput>.</para></section><section id="variant.tutorial.recursive"><title>Recursive <computeroutput>variant</computeroutput> types</title><para>Recursive types facilitate the construction of complex semantics from
    simple syntax. For instance, nearly every programmer is familiar with the
    canonical definition of a linked list implementation, whose simple
    definition allows sequences of unlimited length:

<programlisting>template &lt;typename T&gt;
struct list_node
{
    T data;
    list_node * next;
};</programlisting></para><para>The nature of <computeroutput>variant</computeroutput> as a generic class template
    unfortunately precludes the straightforward construction of recursive
    <computeroutput>variant</computeroutput> types. Consider the following attempt to construct
    a structure for simple mathematical expressions:

    <programlisting>struct add;
struct sub;
template &lt;typename OpTag&gt; struct binary_op;

typedef <link linkend="boost.variant">boost::variant</link>&lt;
      int
    , binary_op&lt;add&gt;
    , binary_op&lt;sub&gt;
    &gt; expression;

template &lt;typename OpTag&gt;
struct binary_op
{
    expression left;  // <emphasis>variant instantiated here...</emphasis>
    expression right;

    binary_op( const expression &amp; lhs, const expression &amp; rhs )
        : left(lhs), right(rhs)
    {
    }

}; // <emphasis>...but binary_op not complete until here!</emphasis></programlisting></para><para>While well-intentioned, the above approach will not compile because
    <computeroutput>binary_op</computeroutput> is still incomplete when the <computeroutput>variant</computeroutput>
    type <computeroutput>expression</computeroutput> is instantiated. Further, the approach suffers
    from a more significant logical flaw: even if C++ syntax were different
    such that the above example could be made to "work,"
    <computeroutput>expression</computeroutput> would need to be of infinite size, which is
    clearly impossible.</para><para>To overcome these difficulties, <computeroutput>variant</computeroutput> includes special
    support for the
    <computeroutput><link linkend="recursive_wrapper">boost::recursive_wrapper</link></computeroutput> class
    template, which breaks the circular dependency at the heart of these
    problems. Further,
    <computeroutput><link linkend="make_recursive_variant">boost::make_recursive_variant</link></computeroutput> provides
    a more convenient syntax for declaring recursive <computeroutput>variant</computeroutput>
    types. Tutorials for use of these facilities is described in
    <xref linkend="variant.tutorial.recursive.recursive-wrapper"/> and
    <xref linkend="variant.tutorial.recursive.recursive-variant"/>.</para><section id="variant.tutorial.recursive.recursive-wrapper"><title>Recursive types with <computeroutput>recursive_wrapper</computeroutput></title><para>The following example demonstrates how <computeroutput>recursive_wrapper</computeroutput>
    could be used to solve the problem presented in
    <xref linkend="variant.tutorial.recursive"/>:

    <programlisting>typedef <link linkend="boost.variant">boost::variant</link>&lt;
      int
    , <link linkend="recursive_wrapper">boost::recursive_wrapper</link>&lt; binary_op&lt;add&gt; &gt;
    , <link linkend="recursive_wrapper">boost::recursive_wrapper</link>&lt; binary_op&lt;sub&gt; &gt;
    &gt; expression;</programlisting></para><para>Because <computeroutput>variant</computeroutput> provides special support for
    <computeroutput>recursive_wrapper</computeroutput>, clients may treat the resultant
    <computeroutput>variant</computeroutput> as though the wrapper were not present. This is seen
    in the implementation of the following visitor, which calculates the value
    of an <computeroutput>expression</computeroutput> without any reference to
    <computeroutput>recursive_wrapper</computeroutput>:

    <programlisting>class calculator : public <link linkend="static_visitor">boost::static_visitor&lt;int&gt;</link>
{
public:

    int operator()(int value) const
    {
        return value;
    }

    int operator()(const binary_op&lt;add&gt; &amp; binary) const
    {
        return <link linkend="apply_visitor">boost::apply_visitor</link>( calculator(), binary.left )
             + <link linkend="apply_visitor">boost::apply_visitor</link>( calculator(), binary.right );
    }

    int operator()(const binary_op&lt;sub&gt; &amp; binary) const
    {
        return <link linkend="apply_visitor">boost::apply_visitor</link>( calculator(), binary.left )
             - <link linkend="apply_visitor">boost::apply_visitor</link>( calculator(), binary.right );
    }

};</programlisting></para><para>Finally, we can demonstrate <computeroutput>expression</computeroutput> in action:
  
    <programlisting>void f()
{
    // result = ((7-3)+8) = 12
    expression result(
        binary_op&lt;add&gt;(
            binary_op&lt;sub&gt;(7,3)
          , 8
          )
      );

    assert( <link linkend="apply_visitor">boost::apply_visitor</link>(calculator(),result) == 12 );
}</programlisting></para></section><section id="variant.tutorial.recursive.recursive-variant"><title>Recursive types with <computeroutput>make_recursive_variant</computeroutput></title><para>For some applications of recursive <computeroutput>variant</computeroutput> types, a user
    may be able to sacrifice the full flexibility of using
    <computeroutput>recursive_wrapper</computeroutput> with <computeroutput>variant</computeroutput> for the following
    convenient syntax:

<programlisting>typedef <link linkend="make_recursive_variant">boost::make_recursive_variant</link>&lt;
      int
    , std::vector&lt; boost::recursive_variant_ &gt;
    &gt;::type int_tree_t;</programlisting></para><para>Use of the resultant <computeroutput>variant</computeroutput> type is as expected:

<programlisting>std::vector&lt; int_tree_t &gt; subresult;
subresult.push_back(3);
subresult.push_back(5);

std::vector&lt; int_tree_t &gt; result;
result.push_back(1);
result.push_back(subresult);
result.push_back(7);

int_tree_t var(result);</programlisting></para><para>To be clear, one might represent the resultant content of
    <computeroutput>var</computeroutput> as <computeroutput>( 1 ( 3 5 ) 7 )</computeroutput>.</para><para>Finally, note that a type sequence can be used to specify the bounded
    types of a recursive <computeroutput>variant</computeroutput> via the use of
    <computeroutput><link linkend="id276892">boost::make_recursive_variant_over</link></computeroutput>,
    whose semantics are the same as <computeroutput>make_variant_over</computeroutput> (which is
    described in <xref linkend="variant.tutorial.over-sequence"/>).</para><para><emphasis role="bold">Portability</emphasis>: Unfortunately, due to
    standard conformance issues in several compilers,
    <computeroutput>make_recursive_variant</computeroutput> is not universally supported. On these
    compilers the library indicates its lack of support via the definition
    of the preprocessor symbol
    <computeroutput><link linkend="id413934">BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT</link></computeroutput>.
    Thus, unless working with highly-conformant compilers, maximum portability
    will be achieved by instead using <computeroutput>recursive_wrapper</computeroutput>, as
    described in
    <xref linkend="variant.tutorial.recursive.recursive-wrapper"/>.</para></section></section><section id="variant.tutorial.binary-visitation"><title>Binary visitation</title><para>As the tutorial above demonstrates, visitation is a powerful mechanism
    for manipulating <computeroutput>variant</computeroutput> content. Binary visitation further
    extends the power and flexibility of visitation by allowing simultaneous
    visitation of the content of two different <computeroutput>variant</computeroutput>
    objects.</para><para>Notably this feature requires that binary visitors are incompatible
    with the visitor objects discussed in the tutorial above, as they must
    operate on two arguments. The following demonstrates the implementation of
    a binary visitor:

<programlisting>class are_strict_equals
    : public <link linkend="static_visitor">boost::static_visitor</link>&lt;bool&gt;
{
public:

    template &lt;typename T, typename U&gt;
    bool operator()( const T &amp;, const U &amp; )
    {
        return false; // cannot compare different types
    }

    template &lt;typename T&gt;
    bool operator()( const T &amp; lhs, const T &amp; rhs )
    {
        return lhs == rhs;
    }

};</programlisting></para><para>As expected, the visitor is applied to two <computeroutput>variant</computeroutput>
    arguments by means of <computeroutput>apply_visitor</computeroutput>:

<programlisting><link linkend="boost.variant">boost::variant</link>&lt; int, std::string &gt; v1( "hello" );

<link linkend="boost.variant">boost::variant</link>&lt; double, std::string &gt; v2( "hello" );
assert( <link linkend="apply_visitor">boost::apply_visitor</link>(are_strict_equals(), v1, v2) );

<link linkend="boost.variant">boost::variant</link>&lt; int, const char * &gt; v3( "hello" );
assert( !<link linkend="apply_visitor">boost::apply_visitor</link>(are_strict_equals(), v1, v3) );</programlisting></para><para>Finally, we must note that the function object returned from the
    "delayed" form of
    <computeroutput><link linkend="apply_visitor">apply_visitor</link></computeroutput> also supports
    binary visitation, as the following demonstrates:

<programlisting>typedef <link linkend="boost.variant">boost::variant</link>&lt;double, std::string&gt; my_variant;

std::vector&lt; my_variant &gt; seq1;
seq1.push_back("pi is close to ");
seq1.push_back(3.14);

std::list&lt; my_variant &gt; seq2;
seq2.push_back("pi is close to ");
seq2.push_back(3.14);

are_strict_equals visitor;
assert( std::equal(
      v1.begin(), v1.end(), v2.begin()
    , <link linkend="apply_visitor">boost::apply_visitor</link>( visitor )
    ) );</programlisting></para></section></section></section><section id="variant.reference"><title>Reference</title><section id="variant.concepts" xml:base="../libs/variant/doc/reference/concepts.xml"><title>Concepts</title><section id="variant.concepts.bounded-type"><title><emphasis>BoundedType</emphasis></title><para>The requirements on a <emphasis role="bold">bounded type</emphasis>
      are as follows:</para><itemizedlist><listitem><link linkend="CopyConstructible">CopyConstructible</link> [20.1.3].</listitem><listitem>Destructor upholds the no-throw exception-safety
        guarantee.</listitem><listitem>Complete at the point of <computeroutput>variant</computeroutput> template
        instantiation. (See
        <computeroutput><link linkend="recursive_wrapper">boost::recursive_wrapper</link>&lt;T&gt;</computeroutput>
        for a type wrapper that accepts incomplete types to enable recursive
        <computeroutput>variant</computeroutput> types.)</listitem></itemizedlist><para>Every type specified as a template argument to
      <computeroutput><link linkend="boost.variant">variant</link></computeroutput> must at minimum fulfill the
      above requirements. In addition, certain features of <computeroutput>variant</computeroutput>
      are available only if its bounded types meet the requirements of these
      following additional concepts:</para><itemizedlist><listitem><link linkend="Assignable">Assignable</link>:
        <computeroutput>variant</computeroutput> is itself <emphasis>Assignable</emphasis> if and
        only if every one of its bounded types meets the requirements of the
        concept. (Note that top-level <computeroutput>const</computeroutput>-qualified types and
        reference types do <emphasis>not</emphasis> meet these
        requirements.)</listitem><listitem><link linkend="DefaultConstructible">DefaultConstructible</link> [20.1.4]:
        <computeroutput>variant</computeroutput> is itself
        <link linkend="DefaultConstructible">DefaultConstructible</link> if and only if its first
        bounded type (i.e., <computeroutput>T1</computeroutput>) meets the requirements of the
        concept.</listitem><listitem><link linkend="EqualityComparable">EqualityComparable</link>:
        <computeroutput>variant</computeroutput> is itself <link linkend="EqualityComparable">EqualityComparable</link>
        if and only if every one of its bounded types meets the requirements
        of the concept.</listitem><listitem><link linkend="LessThanComparable">LessThanComparable</link>:
        <computeroutput>variant</computeroutput> is itself <link linkend="LessThanComparable">LessThanComparable</link>
        if and only if every one of its bounded types meets the requirements
        of the concept.</listitem><listitem><link linkend="variant.concepts.output-streamable"><emphasis>OutputStreamable</emphasis></link>:
        <computeroutput>variant</computeroutput> is itself <emphasis>OutputStreamable</emphasis>
        if and only if every one of its bounded types meets the requirements
        of the concept.</listitem></itemizedlist></section><section id="variant.concepts.static-visitor"><title><emphasis>StaticVisitor</emphasis></title><para>The requirements on a <emphasis role="bold">static
    visitor</emphasis> of a type <computeroutput>T</computeroutput> are as follows:</para><itemizedlist><listitem>Must allow invocation as a function by overloading
        <computeroutput>operator()</computeroutput>, unambiguously accepting any value of type
        <computeroutput>T</computeroutput>.</listitem><listitem>Must expose inner type <computeroutput>result_type</computeroutput>. (See 
        <computeroutput><link linkend="visitor_ptr">boost::visitor_ptr</link></computeroutput> for a
        solution to using functions as visitors.)</listitem><listitem>If <computeroutput>result_type</computeroutput> is not <computeroutput>void</computeroutput>, then
        each operation of the function object must return a value implicitly
        convertible to <computeroutput>result_type</computeroutput>.</listitem></itemizedlist><section id="variant.concepts.static-visitor.examples"><title>Examples</title><para>The following class satisfies the requirements of a static visitor
      of several types (i.e., explicitly: <computeroutput>int</computeroutput> and
      <computeroutput>std::string</computeroutput>; or, e.g., implicitly: <computeroutput>short</computeroutput> and
      <computeroutput>const char *</computeroutput>; etc.):</para><programlisting>class my_visitor
    : public <link linkend="static_visitor">boost::static_visitor</link>&lt;int&gt;
{
public:

    int operator()(int i)
    {
        return i * 2;
    }

    int operator()(const std::string&amp; s)
    {
        return s.length();
    }

};</programlisting><para>Another example is the following class, whose function-call
      operator is a member template, allowing it to operate on values of many
      types. Thus, the following class is a visitor of any type that supports
      streaming output (e.g., <computeroutput>int</computeroutput>, <computeroutput>double</computeroutput>,
      <computeroutput>std::string</computeroutput>, etc.):</para><programlisting>class printer
    : public <link linkend="static_visitor">boost::static_visitor</link>&lt;&gt;
{
    template &lt;typename T&gt;
    void operator()(const T&amp; t)
    {
        std::cout &lt;&lt; t &lt;&lt; std::endl;
    }
};</programlisting></section></section><section id="variant.concepts.output-streamable"><title><emphasis>OutputStreamable</emphasis></title><para>The requirements on an <emphasis role="bold">output
      streamable</emphasis> type <computeroutput>T</computeroutput> are as follows:</para><itemizedlist><listitem>For any object <computeroutput>t</computeroutput> of type <computeroutput>T</computeroutput>,
        <computeroutput>std::cout &lt;&lt; t</computeroutput> must be a valid
        expression.</listitem></itemizedlist></section></section><section id="header.boost.variant.hpp"><title>Header &lt;<ulink url="../../boost/variant.hpp">boost/variant.hpp</ulink>&gt;</title><section id="variant.header.include-all"><para>This header exists simply as a convenience to the user, including
      all of the headers in the <computeroutput>boost/variant</computeroutput> directory.</para></section></section><section id="id262208"><title>Header &lt;<ulink url="../../boost/variant/variant_fwd.hpp">boost/variant/variant_fwd.hpp</ulink>&gt;</title><para>Provides forward declarations of the
    <computeroutput><link linkend="boost.variant">boost::variant</link></computeroutput>,
    <computeroutput><link linkend="make_variant_over">boost::make_variant_over</link></computeroutput>,
    <computeroutput><link linkend="make_recursive_variant">boost::make_recursive_variant</link></computeroutput>, and
    <computeroutput><link linkend="id276892">boost::make_recursive_variant_over</link></computeroutput>
    class templates and the <computeroutput>boost::recursive_variant_</computeroutput> tag type.
    Also defines several preprocessor symbols, as described below.</para><synopsis>

<link linkend="BOOST_VARIANT_LIMIT_TYPES">BOOST_VARIANT_LIMIT_TYPES</link>
<link linkend="BOOST_VARIANT_ENUM_PARAMS">BOOST_VARIANT_ENUM_PARAMS</link>(param)
<link linkend="id238903">BOOST_VARIANT_ENUM_SHIFTED_PARAMS</link>(param)
<link linkend="id509339">BOOST_VARIANT_NO_REFERENCE_SUPPORT</link>
<link linkend="id544182">BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT</link>
<link linkend="id413934">BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT</link></synopsis><refentry id="BOOST_VARIANT_LIMIT_TYPES"><refmeta><refentrytitle>Macro BOOST_VARIANT_LIMIT_TYPES</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>BOOST_VARIANT_LIMIT_TYPES</refname><refpurpose><simpara>Expands to the length of the
        template parameter list for
        <computeroutput><link linkend="boost.variant">variant</link></computeroutput>.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>BOOST_VARIANT_LIMIT_TYPES</synopsis></refsynopsisdiv><refsect1><title>Description</title><para><emphasis role="bold">Note</emphasis>: Conforming
        implementations of <computeroutput>variant</computeroutput> must allow at least ten
        template arguments. That is, BOOST_VARIANT_LIMIT_TYPES must be greater
        or equal to <computeroutput>10</computeroutput>.</para></refsect1></refentry><refentry id="BOOST_VARIANT_ENUM_PARAMS"><refmeta><refentrytitle>Macro BOOST_VARIANT_ENUM_PARAMS</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>BOOST_VARIANT_ENUM_PARAMS</refname><refpurpose><simpara>Enumerate parameters for use with
        <computeroutput><link linkend="boost.variant">variant</link></computeroutput>.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>BOOST_VARIANT_ENUM_PARAMS(param)</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Expands to a comma-separated sequence of length
        <computeroutput><link linkend="BOOST_VARIANT_LIMIT_TYPES">BOOST_VARIANT_LIMIT_TYPES</link></computeroutput>, where
        each element in the sequence consists of the concatenation of
        <emphasis>param</emphasis> with its zero-based index into the
        sequence. That is,
        <computeroutput>param ## 0, param ## 1, ..., param ## BOOST_VARIANT_LIMIT_TYPES - 1</computeroutput>.</para><para><emphasis role="bold">Rationale</emphasis>: This macro greatly
        simplifies for the user the process of declaring
        <computeroutput><link linkend="boost.variant">variant</link></computeroutput> types
        in function templates or explicit partial specializations of class
        templates, as shown in the
        <link linkend="variant.tutorial.preprocessor">tutorial</link>.</para></refsect1></refentry><refentry id="id238903"><refmeta><refentrytitle>Macro BOOST_VARIANT_ENUM_SHIFTED_PARAMS</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>BOOST_VARIANT_ENUM_SHIFTED_PARAMS</refname><refpurpose><simpara>Enumerate all but the first parameter for use with
        <computeroutput><link linkend="boost.variant">variant</link></computeroutput>.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>BOOST_VARIANT_ENUM_SHIFTED_PARAMS(param)</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Expands to a comma-separated sequence of length
        <computeroutput><link linkend="BOOST_VARIANT_LIMIT_TYPES">BOOST_VARIANT_LIMIT_TYPES</link> - 1</computeroutput>,
        where each element in the sequence consists of the concatenation of
        <emphasis>param</emphasis> with its one-based index into the sequence.
        That is,
        <computeroutput>param ## 1, ..., param ## BOOST_VARIANT_LIMIT_TYPES - 1</computeroutput>.</para><para><emphasis role="bold">Note</emphasis>: This macro results in the
        same expansion as
        <computeroutput><link linkend="BOOST_VARIANT_ENUM_PARAMS">BOOST_VARIANT_ENUM_PARAMS</link></computeroutput> -- but
        without the first term.</para></refsect1></refentry><refentry id="id509339"><refmeta><refentrytitle>Macro BOOST_VARIANT_NO_REFERENCE_SUPPORT</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>BOOST_VARIANT_NO_REFERENCE_SUPPORT</refname><refpurpose><simpara>Indicates <computeroutput><link linkend="boost.variant">variant</link></computeroutput> does not
        support references as bounded types.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>BOOST_VARIANT_NO_REFERENCE_SUPPORT</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Defined only if <computeroutput><link linkend="boost.variant">variant</link></computeroutput> does
        not support references as bounded types.</para></refsect1></refentry><refentry id="id544182"><refmeta><refentrytitle>Macro BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT</refname><refpurpose><simpara>Indicates absence of support for specifying the bounded types
        of a <computeroutput><link linkend="boost.variant">variant</link></computeroutput> by the elements of a
        type sequence.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Defined only if
        <computeroutput><link linkend="make_variant_over">make_variant_over</link></computeroutput> and
        <computeroutput><link linkend="id276892">make_recursive_variant_over</link></computeroutput>
        are not supported for some reason on the target compiler.</para></refsect1></refentry><refentry id="id413934"><refmeta><refentrytitle>Macro BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT</refname><refpurpose><simpara>Indicates
        <computeroutput><link linkend="make_recursive_variant">make_recursive_variant</link></computeroutput> operates in
        an implementation-defined manner.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT</synopsis></refsynopsisdiv><refsect1><title>Description</title><para>Defined only if
        <computeroutput><link linkend="make_recursive_variant">make_recursive_variant</link></computeroutput> does not
        operate as documented on the target compiler, but rather in an
        implementation-defined manner.</para><para><emphasis role="bold">Implementation Note</emphasis>: If
        <computeroutput>BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT</computeroutput> is
        defined for the target compiler, the current implementation uses the
        <ulink url="../../libs/mpl/index.html">MPL</ulink> lambda mechanism to approximate the
        desired behavior. (In most cases, however, such compilers do not have
        full lambda support either.)</para></refsect1></refentry></section><section id="id516960"><title>Header &lt;<ulink url="../../boost/variant/variant.hpp">boost/variant/variant.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2 = <emphasis>unspecified</emphasis>, ..., 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> TN = <emphasis>unspecified</emphasis>&gt; 
  &#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="boost.variant">variant</link>;

&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Sequence&gt; <emphasis role="bold">class</emphasis> <link linkend="make_variant_over">make_variant_over</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id503912">swap</link>(<link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; &amp;, <link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ElemType, <emphasis role="bold">typename</emphasis> Traits, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> TN&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type>std::basic_ostream&lt;ElemType,Traits&gt; &amp;</type> 
&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id227095"><emphasis role="bold">operator</emphasis>&lt;&lt;</link>(std::basic_ostream&lt;ElemType,Traits&gt; &amp;, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; &amp;);
}</synopsis><refentry id="boost.variant"><refmeta><refentrytitle>Class template variant</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::variant</refname><refpurpose>Safe, generic, stack-based discriminated union container.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2 = <emphasis>unspecified</emphasis>, ..., 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> TN = <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">class</emphasis> variant {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>unspecified</emphasis> types;

&#xA0;&#xA0;<emphasis>// <link linkend="boost.variantconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id372464-bb">variant</link>();
&#xA0;&#xA0;<link linkend="id508111-bb">variant</link>(<emphasis role="bold">const</emphasis> variant &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <link linkend="id552173-bb">variant</link>(T &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <link linkend="id399284-bb">variant</link>(<emphasis role="bold">const</emphasis> T &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U1, <emphasis role="bold">typename</emphasis> U2, ..., <emphasis role="bold">typename</emphasis> UN&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id571867-bb">variant</link>(variant&lt;U1, U2, ..., UN&gt; &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U1, <emphasis role="bold">typename</emphasis> U2, ..., <emphasis role="bold">typename</emphasis> UN&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="id452740-bb">variant</link>(<emphasis role="bold">const</emphasis> variant&lt;U1, U2, ..., UN&gt; &amp;);
&#xA0;&#xA0;<link linkend="id452937-bb">~variant</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id542939-bb">modifiers</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id558196-bb">swap</link>(variant &amp;);
&#xA0;&#xA0;<type>variant &amp;</type> <link linkend="id506925-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> variant &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type>variant &amp;</type> <link linkend="id454843-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> T &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id463182-bb">queries</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">int</emphasis></type> <link linkend="id479663-bb">which</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id489830-bb">empty</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> std::type_info &amp;</type> <link linkend="id443569-bb">type</link>() <emphasis role="bold">const</emphasis>;

&#xA0;&#xA0;<emphasis>// <link linkend="id401169-bb">relational</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id266128-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> variant &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U&gt; <type><emphasis role="bold">void</emphasis></type> <link linkend="id480375-bb"><emphasis role="bold">operator</emphasis>==</link>(<emphasis role="bold">const</emphasis> U &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type><emphasis role="bold">bool</emphasis></type> <link linkend="id498388-bb"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> variant &amp;) <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U&gt; <type><emphasis role="bold">void</emphasis></type> <link linkend="id458182-bb"><emphasis role="bold">operator</emphasis>&lt;</link>(<emphasis role="bold">const</emphasis> U &amp;) <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara>The <computeroutput>variant</computeroutput> class template (inspired by Andrei
        Alexandrescu's class of the same name
        [<link linkend="variant.refs.ale01a">Ale01A</link>]) is an efficient,
        <link linkend="variant.tutorial.recursive">recursive-capable</link>,
        bounded discriminated union value type capable of containing any value
        type (either POD or non-POD). It supports construction from any type
        convertible to one of its bounded types or from a source
        <computeroutput>variant</computeroutput> whose bounded types are each convertible to one
        of the destination <computeroutput>variant</computeroutput>'s bounded types. As well,
        through <computeroutput><link linkend="apply_visitor">apply_visitor</link></computeroutput>,
        <computeroutput>variant</computeroutput> supports compile-time checked, type-safe
        visitation; and through <computeroutput><link linkend="get">get</link></computeroutput>,
        <computeroutput>variant</computeroutput> supports run-time checked, type-safe value
        retrieval.</simpara><simpara><emphasis role="bold">Notes</emphasis>:</simpara><itemizedlist><listitem>The bounded types of the <computeroutput>variant</computeroutput> are exposed
            via the nested typedef <computeroutput>types</computeroutput>, which is an
            <ulink url="../../libs/mpl/index.html">MPL</ulink>-compatible Sequence containing the
            set of types that must be handled by any
            <link linkend="variant.concepts.static-visitor">visitor</link> to
            the <computeroutput>variant</computeroutput>.</listitem><listitem>All members of <computeroutput>variant</computeroutput> satisfy at least the
            basic guarantee of exception-safety. That is, all operations on
            a <computeroutput>variant</computeroutput> remain defined even after previous
            operations have failed.</listitem><listitem>Each type specified as a template argument to
            <computeroutput>variant</computeroutput> must meet the requirements of the
            <emphasis><link linkend="variant.concepts.bounded-type">BoundedType</link></emphasis>
            concept.</listitem><listitem>Each type specified as a template argument to
            <computeroutput>variant</computeroutput> must be distinct after removal of qualifiers.
            Thus, for instance, both <computeroutput>variant&lt;int, int&gt;</computeroutput> and
            <computeroutput>variant&lt;int, const int&gt;</computeroutput> have undefined
            behavior.</listitem><listitem>Conforming implementations of <computeroutput>variant</computeroutput> must
            allow at least ten types as template arguments. The exact number
            of allowed arguments is exposed by the preprocessor macro
            <computeroutput><link linkend="BOOST_VARIANT_LIMIT_TYPES">BOOST_VARIANT_LIMIT_TYPES</link></computeroutput>.
            (See <computeroutput><link linkend="make_variant_over">make_variant_over</link></computeroutput> for a
            means to specify the bounded types of a <computeroutput>variant</computeroutput> by
            the elements of an <ulink url="../../libs/mpl/index.html">MPL</ulink> or compatible
            Sequence, thus overcoming this limitation.)</listitem></itemizedlist><refsect2><title><anchor id="boost.variantconstruct-copy-destruct"/><computeroutput>variant</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id372464-bb"/>variant();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara>The first bounded type of the <computeroutput>variant</computeroutput> (i.e.,
            <computeroutput>T1</computeroutput>) must fulfill the requirements of the
            <emphasis>DefaultConstructible</emphasis> [20.1.4]
            concept.</simpara></listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><simpara>Content of <computeroutput>*this</computeroutput> is the default value of the
            first bounded type (i.e, <computeroutput>T1</computeroutput>).</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>May fail with any exceptions arising from the default
            constructor of <computeroutput>T1</computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id508111-bb"/>variant(<emphasis role="bold">const</emphasis> variant &amp; other);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Postconditions</term><listitem><simpara>Content of <computeroutput>*this</computeroutput> is a copy of the content of
            <computeroutput>other</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>May fail with any exceptions arising from the
            copy constructor of <computeroutput>other</computeroutput>'s contained type.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <anchor id="id552173-bb"/>variant(T &amp; operand);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara><computeroutput>T</computeroutput> must be unambiguously convertible to one of
            the bounded types (i.e., <computeroutput>T1</computeroutput>, <computeroutput>T2</computeroutput>,
            etc.).</simpara></listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><simpara>Content of <computeroutput>*this</computeroutput> is the best conversion of
            <computeroutput>operand</computeroutput> to one of the bounded types, as determined
            by standard overload resolution rules.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>May fail with any exceptions arising from the conversion of
            <computeroutput>operand</computeroutput> to one of the bounded types.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <anchor id="id399284-bb"/>variant(<emphasis role="bold">const</emphasis> T &amp; operand);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Notes</term><listitem><simpara>Same semantics as previous constructor, but allows
            construction from temporaries.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U1, <emphasis role="bold">typename</emphasis> U2, ..., <emphasis role="bold">typename</emphasis> UN&gt; 
&#xA0;&#xA0;<anchor id="id571867-bb"/>variant(variant&lt;U1, U2, ..., UN&gt; &amp; operand);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara><emphasis>Every</emphasis> one of <computeroutput>U1</computeroutput>,
            <computeroutput>U2</computeroutput>, ..., <computeroutput>UN</computeroutput> must have an unambiguous
            conversion to one of the bounded types (i.e., <computeroutput>T1</computeroutput>,
            <computeroutput>T2</computeroutput>, ..., <computeroutput>TN</computeroutput>).</simpara></listitem></varlistentry><varlistentry><term>Postconditions</term><listitem><simpara>If <computeroutput>variant&lt;U1, U2, ..., UN&gt;</computeroutput> is itself
            one of the bounded types, then content of <computeroutput>*this</computeroutput> is a
            copy of <computeroutput>operand</computeroutput>. Otherwise, content of
            <computeroutput>*this</computeroutput> is the best conversion of the content of
            <computeroutput>operand</computeroutput> to one of the bounded types, as determined
            by standard overload resolution rules.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>If <computeroutput>variant&lt;U1, U2, ..., UN&gt;</computeroutput> is itself
          one of the bounded types, then may fail with any exceptions arising
          from the copy constructor of
          <computeroutput>variant&lt;U1, U2, ..., UN&gt;</computeroutput>. Otherwise, may fail
          with any exceptions arising from the conversion of the content of
          <computeroutput>operand</computeroutput> to one of the bounded types.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U1, <emphasis role="bold">typename</emphasis> U2, ..., <emphasis role="bold">typename</emphasis> UN&gt; 
&#xA0;&#xA0;<anchor id="id452740-bb"/>variant(<emphasis role="bold">const</emphasis> variant&lt;U1, U2, ..., UN&gt; &amp; operand);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Notes</term><listitem><simpara>Same semantics as previous constructor, but allows
            construction from temporaries.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id452937-bb"/>~variant();</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Destroys the content of <computeroutput>*this</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem>Will not throw.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id542939-bb"/><computeroutput>variant</computeroutput> modifiers</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id558196-bb"/>swap(variant &amp; other);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara>Every bounded type must fulfill the requirements of the
              <link linkend="Assignable">Assignable</link>
              concept.</simpara></listitem></varlistentry><varlistentry><term>Effects</term><listitem><simpara>Interchanges the content of <computeroutput>*this</computeroutput> and
              <computeroutput>other</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>If the contained type of <computeroutput>other</computeroutput> is the same as
              the contained type of <computeroutput>*this</computeroutput>, then may fail with any
              exceptions arising from the <computeroutput>swap</computeroutput> of the contents of
              <computeroutput>*this</computeroutput> and <computeroutput>other</computeroutput>. Otherwise, may fail
              with any exceptions arising from either of the copy constructors
              of the contained types. Also, in the event of insufficient
              memory, may fail with <computeroutput>std::bad_alloc</computeroutput>
              (<link linkend="variant.design.never-empty.problem">why?</link>).</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>variant &amp;</type> <anchor id="id506925-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> variant &amp; rhs);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara>Every bounded type must fulfill the requirements of the
              <link linkend="Assignable">Assignable</link>
              concept.</simpara></listitem></varlistentry><varlistentry><term>Effects</term><listitem><simpara>If the contained type of <computeroutput>rhs</computeroutput> is the same as
              the contained type of <computeroutput>*this</computeroutput>, then assigns the
              content of <computeroutput>rhs</computeroutput> into the content of
              <computeroutput>*this</computeroutput>. Otherwise, makes the content of
              <computeroutput>*this</computeroutput> a copy of the content of <computeroutput>rhs</computeroutput>,
              destroying the previous content of <computeroutput>*this</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>If the contained type of <computeroutput>rhs</computeroutput> is the same as
              the contained type of <computeroutput>*this</computeroutput>, then may fail with any
              exceptions arising from the assignment of the content of
              <computeroutput>rhs</computeroutput> into the content <computeroutput>*this</computeroutput>. Otherwise,
              may fail with any exceptions arising from the copy constructor
              of the contained type of <computeroutput>rhs</computeroutput>. Also, in the event of
              insufficient memory, may fail with <computeroutput>std::bad_alloc</computeroutput>
              (<link linkend="variant.design.never-empty.problem">why?</link>).</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <type>variant &amp;</type> <anchor id="id454843-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> T &amp; rhs);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><itemizedlist><listitem><computeroutput>T</computeroutput> must be unambiguously convertible to
                one of the bounded types (i.e., <computeroutput>T1</computeroutput>,
                <computeroutput>T2</computeroutput>, etc.).</listitem><listitem>Every bounded type must fulfill the requirements of the
                <link linkend="Assignable">Assignable</link>
                concept.</listitem></itemizedlist></listitem></varlistentry><varlistentry><term>Effects</term><listitem><simpara>If the contained type of <computeroutput>*this</computeroutput> is
              <computeroutput>T</computeroutput>, then assigns <computeroutput>rhs</computeroutput> into the content
              of <computeroutput>*this</computeroutput>. Otherwise, makes the content of
              <computeroutput>*this</computeroutput> the best conversion of <computeroutput>rhs</computeroutput> to
              one of the bounded types, as determined by standard overload
              resolution rules, destroying the previous content of
              <computeroutput>*this</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>If the contained type of <computeroutput>*this</computeroutput> is
              <computeroutput>T</computeroutput>, then may fail with any exceptions arising from
              the assignment of <computeroutput>rhs</computeroutput> into the content
              <computeroutput>*this</computeroutput>. Otherwise, may fail with any exceptions
              arising from the conversion of <computeroutput>rhs</computeroutput> to one of the
              bounded types. Also, in the event of insufficient memory, may
              fail with <computeroutput>std::bad_alloc</computeroutput>
              (<link linkend="variant.design.never-empty.problem">why?</link>).</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id463182-bb"/><computeroutput>variant</computeroutput> queries</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">int</emphasis></type> <anchor id="id479663-bb"/>which() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>The zero-based index into the set of bounded types
              of the contained type of <computeroutput>*this</computeroutput>. (For instance, if
              called on a <computeroutput>variant&lt;int, std::string&gt;</computeroutput> object
              containing a <computeroutput>std::string</computeroutput>, <computeroutput>which()</computeroutput>
              would return <computeroutput>1</computeroutput>.)</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem>Will not throw.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id489830-bb"/>empty() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>false</computeroutput>: <computeroutput>variant</computeroutput> always contains
              exactly one of its bounded types. (See
              <xref linkend="variant.design.never-empty"/>
              for more information.)</simpara></listitem></varlistentry><varlistentry><term>Rationale</term><listitem><simpara>Facilitates generic compatibility with
              <link linkend="boost.any">boost::any</link>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem>Will not throw.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">const</emphasis> std::type_info &amp;</type> <anchor id="id443569-bb"/>type() <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara><computeroutput>typeid(x)</computeroutput>, where <computeroutput>x</computeroutput> is the the
              content of <computeroutput>*this</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem>Will not throw.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id401169-bb"/><computeroutput>variant</computeroutput> relational</title><orderedlist><listitem><para id="id558203-bb"><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id266128-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> variant &amp; rhs) <emphasis role="bold">const</emphasis>;
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U&gt; <type><emphasis role="bold">void</emphasis></type> <anchor id="id480375-bb"/><emphasis role="bold">operator</emphasis>==(<emphasis role="bold">const</emphasis> U &amp; ) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Notes</term><listitem><simpara>The overload returning <computeroutput>void</computeroutput> exists only to
              prohibit implicit conversion of the operator's right-hand side
              to <computeroutput>variant</computeroutput>; thus, its use will (purposefully)
              result in a compile-time error.</simpara></listitem></varlistentry><varlistentry><term>Requires</term><listitem><simpara>Every bounded type of the <computeroutput>variant</computeroutput> must
              fulfill the requirements of the
              <link linkend="EqualityComparable">EqualityComparable</link>
              concept.</simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara><computeroutput>true</computeroutput> iff <computeroutput>which() == rhs.which()</computeroutput><emphasis>and</emphasis><computeroutput>content_this == content_rhs</computeroutput>, where
              <computeroutput>content_this</computeroutput> is the content of <computeroutput>*this</computeroutput>
              and <computeroutput>content_rhs</computeroutput> is the content of
              <computeroutput>rhs</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>If <computeroutput>which() == rhs.which()</computeroutput> then may fail with
              any exceptions arising from <computeroutput>operator==(T,T)</computeroutput>, where
              <computeroutput>T</computeroutput> is the contained type of
              <computeroutput>*this</computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para id="id446606-bb"><literallayout class="monospaced"><type><emphasis role="bold">bool</emphasis></type> <anchor id="id498388-bb"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> variant &amp; rhs) <emphasis role="bold">const</emphasis>;
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U&gt; <type><emphasis role="bold">void</emphasis></type> <anchor id="id458182-bb"/><emphasis role="bold">operator</emphasis>&lt;(<emphasis role="bold">const</emphasis> U &amp; ) <emphasis role="bold">const</emphasis>;</literallayout></para><variablelist spacing="boost"><varlistentry><term>Notes</term><listitem><simpara>The overload returning <computeroutput>void</computeroutput> exists only to
              prohibit implicit conversion of the operator's right-hand side
              to <computeroutput>variant</computeroutput>; thus, its use will (purposefully)
              result in a compile-time error.</simpara></listitem></varlistentry><varlistentry><term>Requires</term><listitem><simpara>Every bounded type of the <computeroutput>variant</computeroutput> must
              fulfill the requirements of the
              <link linkend="LessThanComparable">LessThanComparable</link>
              concept.</simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara>If <computeroutput>which() == rhs.which()</computeroutput> then:
              <computeroutput>content_this &lt; content_rhs</computeroutput>, where
              <computeroutput>content_this</computeroutput> is the content of <computeroutput>*this</computeroutput>
              and <computeroutput>content_rhs</computeroutput> is the content of <computeroutput>rhs</computeroutput>.
              Otherwise: <computeroutput>which() &lt; rhs.which()</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>If <computeroutput>which() == rhs.which()</computeroutput> then may fail with
              any exceptions arising from <computeroutput>operator&lt;(T,T)</computeroutput>,
              where <computeroutput>T</computeroutput> is the contained type of
              <computeroutput>*this</computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="id503912"><refmeta><refentrytitle>Function template swap</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::swap</refname><refpurpose/></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> swap(<link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; &amp; lhs, <link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; &amp; rhs);</synopsis></refsynopsisdiv><refsect1><title>Description</title><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Swaps <computeroutput>lhs</computeroutput> with <computeroutput>rhs</computeroutput> by application
          of <computeroutput><link linkend="id558196-bb">variant::swap</link></computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>May fail with any exception arising from
          <computeroutput><link linkend="id558196-bb">variant::swap</link></computeroutput>.</simpara></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="id227095"><refmeta><refentrytitle>Function template operator&lt;&lt;</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::operator&lt;&lt;</refname><refpurpose>Provides streaming output for <computeroutput>variant</computeroutput> types.</refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ElemType, <emphasis role="bold">typename</emphasis> Traits, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> TN&gt; 
&#xA0;&#xA0;<type>std::basic_ostream&lt;ElemType,Traits&gt; &amp;</type> 
&#xA0;&#xA0;<emphasis role="bold">operator</emphasis>&lt;&lt;(std::basic_ostream&lt;ElemType,Traits&gt; &amp; out, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">const</emphasis> <link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; &amp; rhs);</synopsis></refsynopsisdiv><refsect1><title>Description</title><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara>Every bounded type of the <computeroutput>variant</computeroutput> must
          fulfill the requirements of the
          <link linkend="variant.concepts.output-streamable"><emphasis>OutputStreamable</emphasis></link>
          concept.</simpara></listitem></varlistentry><varlistentry><term>Effects</term><listitem><simpara>Calls <computeroutput>out &lt;&lt; x</computeroutput>, where <computeroutput>x</computeroutput> is
          the content of <computeroutput>rhs</computeroutput>.</simpara></listitem></varlistentry></variablelist></refsect1></refentry><refentry id="make_variant_over"><refmeta><refentrytitle>Class template make_variant_over</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::make_variant_over</refname><refpurpose><simpara>Exposes a <computeroutput>variant</computeroutput> whose bounded types are the
          elements of the given type sequence.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Sequence&gt; 
<emphasis role="bold">class</emphasis> make_variant_over {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> variant&lt; <emphasis>unspecified</emphasis> &gt; type;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara><computeroutput>type</computeroutput> has behavior equivalent in every respect to
          <computeroutput><link linkend="boost.variant">variant</link>&lt; Sequence[0], Sequence[1], ... &gt;</computeroutput>
          (where <computeroutput>Sequence[<emphasis>i</emphasis>]</computeroutput> denotes the
          <emphasis>i</emphasis>-th element of <computeroutput>Sequence</computeroutput>), except
          that no upper limit is imposed on the number of types.</simpara><simpara><emphasis role="bold">Notes</emphasis>:</simpara><itemizedlist><listitem><computeroutput>Sequence</computeroutput> must meet the requirements of
            <ulink url="../../libs/mpl/index.html">MPL</ulink>'s <emphasis>Sequence</emphasis>
            concept.</listitem><listitem>Due to standard conformance problems in several compilers,
            <computeroutput>make_variant_over</computeroutput> may not be supported on your
            compiler. See
            <computeroutput><link linkend="id544182">BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT</link></computeroutput>
            for more information.</listitem></itemizedlist></refsect1></refentry></section><section id="id267452"><title>Header &lt;<ulink url="../../boost/variant/recursive_variant.hpp">boost/variant/recursive_variant.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>unspecified</emphasis> recursive_variant_;

&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2 = <emphasis>unspecified</emphasis>, ..., 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> TN = <emphasis>unspecified</emphasis>&gt; 
  &#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="make_recursive_variant">make_recursive_variant</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Sequence&gt; <emphasis role="bold">class</emphasis> <link linkend="id276892">make_recursive_variant_over</link>;
}</synopsis><refentry id="make_recursive_variant"><refmeta><refentrytitle>Class template make_recursive_variant</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::make_recursive_variant</refname><refpurpose>Simplifies declaration of recursive <computeroutput>variant</computeroutput> types.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2 = <emphasis>unspecified</emphasis>, ..., 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<emphasis role="bold">typename</emphasis> TN = <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">class</emphasis> make_recursive_variant {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <link linkend="boost.variant">boost::variant</link>&lt; <emphasis>unspecified</emphasis> &gt; type;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para><computeroutput>type</computeroutput> has behavior equivalent in every respect to
          some <computeroutput>variant&lt; U1, U2, ..., UN &gt;</computeroutput>, where each type
          <computeroutput>U<emphasis>i</emphasis></computeroutput> is the result of the
          corresponding type <computeroutput>T<emphasis>i</emphasis></computeroutput> undergone a
          transformation function. The following pseudo-code specifies the
          behavior of this transformation (call it <computeroutput>substitute</computeroutput>):

          <itemizedlist><listitem>If <computeroutput>T<emphasis>i</emphasis></computeroutput> is
              <computeroutput>boost::recursive_variant_</computeroutput> then:
              <computeroutput>variant&lt; U1, U2, ..., UN &gt;</computeroutput>;</listitem><listitem>Else if <computeroutput>T<emphasis>i</emphasis></computeroutput> is of the
              form <computeroutput>X *</computeroutput> then:
              <computeroutput>substitute(X) *</computeroutput>;</listitem><listitem>Else if <computeroutput>T<emphasis>i</emphasis></computeroutput> is of the
              form <computeroutput>X &amp;</computeroutput> then:
              <computeroutput>substitute(X) &amp;</computeroutput>;</listitem><listitem>Else if <computeroutput>T<emphasis>i</emphasis></computeroutput> is of the
              form <computeroutput>R (*)( X1, X2, ..., XN )</computeroutput> then:
              <computeroutput>substitute(R) (*)( substitute(X1), substitute(X2), ..., substitute(XN) )</computeroutput>;</listitem><listitem>Else if <computeroutput>T<emphasis>i</emphasis></computeroutput> is of the
              form <computeroutput>F &lt; X1, X2, ..., XN &gt;</computeroutput> then:
              <computeroutput>F&lt; substitute(X1), substitute(X2), ..., substitute(XN) &gt;</computeroutput>;</listitem><listitem>Else: <computeroutput>T<emphasis>i</emphasis></computeroutput>.</listitem></itemizedlist></para><para>Note that cv-qualifiers are preserved and that the actual
          process is generally a bit more complicated. However, the above does
          convey the essential idea as well as describe the extent of the
          substititions.</para><para>Use of <computeroutput>make_recursive_variant</computeroutput> is demonstrated in
          <xref linkend="variant.tutorial.recursive.recursive-variant"/>.</para><para><emphasis role="bold">Portability</emphasis>: Due to standard
          conformance issues in several compilers,
          <computeroutput>make_recursive_variant</computeroutput> is not universally supported. On
          these compilers the library indicates its lack of support via the
          definition of the preprocessor symbol
          <computeroutput><link linkend="id413934">BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT</link></computeroutput>.</para></refsect1></refentry><refentry id="id276892"><refmeta><refentrytitle>Class template make_recursive_variant_over</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::make_recursive_variant_over</refname><refpurpose><simpara>Exposes a recursive <computeroutput>variant</computeroutput> whose bounded types
          are the elements of the given type sequence.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Sequence&gt; 
<emphasis role="bold">class</emphasis> make_recursive_variant_over {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> variant&lt; <emphasis>unspecified</emphasis> &gt; type;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara><computeroutput>type</computeroutput> has behavior equivalent in every respect to
          <computeroutput><link linkend="make_recursive_variant">make_recursive_variant</link>&lt; Sequence[0], Sequence[1], ... &gt;::type</computeroutput>
          (where <computeroutput>Sequence[<emphasis>i</emphasis>]</computeroutput> denotes the
          <emphasis>i</emphasis>-th element of <computeroutput>Sequence</computeroutput>), except
          that no upper limit is imposed on the number of types.</simpara><simpara><emphasis role="bold">Notes</emphasis>:</simpara><itemizedlist><listitem><computeroutput>Sequence</computeroutput> must meet the requirements of
            <ulink url="../../libs/mpl/index.html">MPL</ulink>'s <emphasis>Sequence</emphasis>
            concept.</listitem><listitem>Due to standard conformance problems in several compilers,
            <computeroutput>make_recursive_variant_over</computeroutput> may not be supported on
            your compiler. See
            <computeroutput><link linkend="id544182">BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT</link></computeroutput>
            for more information.</listitem></itemizedlist></refsect1></refentry></section><section id="id352292"><title>Header &lt;<ulink url="../../boost/variant/recursive_wrapper.hpp">boost/variant/recursive_wrapper.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <emphasis role="bold">class</emphasis> <link linkend="recursive_wrapper">recursive_wrapper</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <emphasis role="bold">class</emphasis> <link linkend="is_recursive_wrapper">is_recursive_wrapper</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; <emphasis role="bold">class</emphasis> <link linkend="unwrap_recursive_wrapper">unwrap_recursive_wrapper</link>;
}</synopsis><refentry id="recursive_wrapper"><refmeta><refentrytitle>Class template recursive_wrapper</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::recursive_wrapper</refname><refpurpose>Solves circular dependencies, enabling recursive types.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; 
<emphasis role="bold">class</emphasis> recursive_wrapper {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> T type;

&#xA0;&#xA0;<emphasis>// <link linkend="recursive_wrapperconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<link linkend="id419143-bb">recursive_wrapper</link>();
&#xA0;&#xA0;<link linkend="id455143-bb">recursive_wrapper</link>(<emphasis role="bold">const</emphasis> recursive_wrapper &amp;);
&#xA0;&#xA0;<link linkend="id521823-bb">recursive_wrapper</link>(<emphasis role="bold">const</emphasis> T &amp;);
&#xA0;&#xA0;<link linkend="id267948-bb">~recursive_wrapper</link>();

&#xA0;&#xA0;<emphasis>// <link linkend="id440910-bb">modifiers</link></emphasis>
&#xA0;&#xA0;<type><emphasis role="bold">void</emphasis></type> <link linkend="id337749-bb">swap</link>(recursive_wrapper &amp;);
&#xA0;&#xA0;<type>recursive_wrapper &amp;</type> <link linkend="id523522-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> recursive_wrapper &amp;);
&#xA0;&#xA0;<type>recursive_wrapper &amp;</type> <link linkend="id325835-bb"><emphasis role="bold">operator</emphasis>=</link>(<emphasis role="bold">const</emphasis> T &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id432813-bb">queries</link></emphasis>
&#xA0;&#xA0;<type>T &amp;</type> <link linkend="id232939-bb">get</link>();
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> T &amp;</type> <link linkend="id288118-bb">get</link>() <emphasis role="bold">const</emphasis>;
&#xA0;&#xA0;<type>T *</type> <link linkend="id280820-bb">get_pointer</link>();
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> T *</type> <link linkend="id339517-bb">get_pointer</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara>The <computeroutput>recursive_wrapper</computeroutput> class template has an
          interface similar to a simple value container, but its content is
          allocated dynamically. This allows <computeroutput>recursive_wrapper</computeroutput> to
          hold types <computeroutput>T</computeroutput> whose member data leads to a circular
          dependency (e.g., a data member of <computeroutput>T</computeroutput> has a data member
          of type <computeroutput>T</computeroutput>).</simpara><simpara>The application of <computeroutput>recursive_wrapper</computeroutput> is easiest
          understood in context. See
          <xref linkend="variant.tutorial.recursive.recursive-wrapper"/> for a
          demonstration of a common use of the class template.</simpara><simpara><emphasis role="bold">Notes</emphasis>:</simpara><itemizedlist><listitem>Any type specified as the template argument to
            <computeroutput>recursive_wrapper</computeroutput> must be capable of construction via
            <computeroutput>operator new</computeroutput>. Thus, for instance, references are not
            supported.</listitem></itemizedlist><refsect2><title><anchor id="recursive_wrapperconstruct-copy-destruct"/><computeroutput>recursive_wrapper</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><anchor id="id419143-bb"/>recursive_wrapper();</literallayout></para><simpara>Initializes <computeroutput>*this</computeroutput> by default construction of
            <computeroutput>T</computeroutput>.</simpara><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara><computeroutput>T</computeroutput> must fulfill the requirements of the
            <emphasis>DefaultConstructible</emphasis> [20.1.4]
            concept.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>May fail with any exceptions arising from the default
            constructor of <computeroutput>T</computeroutput> or, in the event of
            insufficient memory, with <computeroutput>std::bad_alloc</computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id455143-bb"/>recursive_wrapper(<emphasis role="bold">const</emphasis> recursive_wrapper &amp; other);</literallayout></para><simpara>Copies the content of <computeroutput>other</computeroutput> into
            <computeroutput>*this</computeroutput>.</simpara><variablelist spacing="boost"><varlistentry><term>Throws</term><listitem><simpara>May fail with any exceptions arising from the
            copy constructor of <computeroutput>T</computeroutput> or, in the event of
            insufficient memory, with <computeroutput>std::bad_alloc</computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id521823-bb"/>recursive_wrapper(<emphasis role="bold">const</emphasis> T &amp; operand);</literallayout></para><simpara>Copies <computeroutput>operand</computeroutput> into
            <computeroutput>*this</computeroutput>.</simpara><variablelist spacing="boost"><varlistentry><term>Throws</term><listitem><simpara>May fail with any exceptions arising from the
            copy constructor of <computeroutput>T</computeroutput> or, in the event of
            insufficient memory, with <computeroutput>std::bad_alloc</computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><anchor id="id267948-bb"/>~recursive_wrapper();</literallayout></para><simpara>Deletes the content of <computeroutput>*this</computeroutput>.</simpara><variablelist spacing="boost"><varlistentry><term>Throws</term><listitem>Will not throw.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id440910-bb"/><computeroutput>recursive_wrapper</computeroutput> modifiers</title><orderedlist><listitem><para><literallayout class="monospaced"><type><emphasis role="bold">void</emphasis></type> <anchor id="id337749-bb"/>swap(recursive_wrapper &amp; other);</literallayout></para><simpara>Exchanges contents of <computeroutput>*this</computeroutput> and
              <computeroutput>other</computeroutput>.</simpara><variablelist spacing="boost"><varlistentry><term>Throws</term><listitem>Will not throw.</listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>recursive_wrapper &amp;</type> <anchor id="id523522-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> recursive_wrapper &amp; rhs);</literallayout></para><simpara>Assigns the content of <computeroutput>rhs</computeroutput> to the content of
              <computeroutput>*this</computeroutput>.</simpara><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara><computeroutput>T</computeroutput> must fulfill the requirements of
            the <link linkend="Assignable">Assignable</link>
            concept.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>May fail with any exceptions arising from the assignment
              operator of <computeroutput>T</computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem><listitem><para><literallayout class="monospaced"><type>recursive_wrapper &amp;</type> <anchor id="id325835-bb"/><emphasis role="bold">operator</emphasis>=(<emphasis role="bold">const</emphasis> T &amp; rhs);</literallayout></para><simpara>Assigns <computeroutput>rhs</computeroutput> into the content of
              <computeroutput>*this</computeroutput>.</simpara><variablelist spacing="boost"><varlistentry><term>Requires</term><listitem><simpara><computeroutput>T</computeroutput> must fulfill the requirements of the
              <link linkend="Assignable">Assignable</link>
              concept.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>May fail with any exceptions arising from the assignment
              operator of <computeroutput>T</computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id432813-bb"/><computeroutput>recursive_wrapper</computeroutput> queries</title><orderedlist><listitem><para id="id457164-bb"><literallayout class="monospaced"><type>T &amp;</type> <anchor id="id232939-bb"/>get();
<type><emphasis role="bold">const</emphasis> T &amp;</type> <anchor id="id288118-bb"/>get() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns a reference to the content of
              <computeroutput>*this</computeroutput>.</simpara><variablelist spacing="boost"><varlistentry><term>Throws</term><listitem>Will not throw.</listitem></varlistentry></variablelist></listitem><listitem><para id="id508770-bb"><literallayout class="monospaced"><type>T *</type> <anchor id="id280820-bb"/>get_pointer();
<type><emphasis role="bold">const</emphasis> T *</type> <anchor id="id339517-bb"/>get_pointer() <emphasis role="bold">const</emphasis>;</literallayout></para><simpara>Returns a pointer to the content of
              <computeroutput>*this</computeroutput>.</simpara><variablelist spacing="boost"><varlistentry><term>Throws</term><listitem>Will not throw.</listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="is_recursive_wrapper"><refmeta><refentrytitle>Class template is_recursive_wrapper</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::is_recursive_wrapper</refname><refpurpose><simpara>Determines whether the specified type is a specialization of
          <computeroutput>recursive_wrapper</computeroutput>.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; 
<emphasis role="bold">class</emphasis> is_recursive_wrapper {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>unspecified</emphasis> type;

&#xA0;&#xA0;<emphasis>// static constants</emphasis>
&#xA0;&#xA0;<emphasis role="bold">static</emphasis> <emphasis role="bold">const</emphasis> <emphasis role="bold">bool</emphasis> value = unspecified;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara>Value is true iff <computeroutput>T</computeroutput> is a specialization of
          <computeroutput><link linkend="recursive_wrapper">recursive_wrapper</link></computeroutput>.</simpara><simpara><emphasis role="bold">Note</emphasis>:
          <computeroutput>is_recursive_wrapper</computeroutput> is a model of
          <ulink url="../../libs/mpl/index.html">MPL</ulink>'s
          <emphasis>IntegralConstant</emphasis> concept.</simpara></refsect1></refentry><refentry id="unwrap_recursive_wrapper"><refmeta><refentrytitle>Class template unwrap_recursive_wrapper</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::unwrap_recursive_wrapper</refname><refpurpose><simpara>Unwraps the specified argument if given a specialization of
          <computeroutput><link linkend="recursive_wrapper">recursive_wrapper</link></computeroutput>.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T&gt; 
<emphasis role="bold">class</emphasis> unwrap_recursive_wrapper {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis>unspecified</emphasis> type;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara><computeroutput>type</computeroutput> is equivalent to <computeroutput>T::type</computeroutput> if
          <computeroutput>T</computeroutput> is a specialization of
          <computeroutput><link linkend="recursive_wrapper">recursive_wrapper</link></computeroutput>. Otherwise,
          <computeroutput>type</computeroutput> is equivalent to <computeroutput>T</computeroutput>.</simpara></refsect1></refentry></section><section id="id388564"><title>Header &lt;<ulink url="../../boost/variant/apply_visitor.hpp">boost/variant/apply_visitor.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Visitor&gt; <emphasis role="bold">class</emphasis> <link linkend="apply_visitor_delayed_t">apply_visitor_delayed_t</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Visitor, <emphasis role="bold">typename</emphasis> Variant&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">typename</emphasis> Visitor::result_type</type> <link linkend="apply_visitor">apply_visitor</link>(Visitor &amp;, Variant &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Visitor, <emphasis role="bold">typename</emphasis> Variant&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">typename</emphasis> Visitor::result_type</type> <link linkend="apply_visitor">apply_visitor</link>(<emphasis role="bold">const</emphasis> Visitor &amp;, Variant &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> BinaryVisitor, <emphasis role="bold">typename</emphasis> Variant1, <emphasis role="bold">typename</emphasis> Variant2&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">typename</emphasis> BinaryVisitor::result_type</type> 
&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="apply_visitor">apply_visitor</link>(BinaryVisitor &amp;, Variant1 &amp;, Variant2 &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> BinaryVisitor, <emphasis role="bold">typename</emphasis> Variant1, <emphasis role="bold">typename</emphasis> Variant2&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">typename</emphasis> BinaryVisitor::result_type</type> 
&#xA0;&#xA0;&#xA0;&#xA0;<link linkend="apply_visitor">apply_visitor</link>(<emphasis role="bold">const</emphasis> BinaryVisitor &amp;, Variant1 &amp;, Variant2 &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Visitor&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><link linkend="apply_visitor_delayed_t">apply_visitor_delayed_t</link>&lt;Visitor&gt;</type> <link linkend="apply_visitor">apply_visitor</link>(Visitor &amp;);
}</synopsis><refentry id="apply_visitor_delayed_t"><refmeta><refentrytitle>Class template apply_visitor_delayed_t</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::apply_visitor_delayed_t</refname><refpurpose>Adapts a visitor for use as a function object.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Visitor&gt; 
<emphasis role="bold">class</emphasis> apply_visitor_delayed_t {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> <emphasis role="bold">typename</emphasis> Visitor::result_type result_type;

&#xA0;&#xA0;<emphasis>// <link linkend="apply_visitor_delayed_tconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">explicit</emphasis> <link linkend="id232670-bb">apply_visitor_delayed_t</link>(Visitor &amp;);

&#xA0;&#xA0;<emphasis>// <link linkend="id232252-bb">function object interface</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Variant&gt; <type>result_type</type> <link linkend="id238208-bb"><emphasis role="bold">operator</emphasis>()</link>(Variant &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Variant1, <emphasis role="bold">typename</emphasis> Variant2&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type>result_type</type> <link linkend="id552353-bb"><emphasis role="bold">operator</emphasis>()</link>(Variant1 &amp;, Variant2 &amp;);
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara>Adapts the function given at construction for use as a
          function object. This is useful, for example, when one needs to
          operate on each element of a sequence of variant objects using a
          standard library algorithm such as
          <computeroutput>std::for_each</computeroutput>.</simpara><simpara>See the "visitor-only" form of
          <computeroutput><link linkend="apply_visitor">apply_visitor</link></computeroutput> for a simple
          way to create <computeroutput>apply_visitor_delayed_t</computeroutput> objects.</simpara><refsect2><title><anchor id="apply_visitor_delayed_tconstruct-copy-destruct"/><computeroutput>apply_visitor_delayed_t</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">explicit</emphasis> <anchor id="id232670-bb"/>apply_visitor_delayed_t(Visitor &amp; visitor);</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Constructs the function object with the given
            visitor.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id232252-bb"/><computeroutput>apply_visitor_delayed_t</computeroutput> function object interface</title><orderedlist><listitem><para id="id524917-bb"><literallayout class="monospaced"><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Variant&gt; <type>result_type</type> <anchor id="id238208-bb"/><emphasis role="bold">operator</emphasis>()(Variant &amp; operand);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Variant1, <emphasis role="bold">typename</emphasis> Variant2&gt; 
&#xA0;&#xA0;<type>result_type</type> <anchor id="id552353-bb"/><emphasis role="bold">operator</emphasis>()(Variant1 &amp; operand1, Variant2 &amp; operand2);</literallayout></para><simpara>Invokes
            <computeroutput><link linkend="apply_visitor">apply_visitor</link></computeroutput> on the
            stored visitor using the given operands.</simpara></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="apply_visitor"><refmeta><refentrytitle>Function apply_visitor</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::apply_visitor</refname><refpurpose><simpara>Allows compile-time checked type-safe application of the
        given visitor to the content of the given variant, ensuring that all
        types are handled by the visitor.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Visitor, <emphasis role="bold">typename</emphasis> Variant&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">typename</emphasis> Visitor::result_type</type> 
&#xA0;&#xA0;apply_visitor(Visitor &amp; visitor, Variant &amp; operand);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Visitor, <emphasis role="bold">typename</emphasis> Variant&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">typename</emphasis> Visitor::result_type</type> 
&#xA0;&#xA0;apply_visitor(<emphasis role="bold">const</emphasis> Visitor &amp; visitor, Variant &amp; operand);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> BinaryVisitor, <emphasis role="bold">typename</emphasis> Variant1, <emphasis role="bold">typename</emphasis> Variant2&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">typename</emphasis> BinaryVisitor::result_type</type> 
&#xA0;&#xA0;apply_visitor(BinaryVisitor &amp; visitor, Variant1 &amp; operand1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Variant2 &amp; operand2);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> BinaryVisitor, <emphasis role="bold">typename</emphasis> Variant1, <emphasis role="bold">typename</emphasis> Variant2&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">typename</emphasis> BinaryVisitor::result_type</type> 
&#xA0;&#xA0;apply_visitor(<emphasis role="bold">const</emphasis> BinaryVisitor &amp; visitor, Variant1 &amp; operand1, 
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Variant2 &amp; operand2);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> Visitor&gt; 
&#xA0;&#xA0;<type><link linkend="apply_visitor_delayed_t">apply_visitor_delayed_t</link>&lt;Visitor&gt;</type> apply_visitor(Visitor &amp; visitor);</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara>The behavior of <computeroutput>apply_visitor</computeroutput> is dependent on
        the number of arguments on which it operates (i.e., other than the
        visitor). The function behaves as follows:

          <itemizedlist><listitem>Overloads accepting one operand invoke the unary function
              call operator of the given visitor on the content of the given
              <computeroutput><link linkend="boost.variant">variant</link></computeroutput> operand.</listitem><listitem>Overloads accepting two operands invoke the binary
              function call operator of the given visitor on the content of
              the given <computeroutput><link linkend="boost.variant">variant</link></computeroutput>
              operands.</listitem><listitem>The overload accepting only a visitor returns a
              <link linkend="apply_visitor_delayed_t">generic function object</link>
              that accepts either one or two arguments and invokes
              <computeroutput><link linkend="apply_visitor">apply_visitor</link></computeroutput> using
              these arguments and <computeroutput>visitor</computeroutput>, thus behaving as
              specified above. (This behavior is particularly useful, for
              example, when one needs to operate on each element of a sequence
              of variant objects using a standard library
              algorithm.)</listitem></itemizedlist></simpara><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>The overloads acccepting operands return the result of
        applying the given visitor to the content of the given operands.
        The overload accepting only a visitor return a function object, thus
        delaying application of the visitor to any operands.</simpara></listitem></varlistentry><varlistentry><term>Requires</term><listitem><simpara>The given visitor must fulfill the
        <link linkend="variant.concepts.static-visitor"><emphasis>StaticVisitor</emphasis></link>
        concept requirements with respect to each of the bounded types of the
        given <computeroutput>variant</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>The overloads accepting operands throw only if the given
        visitor throws when applied. The overload accepting only a visitor
        will not throw. (Note, however, that the returned
        <link linkend="apply_visitor_delayed_t">function object</link>
        may throw when invoked.)</simpara></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id446657"><title>Header &lt;<ulink url="../../boost/variant/get.hpp">boost/variant/get.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="bad_get">bad_get</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type>U *</type> <link linkend="get">get</link>(<link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; *);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> U *</type> <link linkend="get">get</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; *);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type>U &amp;</type> <link linkend="get">get</link>(<link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; &amp;);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN&gt; 
&#xA0;&#xA0;&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> U &amp;</type> <link linkend="get">get</link>(<emphasis role="bold">const</emphasis> <link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; &amp;);
}</synopsis><refentry id="bad_get"><refmeta><refentrytitle>Class bad_get</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::bad_get</refname><refpurpose><simpara>The exception thrown in	the	event	of a failed application of
        <computeroutput><link linkend="get">boost::get</link></computeroutput> on	the given
        operand value.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> bad_get : <emphasis role="bold">public</emphasis> std::exception {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis role="bold">virtual</emphasis> <type><emphasis role="bold">const</emphasis>	<emphasis role="bold">char</emphasis> *</type> <link linkend="id480368-bb">what</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para><literallayout class="monospaced"><emphasis role="bold">virtual</emphasis> <type><emphasis role="bold">const</emphasis>	<emphasis role="bold">char</emphasis> *</type> <anchor id="id480368-bb"/>what() <emphasis role="bold">const</emphasis>;</literallayout></para></refsect1></refentry><refentry id="get"><refmeta><refentrytitle>Function get</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::get</refname><refpurpose><simpara>Retrieves a value of a specified type from a given
          <computeroutput><link linkend="boost.variant">variant</link></computeroutput>.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN&gt; 
&#xA0;&#xA0;<type>U *</type> get(<link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; * operand);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> U *</type> get(<emphasis role="bold">const</emphasis> <link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; * operand);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN&gt; 
&#xA0;&#xA0;<type>U &amp;</type> get(<link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; &amp; operand);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U, <emphasis role="bold">typename</emphasis> T1, <emphasis role="bold">typename</emphasis> T2, ..., <emphasis role="bold">typename</emphasis> TN&gt; 
&#xA0;&#xA0;<type><emphasis role="bold">const</emphasis> U &amp;</type> get(<emphasis role="bold">const</emphasis> <link linkend="boost.variant">variant</link>&lt;T1, T2, ..., TN&gt; &amp; operand);</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara>The <computeroutput>get</computeroutput> function allows run-time checked,
          type-safe retrieval of the content of the given
          <computeroutput><link linkend="boost.variant">variant</link></computeroutput>. The function succeeds
          only if the content is of the specified type <computeroutput>U</computeroutput>, with
          failure indicated as described below.</simpara><simpara><emphasis role="bold">Warning</emphasis>: After either
          <computeroutput>operand</computeroutput> or its content is destroyed (e.g., when the
          given <computeroutput><link linkend="boost.variant">variant</link></computeroutput> is assigned a
          value of different type), the returned reference is invalidated.
          Thus, significant care and caution must be extended when handling
          the returned reference.</simpara><variablelist spacing="boost"><varlistentry><term>Notes</term><listitem><simpara>As part of its guarantee of type-safety, <computeroutput>get</computeroutput>
        enforces <computeroutput>const</computeroutput>-correctness. Thus, the specified type
        <computeroutput>U</computeroutput> must be <computeroutput>const</computeroutput>-qualified whenever
        <computeroutput>operand</computeroutput> or its content is likewise
        <computeroutput>const</computeroutput>-qualified. The converse, however, is not required:
        that is, the specified type <computeroutput>U</computeroutput> may be
        <computeroutput>const</computeroutput>-qualified even when <computeroutput>operand</computeroutput> and its
        content are not.</simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem><simpara>If passed a pointer, <computeroutput>get</computeroutput> returns a pointer to
        the value content if it is of the specified type <computeroutput>U</computeroutput>;
        otherwise, a null pointer is returned. If passed a reference,
        <computeroutput>get</computeroutput> returns a reference to the value content if it is of
        the specified type <computeroutput>U</computeroutput>; otherwise, an exception is thrown
        (see below).</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Overloads taking a
        <computeroutput><link linkend="boost.variant">variant</link></computeroutput> pointer will not
        throw; the overloads taking a
        <computeroutput><link linkend="boost.variant">variant</link></computeroutput> reference throw
        <computeroutput><link linkend="bad_get">bad_get</link></computeroutput> if the content is not of
        the specified type <computeroutput>U</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Rationale</term><listitem><simpara>While visitation via
        <computeroutput><link linkend="apply_visitor">apply_visitor</link></computeroutput>
        is generally prefered due to its greater safety, <computeroutput>get</computeroutput> may
        may be more convenient in some cases due to its straightforward
        usage.</simpara></listitem></varlistentry></variablelist></refsect1></refentry></section><section id="id503352"><title>Header &lt;<ulink url="../../boost/variant/bad_visit.hpp">boost/variant/bad_visit.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">class</emphasis> <link linkend="bad_visit">bad_visit</link>;
}</synopsis><refentry id="bad_visit"><refmeta><refentrytitle>Class bad_visit</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::bad_visit</refname><refpurpose><simpara>The exception thrown in the event of a visitor
          unable to handle the visited value.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">class</emphasis> bad_visit : <emphasis role="bold">public</emphasis> std::exception {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis role="bold">virtual</emphasis> <type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <link linkend="id356415-bb">what</link>() <emphasis role="bold">const</emphasis>;
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><para><literallayout class="monospaced"><emphasis role="bold">virtual</emphasis> <type><emphasis role="bold">const</emphasis> <emphasis role="bold">char</emphasis> *</type> <anchor id="id356415-bb"/>what() <emphasis role="bold">const</emphasis>;</literallayout></para></refsect1></refentry></section><section id="id382199"><title>Header &lt;<ulink url="../../boost/variant/static_visitor.hpp">boost/variant/static_visitor.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ResultType&gt; <emphasis role="bold">class</emphasis> <link linkend="static_visitor">static_visitor</link>;
}</synopsis><refentry id="static_visitor"><refmeta><refentrytitle>Class template static_visitor</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::static_visitor</refname><refpurpose>Convenient base type for static visitors.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> ResultType&gt; 
<emphasis role="bold">class</emphasis> static_visitor {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// types</emphasis>
&#xA0;&#xA0;<emphasis role="bold">typedef</emphasis> ResultType result_type;  <emphasis>// Exposes result_type member as required by StaticVisitor concept.</emphasis>
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara>Denotes the intent of the deriving class as meeting the
          requirements of a static visitor of some type. Also exposes the
          inner type <computeroutput>result_type</computeroutput> as required by the
          <link linkend="variant.concepts.static-visitor"><emphasis>StaticVisitor</emphasis></link>
          concept.</simpara><simpara><emphasis role="bold">Notes</emphasis>:
          <computeroutput>static_visitor</computeroutput> is intended for use as a base type only
          and is therefore noninstantiable.</simpara></refsect1></refentry></section><section id="id500650"><title>Header &lt;<ulink url="../../boost/variant/visitor_ptr.hpp">boost/variant/visitor_ptr.hpp</ulink>&gt;</title><synopsis><emphasis role="bold">namespace</emphasis> boost {
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, <emphasis role="bold">typename</emphasis> R&gt; <emphasis role="bold">class</emphasis> <link linkend="visitor_ptr_t">visitor_ptr_t</link>;
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> R, <emphasis role="bold">typename</emphasis> T&gt; <type><link linkend="visitor_ptr_t">visitor_ptr_t</link>&lt;T,R&gt;</type> <link linkend="visitor_ptr">visitor_ptr</link>(R (*)(T));
}</synopsis><refentry id="visitor_ptr_t"><refmeta><refentrytitle>Class template visitor_ptr_t</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::visitor_ptr_t</refname><refpurpose>Adapts a function pointer for use as a static visitor.</refpurpose></refnamediv><refsynopsisdiv><synopsis><emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> T, <emphasis role="bold">typename</emphasis> R&gt; 
<emphasis role="bold">class</emphasis> visitor_ptr_t : <emphasis role="bold">public</emphasis> <link linkend="static_visitor">static_visitor</link>&lt;R&gt; {
<emphasis role="bold">public</emphasis>:
&#xA0;&#xA0;<emphasis>// <link linkend="visitor_ptr_tconstruct-copy-destruct">construct/copy/destruct</link></emphasis>
&#xA0;&#xA0;<emphasis role="bold">explicit</emphasis> <link linkend="id405420-bb">visitor_ptr_t</link>(R (*)(T));

&#xA0;&#xA0;<emphasis>// <link linkend="id481416-bb">static visitor interfaces</link></emphasis>
&#xA0;&#xA0;<type>R</type> <link linkend="id548238-bb"><emphasis role="bold">operator</emphasis>()</link>(<emphasis>unspecified-forwarding-type</emphasis>);
&#xA0;&#xA0;<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U&gt; <type><emphasis role="bold">void</emphasis></type> <link linkend="id416481-bb"><emphasis role="bold">operator</emphasis>()</link>(<emphasis role="bold">const</emphasis> U&amp;);
};</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara>Adapts the function given at construction for use as a
        <link linkend="variant.concepts.static-visitor">static visitor</link>
        of type <computeroutput>T</computeroutput> with result type <computeroutput>R</computeroutput>.</simpara><refsect2><title><anchor id="visitor_ptr_tconstruct-copy-destruct"/><computeroutput>visitor_ptr_t</computeroutput> construct/copy/destruct</title><orderedlist><listitem><para><literallayout class="monospaced"><emphasis role="bold">explicit</emphasis> <anchor id="id405420-bb"/>visitor_ptr_t(R (*)(T) );</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>Constructs the visitor with the given function.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2><refsect2><title><anchor id="id481416-bb"/><computeroutput>visitor_ptr_t</computeroutput> static visitor interfaces</title><orderedlist><listitem><para id="id532183-bb"><literallayout class="monospaced"><type>R</type> <anchor id="id548238-bb"/><emphasis role="bold">operator</emphasis>()(<emphasis>unspecified-forwarding-type</emphasis> operand);
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> U&gt; <type><emphasis role="bold">void</emphasis></type> <anchor id="id416481-bb"/><emphasis role="bold">operator</emphasis>()(<emphasis role="bold">const</emphasis> U&amp; );</literallayout></para><variablelist spacing="boost"><varlistentry><term>Effects</term><listitem><simpara>If passed a value or reference of type
              <computeroutput>T</computeroutput>, it invokes the function given at
              construction, appropriately forwarding
              <computeroutput>operand</computeroutput>.</simpara></listitem></varlistentry><varlistentry><term>Returns</term><listitem>Returns the result of the function invocation.</listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>The overload taking a value or reference of type
              <computeroutput>T</computeroutput> throws if the invoked function throws.
              The overload taking all other values <emphasis>always</emphasis>
              throws <computeroutput><link linkend="bad_visit">bad_visit</link></computeroutput>.</simpara></listitem></varlistentry></variablelist></listitem></orderedlist></refsect2></refsect1></refentry><refentry id="visitor_ptr"><refmeta><refentrytitle>Function template visitor_ptr</refentrytitle><manvolnum>3</manvolnum></refmeta><refnamediv><refname>boost::visitor_ptr</refname><refpurpose><simpara>Returns a visitor object that adapts function pointers for
        use as a static visitor.</simpara></refpurpose></refnamediv><refsynopsisdiv><synopsis>
<emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename</emphasis> R, <emphasis role="bold">typename</emphasis> T&gt; <type><link linkend="visitor_ptr_t">visitor_ptr_t</link>&lt;T,R&gt;</type> visitor_ptr(R (*)(T) );</synopsis></refsynopsisdiv><refsect1><title>Description</title><simpara>Constructs and returns a
        <computeroutput><link linkend="visitor_ptr_t">visitor_ptr_t</link></computeroutput> adaptor over the
        given function.</simpara><variablelist spacing="boost"><varlistentry><term>Returns</term><listitem><simpara>Returns a <computeroutput><link linkend="visitor_ptr_t">visitor_ptr_t</link></computeroutput>
          visitor object that, when applied, invokes the given
          function.</simpara></listitem></varlistentry><varlistentry><term>Throws</term><listitem><simpara>Will not throw. (Note, however, that the returned
        <link linkend="visitor_ptr_t">visitor object</link> may
        throw when applied.)</simpara></listitem></varlistentry></variablelist></refsect1></refentry></section></section><section id="variant.design" xml:base="../libs/variant/doc/design.xml"><title>Design Overview</title><section id="variant.design.never-empty"><title>"Never-Empty" Guarantee</title><section id="variant.design.never-empty.guarantee"><title>The Guarantee</title><para>All instances <computeroutput>v</computeroutput> of type
        <computeroutput><link linkend="boost.variant">variant</link>&lt;T1,T2,...,TN&gt;</computeroutput>
        guarantee that <computeroutput>v</computeroutput> has constructed content of one of the
        types <computeroutput>T<emphasis>i</emphasis></computeroutput>, even if an operation on
        <computeroutput>v</computeroutput> has previously failed.</para><para>This implies that <computeroutput>variant</computeroutput> may be viewed precisely as
        a union of <emphasis>exactly</emphasis> its bounded types. This
        "never-empty" property insulates the user from the
        possibility of undefined <computeroutput>variant</computeroutput> content and the
        significant additional complexity-of-use attendant with such a
        possibility.</para></section><section id="variant.design.never-empty.problem"><title>The Implementation Problem</title><para>While the
        <link linkend="variant.design.never-empty.guarantee">never-empty guarantee</link>
        might at first seem "obvious," it is in fact not even
        straightforward how to implement it in general (i.e., without
        unreasonably restrictive additional requirements on
        <link linkref="variant.concepts.bounded-type">bounded types</link>).</para><para>The central difficulty emerges in the details of
        <computeroutput>variant</computeroutput> assignment. Given two instances <computeroutput>v1</computeroutput>
        and <computeroutput>v2</computeroutput> of some concrete <computeroutput>variant</computeroutput> type, there
        are two distinct, fundamental cases we must consider for the assignment
        <computeroutput>v1 = v2</computeroutput>.</para><para>First consider the case that <computeroutput>v1</computeroutput> and <computeroutput>v2</computeroutput>
        each contains a value of the same type. Call this type <computeroutput>T</computeroutput>.
        In this situation, assignment is perfectly straightforward: use
        <computeroutput>T::operator=</computeroutput>.</para><para>However, we must also consider the case that <computeroutput>v1</computeroutput> and
        <computeroutput>v2</computeroutput> contain values <emphasis>of distinct types</emphasis>.
        Call these types <computeroutput>T</computeroutput> and <computeroutput>U</computeroutput>. At this point,
        since <computeroutput>variant</computeroutput> manages its content on the stack, the
        left-hand side of the assignment (i.e., <computeroutput>v1</computeroutput>) must destroy
        its content so as to permit in-place copy-construction of the content
        of the right-hand side (i.e., <computeroutput>v2</computeroutput>). In the end, whereas
        <computeroutput>v1</computeroutput> began with content of type <computeroutput>T</computeroutput>, it ends
        with content of type <computeroutput>U</computeroutput>, namely a copy of the content of
        <computeroutput>v2</computeroutput>.</para><para>The crux of the problem, then, is this: in the event that
        copy-construction of the content of <computeroutput>v2</computeroutput> fails, how can
        <computeroutput>v1</computeroutput> maintain its "never-empty" guarantee?
        By the time copy-construction from <computeroutput>v2</computeroutput> is attempted,
        <computeroutput>v1</computeroutput> has already destroyed its content!</para></section><section id="variant.design.never-empty.memcpy-solution"><title>The "Ideal" Solution: False Hopes</title><para>Upon learning of this dilemma, clever individuals may propose the
        following scheme hoping to solve the problem:

        <orderedlist><listitem>Provide some "backup" storage, appropriately
            aligned, capable of holding values of the contained type of the
            left-hand side.</listitem><listitem>Copy the memory (e.g., using <computeroutput>memcpy</computeroutput>) of the
            storage of the left-hand side to the backup storage.</listitem><listitem>Attempt a copy of the right-hand side content to the
            (now-replicated) left-hand side storage.</listitem><listitem>In the event of an exception from the copy, restore the
            backup (i.e., copy the memory from the backup storage back into
            the left-hand side storage).</listitem><listitem>Otherwise, in the event of success, now copy the memory
            of the left-hand side storage to another "temporary"
            aligned storage.</listitem><listitem>Now restore the backup (i.e., again copying the memory)
            to the left-hand side storage; with the "old" content
            now restored, invoke the destructor of the contained type on the
            storage of the left-hand side.</listitem><listitem>Finally, copy the memory of the temporary storage to the
            (now-empty) storage of the left-hand side.</listitem></orderedlist></para><para>While complicated, it appears such a scheme could provide the
        desired safety in a relatively efficient manner. In fact, several
        early iterations of the library implemented this very approach.</para><para>Unfortunately, as Dave Abraham's first noted, the scheme results
        in undefined behavior:

        <blockquote><para>"That's a lot of code to read through, but if it's
            doing what I think it's doing, it's undefined behavior.</para><para>"Is the trick to move the bits for an existing object
            into a buffer so we can tentatively construct a new object in
            that memory, and later move the old bits back temporarily to
            destroy the old object?</para><para>"The standard does not give license to do that: only one
            object may have a given address at a time. See 3.8, and
            particularly paragraph 4."</para></blockquote></para><para>Additionally, as close examination quickly reveals, the scheme has
        the potential to create irreconcilable race-conditions in concurrent
        environments.</para><para>Ultimately, even if the above scheme could be made to work on
        certain platforms with particular compilers, it is still necessary to
        find a portable solution.</para></section><section id="variant.design.never-empty.double-storage-solution"><title>An Initial Solution: Double Storage</title><para>Upon learning of the infeasibility of the above scheme, Anthony
        Williams proposed in
        <link linkend="variant.refs.wil02">[Wil02]</link> a scheme that served
        as the basis for a portable solution in some pre-release
        implementations of <computeroutput>variant</computeroutput>.</para><para>The essential idea to this scheme, which shall be referred to as
        the "double storage" scheme, is to provide enough space
        within a <computeroutput>variant</computeroutput> to hold two separate values of any of
        the bounded types.</para><para>With the secondary storage, a copy the right-hand side can be
        attempted without first destroying the content of the left-hand side;
        accordingly, the content of the left-hand side remains available in
        the event of an exception.</para><para>Thus, with this scheme, the <computeroutput>variant</computeroutput> implementation
        needs only to keep track of which storage contains the content -- and
        dispatch any visitation requests, queries, etc. accordingly.</para><para>The most obvious flaw to this approach is the space overhead
        incurred. Though some optimizations could be applied in special cases
        to eliminate the need for double storage -- for certain bounded types
        or in some cases entirely (see
        <xref linkend="variant.design.never-empty.optimizations"/> for more
        details) -- many users on the Boost mailing list strongly objected to
        the use of double storage. In particular, it was noted that the
        overhead of double storage would be at play at all times -- even if
        assignment to <computeroutput>variant</computeroutput> never occurred. For this reason
        and others, a new approach was developed.</para></section><section id="variant.design.never-empty.heap-backup-solution"><title>Current Approach: Temporary Heap Backup</title><para>Despite the many objections to the double storage solution, it was
        realized that no replacement would be without drawbacks. Thus, a
        compromise was desired.</para><para>To this end, Dave Abrahams suggested to include the following in
        the behavior specification for <computeroutput>variant</computeroutput> assignment:
        "<computeroutput>variant</computeroutput> assignment from one type to another may
        incur dynamic allocation." That is, while <computeroutput>variant</computeroutput> would
        continue to store its content <emphasis>in situ</emphasis> after
        construction and after assignment involving identical contained types,
        <computeroutput>variant</computeroutput> would store its content on the heap after
        assignment involving distinct contained types.</para><para>The algorithm for assignment would proceed as follows:

        <orderedlist><listitem>Copy-construct the content of the right-hand side to the
            heap; call the pointer to this data <computeroutput>p</computeroutput>.</listitem><listitem>Destroy the content of the left-hand side.</listitem><listitem>Copy <computeroutput>p</computeroutput> to the left-hand side
            storage.</listitem></orderedlist>

        Since all operations on pointers are nothrow, this scheme would allow
        <computeroutput>variant</computeroutput> to meet its never-empty guarantee.
      </para><para>The most obvious concern with this approach is that while it
        certainly eliminates the space overhead of double storage, it
        introduces the overhead of dynamic-allocation to <computeroutput>variant</computeroutput>
        assignment -- not just in terms of the initial allocation but also
        as a result of the continued storage of the content on the heap. While
        the former problem is unavoidable, the latter problem may be avoided
        with the following "temporary heap backup" technique:

        <orderedlist><listitem>Copy-construct the content of the
            <emphasis>left</emphasis>-hand side to the heap; call the pointer to
            this data <computeroutput>backup</computeroutput>.</listitem><listitem>Destroy the content of the left-hand side.</listitem><listitem>Copy-construct the content of the right-hand side in the
            (now-empty) storage of the left-hand side.</listitem><listitem>In the event of failure, copy <computeroutput>backup</computeroutput> to the
            left-hand side storage.</listitem><listitem>In the event of success, deallocate the data pointed to
            by <computeroutput>backup</computeroutput>.</listitem></orderedlist></para><para>With this technique: 1) only a single storage is used;
        2) allocation is on the heap in the long-term only if the assignment
        fails; and 3) after any <emphasis>successful</emphasis> assignment,
        storage within the <computeroutput>variant</computeroutput> is guaranteed. For the
        purposes of the initial release of the library, these characteristics
        were deemed a satisfactory compromise solution.</para><para>There remain notable shortcomings, however. In particular, there
        may be some users for which heap allocation must be avoided at all
        costs; for other users, any allocation may need to occur via a
        user-supplied allocator. These issues will be addressed in the future
        (see <xref linkend="variant.design.never-empty.roadmap"/>). For now,
        though, the library treats storage of its content as an implementation
        detail. Nonetheless, as described in the next section, there
        <emphasis>are</emphasis> certain things the user can do to ensure the
        greatest efficiency for <computeroutput>variant</computeroutput> instances (see
        <xref linkend="variant.design.never-empty.optimizations"/> for
        details).</para></section><section id="variant.design.never-empty.optimizations"><title>Enabling Optimizations</title><para>As described in
        <xref linkend="variant.design.never-empty.problem"/>, the central
        difficulty in implementing the never-empty guarantee is the
        possibility of failed copy-construction during <computeroutput>variant</computeroutput>
        assignment. Yet types with nothrow copy constructors clearly never
        face this possibility. Similarly, if one of the bounded types of the
        <computeroutput>variant</computeroutput> is nothrow default-constructible, then such a
        type could be used as a safe "fallback" type in the event of
        failed copy construction.</para><para>Accordingly, <computeroutput>variant</computeroutput> is designed to enable the
        following optimizations once the following criteria on its bounded
        types are met:

        <itemizedlist><listitem>For each bounded type <computeroutput>T</computeroutput> that is nothrow
            copy-constructible (as indicated by
            <computeroutput>boost::has_nothrow_copy</computeroutput>), the
            library guarantees <computeroutput>variant</computeroutput> will use only single
            storage and in-place construction for <computeroutput>T</computeroutput>.</listitem><listitem>If <emphasis>any</emphasis> bounded type is nothrow
            default-constructible (as indicated by
            <computeroutput>boost::has_nothrow_constructor</computeroutput>),
            the library guarantees <computeroutput>variant</computeroutput> will use only single
            storage and in-place construction for <emphasis>every</emphasis>
            bounded type in the <computeroutput>variant</computeroutput>. Note, however, that in
            the event of assignment failure, an unspecified nothrow
            default-constructible bounded type will be default-constructed in
            the left-hand side operand so as to preserve the never-empty
            guarantee.</listitem></itemizedlist></para><para><emphasis role="bold">Caveat</emphasis>: On most platforms, the
        <ulink url="../../libs/type_traits/index.html">Type Traits</ulink> templates
        <computeroutput>has_nothrow_copy</computeroutput> and <computeroutput>has_nothrow_constructor</computeroutput>
        by default return <computeroutput>false</computeroutput> for all <computeroutput>class</computeroutput> and
        <computeroutput>struct</computeroutput> types. It is necessary therefore to provide
        specializations of these templates as appropriate for user-defined
        types, as demonstrated in the following:

<programlisting>// ...in your code (at file scope)...

namespace boost {

  template &lt;&gt;
  struct has_nothrow_copy&lt; myUDT &gt;
    : mpl::true_
  {
  };

}
</programlisting></para><para><emphasis role="bold">Implementation Note</emphasis>: So as to make
        the behavior of <computeroutput>variant</computeroutput> more predictable in the aftermath
        of an exception, the current implementation prefers to default-construct
        <computeroutput>boost::blank</computeroutput> if specified as a
        bounded type instead of other nothrow default-constructible bounded
        types. (If this is deemed to be a useful feature, it will become part
        of the specification for <computeroutput>variant</computeroutput>; otherwise, it may be
        obsoleted. Please provide feedback to the Boost mailing list.)</para></section><section id="variant.design.never-empty.roadmap"><title>Future Direction: Policy-based Implementation</title><para>As the previous sections have demonstrated, much effort has been
        expended in an attempt to provide a balance between performance, data
        size, and heap usage. Further, significant optimizations may be
        enabled in <computeroutput>variant</computeroutput> on the basis of certain traits of its
        bounded types.</para><para>However, there will be some users for whom the chosen compromise
        is unsatisfactory (e.g.: heap allocation must be avoided at all costs;
        if heap allocation is used, custom allocators must be used; etc.). For
        this reason, a future version of the library will support a
        policy-based implementation of <computeroutput>variant</computeroutput>. While this will
        not eliminate the problems described in the previous sections, it will
        allow the decisions regarding tradeoffs to be decided by the user
        rather than the library designers.</para></section></section></section><section id="variant.misc" xml:base="../libs/variant/doc/misc.xml"><title>Miscellaneous Notes</title><section id="variant.versus-any"><title>Boost.Variant vs. Boost.Any</title><para>As a discriminated union container, the Variant library shares many
    of the same features of the <link linkend="any">Any</link> library.
    However, since neither library wholly encapsulates the features of the
    other, one library cannot be generally recommended for use over the
    other.</para><para>That said, Boost.Variant has several advantages over Boost.Any,
    such as:

    <itemizedlist><listitem>Boost.Variant guarantees the type of its content is one of a
        finite, user-specified set of types.</listitem><listitem>Boost.Variant provides <emphasis>compile-time</emphasis>
        checked visitation of its content. (By contrast, the current version
        of Boost.Any provides no visitation mechanism at all; but even if it
        did, it would need to be checked at run-time.)</listitem><listitem>Boost.Variant enables generic visitation of its content.
        (Even if Boost.Any did provide a visitation mechanism, it would enable
        visitation only of explicitly-specified types.)</listitem><listitem>Boost.Variant offers an efficient, stack-based storage scheme
        (avoiding the overhead of dynamic allocation).</listitem></itemizedlist></para><para>Of course, Boost.Any has several advantages over Boost.Variant,
    such as:

    <itemizedlist><listitem>Boost.Any, as its name implies, allows virtually any type for
        its content, providing great flexibility.</listitem><listitem>Boost.Any provides the no-throw guarantee of exception safety
        for its swap operation.</listitem><listitem>Boost.Any makes little use of template metaprogramming
        techniques (avoiding potentially hard-to-read error messages and
        significant compile-time processor and memory demands).</listitem></itemizedlist></para></section><section><title>Portability</title><para>The library aims for 100% ANSI/ISO C++ conformance. However, this is
    strictly impossible due to the inherently non-portable nature of the
    <ulink url="../../libs/type_traits/index.html">Type Traits</ulink> library's
    <computeroutput>type_with_alignment</computeroutput> facility. In
    practice though, no compilers or platforms have been discovered where this
    reliance on undefined behavior has been an issue.</para><para>Additionally, significant effort has been expended to ensure proper
    functioning despite various compiler bugs and other conformance problems.
    To date the library <link linkend="variant.tests">testsuite</link> has
    been compiled and tested successfully on at least the following compilers
    for basic and advanced functionality:

    <informaltable><tgroup cols="5"><thead><row><entry/><entry>Basic</entry><entry><computeroutput>variant&lt;T&amp;&gt;</computeroutput></entry><entry><link linkend="variant.tutorial.over-sequence"><computeroutput>make_variant_over</computeroutput></link></entry><entry><link linkend="variant.tutorial.recursive.recursive-variant"><computeroutput>make_recursive_variant</computeroutput></link></entry></row></thead><tbody><row><entry>Borland C++ 5.5.1 and 5.6.4</entry><entry>X</entry><entry>X</entry><entry/><entry/></row><row><entry>Comeau C++ 4.3.0</entry><entry>X</entry><entry>X</entry><entry>X</entry><entry>X</entry></row><row><entry>GNU GCC 3.3.1</entry><entry>X</entry><entry>X</entry><entry>X</entry><entry>X</entry></row><row><entry>GNU GCC 2.95.3</entry><entry>X</entry><entry>X</entry><entry/><entry>X</entry></row><row><entry>Intel C++ 7.0</entry><entry>X</entry><entry/><entry>X</entry><entry>X</entry></row><row><entry>Metrowerks CodeWarrior 8.3</entry><entry>X</entry><entry/><entry>X</entry><entry>X</entry></row><row><entry>Microsoft Visual C++ 7.1</entry><entry>X</entry><entry>X</entry><entry>X</entry><entry>X</entry></row><row><entry>Microsoft Visual C++ 6 SP5 and 7</entry><entry>X</entry><entry/><entry/><entry/></row></tbody></tgroup></informaltable></para><para>Finally, the current state of the testsuite in CVS may be found on the
    <ulink url="http://boost.sourceforge.net/regression-logs">Test Summary</ulink>
    page. Please note, however, that this page reports on day-to-day changes
    to inter-release code found in the Boost CVS and thus likely does not
    match the state of code found in Boost releases.</para></section><section id="variant.troubleshooting"><title>Troubleshooting</title><para>Due to the heavy use of templates in the implementation of
  <computeroutput>variant</computeroutput>, it is not uncommon when compiling to encounter
  problems related to template instantiaton depth, compiler memory, etc. This
  section attempts to provide advice to common problems experienced on several
  popular compilers.</para><para>(This section is still in progress, with additional advice/feedback
  welcome. Please post to the Boost-Users list with any useful experiences you
  may have.)</para><section id="variant.troubleshooting.template-depth"><title>"Template instantiation depth exceeds maximum"</title><section id="variant.troubleshooting.template-depth.gcc"><title>GNU GCC</title><para>The compiler option
        <computeroutput>-ftemplate-depth-<emphasis>NN</emphasis></computeroutput> can increase the
        maximum allowed instantiation depth. (Try
        <computeroutput>-ftemplate-depth-50</computeroutput>.)</para></section></section><section id="variant.troubleshooting.compiler-memory"><title>"Internal heap limit reached"</title><section id="variant.troubleshooting.compiler-memory.msvc"><title>Microsoft Visual C++</title><para>The compiler option <computeroutput>/Zm<emphasis>NNN</emphasis></computeroutput> can
        increase the memory allocation limit. The <computeroutput>NNN</computeroutput> is a
        scaling percentage (i.e., <computeroutput>100</computeroutput> denotes the default limit).
        (Try <computeroutput>/Zm200</computeroutput>.)</para></section></section></section><section id="variant.ack"><title>Acknowledgments</title><para>Eric Friedman and Itay Maman designed the initial submission; Eric was
  the primary implementer.</para><para>Eric is also the library maintainer and has expanded upon the initial
  submission -- adding
  <computeroutput><link linkend="make_recursive_variant">make_recursive_variant</link></computeroutput>,
  <computeroutput><link linkend="make_variant_over">make_variant_over</link></computeroutput>, support for
  reference content, etc.</para><para>Andrei Alexandrescu's work in
    [<link linkend="variant.refs.ale01a">Ale01a</link>]
and
    [<link linkend="variant.refs.ale02">Ale02</link>]
inspired the library's design.</para><para>Jeff Garland was the formal review manager.</para><para>Douglas Gregor,
Dave Abrahams,
Anthony Williams,
Fernando Cacciola,
Joel de Guzman,
Dirk Schreib,
Brad King,
Giovanni Bajo,
Eugene Gladyshev,
and others provided helpful feedback and suggestions to refine the semantics,
interface, and implementation of the library.</para></section></section><section id="variant.refs" xml:base="../libs/variant/doc/biblio.xml"><title>References</title><para id="variant.refs.abr00"><ulink url="http://boost.org/more/generic_exception_safety.html">[Abr00]</ulink>
    David Abrahams.
    "Exception-Safety in Generic Components."
    M. Jazayeri, R. Loos, D. Musser (eds.):
      Generic Programming '98, Proc. of a Dagstuhl Seminar, Lecture Notes on Computer Science, Vol. 1766, pp. 69-79.
    Springer-Verlag Berlin Heidelberg.
    2000.
</para><para id="variant.refs.abr01"><ulink url="http://boost.org/more/error_handling.html">[Abr01]</ulink>
    David Abrahams.
    "Error and Exception Handling."
    Boost technical article.
    2001-2003.
</para><para id="variant.refs.ale01a"><ulink url="http://www.oonumerics.org/tmpw01/alexandrescu.pdf">[Ale01a]</ulink>
    Andrei Alexandrescu.
    "An Implementation of Discriminated Unions in C++."
    <emphasis>OOPSLA 2001</emphasis>, Second Workshop on C++ Template Programming.
    Tampa Bay, 14 October 2001.
</para><para id="variant.refs.ale01b"><ulink url="http://www.moderncppdesign.com/book/main.html">[Ale01b]</ulink>
    Andrei Alexandrescu.
    <emphasis>Modern C++ Design</emphasis>.
    Addison-Wesley, C++ In-Depth series.
    2001.
</para><para id="variant.refs.ale02"><ulink url="http://cuj.com/experts/2008/alexandr.htm">[Ale02]</ulink>
    Andrei Alexandrescu.
    "Generic&lt;Programming&gt;: Discriminated Unions" series:
        <ulink url="http://cuj.com/experts/2004/alexandr.htm">Part 1</ulink>,
        <ulink url="http://cuj.com/experts/2006/alexandr.htm">Part 2</ulink>,
        <ulink url="http://cuj.com/experts/2008/alexandr.htm">Part 3</ulink>.
    <emphasis>C/C++ Users Journal</emphasis>.
    2002.
</para><para id="variant.refs.boo02"><ulink url="http://lists.boost.org/MailArchives/boost/msg30415.php">[Boo02]</ulink>
    Various Boost members.
    "Proposal --- A type-safe union."
    Boost public discussion.
    2002.
</para><para id="variant.refs.c++98">
  [C++98]
  <emphasis>International Standard, Programming Languages &#x2013; C++</emphasis>.
  ISO/IEC:14882.
  1998.
</para><para id="variant.refs.gof95">
    [GoF95]
    Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides.
    <emphasis>Design Patterns: Elements of Reusable Object-Oriented Software</emphasis>.
    Addison-Wesley.
    1995.
</para><para id="variant.refs.gre02"><ulink url="http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?variant">[Gre02]</ulink>
    Douglas Gregor.
    "BOOST_USER: variant."
    Boost Wiki paper.
    2002.
</para><para id="variant.refs.gur02"><ulink url="../../libs/mpl/index.html">[Gur02]</ulink>
    Aleksey Gurtovoy.
    <emphasis>Boost Metaprogramming Library.</emphasis>
    2002.
</para><para id="variant.refs.hen01"><link linkend="any">[Hen01]</link>
    Kevlin Henney.
    <emphasis>Boost Any Library.</emphasis>
    2001.
</para><para id="variant.refs.mk02"><ulink url="../../libs/preprocessor/index.html">[MK02]</ulink>
    Paul Mensonides and Vesa Karvonen.
    <emphasis>Boost Preprocessor Library.</emphasis>
    2002.
</para><para id="variant.refs.mcd+01"><ulink url="../../libs/type_traits/index.html">[MCD+01]</ulink>
    Steve Cleary, Beman Dawes, Aleksey Gurtovoy, Howard Hinnant, Jesse Jones, Mat Marcus, John Maddock, Jeremy Siek.
    <emphasis>Boost Type Traits Library</emphasis>.
    2001.
</para><para id="variant.refs.sut00"><ulink url="http://www.gotw.ca/publications/xc++.htm">[Sut00]</ulink>
    Herb Sutter.
    <emphasis>Exceptional C++: 47 Engineering Puzzles, Programming Problems, and Solutions</emphasis>.
    Addison-Wesley, C++ In-Depth series.
    2000.
</para><para id="variant.refs.wil02"><ulink url="http://aspn.activestate.com/ASPN/Mail/Message/boost/1314807">[Wil02]</ulink>
    Anthony Williams.
    Double-Storage Proposal.
    2002.
</para></section></chapter></part><part xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="boostbook" rev:last-revision="$Date: 2004/11/02 06:31:59 $" xml:base="../tools/boostbook/doc/boostbook.xml"><partinfo><author><firstname>Douglas</firstname><surname>Gregor</surname></author><copyright><year>2003</year><holder>Douglas Gregor</holder></copyright><legalnotice><para>Permission to copy, use, sell and distribute this software
      is granted provided this copyright notice appears in all copies.
      Permission to modify the code and to distribute modified code is
      granted provided this copyright notice appears in all copies,
      and a notice that the code was modified is included with the
      copyright notice. </para><para> This software is provided "as is" without express or
      implied warranty, and with no claim as to its suitability for
      any purpose. </para></legalnotice></partinfo><title>The BoostBook Documentation Format</title><chapter><title>Introduction</title><para>The BoostBook documentation format is an extension of <ulink url="http://www.docbook.org">DocBook</ulink>, an SGML- or
    XML-based format for describing documentation. BoostBook augments
    DocBook with semantic markup that aids in the documentation of C++
    libraries, specifically the <ulink url="http://www.boost.org">Boost C++ libraries</ulink>, by
    providing the ability to express and refer to C++ constructs such
    as namespaces, classes, overloaded functions, templates, and
    specializations.</para><para>
    BoostBook offers additional features more specific to its use for
    documenting the <ulink url="http://www.boost.org">Boost C++
    libraries</ulink>. These features are intended to eliminate or
    reduce the need for duplication of information and to aid in
    documenting portions of Boost that might otherwise not be
    documented. Examples of Boost-centric features include:
      <itemizedlist><listitem><para><emphasis role="bold">Testsuites</emphasis>:
          Testsuites in Boost are created by writing an appropriate
          Jamfile and including that Jamfile in
          <filename>status/Jamfile</filename>. If the testsuites are
          documented (<ulink url="http://www.boost.org/libs/multi_array/doc/test_cases.html">as
          in the MultiArray library</ulink>), the documentation is
          maintained separately from the testcase Jamfile, leading to
          duplication of information and the possibility of having the
          documentation out of sync with the Jamfile. BoostBook
          contains elements that describe a testsuite for both
          purposes: the BoostBook stylesheets can generate
          documentation for the testcases and also generate an
          appropriate Jamfile to integrate the testcases with the
          regression testing system.</para></listitem><listitem><para><emphasis role="bold">Example programs</emphasis>:
          Example programs in documentation need to be duplicated in
          testcases to ensure that the examples compile and execute
          correctly. Keeping the two copies in sync is a tedious and
          error-prone task. For instance, the following code snippet
          persisted for six months:</para><programlisting>
std::cout &lt;&lt; f(5, 3) &gt;&gt; std::endl;
</programlisting><para>The BoostBook format allows testcases to be generated
          by weaving together program fragments from example programs
          in the documentation. This capability is integrated with
          testsuite generation so that example programs are normal
          tests in BoostBook.</para></listitem><listitem><para><emphasis role="bold">Library
          categorization</emphasis>: BoostBook contains primitives for
          placing libraries into categories and generating categorized
          and alphabetized lists of libraries.</para></listitem></itemizedlist></para></chapter><chapter id="boostbook.getting.started"><title>Getting Started</title><para>To use the Boost documentation tools, you will need an
    <ulink url="http://www.w3c.org/Style/XSL/">XSLT</ulink>
    processor. There are many XSLT processors available, but for now
    we suggest that you use <computeroutput>xsltproc</computeroutput>, part of <ulink url="http://xmlsoft.org/XSLT/">libxslt</ulink>. There are several
    ways to get libxslt, depending on your platform:</para><itemizedlist><listitem><para>On Unix: Build and install <ulink url="http://xmlsoft.org/">libxml2</ulink> and then <ulink url="http://xmlsoft.org/XSLT/">libxslt</ulink>. Both
        libraries are part of the <ulink url="http://www.gnome.org">GNOME</ulink> project.</para></listitem><listitem><para>On Windows:</para><itemizedlist><listitem><para>With <ulink url="http://www.cygwin.com/">Cygwin</ulink>, select the
            libxml2 and libxslt packages</para></listitem><listitem><para>Without Cygwin, you need a patched version of the tools available from 
            <ulink url="http://www.meta-comm.com/engineering/boost/xsltproc-win32.zip">
            here</ulink>.</para></listitem></itemizedlist></listitem><listitem><para>On MacOS X:</para><itemizedlist><listitem><para>If you have Fink, just get the <computeroutput>libxslt</computeroutput> and <computeroutput>doxygen</computeroutput> packages.</para><para>Without Fink, you can <ulink url="http://www.zveno.com/open_source/libxml2xslt.html">download the libxslt binaries</ulink>.</para></listitem></itemizedlist></listitem></itemizedlist><para>You will also need a recent checkout of Boost from <ulink url="http://www.boost.org/more/download.html#CVS">CVS</ulink>. If
    you would like to limit your network bandwidth or limit delays in
    building documentation, now might be a good time to download the
    DocBook DTD and XSL stylesheets as described in <xref linkend="boostbook.docbook.config"/>. You should delete or make
    writable the <computeroutput>.html</computeroutput> files in
    <computeroutput>$BOOST_ROOT/doc/html</computeroutput> before continuing.</para><para>Now we can build some documentation. Change to the directory
    <computeroutput>$BOOST_ROOT/doc</computeroutput> and run <computeroutput>bjam --v2</computeroutput> to
    build HTML documentation. You should see several warnings like
    these while DocBook documentation is being built from BoostBook
    documentation:</para><programlisting>Cannot find function named 'checked_delete'
Cannot find function named 'checked_array_delete'
Cannot find function named 'next'</programlisting><para>These warnings are emitted when the Boost documentation
    tools cannot find documentation for functions, methods, or classes
    that are referenced in the source, and are not harmful in any
    way. Once Boost.Jam has completed its execution, HTML
    documentation for Boost will be available in
    <computeroutput>$BOOST_ROOT/doc/html</computeroutput>. You can also create HTML
    documentation in a single (large!) HTML file with the command line
    <computeroutput>bjam --v2 onehtml</computeroutput>, or Unix man pages with the command
    line <computeroutput>bjam --v2 man</computeroutput>. The complete list of output
    formats is listed in <xref linkend="boostbook.output.formats"/>. Several output formats can
    be passed to a single invocation of <computeroutput>bjam</computeroutput>, e.g.,
    <computeroutput>bjam --v2 html man docbook</computeroutput> would generate HTML
    (multiple files), man pages, and DocBook documentation.</para><table id="boostbook.output.formats"><title>BoostBook Output Formats</title><tgroup cols="2"><thead><row><entry>Format</entry><entry>Description</entry></row></thead><tbody><row><entry>html</entry><entry><simpara>HTML output (multiple files). This is the default</simpara></entry></row><row><entry>onehtml</entry><entry><simpara>HTML output in a single HTML file.</simpara></entry></row><row><entry>man</entry><entry><simpara>Unix man pages.</simpara></entry></row><row><entry>pdf</entry><entry><simpara>PDF. Requires <ulink url="http://xml.apache.org/fop/index.html">Apache FOP</ulink>.</simpara></entry></row><row><entry>ps</entry><entry><simpara>Postscript. Requires <ulink url="http://xml.apache.org/fop/index.html">Apache FOP</ulink>.</simpara></entry></row><row><entry>docbook</entry><entry><ulink url="http://www.docbook.org/">DocBook</ulink>.</entry></row><row><entry>fo</entry><entry><ulink url="http://www.w3.org/TR/xsl/">XSL Formatting Objects</ulink></entry></row></tbody></tgroup></table><section id="boostbook.docbook.config"><title>Configuring local DocBook XSL and DTD distributions</title><para>By default, the DocBook DTD and XSL stylesheets are
      accessed over a network automatically by the XSLT
      processor. However, these documents tend to be large and
      introduce a noticeable delay in the XSLT transformation
      step. This section describes how to configure Boost.Build to use
      local copies of the DocBook DTD and XSL stylesheets to improve
      processing time. There are a few requirements:

      <itemizedlist><listitem><para>Norman Walsh's DocBook XSL stylesheets,
        available at the <ulink url="http://docbook.sourceforge.net">DocBook sourceforge
        site</ulink>. Extract the DocBook XSL stylesheets to a
        directory on your hard disk (which we'll refer to as the
        <computeroutput>DOCBOOK_XSL_DIR</computeroutput>).</para></listitem><listitem><para>The DocBook DTD, available as a ZIP archive at
        the <ulink url="http://www.oasis-open.org/docbook/xml/4.2/index.shtml">OASIS
        DocBook site</ulink>. The package is called "DocBook XML
        4.2". Extract the DocBook DTD to a directory on your hard disk
        (which we'll refer to as the
        <computeroutput>DOCBOOK_DTD_DIR</computeroutput>).</para></listitem></itemizedlist></para><para>In the directory <computeroutput>tools/build/v2</computeroutput> is a file
      named <filename>user-config.jam</filename>. Copy it to your home
      directory (or edit it in-place), and add a directive telling
      Boost.Build where to find the DocBook DTD and XSL stylesheets,
      replacing <computeroutput>DOCBOOK_XSL_DIR</computeroutput> and
      <computeroutput>DOCBOOK_DTD_DIR</computeroutput> with the paths of the DocBook XSL
      stylsheets and DTD, respectively:

<programlisting>#  BoostBook configuration
using boostbook : DOCBOOK_XSL_DIR
                : DOCBOOK_DTD_DIR
                ;</programlisting></para><para>Future invocations of <command>bjam</command> will use the
      specified local copies of the DTD and XSL stylesheets in lieu of
      downloading the same sources over the network.</para></section><section id="boostbook.fop"><title>Configuring Apache FOP for PostScript/PDF Output</title><para>This section describes the steps required to configure
      <ulink url="http://xml.apache.org/fop/index.html">Apache
      FOP</ulink> to generate PostScript and PDF output for BoostBook
      documents. To begin, you will need two pieces of software:
        <itemizedlist><listitem><simpara>A Java interpreter, available at <ulink url="http://java.sun.com"/>.</simpara></listitem><listitem><simpara>Apache FOP, available at <ulink url="http://xml.apache.org/fop/download.html"/>. Version 0.20.4 seems to be most stable.</simpara></listitem></itemizedlist></para><para>Once Java is installed (we'll call Java's directory
      <computeroutput>JAVA_HOME</computeroutput>) and Apache FOP has been extracted into a
      directory (we'll call FOP's directory <computeroutput>FOP_DIR</computeroutput>), we
      need to configure Boost.Build to use FOP. Edit your
      <filename>user-config.jam</filename> or
      <filename>site-config.jam</filename> and add the following,
      replacing <computeroutput>FOP_DIR</computeroutput> with the directory where Apache
      FOP is installed, and replace <computeroutput>JAVA_HOME</computeroutput> with the
      directory where Java is installed:

<programlisting>using fop : FOP_DIR
          : JAVA_HOME
          ;</programlisting>

      In some cases, <computeroutput>JAVA_HOME</computeroutput> is optional, but it often
      helps to specify it.</para><para>To test PDF generation, switch to the directory <filename class="directory">$BOOST_ROOT/doc</filename> and execute the
      command <command>bjam --v2 pdf</command>. In the absence of any
      errors, Apache FOP will be executed to transform the XSL:FO
      output of DocBook into a PDF file.</para></section><section id="boostbook.doxygen"><title>Configuring Doxygen for Documentation Extraction</title><para>This section details the steps necessary to use Doxygen to
      extract documentation and comments from source code to build a
      BoostBook document (and transform it into end-user
      documentation). You will need a somewhat recent version of <ulink url="http://www.doxygen.org">Doxygen</ulink>; 1.2.18 or newer should suffice.</para><para>Boost.Build can be configured for Doxygen support by editing
      <filename>user-config.jam</filename> or
      <filename>site-config.jam</filename> to add:

        <programlisting>using doxygen : DOXYGEN ;</programlisting><filename>DOXYGEN</filename> should be replaced with the name of
      the <command>doxygen</command> executable (with full path
      name). If the right <command>doxygen</command> executable can be
      found via the path, this parameter can be omitted.</para><important><para>The relative order of declarations in 
        <filename>user-config.jam</filename> / <filename>site-config.jam</filename>
        files is significant. In particular, <literal>using doxygen</literal> 
        line should come <emphasis>after</emphasis> the
        <literal>using boostbook</literal> declaration.
        </para></important><para>Generating of documentation from source files using
      Doxygen requires two steps. The first step involves identifying
      the source files so that Doxygen can process them. The second
      step is to specify that the output of this process, a file in
      the Doxygen XML format, is input for a BoostBook document. The
      following <filename>Jamfile.v2</filename> illustrates a simple
      case of generating reference documentation for the
      <link linkend="any">Any</link> library: </para><programlisting>project boost/any/doc ;
import boostbook : boostbook ; 
import doxygen : doxygen ;

doxygen any.doxygen : ../../../boost/any.hpp ;
boostbook any : any.doxygen ;</programlisting><para>In this example, we generate the Doxygen XML
      representation in the file <filename>any.doxygen</filename> from
      the source file <filename>../../../boost/any.hpp</filename> by
      invocing Doxygen. We then use <filename>any.doxygen</filename>
      as a source for the BoostBook target <computeroutput>any</computeroutput>, which
      will generate documentation in any format the user requests. The
      actual sequence of events in this transformation is:</para><orderedlist><listitem><simpara>Doxygen parses the header file <filename>../../../boost/any.hpp</filename> and outputs a single XML file <filename>any.doxygen</filename>.</simpara></listitem><listitem><simpara>The XSLT processor applies the stylesheet <filename>doxygen2boostbook.xsl</filename> to transform <filename>any.doxygen</filename> into the BoostBook file <filename>any.xml</filename>.</simpara></listitem><listitem><simpara>The XSLT processor applies the stylesheet <filename>docbook.xsl</filename> to transform <filename>any.xml</filename> into the DocBook XML document <filename>any.docbook</filename>.</simpara></listitem><listitem><simpara>Further transformations may generate HTML, FO, PDF, etc. from <filename>any.docbook</filename>.</simpara></listitem></orderedlist></section><section id="boostbook.troubleshooting"><title>Troubleshooting</title><para>The Boost documentation tools are still in their early phase of 
      development, and some things don't work as seamlessly as we would like 
      them to, yet. In particular, error messages can be somewhat 
      uninformative at times. If you find yourself in the situation when 
      you have double checked everything, and yet things still don't work as 
      expected, consider helping the tools by deleting 
      <literal>bin.v2</literal> build directory.
      </para></section></chapter><chapter id="boostbook.documenting" last-revision="$Date: 2004/07/05 16:26:11 $" xml:base="../tools/boostbook/doc/documenting.xml"><title>Documenting libraries</title><para>BoostBook is an extension to <ulink url="http://www.docbook.org">DocBook</ulink>, an XML format for
  representing documentation. BoostBook inherits much of its
  functionality and many elements from DocBook that are not
  redocumented here. When writing BoostBook documentation, please
  refer also to <ulink url="http://docbook.org/tdg/en/index.html">DocBook: The Definitive
  Guide</ulink>.</para><section id="boostbook.defining"><title>Defining a BoostBook library</title><para>BoostBook library documentation is contained entirely within
    a &lt;library&gt; XML element. To create a skeletal library, we
    need to create a new XML document (call it <computeroutput>any.xml</computeroutput>)
    that contains basic information about the library. The following
    <link linkend="boostbook.documenting.skeletal">BoostBook XML
    example</link> describes basic information about the <ulink url="http://www.boost.org/libs/any/index.html">Boost.Any</ulink>
    library:</para><example id="boostbook.documenting.skeletal"><title>A Skeletal BoostBook Library</title><programlisting>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd"&gt;
&lt;library name="Any" dirname="any" xmlns:xi="http://www.w3.org/2001/XInclude"
  id="any" last-revision="$Date: 2004/07/05 16:26:11 $"&gt;
  &lt;libraryinfo&gt;
    &lt;author&gt;
      &lt;firstname&gt;Kevlin&lt;/firstname&gt;
      &lt;surname&gt;Henney&lt;/surname&gt;
    &lt;/author&gt;
    &lt;librarypurpose&gt;
      Safe, generic container for single values of different value types
    &lt;/librarypurpose&gt; 
    &lt;librarycategory name="category:data-structures"/&gt;
  &lt;/libraryinfo&gt;
&lt;/library&gt;
</programlisting></example><para>The first three lines identify this document as a BoostBook
    <ulink url="http://www.w3.org/XML/">XML</ulink> document. The
    DOCTYPE line states that the document conforms to the BoostBook
    DTD, and that the top-level element is a BoostBook
    &lt;library&gt;.</para><para>The &lt;library&gt; element actually describes the aspects
    of BoostBook library documentation. The attributes for the
    &lt;library&gt; element are:</para><variablelist><title>Attributes for the &lt;library&gt; element</title><varlistentry><term><computeroutput>name</computeroutput></term><listitem><simpara>The full name of the library, e.g., "Any"</simpara></listitem></varlistentry><varlistentry><term><computeroutput>dirname</computeroutput></term><listitem><simpara>The name of the directory, relative to
            <computeroutput>boost/libs</computeroutput>, in which the library
            resides. This name may be a relative path, such as
            <computeroutput>math/octonion</computeroutput>, using "/" for the directory
            separator.</simpara></listitem></varlistentry><varlistentry><term><computeroutput>id</computeroutput></term><listitem><simpara>A short, unique name for the library. For libraries
          with simple directory names (e.g., ones that do not contain
          a "/"), this should be the same as the
          <computeroutput>dirname</computeroutput>. This <computeroutput>id</computeroutput> will be used to
          identify libraries and, for HTML output, will be used as the
          base name for the HTML file in which the library's
          documentation resides, so it should use only lowercase
          alphanumeric characters and underscores.</simpara></listitem></varlistentry><varlistentry><term><computeroutput>last-revision</computeroutput></term><listitem><simpara>Always set to <computeroutput>$Date: 2004/07/05 16:26:11 $</computeroutput>, which is
          expanded by CVS to include the date and time that the file
          was last modified.</simpara></listitem></varlistentry></variablelist><para>Inside the &lt;library&gt; element we have the
    &lt;libraryinfo&gt; element, which gives information about the
    library itself. It contains the author's name (there may be more
    than one &lt;author&gt; element), followed by the purpose of the
    library and the list of categorizations. The
    &lt;librarypurpose&gt; element should always contain a very short
    (single sentence) description of the library's purpose, and should
    <emphasis>not</emphasis> terminate with a period.</para><para>The list of categories is specified by a set of
    &lt;librarycategory&gt; elements. Each &lt;librarycategory&gt;
    element has a <computeroutput>name</computeroutput> element that identifies one of the
    categories. The actual list of categories is in the file
    <filename>doc/src/boost.xml</filename>.
    </para><para>At this point, we can apply the BoostBook XSL stylesheets to
    <computeroutput>any.xml</computeroutput> (to DocBook) followed by a DocBook XSL
    stylesheet to generate HTML output, as described in <xref linkend="boostbook.getting.started"/>.</para></section><section><title>From HTML to BoostBook</title><para>Most library authors are comfortable with writing HTML
    documentation. Writing <ulink url="http://www.docbook.org">DocBook</ulink> documentation (and,
    by extension, BoostBook documentation) is quite similar to writing
    HTML, except that BoostBook uses different element names from HTML
    (see <xref linkend="html.to.boostbook"/>) and BoostBook XML is a
    much more rigid format than HTML.</para><para>One of the easiest ways to convert HTML documentation into
    BoostBook documentation is to use <ulink url="http://tidy.sourceforge.net/">HTML Tidy</ulink> to transform
    your HTML into valid XHTML, which will make sure that all elements
    are properly closed, then apply the transformations in <xref linkend="html.to.boostbook"/> to the body of the XHTML
    document. The following command uses HTML Tidy to transform HTML
    into valid XHTML:</para><programlisting>
  tidy -asxhtml input.html &gt; output.xhtml</programlisting><para>When converting documentation from HTML to BoostBook, note
    that some redundant information that has to be manually maintained
    in HTML is automatically generated in BoostBook: for instance, the
    library categorizations, purpose, and author list described in
    <xref linkend="boostbook.defining"/> are used both in the
    documentation for the library and to build alphabetical and
    categorized lists of known libraries; similarly, tables of
    contents are built automatically from the titles of sections in
    the BoostBook document.</para><table id="html.to.boostbook"><title>Converting HTML elements to BoostBook</title><tgroup cols="2" align="left"><thead><row><entry>HTML</entry><entry>BoostBook</entry></row></thead><tbody><row><entry><simpara>&lt;h1&gt;, &lt;h2&gt;, etc.</simpara></entry><entry><simpara>&lt;section&gt;, &lt;title&gt;; See <xref linkend="boostbook.sectioning"/></simpara></entry></row><row><entry><simpara>&lt;i&gt;, &lt;em&gt;</simpara></entry><entry><simpara>&lt;emphasis&gt;</simpara></entry></row><row><entry><simpara>&lt;b&gt;</simpara></entry><entry><simpara>&lt;emphasis role="bold"&gt;</simpara></entry></row><row><entry><simpara>&lt;ol&gt;</simpara></entry><entry><simpara>&lt;orderedlist&gt;</simpara></entry></row><row><entry><simpara>&lt;ul&gt;</simpara></entry><entry><simpara>&lt;itemizedlist&gt;</simpara></entry></row><row><entry><simpara>&lt;li&gt;</simpara></entry><entry><simpara>&lt;listitem&gt;</simpara></entry></row><row><entry><simpara>&lt;pre&gt;</simpara></entry><entry><simpara>&lt;programlisting&gt;</simpara></entry></row><row><entry><simpara>&lt;code&gt;</simpara></entry><entry><simpara>&lt;computeroutput&gt;,&lt;code&gt;</simpara></entry></row><row><entry><simpara>&lt;p&gt;</simpara></entry><entry><simpara>&lt;para&gt;, &lt;simpara&gt;</simpara></entry></row><row><entry><simpara>&lt;a&gt;</simpara></entry><entry><simpara>&lt;xref&gt;, &lt;link&gt;, &lt;ulink&gt;;, See <xref linkend="boostbook.linking"/></simpara></entry></row><row><entry><simpara>&lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt;</simpara></entry><entry><simpara>&lt;table&gt;, &lt;informaltable&gt;, &lt;tgroup&gt;, &lt;thead&gt;, &lt;tfoot&gt;, &lt;tbody&gt;, &lt;row&gt;, &lt;entry&gt;, &lt;entrytbl&gt;; BoostBook tables are equivalent to DocBook tables, for which there is a good <ulink url="http://opensource.bureau-cornavin.com/crash-course/tables.html">tutorial here</ulink></simpara></entry></row></tbody></tgroup></table></section><section id="boostbook.sectioning"><title>Sectioning in BoostBook</title><para>"Sectioning" refers to organization of a document into separate sections, each with a title, some text, and possibly subsections. Each section is described in BoostBook via a &lt;section&gt; element. An introduction section may look like this:</para><programlisting>
&lt;section id="any.intro"&gt;
  &lt;title&gt;Introduction&lt;/title&gt;
 
  &lt;para&gt;Introduction to a library...&lt;/para&gt;

  &lt;section&gt;
    &lt;title&gt;A Subsection&lt;/title&gt;
    &lt;para&gt;Subsection information...&lt;/para&gt;
  &lt;/section&gt;
&lt;/section&gt;
</programlisting><para>The &lt;section&gt; element contains all information that
    should logically be grouped within that section. The title of the
    section is placed within the &lt;title&gt; element, and any
    paragraphs, programs, lists, tables, or subsections can occur
    within the section. The <computeroutput>id</computeroutput> attribute of the
    &lt;section&gt; element gives a unique ID to each section, so that
    it may later be identified for linking. It is suggested that all
    IDs start with the short name of a library followed by a period,
    so that IDs do not conflict between libraries.</para></section></chapter><chapter id="boostbook.together" last-revision="$Date: 2004/07/05 16:26:11 $" xml:base="../tools/boostbook/doc/together.xml"><title>Bringing Together a BoostBook Document</title><section id="boostbook.linking"><title>Linking in BoostBook</title><para>How one links to another element in BoostBook depends
    greatly on the nature of the element linked and how the link
    should appear. There are three general linking elements:
    &lt;xref&gt;, &lt;link&gt;, and &lt;ulink&gt;. Additionally, there
    are linking elements for referencing specific types of entities,
    such as classes (&lt;classname&gt;), functions
    (&lt;functionname&gt;), or libraries (&lt;libraryname&gt;).</para><para>The &lt;xref&gt; element references elements that have an
    <computeroutput>id</computeroutput> attribute and a title. The actual link text is
    composed from title and type of the element referenced. To link to
    a particular ID, create an &lt;xref&gt; element with the
    <computeroutput>linkend</computeroutput> attribute set to the ID of the intended
    target. For instance, this section's ID is
    <computeroutput>boostbook.linking</computeroutput>, so we create a reference it to
    with <computeroutput>&lt;xref linkend="boostbook.linking"/&gt;</computeroutput>, which
    will look like this in the text: <xref linkend="boostbook.linking"/>.</para><para>The &lt;link&gt; element references an ID in the same way as
    &lt;xref&gt;, except that &lt;link&gt; does not generate any text
    for the link, so text must be supplied within the element. For
    instance, we can again link to this chapter but this time specify
    our own text with <computeroutput>&lt;link
    linkend="boostbook.linking"&gt;like this&lt;/link&gt;</computeroutput>. This
    markup will result in a link to this chapter that looks <link linkend="boostbook.linking">like this</link>.</para><para>The &lt;ulink&gt; element references a URL that is outside
    of the DocBook document. The <computeroutput>url</computeroutput> attribute contains
    the URL to link to, and the element data provides the link
    text.For instance, we can link to the the Boost web site with
    <computeroutput>&lt;ulink
    url="http://www.boost.org"&gt;Boost&lt;/ulink&gt;,</computeroutput> which
    appears in the document like this: <ulink url="http://www.boost.org">Boost</ulink>.</para><para>The &lt;classname&gt;, &lt;functionname&gt;,
    &lt;methodname&gt;, and &lt;libraryname&gt; link to classes,
    functions, methods, and libraries, respectively. The text of each
    element gives both the name of the element to link to and the link
    text. For instance, we can link to the Function library with
    <computeroutput>&lt;libraryname&gt;Function&lt;/libraryname&gt;</computeroutput>,
    which results in the following:
    <link linkend="function">Function</link>. In cases where the displayed
    text is different from the actual name, the <computeroutput>alt</computeroutput>
    attribute can be specified. For instance, the following XML
    element references the <link linkend="boost.function">boost::function</link>
    class template but displays the text <link linkend="boost.function">function</link>: <computeroutput>&lt;classname
    alt="boost::function"&gt;function&lt;/classname&gt;</computeroutput>.</para></section></chapter><chapter id="reference" xml:base="../tools/boostbook/doc/reference.xml"><title>Reference</title><para>Elements:<itemizedlist spacing="compact"><listitem><simpara><link linkend="boostbook.dtd.boostbook">Element <sgmltag>boostbook</sgmltag> - Defines a BoostBook book</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.class">Element <sgmltag>class</sgmltag> - Declares a class or class template</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.class-specialization">Element <sgmltag>class-specialization</sgmltag> - A specialization (partial or full) of a class template</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.code">Element <sgmltag>code</sgmltag> - Mimics the <sgmltag>code</sgmltag> tag in HTML</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.compile-fail-test">Element <sgmltag>compile-fail-test</sgmltag> - A testcase that should fail to compile</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.compile-test">Element <sgmltag>compile-test</sgmltag> - A testcase that should compile correctly</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.complexity">Element <sgmltag>complexity</sgmltag> - The time/space/etc. complexity of a function</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.constructor">Element <sgmltag>constructor</sgmltag> - Declares a constructor of the enclosing class</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.copy-assignment">Element <sgmltag>copy-assignment</sgmltag> - Declares a copy-assignment operator</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.data-member">Element <sgmltag>data-member</sgmltag> - Declares a data member of a class</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.default">Element <sgmltag>default</sgmltag> - The default value of a function or template parameter</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.description">Element <sgmltag>description</sgmltag> - Detailed description of a construct</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.destructor">Element <sgmltag>destructor</sgmltag> - Declares a destructor for the enclosing class</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.effects">Element <sgmltag>effects</sgmltag> - Declares the side effects of a function</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.enum">Element <sgmltag>enum</sgmltag> - Declares an enumeration type</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.enumvalue">Element <sgmltag>enumvalue</sgmltag> - A single value of an enumeration</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.free-function-group">Element <sgmltag>free-function-group</sgmltag> - A set of functions that are grouped together under one name</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.function">Element <sgmltag>function</sgmltag> - Declares a function</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.functionname">Element <sgmltag>functionname</sgmltag> - References a function with the given name</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.header">Element <sgmltag>header</sgmltag> - Declares a C++ header with the given name</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.if-fails">Element <sgmltag>if-fails</sgmltag> - What it means when a testcase fails</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.inherit">Element <sgmltag>inherit</sgmltag> - Declares a base class of the enclosing class or struct</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.lib">Element <sgmltag>lib</sgmltag> - A library dependency</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.library">Element <sgmltag>library</sgmltag> - Top-level element for a library</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.library-reference">Element <sgmltag>library-reference</sgmltag> - Declares the reference material for a library</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.librarycategory">Element <sgmltag>librarycategory</sgmltag> - Declares that the enclosing library is in this category</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.librarycategorydef">Element <sgmltag>librarycategorydef</sgmltag> - Defines a new library category</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.librarycategorylist">Element <sgmltag>librarycategorylist</sgmltag> - Categorized listing of libraries</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.libraryinfo">Element <sgmltag>libraryinfo</sgmltag> - Provides information about a library</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.librarylist">Element <sgmltag>librarylist</sgmltag> - Placeholder for an alphabetical list of libraries</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.libraryname">Element <sgmltag>libraryname</sgmltag> - References a library of the given name</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.librarypurpose">Element <sgmltag>librarypurpose</sgmltag> - Describes in one short sentence or phrase the purpose of a library</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.link-fail-test">Element <sgmltag>link-fail-test</sgmltag> - Declares a test that should compile but fail to link</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.link-test">Element <sgmltag>link-test</sgmltag> - Declares a test that should compile and link</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.method">Element <sgmltag>method</sgmltag> - Declares a method, i.e., a member function</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.method-group">Element <sgmltag>method-group</sgmltag> - A set of methods that are grouped together under one name</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.namespace">Element <sgmltag>namespace</sgmltag> - Declares a namespace</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.notes">Element <sgmltag>notes</sgmltag> - Non-normative notes about a function's semantics</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.overloaded-function">Element <sgmltag>overloaded-function</sgmltag> - An overloaded function</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.overloaded-method">Element <sgmltag>overloaded-method</sgmltag> - An overloaded method</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.parameter">Element <sgmltag>parameter</sgmltag> - A function parameter</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.paramtype">Element <sgmltag>paramtype</sgmltag> - The type of a function parameter</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.postconditions">Element <sgmltag>postconditions</sgmltag> - Conditions that must hold after the function returns</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.precondition">Element <sgmltag>precondition</sgmltag> - Conditions that must be met prior to executing a function</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.programlisting">Element <sgmltag>programlisting</sgmltag> - A sample of program code</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.purpose">Element <sgmltag>purpose</sgmltag> - A short description of an entity's use</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.rationale">Element <sgmltag>rationale</sgmltag> - Describes the rationale for a particular function's design</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.requirement">Element <sgmltag>requirement</sgmltag> - A requirement/property in the Jamfile for a testcase</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.requires">Element <sgmltag>requires</sgmltag> - Declares the requirements of a function</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.returns">Element <sgmltag>returns</sgmltag> - Description of the return value of a function</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.run-fail-test">Element <sgmltag>run-fail-test</sgmltag> - A testcase that should compile and link, but fail on execution</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.run-test">Element <sgmltag>run-test</sgmltag> - A testcase that should compile, link, and execute</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.signature">Element <sgmltag>signature</sgmltag> - One signature of an overloaded function or method</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.snippet">Element <sgmltag>snippet</sgmltag> - Pulls in a code snippet from a <sgmltag>programlisting</sgmltag> element</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.source">Element <sgmltag>source</sgmltag> - Defines source code for a test</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.specialization">Element <sgmltag>specialization</sgmltag> - Defines the specialization arguments for a class specialization</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.static-constant">Element <sgmltag>static-constant</sgmltag> - Declares a static constant, e.g., <computeroutput>const int foo = 5;</computeroutput>.</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.struct">Element <sgmltag>struct</sgmltag> - Declares a C++ struct</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.struct-specialization">Element <sgmltag>struct-specialization</sgmltag> - A specialization (full or partial) of a struct template</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.template">Element <sgmltag>template</sgmltag> - Declares the template parameters of a class or function</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.template-arg">Element <sgmltag>template-arg</sgmltag> - A template argument in a specialization</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.template-nontype-parameter">Element <sgmltag>template-nontype-parameter</sgmltag> - A nontype template parameter</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.template-type-parameter">Element <sgmltag>template-type-parameter</sgmltag> - Declares a template type parameter</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.template-varargs">Element <sgmltag>template-varargs</sgmltag> - Declares a variable-length list of template parameters</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.testsuite">Element <sgmltag>testsuite</sgmltag> - Describes a library testsuite</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.throws">Element <sgmltag>throws</sgmltag> - Description of the exceptions thrown by a function</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.type">Element <sgmltag>type</sgmltag> - The type of an element or return type of a function</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.typedef">Element <sgmltag>typedef</sgmltag> - Declares a typedef</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.union">Element <sgmltag>union</sgmltag> - Declares a C++ union or union template</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.union-specialization">Element <sgmltag>union-specialization</sgmltag> - A specialization (full or partial) of a union template</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.using-class">Element <sgmltag>using-class</sgmltag> - Injects the method and function names of a class into the local scope</link></simpara></listitem><listitem><simpara><link linkend="boostbook.dtd.using-namespace">Element <sgmltag>using-namespace</sgmltag> - Injects the declared names from a namespace into the local scope</link></simpara></listitem></itemizedlist></para><refentry id="boostbook.dtd.class-specialization"><refmeta><refentrytitle>
          BoostBook element <sgmltag>class-specialization</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>class-specialization</refname><refpurpose>A specialization (partial or full) of a class template</refpurpose></refnamediv><refsynopsisdiv>class-specialization ::= 
  (<link linkend="boostbook.dtd.template">template</link>?, <link linkend="boostbook.dtd.specialization">specialization</link>?, <link linkend="boostbook.dtd.inherit">inherit</link>?, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?, (<link linkend="boostbook.dtd.static-constant">static-constant</link>| <link linkend="boostbook.dtd.typedef">typedef</link>| <link linkend="boostbook.dtd.enum">enum</link>| <link linkend="boostbook.dtd.copy-assignment">copy-assignment</link>| <link linkend="boostbook.dtd.constructor">constructor</link>| <link linkend="boostbook.dtd.destructor">destructor</link>| <link linkend="boostbook.dtd.method-group">method-group</link>| <link linkend="boostbook.dtd.free-function-group">free-function-group</link>| <link linkend="boostbook.dtd.function">function</link>| <link linkend="boostbook.dtd.method">method</link>| <link linkend="boostbook.dtd.overloaded-function">overloaded-function</link>| <link linkend="boostbook.dtd.overloaded-method">overloaded-method</link>| <link linkend="boostbook.dtd.data-member">data-member</link>| <link linkend="boostbook.dtd.class">class</link>| <link linkend="boostbook.dtd.class-specialization">class-specialization</link>| <link linkend="boostbook.dtd.struct">struct</link>| <link linkend="boostbook.dtd.struct-specialization">struct-specialization</link>| <link linkend="boostbook.dtd.union">union</link>| <link linkend="boostbook.dtd.union-specialization">union-specialization</link>)*)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.link-test"><refmeta><refentrytitle>
          BoostBook element <sgmltag>link-test</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>link-test</refname><refpurpose>Declares a test that should compile and link</refpurpose></refnamediv><refsynopsisdiv>link-test ::= 
  (<link linkend="boostbook.dtd.source">source</link>*, <link linkend="boostbook.dtd.lib">lib</link>*, <link linkend="boostbook.dtd.requirement">requirement</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>, <link linkend="boostbook.dtd.if-fails">if-fails</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>filename</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the file associated with this element</entry></row><row><entry>name</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.link-fail-test"><refmeta><refentrytitle>
          BoostBook element <sgmltag>link-fail-test</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>link-fail-test</refname><refpurpose>Declares a test that should compile but fail to link</refpurpose></refnamediv><refsynopsisdiv>link-fail-test ::= 
  (<link linkend="boostbook.dtd.source">source</link>*, <link linkend="boostbook.dtd.lib">lib</link>*, <link linkend="boostbook.dtd.requirement">requirement</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>, <link linkend="boostbook.dtd.if-fails">if-fails</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>filename</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the file associated with this element</entry></row><row><entry>name</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.typedef"><refmeta><refentrytitle>
          BoostBook element <sgmltag>typedef</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>typedef</refname><refpurpose>Declares a typedef</refpurpose></refnamediv><refsynopsisdiv>typedef ::= 
  (<link linkend="boostbook.dtd.type">type</link>, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.static-constant"><refmeta><refentrytitle>
          BoostBook element <sgmltag>static-constant</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>static-constant</refname><refpurpose>Declares a static constant, e.g., <computeroutput>const int foo = 5;</computeroutput>.</refpurpose></refnamediv><refsynopsisdiv>static-constant ::= 
  (<link linkend="boostbook.dtd.type">type</link>, <link linkend="boostbook.dtd.default">default</link>, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.code"><refmeta><refentrytitle>
          BoostBook element <sgmltag>code</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>code</refname><refpurpose>Mimics the <sgmltag>code</sgmltag> tag in HTML</refpurpose></refnamediv><refsynopsisdiv>code ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Description</title><para>Text within a <sgmltag>code</sgmltag> tag is generally typeset
  in a different, monospaced font so that it stands out as code. The
  <sgmltag>code</sgmltag> tag in BoostBook is transformed directly
  into the <sgmltag>computeroutput</sgmltag> tag in DocBook.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.destructor"><refmeta><refentrytitle>
          BoostBook element <sgmltag>destructor</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>destructor</refname><refpurpose>Declares a destructor for the enclosing class</refpurpose></refnamediv><refsynopsisdiv>destructor ::= 
  (<link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?, <link linkend="boostbook.dtd.requires">requires</link>?, <link linkend="boostbook.dtd.effects">effects</link>?, <link linkend="boostbook.dtd.postconditions">postconditions</link>?, <link linkend="boostbook.dtd.returns">returns</link>?, <link linkend="boostbook.dtd.throws">throws</link>?, <link linkend="boostbook.dtd.complexity">complexity</link>?, <link linkend="boostbook.dtd.notes">notes</link>?, <link linkend="boostbook.dtd.rationale">rationale</link>?)
</refsynopsisdiv><refsection><title>Description</title><para>General documentation on functions in BoostBook is provided in
  the <link linkend="boostbook.dtd.function"><sgmltag>function</sgmltag></link>
  element documentation.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>specifiers</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The specifiers for this function, e.g., inline, static, etc.</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.template-type-parameter"><refmeta><refentrytitle>
          BoostBook element <sgmltag>template-type-parameter</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>template-type-parameter</refname><refpurpose>Declares a template type parameter</refpurpose></refnamediv><refsynopsisdiv>template-type-parameter ::= 
  (<link linkend="boostbook.dtd.default">default</link>?, <link linkend="boostbook.dtd.purpose">purpose</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.description"><refmeta><refentrytitle>
          BoostBook element <sgmltag>description</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>description</refname><refpurpose>Detailed description of a construct</refpurpose></refnamediv><refsynopsisdiv>description ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Description</title><para>Although the context model for this element is
  <computeroutput>ANY</computeroutput>, detailed descriptions should contain structured
  DocBook elements that occur within sections, e.g., paragraphs
  (<sgmltag>para</sgmltag>, <sgmltag>simpara</sgmltag>), lists
  (<sgmltag>orderedlist</sgmltag>, <sgmltag>itemizedlist</sgmltag>),
  tables (<sgmltag>informaltable</sgmltag>, <sgmltag>table</sgmltag>),
  etc.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.librarylist"><refmeta><refentrytitle>
          BoostBook element <sgmltag>librarylist</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>librarylist</refname><refpurpose>Placeholder for an alphabetical list of libraries</refpurpose></refnamediv><refsynopsisdiv>librarylist ::= 
  EMPTY
</refsynopsisdiv><refsection><title>Description</title><para>Developers aren't generally expected to use this element. Its existence is mainly as a placeholder in <filename>boost.xml</filename> for the alphabetical list of libraries.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.library-reference"><refmeta><refentrytitle>
          BoostBook element <sgmltag>library-reference</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>library-reference</refname><refpurpose>Declares the reference material for a library</refpurpose></refnamediv><refsynopsisdiv>library-reference ::= 
  (title?, section*, (<link linkend="boostbook.dtd.header">header</link>| <link linkend="boostbook.dtd.library-reference">library-reference</link>)*)
</refsynopsisdiv><refsection><title>Description</title><para>Reference documentation for a library is contained with a
  &lt;library-reference&gt; element. The &lt;library-reference&gt;
  element has no attributes, and contains as children only
  &lt;header&gt; elements.</para><para>The &lt;header&gt; element defines a C++ header file. Within
  each C++ header file lie the definitions of C++ constructs to be
  documented. The <computeroutput>name</computeroutput> attribute of the &lt;header&gt;
  element gives the name of the header, as one would specify when
  including the header. For instance, the &lt;library-reference&gt;
  for the <link linkend="any">Any</link> library may look like
  this:</para><programlisting>&lt;library-reference&gt;
  &lt;header name="boost/any.hpp"&gt;
    &lt;!-- C++ constructs in this header --&gt;
  &lt;/header&gt;
&lt;/library-reference&gt;</programlisting><para>If the <link linkend="any">Any</link> library contained
  multiple headers, we would list them all as children of the
  &lt;library-reference&gt; element.</para><para><sgmltag>library-reference</sgmltag> elements can be nested,
  so that reference material can be divided into separate sections
  that each contain different headers.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.boostbook"><refmeta><refentrytitle>
          BoostBook element <sgmltag>boostbook</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>boostbook</refname><refpurpose>Defines a BoostBook book</refpurpose></refnamediv><refsynopsisdiv>boostbook ::= 
  (title, (chapter| <link linkend="boostbook.dtd.library">library</link>)*)
</refsynopsisdiv><refsection><title>Description</title><simpara>This element is the topmost level defined by
  <filename>boost.xml</filename> for all Boost documentation. It will
  not generally be used by developers.</simpara></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.union"><refmeta><refentrytitle>
          BoostBook element <sgmltag>union</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>union</refname><refpurpose>Declares a C++ union or union template</refpurpose></refnamediv><refsynopsisdiv>union ::= 
  (<link linkend="boostbook.dtd.template">template</link>?, <link linkend="boostbook.dtd.inherit">inherit</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?, (<link linkend="boostbook.dtd.static-constant">static-constant</link>| <link linkend="boostbook.dtd.typedef">typedef</link>| <link linkend="boostbook.dtd.enum">enum</link>| <link linkend="boostbook.dtd.copy-assignment">copy-assignment</link>| <link linkend="boostbook.dtd.constructor">constructor</link>| <link linkend="boostbook.dtd.destructor">destructor</link>| <link linkend="boostbook.dtd.method-group">method-group</link>| <link linkend="boostbook.dtd.free-function-group">free-function-group</link>| <link linkend="boostbook.dtd.function">function</link>| <link linkend="boostbook.dtd.method">method</link>| <link linkend="boostbook.dtd.overloaded-function">overloaded-function</link>| <link linkend="boostbook.dtd.overloaded-method">overloaded-method</link>| <link linkend="boostbook.dtd.data-member">data-member</link>| <link linkend="boostbook.dtd.class">class</link>| <link linkend="boostbook.dtd.class-specialization">class-specialization</link>| <link linkend="boostbook.dtd.struct">struct</link>| <link linkend="boostbook.dtd.struct-specialization">struct-specialization</link>| <link linkend="boostbook.dtd.union">union</link>| <link linkend="boostbook.dtd.union-specialization">union-specialization</link>)*)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.inherit"><refmeta><refentrytitle>
          BoostBook element <sgmltag>inherit</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>inherit</refname><refpurpose>Declares a base class of the enclosing class or struct</refpurpose></refnamediv><refsynopsisdiv>inherit ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Description</title><para>This element contains the name of the class inherited. The
  content model is free-form, as the inherited class may be an
  instantiation of a template and may have markup in it (e.g.,
  <sgmltag>classname</sgmltag> tags).</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>access</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry/></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.template-varargs"><refmeta><refentrytitle>
          BoostBook element <sgmltag>template-varargs</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>template-varargs</refname><refpurpose>Declares a variable-length list of template parameters</refpurpose></refnamediv><refsynopsisdiv>template-varargs ::= 
  EMPTY
</refsynopsisdiv><refsection><title>Description</title><para>Variable-length template parameter lists are not allowed in
  C++, but because they are sometimes needed in documentation they are
  allowed in BoostBook. This element generally expands to "..." and
  can be used anywhere any other template parameter can be
  used.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.source"><refmeta><refentrytitle>
          BoostBook element <sgmltag>source</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>source</refname><refpurpose>Defines source code for a test</refpurpose></refnamediv><refsynopsisdiv>source ::= 
  (#PCDATA| <link linkend="boostbook.dtd.snippet">snippet</link>)*
</refsynopsisdiv><refsection><title>Description</title><para>This element will contain the source code for a testcase that
  will be generated from the documentation. To reduce the amount of escaping in the text, it is recommended to use CDATA sections, which look like this:

    <programlisting>&lt;![CDATA[
&lt;your program text here: no escaping needed!&gt;
]]&gt;</programlisting></para><para>In addition to CDATA sections, code snippets can be pulled in
  from <sgmltag>programlisting</sgmltag> elements using the <link linkend="boostbook.dtd.snippet"><sgmltag>snippet</sgmltag></link>
  element.</para></refsection></refentry><refentry id="boostbook.dtd.function"><refmeta><refentrytitle>
          BoostBook element <sgmltag>function</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>function</refname><refpurpose>Declares a function</refpurpose></refnamediv><refsynopsisdiv>function ::= 
  (<link linkend="boostbook.dtd.template">template</link>?, <link linkend="boostbook.dtd.type">type</link>, <link linkend="boostbook.dtd.parameter">parameter</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?, <link linkend="boostbook.dtd.requires">requires</link>?, <link linkend="boostbook.dtd.effects">effects</link>?, <link linkend="boostbook.dtd.postconditions">postconditions</link>?, <link linkend="boostbook.dtd.returns">returns</link>?, <link linkend="boostbook.dtd.throws">throws</link>?, <link linkend="boostbook.dtd.complexity">complexity</link>?, <link linkend="boostbook.dtd.notes">notes</link>?, <link linkend="boostbook.dtd.rationale">rationale</link>?)
</refsynopsisdiv><refsection><title>Description</title><para>BoostBook functions are documented by specifying the
  function's interface (e.g., its C++ signature) and its
  behavior. Constructors, destructors, member functions, and free
  functions all use the same documentation method, although the
  top-level tags differ.</para><para>The behavior of functions in BoostBook is documenting using a
  style similar to that of the C++ standard, with clauses describing
  the requirements, effects, postconditions, exception behavior, and
  return values of functions.</para><para>The following example illustrates some constructors and a
  destructor for <link linkend="boost.any">boost::any</link>. Note that one of
  the constructors takes a single parameter whose name is "other" and
  whose type, <computeroutput>const any&amp;</computeroutput> is contained in the
  &lt;paramtype&gt; element; any number of parameters may be specified
  in this way.</para><programlisting>&lt;class name="any"&gt;
  &lt;constructor&gt;
    &lt;postconditions&gt;&lt;para&gt;&lt;this-&gt;empty()&gt;&lt;/para&gt;&lt;/postconditions&gt;
  &lt;/constructor&gt;

  &lt;constructor&gt;
    &lt;parameter name="other"&gt;
      &lt;paramtype&gt;const &lt;classname&gt;any&lt;/classname&gt;&amp;amp;&lt;/paramtype&gt;
    &lt;/parameter&gt;

    &lt;effects&gt;
      &lt;simpara&gt; Copy constructor that copies
        content of &lt;code&gt;other&lt;/code&gt; into the new instance,
        so that any content is equivalent in both type and value to the
        content of &lt;code&gt;other&lt;/code&gt;, or empty if
        &lt;code&gt;other&lt;/code&gt; is
        empty. 
      &lt;/simpara&gt;
    &lt;/effects&gt;

    &lt;throws&gt;
      &lt;simpara&gt;May fail with a 
        &lt;classname&gt;std::bad_alloc&lt;/classname&gt; exception or any
        exceptions arising from the copy constructor of the
        contained type.
      &lt;/simpara&gt;
    &lt;/throws&gt;
  &lt;/constructor&gt;

  &lt;destructor&gt;
     &lt;effects&gt;&lt;simpara&gt;Releases any and all resources used in
     management of instance.&lt;/simpara&gt;&lt;/effects&gt;

     &lt;throws&gt;&lt;simpara&gt;Nothing.&lt;/simpara&gt;&lt;/throws&gt;
  &lt;/destructor&gt;
&lt;/class&gt;</programlisting></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>specifiers</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The specifiers for this function, e.g., inline, static, etc.</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.postconditions"><refmeta><refentrytitle>
          BoostBook element <sgmltag>postconditions</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>postconditions</refname><refpurpose>Conditions that must hold after the function returns</refpurpose></refnamediv><refsynopsisdiv>postconditions ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.compile-test"><refmeta><refentrytitle>
          BoostBook element <sgmltag>compile-test</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>compile-test</refname><refpurpose>A testcase that should compile correctly</refpurpose></refnamediv><refsynopsisdiv>compile-test ::= 
  (<link linkend="boostbook.dtd.source">source</link>*, <link linkend="boostbook.dtd.lib">lib</link>*, <link linkend="boostbook.dtd.requirement">requirement</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>, <link linkend="boostbook.dtd.if-fails">if-fails</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>filename</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the file associated with this element</entry></row><row><entry>name</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.method"><refmeta><refentrytitle>
          BoostBook element <sgmltag>method</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>method</refname><refpurpose>Declares a method, i.e., a member function</refpurpose></refnamediv><refsynopsisdiv>method ::= 
  (<link linkend="boostbook.dtd.template">template</link>?, <link linkend="boostbook.dtd.type">type</link>, <link linkend="boostbook.dtd.parameter">parameter</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?, <link linkend="boostbook.dtd.requires">requires</link>?, <link linkend="boostbook.dtd.effects">effects</link>?, <link linkend="boostbook.dtd.postconditions">postconditions</link>?, <link linkend="boostbook.dtd.returns">returns</link>?, <link linkend="boostbook.dtd.throws">throws</link>?, <link linkend="boostbook.dtd.complexity">complexity</link>?, <link linkend="boostbook.dtd.notes">notes</link>?, <link linkend="boostbook.dtd.rationale">rationale</link>?)
</refsynopsisdiv><refsection><title>Description</title><para>General documentation on functions in BoostBook is provided in
  the <link linkend="boostbook.dtd.function"><sgmltag>function</sgmltag></link>
  element documentation.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>cv</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>cv-qualifiers for this method, e.g., const volatile</entry></row><row><entry>specifiers</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The specifiers for this function, e.g., inline, static, etc.</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.snippet"><refmeta><refentrytitle>
          BoostBook element <sgmltag>snippet</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>snippet</refname><refpurpose>Pulls in a code snippet from a <sgmltag>programlisting</sgmltag> element</refpurpose></refnamediv><refsynopsisdiv>snippet ::= 
  EMPTY
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the <sgmltag>programlisting</sgmltag> element to insert</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.constructor"><refmeta><refentrytitle>
          BoostBook element <sgmltag>constructor</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>constructor</refname><refpurpose>Declares a constructor of the enclosing class</refpurpose></refnamediv><refsynopsisdiv>constructor ::= 
  (<link linkend="boostbook.dtd.template">template</link>?, <link linkend="boostbook.dtd.parameter">parameter</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?, <link linkend="boostbook.dtd.requires">requires</link>?, <link linkend="boostbook.dtd.effects">effects</link>?, <link linkend="boostbook.dtd.postconditions">postconditions</link>?, <link linkend="boostbook.dtd.returns">returns</link>?, <link linkend="boostbook.dtd.throws">throws</link>?, <link linkend="boostbook.dtd.complexity">complexity</link>?, <link linkend="boostbook.dtd.notes">notes</link>?, <link linkend="boostbook.dtd.rationale">rationale</link>?)
</refsynopsisdiv><refsection><title>Description</title><para>General documentation on functions in BoostBook is provided in
  the <link linkend="boostbook.dtd.function"><sgmltag>function</sgmltag></link>
  element documentation.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>specifiers</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The specifiers for this function, e.g., inline, static, etc.</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.namespace"><refmeta><refentrytitle>
          BoostBook element <sgmltag>namespace</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>namespace</refname><refpurpose>Declares a namespace</refpurpose></refnamediv><refsynopsisdiv>namespace ::= 
  (<link linkend="boostbook.dtd.class">class</link>| <link linkend="boostbook.dtd.class-specialization">class-specialization</link>| <link linkend="boostbook.dtd.struct">struct</link>| <link linkend="boostbook.dtd.struct-specialization">struct-specialization</link>| <link linkend="boostbook.dtd.union">union</link>| <link linkend="boostbook.dtd.union-specialization">union-specialization</link>| <link linkend="boostbook.dtd.typedef">typedef</link>| <link linkend="boostbook.dtd.enum">enum</link>| <link linkend="boostbook.dtd.free-function-group">free-function-group</link>| <link linkend="boostbook.dtd.function">function</link>| <link linkend="boostbook.dtd.overloaded-function">overloaded-function</link>| <link linkend="boostbook.dtd.namespace">namespace</link>)*
</refsynopsisdiv><refsection><title>Description</title><para>BoostBook namespaces are declared via the &lt;namespace&gt;
  element. As in C++, namespaces can be nested and contain other C++
  constructs, such as classes or functions. The <computeroutput>name</computeroutput>
  attribute of a &lt;namespace&gt; element gives the namespace name
  (e.g., "boost"). The <link linkend="any">Any</link> library is
  defined entirely within namespace boost by:</para><programlisting>&lt;library-reference&gt;
  &lt;header name="boost/any.hpp"&gt;
    &lt;namespace name="boost"&gt;  
      &lt;!-- C++ constructs in the boost namespace --&gt;
    &lt;/namespace&gt;
  &lt;/header&gt;
&lt;/library-reference&gt;</programlisting></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.if-fails"><refmeta><refentrytitle>
          BoostBook element <sgmltag>if-fails</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>if-fails</refname><refpurpose>What it means when a testcase fails</refpurpose></refnamediv><refsynopsisdiv>if-fails ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Description</title><para>
    Describes to the user the effect a certain failing testcase will
    have on the usefulness of a library. This field is useful in cases
    where a failed testcase does not mean that the library won't be
    useful, but may mean that certain library features will not be
    available.
  </para></refsection></refentry><refentry id="boostbook.dtd.free-function-group"><refmeta><refentrytitle>
          BoostBook element <sgmltag>free-function-group</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>free-function-group</refname><refpurpose>A set of functions that are grouped together under one name</refpurpose></refnamediv><refsynopsisdiv>free-function-group ::= 
  (<link linkend="boostbook.dtd.function">function</link>| <link linkend="boostbook.dtd.overloaded-function">overloaded-function</link>)*
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.functionname"><refmeta><refentrytitle>
          BoostBook element <sgmltag>functionname</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>functionname</refname><refpurpose>References a function with the given name</refpurpose></refnamediv><refsynopsisdiv>functionname ::= 
  (#PCDATA)
</refsynopsisdiv><refsection><title>Description</title><para>If a function (or overloaded function) with the given,
  possibly-qualified name is found, this generates a link to that
  function. Lookups obey currently-active <link linkend="boostbook.dtd.using-class"><sgmltag>using-class</sgmltag></link>
  and <link linkend="boostbook.dtd.using-namespace"><sgmltag>using-namespace</sgmltag></link>
  directives to aid in the search, along with searching within the
  current scope.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.librarycategory"><refmeta><refentrytitle>
          BoostBook element <sgmltag>librarycategory</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>librarycategory</refname><refpurpose>Declares that the enclosing library is in this category</refpurpose></refnamediv><refsynopsisdiv>librarycategory ::= 
  (#PCDATA)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.notes"><refmeta><refentrytitle>
          BoostBook element <sgmltag>notes</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>notes</refname><refpurpose>Non-normative notes about a function's semantics</refpurpose></refnamediv><refsynopsisdiv>notes ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.data-member"><refmeta><refentrytitle>
          BoostBook element <sgmltag>data-member</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>data-member</refname><refpurpose>Declares a data member of a class</refpurpose></refnamediv><refsynopsisdiv>data-member ::= 
  (<link linkend="boostbook.dtd.type">type</link>, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.specialization"><refmeta><refentrytitle>
          BoostBook element <sgmltag>specialization</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>specialization</refname><refpurpose>Defines the specialization arguments for a class specialization</refpurpose></refnamediv><refsynopsisdiv>specialization ::= 
  (<link linkend="boostbook.dtd.template-arg">template-arg</link>)*
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.union-specialization"><refmeta><refentrytitle>
          BoostBook element <sgmltag>union-specialization</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>union-specialization</refname><refpurpose>A specialization (full or partial) of a union template</refpurpose></refnamediv><refsynopsisdiv>union-specialization ::= 
  (<link linkend="boostbook.dtd.template">template</link>?, <link linkend="boostbook.dtd.specialization">specialization</link>?, <link linkend="boostbook.dtd.inherit">inherit</link>?, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?, (<link linkend="boostbook.dtd.static-constant">static-constant</link>| <link linkend="boostbook.dtd.typedef">typedef</link>| <link linkend="boostbook.dtd.enum">enum</link>| <link linkend="boostbook.dtd.copy-assignment">copy-assignment</link>| <link linkend="boostbook.dtd.constructor">constructor</link>| <link linkend="boostbook.dtd.destructor">destructor</link>| <link linkend="boostbook.dtd.method-group">method-group</link>| <link linkend="boostbook.dtd.free-function-group">free-function-group</link>| <link linkend="boostbook.dtd.function">function</link>| <link linkend="boostbook.dtd.method">method</link>| <link linkend="boostbook.dtd.overloaded-function">overloaded-function</link>| <link linkend="boostbook.dtd.overloaded-method">overloaded-method</link>| <link linkend="boostbook.dtd.data-member">data-member</link>| <link linkend="boostbook.dtd.class">class</link>| <link linkend="boostbook.dtd.class-specialization">class-specialization</link>| <link linkend="boostbook.dtd.struct">struct</link>| <link linkend="boostbook.dtd.struct-specialization">struct-specialization</link>| <link linkend="boostbook.dtd.union">union</link>| <link linkend="boostbook.dtd.union-specialization">union-specialization</link>)*)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.throws"><refmeta><refentrytitle>
          BoostBook element <sgmltag>throws</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>throws</refname><refpurpose>Description of the exceptions thrown by a function</refpurpose></refnamediv><refsynopsisdiv>throws ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.template-arg"><refmeta><refentrytitle>
          BoostBook element <sgmltag>template-arg</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>template-arg</refname><refpurpose>A template argument in a specialization</refpurpose></refnamediv><refsynopsisdiv>template-arg ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.method-group"><refmeta><refentrytitle>
          BoostBook element <sgmltag>method-group</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>method-group</refname><refpurpose>A set of methods that are grouped together under one name</refpurpose></refnamediv><refsynopsisdiv>method-group ::= 
  (<link linkend="boostbook.dtd.method">method</link>| <link linkend="boostbook.dtd.overloaded-method">overloaded-method</link>)*
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.requirement"><refmeta><refentrytitle>
          BoostBook element <sgmltag>requirement</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>requirement</refname><refpurpose>A requirement/property in the Jamfile for a testcase</refpurpose></refnamediv><refsynopsisdiv>requirement ::= 
  (#PCDATA)
</refsynopsisdiv><refsection><title>Description</title><para>A requirement is part of the dependencies of a target in a
  Jamfile. The <computeroutput>name</computeroutput> attribute of a requirement element
  gives the name of the Boost.Build feature and the content of the
  requirement gives the value of that feature. A requirement such as
  <computeroutput>&lt;includes&gt;foo.hpp</computeroutput> would be encoded as
  <computeroutput>&lt;requirement
  name="includes"&gt;foo.hpp&lt;/requirement&gt;</computeroutput>.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.precondition"><refmeta><refentrytitle>
          BoostBook element <sgmltag>precondition</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>precondition</refname><refpurpose>Conditions that must be met prior to executing a function</refpurpose></refnamediv><refsynopsisdiv>precondition ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.paramtype"><refmeta><refentrytitle>
          BoostBook element <sgmltag>paramtype</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>paramtype</refname><refpurpose>The type of a function parameter</refpurpose></refnamediv><refsynopsisdiv>paramtype ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.using-class"><refmeta><refentrytitle>
          BoostBook element <sgmltag>using-class</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>using-class</refname><refpurpose>Injects the method and function names of a class into the local scope</refpurpose></refnamediv><refsynopsisdiv>using-class ::= 
  EMPTY
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.run-test"><refmeta><refentrytitle>
          BoostBook element <sgmltag>run-test</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>run-test</refname><refpurpose>A testcase that should compile, link, and execute</refpurpose></refnamediv><refsynopsisdiv>run-test ::= 
  (<link linkend="boostbook.dtd.source">source</link>*, <link linkend="boostbook.dtd.lib">lib</link>*, <link linkend="boostbook.dtd.requirement">requirement</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>, <link linkend="boostbook.dtd.if-fails">if-fails</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>filename</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the file associated with this element</entry></row><row><entry>name</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.librarypurpose"><refmeta><refentrytitle>
          BoostBook element <sgmltag>librarypurpose</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>librarypurpose</refname><refpurpose>Describes in one short sentence or phrase the purpose of a library</refpurpose></refnamediv><refsynopsisdiv>librarypurpose ::= 
  (#PCDATA| <link linkend="boostbook.dtd.code">code</link>| ulink| <link linkend="boostbook.dtd.functionname">functionname</link>| methodname| classname)*
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.copy-assignment"><refmeta><refentrytitle>
          BoostBook element <sgmltag>copy-assignment</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>copy-assignment</refname><refpurpose>Declares a copy-assignment operator</refpurpose></refnamediv><refsynopsisdiv>copy-assignment ::= 
  (<link linkend="boostbook.dtd.template">template</link>?, <link linkend="boostbook.dtd.type">type</link>?, <link linkend="boostbook.dtd.parameter">parameter</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?, <link linkend="boostbook.dtd.requires">requires</link>?, <link linkend="boostbook.dtd.effects">effects</link>?, <link linkend="boostbook.dtd.postconditions">postconditions</link>?, <link linkend="boostbook.dtd.returns">returns</link>?, <link linkend="boostbook.dtd.throws">throws</link>?, <link linkend="boostbook.dtd.complexity">complexity</link>?, <link linkend="boostbook.dtd.notes">notes</link>?, <link linkend="boostbook.dtd.rationale">rationale</link>?)
</refsynopsisdiv><refsection><title>Description</title><para>The return type of the copy-assignment operator does not need
  to be specified. If left unspecified, it will default to an
  unqualified reference to the enclosing class type.</para><para>General documentation on functions in BoostBook is provided in
  the <link linkend="boostbook.dtd.function"><sgmltag>function</sgmltag></link>
  element documentation.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>cv</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>cv-qualifiers for this method, e.g., const volatile</entry></row><row><entry>specifiers</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The specifiers for this function, e.g., inline, static, etc.</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.run-fail-test"><refmeta><refentrytitle>
          BoostBook element <sgmltag>run-fail-test</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>run-fail-test</refname><refpurpose>A testcase that should compile and link, but fail on execution</refpurpose></refnamediv><refsynopsisdiv>run-fail-test ::= 
  (<link linkend="boostbook.dtd.source">source</link>*, <link linkend="boostbook.dtd.lib">lib</link>*, <link linkend="boostbook.dtd.requirement">requirement</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>, <link linkend="boostbook.dtd.if-fails">if-fails</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>filename</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the file associated with this element</entry></row><row><entry>name</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.template"><refmeta><refentrytitle>
          BoostBook element <sgmltag>template</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>template</refname><refpurpose>Declares the template parameters of a class or function</refpurpose></refnamediv><refsynopsisdiv>template ::= 
  (<link linkend="boostbook.dtd.template-type-parameter">template-type-parameter</link>| <link linkend="boostbook.dtd.template-nontype-parameter">template-nontype-parameter</link>| <link linkend="boostbook.dtd.template-varargs">template-varargs</link>)*
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.compile-fail-test"><refmeta><refentrytitle>
          BoostBook element <sgmltag>compile-fail-test</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>compile-fail-test</refname><refpurpose>A testcase that should fail to compile</refpurpose></refnamediv><refsynopsisdiv>compile-fail-test ::= 
  (<link linkend="boostbook.dtd.source">source</link>*, <link linkend="boostbook.dtd.lib">lib</link>*, <link linkend="boostbook.dtd.requirement">requirement</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>, <link linkend="boostbook.dtd.if-fails">if-fails</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>filename</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the file associated with this element</entry></row><row><entry>name</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.returns"><refmeta><refentrytitle>
          BoostBook element <sgmltag>returns</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>returns</refname><refpurpose>Description of the return value of a function</refpurpose></refnamediv><refsynopsisdiv>returns ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.default"><refmeta><refentrytitle>
          BoostBook element <sgmltag>default</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>default</refname><refpurpose>The default value of a function or template parameter</refpurpose></refnamediv><refsynopsisdiv>default ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.parameter"><refmeta><refentrytitle>
          BoostBook element <sgmltag>parameter</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>parameter</refname><refpurpose>A function parameter</refpurpose></refnamediv><refsynopsisdiv>parameter ::= 
  (<link linkend="boostbook.dtd.paramtype">paramtype</link>, <link linkend="boostbook.dtd.default">default</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>name</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.signature"><refmeta><refentrytitle>
          BoostBook element <sgmltag>signature</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>signature</refname><refpurpose>One signature of an overloaded function or method</refpurpose></refnamediv><refsynopsisdiv>signature ::= 
  (<link linkend="boostbook.dtd.template">template</link>?, <link linkend="boostbook.dtd.type">type</link>, <link linkend="boostbook.dtd.parameter">parameter</link>*)
</refsynopsisdiv><refsection><title>Description</title><para>
    A signature refers to one declaration of an overloaded function or
    method. The signature itself has no name, because the name of the
    overloaded function or method is used. An overloaded function or
    method will have several signatures that will generally be typeset
    together.
  </para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>cv</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>cv-qualifiers for this method, e.g., const volatile</entry></row><row><entry>specifiers</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The specifiers for this function, e.g., inline, static, etc.</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.overloaded-function"><refmeta><refentrytitle>
          BoostBook element <sgmltag>overloaded-function</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>overloaded-function</refname><refpurpose>An overloaded function</refpurpose></refnamediv><refsynopsisdiv>overloaded-function ::= 
  (<link linkend="boostbook.dtd.signature">signature</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?, <link linkend="boostbook.dtd.requires">requires</link>?, <link linkend="boostbook.dtd.effects">effects</link>?, <link linkend="boostbook.dtd.postconditions">postconditions</link>?, <link linkend="boostbook.dtd.returns">returns</link>?, <link linkend="boostbook.dtd.throws">throws</link>?, <link linkend="boostbook.dtd.complexity">complexity</link>?, <link linkend="boostbook.dtd.notes">notes</link>?, <link linkend="boostbook.dtd.rationale">rationale</link>?)
</refsynopsisdiv><refsection><title>Description</title><para>General documentation on functions in BoostBook is provided in
  the <link linkend="boostbook.dtd.function"><sgmltag>function</sgmltag></link>
  element documentation.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.class"><refmeta><refentrytitle>
          BoostBook element <sgmltag>class</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>class</refname><refpurpose>Declares a class or class template</refpurpose></refnamediv><refsynopsisdiv>class ::= 
  (<link linkend="boostbook.dtd.template">template</link>?, <link linkend="boostbook.dtd.inherit">inherit</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?, (<link linkend="boostbook.dtd.static-constant">static-constant</link>| <link linkend="boostbook.dtd.typedef">typedef</link>| <link linkend="boostbook.dtd.enum">enum</link>| <link linkend="boostbook.dtd.copy-assignment">copy-assignment</link>| <link linkend="boostbook.dtd.constructor">constructor</link>| <link linkend="boostbook.dtd.destructor">destructor</link>| <link linkend="boostbook.dtd.method-group">method-group</link>| <link linkend="boostbook.dtd.free-function-group">free-function-group</link>| <link linkend="boostbook.dtd.function">function</link>| <link linkend="boostbook.dtd.method">method</link>| <link linkend="boostbook.dtd.overloaded-function">overloaded-function</link>| <link linkend="boostbook.dtd.overloaded-method">overloaded-method</link>| <link linkend="boostbook.dtd.data-member">data-member</link>| <link linkend="boostbook.dtd.class">class</link>| <link linkend="boostbook.dtd.class-specialization">class-specialization</link>| <link linkend="boostbook.dtd.struct">struct</link>| <link linkend="boostbook.dtd.struct-specialization">struct-specialization</link>| <link linkend="boostbook.dtd.union">union</link>| <link linkend="boostbook.dtd.union-specialization">union-specialization</link>)*)
</refsynopsisdiv><refsection><title>Description</title><para>C++ classes and class templates are described via the
  &lt;class&gt; element. Each class has a name (e.g., "any") given by
  the <computeroutput>name</computeroutput> attribute, a purpose given by the
  &lt;purpose&gt; element, documentation, and a set of types,
  functions, base classes, and data members. Here is a minimal
  definition of the <link linkend="boost.any">boost::any</link> class:</para><programlisting>&lt;namespace name="boost"&gt;
  &lt;class name="any"&gt;
    &lt;purpose&gt;
      A class whose instances can hold instances of any type that satisfies
      ValueType requirements.
    &lt;/purpose&gt;
  &lt;/class&gt;
&lt;/namespace&gt;</programlisting><para>Additional class documentation can be contained in a
  <sgmltag>description</sgmltag> element following the &lt;purpose&gt;
  element. This documentation will be typeset prior to documentation
  for specific elements in the class (e.g., constructors or
  methods).</para><para>Class inheritance is described via the &lt;inherit&gt;
  element. The &lt;inherit&gt; element requires an <computeroutput>access</computeroutput>
  attribute which must be one of <emphasis>public</emphasis>,
  <emphasis>protected</emphasis>, or <emphasis>private</emphasis>. The
  content of the &lt;inherited&gt; element in C++ code that names the
  class inherited, and may contain markup to link to the class. The
  following description of the class
  <link linkend="bad_any_cast">boost::bad_any_cast</link> describes public
  inheritance from the class std::bad_cast. It
  also defines the &lt;purpose&gt; element, which contains a short
  description of the use of the class.</para><programlisting>&lt;class name="bad_any_cast"&gt;
  &lt;inherit access="public"&gt;&lt;classname&gt;std::bad_cast&lt;/classname&gt;&lt;/inherit&gt;
  &lt;purpose&gt;&lt;para&gt;The exception thrown in the event of a failed
  &lt;functionname&gt;any_cast&lt;/functionname&gt; of an
  &lt;classname&gt;any&lt;/classname&gt; value.&lt;/para&gt;&lt;/purpose&gt;
&lt;/class&gt;</programlisting><para>Class templates are defined by &lt;class&gt; elements with a
  &lt;template&gt; child element at the beginning.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.librarycategorydef"><refmeta><refentrytitle>
          BoostBook element <sgmltag>librarycategorydef</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>librarycategorydef</refname><refpurpose>Defines a new library category</refpurpose></refnamediv><refsynopsisdiv>librarycategorydef ::= 
  (#PCDATA)
</refsynopsisdiv><refsection><title>Description</title><para>All library category definitions should be in <filename>doc/src/boost.xml</filename>, and the names of categories must be prefixed with "<computeroutput>category:</computeroutput>".</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.type"><refmeta><refentrytitle>
          BoostBook element <sgmltag>type</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>type</refname><refpurpose>The type of an element or return type of a function</refpurpose></refnamediv><refsynopsisdiv>type ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.enumvalue"><refmeta><refentrytitle>
          BoostBook element <sgmltag>enumvalue</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>enumvalue</refname><refpurpose>A single value of an enumeration</refpurpose></refnamediv><refsynopsisdiv>enumvalue ::= 
  (<link linkend="boostbook.dtd.default">default</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.overloaded-method"><refmeta><refentrytitle>
          BoostBook element <sgmltag>overloaded-method</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>overloaded-method</refname><refpurpose>An overloaded method</refpurpose></refnamediv><refsynopsisdiv>overloaded-method ::= 
  (<link linkend="boostbook.dtd.signature">signature</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?, <link linkend="boostbook.dtd.requires">requires</link>?, <link linkend="boostbook.dtd.effects">effects</link>?, <link linkend="boostbook.dtd.postconditions">postconditions</link>?, <link linkend="boostbook.dtd.returns">returns</link>?, <link linkend="boostbook.dtd.throws">throws</link>?, <link linkend="boostbook.dtd.complexity">complexity</link>?, <link linkend="boostbook.dtd.notes">notes</link>?, <link linkend="boostbook.dtd.rationale">rationale</link>?)
</refsynopsisdiv><refsection><title>Description</title><para>General documentation on functions in BoostBook is provided in
  the <link linkend="boostbook.dtd.function"><sgmltag>function</sgmltag></link>
  element documentation.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.programlisting"><refmeta><refentrytitle>
          BoostBook element <sgmltag>programlisting</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>programlisting</refname><refpurpose>A sample of program code</refpurpose></refnamediv><refsynopsisdiv>programlisting ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>name</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.complexity"><refmeta><refentrytitle>
          BoostBook element <sgmltag>complexity</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>complexity</refname><refpurpose>The time/space/etc. complexity of a function</refpurpose></refnamediv><refsynopsisdiv>complexity ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.purpose"><refmeta><refentrytitle>
          BoostBook element <sgmltag>purpose</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>purpose</refname><refpurpose>A short description of an entity's use</refpurpose></refnamediv><refsynopsisdiv>purpose ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.template-nontype-parameter"><refmeta><refentrytitle>
          BoostBook element <sgmltag>template-nontype-parameter</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>template-nontype-parameter</refname><refpurpose>A nontype template parameter</refpurpose></refnamediv><refsynopsisdiv>template-nontype-parameter ::= 
  (<link linkend="boostbook.dtd.type">type</link>, <link linkend="boostbook.dtd.default">default</link>?, <link linkend="boostbook.dtd.purpose">purpose</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.library"><refmeta><refentrytitle>
          BoostBook element <sgmltag>library</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>library</refname><refpurpose>Top-level element for a library</refpurpose></refnamediv><refsynopsisdiv>library ::= 
  (<link linkend="boostbook.dtd.libraryinfo">libraryinfo</link>, (title, ((section| <link linkend="boostbook.dtd.library-reference">library-reference</link>| <link linkend="boostbook.dtd.testsuite">testsuite</link>))+)?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>dirname</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry/></row><row><entry>url</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry/></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row><row><entry>html-only</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry/></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.librarycategorylist"><refmeta><refentrytitle>
          BoostBook element <sgmltag>librarycategorylist</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>librarycategorylist</refname><refpurpose>Categorized listing of libraries</refpurpose></refnamediv><refsynopsisdiv>librarycategorylist ::= 
  (<link linkend="boostbook.dtd.librarycategorydef">librarycategorydef</link>)*
</refsynopsisdiv><refsection><title>Description</title><para>This element is not intended for use by developers, but is
  used by <filename>doc/src/boost.xml</filename> as a
  placeholder.</para></refsection><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.using-namespace"><refmeta><refentrytitle>
          BoostBook element <sgmltag>using-namespace</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>using-namespace</refname><refpurpose>Injects the declared names from a namespace into the local scope</refpurpose></refnamediv><refsynopsisdiv>using-namespace ::= 
  EMPTY
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.struct-specialization"><refmeta><refentrytitle>
          BoostBook element <sgmltag>struct-specialization</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>struct-specialization</refname><refpurpose>A specialization (full or partial) of a struct template</refpurpose></refnamediv><refsynopsisdiv>struct-specialization ::= 
  (<link linkend="boostbook.dtd.template">template</link>?, <link linkend="boostbook.dtd.specialization">specialization</link>?, <link linkend="boostbook.dtd.inherit">inherit</link>?, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?, (<link linkend="boostbook.dtd.static-constant">static-constant</link>| <link linkend="boostbook.dtd.typedef">typedef</link>| <link linkend="boostbook.dtd.enum">enum</link>| <link linkend="boostbook.dtd.copy-assignment">copy-assignment</link>| <link linkend="boostbook.dtd.constructor">constructor</link>| <link linkend="boostbook.dtd.destructor">destructor</link>| <link linkend="boostbook.dtd.method-group">method-group</link>| <link linkend="boostbook.dtd.free-function-group">free-function-group</link>| <link linkend="boostbook.dtd.function">function</link>| <link linkend="boostbook.dtd.method">method</link>| <link linkend="boostbook.dtd.overloaded-function">overloaded-function</link>| <link linkend="boostbook.dtd.overloaded-method">overloaded-method</link>| <link linkend="boostbook.dtd.data-member">data-member</link>| <link linkend="boostbook.dtd.class">class</link>| <link linkend="boostbook.dtd.class-specialization">class-specialization</link>| <link linkend="boostbook.dtd.struct">struct</link>| <link linkend="boostbook.dtd.struct-specialization">struct-specialization</link>| <link linkend="boostbook.dtd.union">union</link>| <link linkend="boostbook.dtd.union-specialization">union-specialization</link>)*)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.struct"><refmeta><refentrytitle>
          BoostBook element <sgmltag>struct</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>struct</refname><refpurpose>Declares a C++ struct</refpurpose></refnamediv><refsynopsisdiv>struct ::= 
  (<link linkend="boostbook.dtd.template">template</link>?, <link linkend="boostbook.dtd.inherit">inherit</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?, (<link linkend="boostbook.dtd.static-constant">static-constant</link>| <link linkend="boostbook.dtd.typedef">typedef</link>| <link linkend="boostbook.dtd.enum">enum</link>| <link linkend="boostbook.dtd.copy-assignment">copy-assignment</link>| <link linkend="boostbook.dtd.constructor">constructor</link>| <link linkend="boostbook.dtd.destructor">destructor</link>| <link linkend="boostbook.dtd.method-group">method-group</link>| <link linkend="boostbook.dtd.free-function-group">free-function-group</link>| <link linkend="boostbook.dtd.function">function</link>| <link linkend="boostbook.dtd.method">method</link>| <link linkend="boostbook.dtd.overloaded-function">overloaded-function</link>| <link linkend="boostbook.dtd.overloaded-method">overloaded-method</link>| <link linkend="boostbook.dtd.data-member">data-member</link>| <link linkend="boostbook.dtd.class">class</link>| <link linkend="boostbook.dtd.class-specialization">class-specialization</link>| <link linkend="boostbook.dtd.struct">struct</link>| <link linkend="boostbook.dtd.struct-specialization">struct-specialization</link>| <link linkend="boostbook.dtd.union">union</link>| <link linkend="boostbook.dtd.union-specialization">union-specialization</link>)*)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.lib"><refmeta><refentrytitle>
          BoostBook element <sgmltag>lib</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>lib</refname><refpurpose>A library dependency</refpurpose></refnamediv><refsynopsisdiv>lib ::= 
  (#PCDATA)
</refsynopsisdiv><refsection><title>Description</title><para>Declares a library dependency on the library named by the content of this element, to be emitted in a Jamfile.</para></refsection></refentry><refentry id="boostbook.dtd.enum"><refmeta><refentrytitle>
          BoostBook element <sgmltag>enum</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>enum</refname><refpurpose>Declares an enumeration type</refpurpose></refnamediv><refsynopsisdiv>enum ::= 
  (<link linkend="boostbook.dtd.enumvalue">enumvalue</link>*, <link linkend="boostbook.dtd.purpose">purpose</link>?, <link linkend="boostbook.dtd.description">description</link>?)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.requires"><refmeta><refentrytitle>
          BoostBook element <sgmltag>requires</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>requires</refname><refpurpose>Declares the requirements of a function</refpurpose></refnamediv><refsynopsisdiv>requires ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.effects"><refmeta><refentrytitle>
          BoostBook element <sgmltag>effects</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>effects</refname><refpurpose>Declares the side effects of a function</refpurpose></refnamediv><refsynopsisdiv>effects ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.libraryname"><refmeta><refentrytitle>
          BoostBook element <sgmltag>libraryname</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>libraryname</refname><refpurpose>References a library of the given name</refpurpose></refnamediv><refsynopsisdiv>libraryname ::= 
  (#PCDATA)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.libraryinfo"><refmeta><refentrytitle>
          BoostBook element <sgmltag>libraryinfo</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>libraryinfo</refname><refpurpose>Provides information about a library</refpurpose></refnamediv><refsynopsisdiv>libraryinfo ::= 
  (author+, copyright*, legalnotice*, <link linkend="boostbook.dtd.librarypurpose">librarypurpose</link>, <link linkend="boostbook.dtd.librarycategory">librarycategory</link>*)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.testsuite"><refmeta><refentrytitle>
          BoostBook element <sgmltag>testsuite</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>testsuite</refname><refpurpose>Describes a library testsuite</refpurpose></refnamediv><refsynopsisdiv>testsuite ::= 
  ((<link linkend="boostbook.dtd.compile-test">compile-test</link>| <link linkend="boostbook.dtd.link-test">link-test</link>| <link linkend="boostbook.dtd.run-test">run-test</link>| <link linkend="boostbook.dtd.compile-fail-test">compile-fail-test</link>| <link linkend="boostbook.dtd.link-fail-test">link-fail-test</link>| <link linkend="boostbook.dtd.run-fail-test">run-fail-test</link>)+)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.header"><refmeta><refentrytitle>
          BoostBook element <sgmltag>header</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>header</refname><refpurpose>Declares a C++ header with the given name</refpurpose></refnamediv><refsynopsisdiv>header ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>name</entry><entry>#REQUIRED</entry><entry>CDATA</entry><entry>The name of the element being declared to referenced</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry><refentry id="boostbook.dtd.rationale"><refmeta><refentrytitle>
          BoostBook element <sgmltag>rationale</sgmltag></refentrytitle><manvolnum>9</manvolnum></refmeta><refnamediv><refname>rationale</refname><refpurpose>Describes the rationale for a particular function's design</refpurpose></refnamediv><refsynopsisdiv>rationale ::= 
  (ANY)
</refsynopsisdiv><refsection><title>Attributes</title><informaltable><tgroup cols="4"><thead><row><entry>Name</entry><entry>Type</entry><entry>Value</entry><entry>Purpose</entry></row></thead><tbody><row><entry>last-revision</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Set to $Date: 2004/07/05 16:26:11 $ to keep "last revised" information in sync with CVS changes</entry></row><row><entry>id</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>A global identifier for this element</entry></row><row><entry>xml:base</entry><entry>#IMPLIED</entry><entry>CDATA</entry><entry>Implementation detail used by XIncludes</entry></row></tbody></tgroup></informaltable></refsection></refentry></chapter></part><part xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="bbv2" rev:last-revision="$Date: 2004/10/30 09:35:01 $" xml:base="../tools/build/v2/doc/src/userman.xml"><title>Boost.Build v2 User Manual</title><chapter id="bbv2.howto" xml:base="../tools/build/v2/doc/src/howto.xml"><title>How to use this document</title><para>
      If you've just found out about Boost.Build V2 and want to know
      if it will work for you, start with <xref linkend="bbv2.tutorial"/>. You can continue with the <xref linkend="bbv2.advanced"/>. When you're ready to try Boost.Build
      in practice, go to <xref linkend="bbv2.installation"/>.
    </para><para>
      If you are about to use Boost.Build on your project, or already
      using it and have a problem, look at <xref linkend="bbv2.advanced"/>.
    </para><para>
      If you're trying to build a project which uses Boost.Build,
      look at <xref linkend="bbv2.installation"/> and then read about
      <xref linkend="bbv2.reference.commandline"/>.
    </para><para>
      If you have questions, please post them to our <ulink url="http://boost.org/more/mailing_lists.htm#jamboost">mailing
      list</ulink>, and be sure to indicate in the subject line that
      you're asking about Boost.Build <emphasis role="bold">V2</emphasis>.
    </para></chapter><chapter id="bbv2.installation" xml:base="../tools/build/v2/doc/src/install.xml"><title>Installation</title><para>
      This section describes how to install Boost.Build from a
      released source distribution. All paths are given relative to
      the <firstterm>Boost.Build v2 root directory</firstterm>, which is 

      

      located in the <filename>tools/build/v2</filename> subdirectory
      of a full <ulink url="http://www.boost.org">Boost</ulink>
      distribution.
    </para><orderedlist><listitem><simpara>
          Boost.Build uses <ulink url="../../tools/build/jam_src/index.html">Boost.Jam</ulink>, an
          extension of the <ulink url="http://www.perforce.com/jam/jam.html">Perforce
          Jam</ulink> portable <command>make</command> replacement. The
          recommended way to get Boost.Jam is to <emphasis role="bold"><ulink url="http://sourceforge.net/project/showfiles.php?group_id=7586&amp;package_id=72941">download
          a prebuilt executable</ulink></emphasis> from SourceForge.
          If a prebuilt executable is not provided for your platform
          or you are using Boost's sources in an unreleased state, it
          may be neccessary to <ulink url="../../tools/build/jam_src/index.html#building_bjam">build <command>bjam</command>
          from sources</ulink> included in the Boost source tree.
        </simpara></listitem><listitem><para>

          To install Boost.Jam, copy the executable,
          called <command>bjam</command>
          or <command>bjam.exe</command> to a location accessible in
          your <envar>PATH</envar>.  Go to the Boost.Build root
          directory and
          run <command>bjam <option>--version</option></command>. You
          should see:

          <screen>
            Boost.Build V2 (Milestone N)
            Boost.Jam xx.xx.xx 
          </screen>

          where N is the version of Boost.Build you're using.
        </para></listitem><listitem><simpara>
          Configure Boost.Build to recognize the build resources (such
          as compilers and libraries) you have installed on your
          system.  Open the
          <filename>user-config.jam</filename> file in the Boost.Build
          root directory and follow the instructions there to describe
          your toolsets and libraries, and, if neccessary, where they
          are located.
        </simpara></listitem><listitem><simpara>
          You should now be able to go to the
          <filename>example/hello/</filename> directory and run
          <command>bjam</command> there. A simple application will be
          built. You can also play with other projects in the
          <filename>example/</filename> directory. 
    </simpara></listitem></orderedlist><para>
      If you are using Boost's CVS state, be sure to
      rebuild <command>bjam</command> even if you have a previous
      version.  The CVS version of Boost.Build requires the CVS
      version of Boost.Jam.
    </para><para>
      When <command>bjam</command> is invoked, it always needs to be
      able to find the Boost.Build root directory, where the
      interpreted source code of Boost.Build is located.  There are
      two ways to tell <command>bjam</command> about the root directory:
    </para><itemizedlist><listitem><simpara>
          Set the environment variable <envar>BOOST_BUILD_PATH</envar>
          to the absolute path of the Boost.Build root directory.
        </simpara></listitem><listitem><para>
          At the root directory of your project or in any of its
          parent directories, create a file called
          <filename>boost-build.jam</filename>, with a single line:

<programlisting>
boost-build <replaceable>/path/to/boost.build</replaceable> ;
</programlisting></para></listitem></itemizedlist><para><emphasis role="bold">N.B.</emphasis>
  When <command>bjam</command> is invoked from anywhere in the Boost
  directory tree <emphasis>other than</emphasis> the Boost.Build root
  and its subdirectories, <ulink url="../../tools/build">Boost.Build
  v1</ulink> is used by default. To override the default and use
  Boost.Build v2, you have to add the <option>--v2</option> command
  line option to all <command>bjam</command> invocations.</para></chapter><chapter id="bbv2.tutorial" status="draft" xml:base="../tools/build/v2/doc/src/tutorial.xml"><title>Tutorial</title><section id="bbv2.tutorial.hello"><title>Hello, world</title><para>The simplest project that Boost.Build can construct is
      stored in <filename>example/hello/</filename> directory. The
      project is described by a file
      called <filename>Jamfile</filename> that contains:

<programlisting>
exe hello : hello.cpp ;
</programlisting>

      Even with this simple setup, you can do some interesting
      things. First of all, just invoking <command>bjam</command> will
      build the debug variant of the <command>hello</command>
      executable by compiling and
      linking <filename>hello.cpp</filename>.  Now, to build the
      release variant of <command>hello</command>, invoke

<screen>
bjam release
</screen>

      Note that debug and release variants are created in different
      directories, so you can switch between variants or even build
      multiple variants at once, without any unneccessary
      recompilation. Let's extend the example by adding another line
      to our project's <filename>Jamfile</filename>:

<programlisting>
exe hello2 : hello.cpp ;
</programlisting>

      Now we can build both the debug and release variants of our
      project:

<screen>
bjam debug release
</screen>

      Note that two variants of <command>hello2</command> are linked.
      Since we have already built both variants
      of <command>hello</command>, hello.cpp won't be recompiled;
      instead the existing object files will just be linked into the
      corresponding variants of <command>hello2</command>. Now 
      let's remove all the built products:

<screen>
bjam --clean debug release
</screen>

      It's also possible to build or clean specific targets.  The
      following two commands, respectively, build or clean only the
      debug version of <command>hello2</command>.

<screen>
bjam hello2
bjam --clean hello2
</screen></para></section><section id="bbv2.tutorial.properties"><title>Properties</title><para>
      To portably represent aspects of target configuration such as
      debug and release variants, or single- and multi-threaded
      builds, Boost.Build uses <firstterm>features</firstterm> with
      associated <firstterm>values</firstterm>.  For
      example, the "debug-symbols" feature can have a value of "on" or
      "off".  A <firstterm>property</firstterm> is just a (feature,
      value) pair.  When a user initiates a build, Boost.Build
      automatically translates the requested properties into appropriate
      command-line flags for invoking toolset components like compilers
      and linkers.</para><para>There are many built-in features that can be combined to
      produce arbitrary build configurations.  The following command
      builds the project's "release" variant with inlining
      disabled and debug symbols enabled:

<screen>
bjam release inlining=off debug-symbols=on
</screen></para><para>Properties on the command-line are specified with the syntax:

<screen><replaceable>feature-name</replaceable>=<replaceable>feature-value</replaceable></screen></para><para>The "release" and "debug" that we've seen
      in <command>bjam</command> invocations are just a shorthand way to
      specify values of the "variant" feature.  For example, the command
      above could also have been written this way:

      <screen>
bjam variant=release inlining=off debug-symbols=on
      </screen></para><para>  "variant" is so commonly-used that it has been given
      special status as an <firstterm>implicit</firstterm> feature
      &#x2014; Boost.Build will deduce the its identity just from the name
      of one of its values.  
    </para><para>
      A complete description of features can be found
      <link linkend="bbv2.reference.features">here</link>. 
    </para><section id="bbv2.tutorial.properties.requirements"><title>Build Requests and Target Requirements</title><para>      
        The set of properties specified in the command line constitute a
        <firstterm>build request</firstterm> &#x2014; a description of
        the desired properties for building the requested targets (or,
        if no targets were explicitly requested, the project in the
        current directory).  The <emphasis>actual</emphasis> properties
        used for building targets is typically a combination of the
        build request and properties derived from the
        project's <filename>Jamfile</filename>s.  For example, the
        locations of <computeroutput>#include</computeroutput>d header files are normally
        not specified on the command-line, but described
        in <filename>Jamfile</filename>s as <firstterm>target
          requirements</firstterm> and automatically combined with the
        build request for those targets.  Multithread-enabled
        compilation is another example of a typical target requirement.
        The <filename>Jamfile</filename> fragment below illustrates how
        these requirements might be specified.
      </para><programlisting>
exe hello 
    : hello.cpp
    : &lt;include&gt;/home/ghost/Work/boost &lt;threading&gt;multi
    ;
</programlisting><para> 
        When <filename>hello</filename> is built, the two
        requirements specified above will normally always be present.
        If the build request given on the <command>bjam</command>
        command-line explictly contradicts a target's requirements,
        the command-line usually overrides (or, in the case of
        "free" feautures like <computeroutput>&lt;include&gt;</computeroutput><footnote>See <xref linkend="bbv2.reference.features.attributes"/></footnote>,
        augments) the target requirements.  
</para></section><section id="bbv2.tutorial.properties.project_attributes"><title>Project Attributes</title><para>
        If we want the same requirements for our other
        target, <filename>hello2</filename>, we could simply duplicate
        them.  However, as projects grow, that approach leads to a great
        deal of repeated boilerplate in Jamfiles.
        
        Fortunately, there's a better way. Each project (i.e. each
        <filename>Jamfile</filename>), can specify a set of <firstterm>attributes</firstterm>,
        including requirements:

<programlisting>
project 
    : requirements &lt;include&gt;/home/ghost/Work/boost &lt;threading&gt;multi 
    ;

exe hello : hello.cpp ;
exe hello2 : hello.cpp ;
</programlisting>

        The effect would be as if we specified the same requirement for
        both <command>hello</command> and <command>hello2</command>.
      </para></section></section><section id="bbv2.tutorial.hierarchy"><title>Project Hierarchies</title><para>So far we've only considered examples with one project
      (i.e. with one <filename>Jamfile</filename>). A typical large
      software project would be composed of sub-projects organized
      into a tree. The top of the tree is called the
      <firstterm>project root</firstterm>.  Besides a
      <filename>Jamfile</filename>, the project root directory
      contains a file called <filename>project-root.jam</filename>. Every other
      <filename>Jamfile</filename> in the project has a single parent
      project, rooted in the nearest parent directory containing a
      <filename>Jamfile</filename>. For example, in the following
      directory layout:

<screen>
top/ 
  |
  +-- Jamfile
  +-- project-root.jam
  |
  +-- src/
  |    |
  |    +-- Jamfile
  |    `-- app.cpp
  | 
  `-- util/
       |
       +-- foo/
       .    |
       .    +-- Jamfile
       .    `-- bar.cpp
</screen>

      the project root is <filename>top/</filename>.  Because there is
      no <filename>Jamfile</filename> in
      <filename>top/util/</filename>, the projects in
      <filename>top/src/</filename> and
      <filename>top/util/foo/</filename> are immediate children of the
      root project.
    </para><para>
      Projects inherit all attributes (such as requirements)
      from their parents.  Inherited requirements are combined with
      any requirements specified by the sub-project.  
      For example, if <filename>top/Jamfile</filename> has

<programlisting>
&lt;include&gt;/home/ghost/local
</programlisting>

      in its requirements, then all of its sub-projects will have it
      in their requirements, too.  Of course, any project can add
      additional includes. <footnote>Many features will be overridden,
      rather than added-to, in sub-projects.  See <xref linkend="bbv2.reference.features.attributes"/> for more
      information</footnote> More details can be found in the section
      on <link linkend="bbv2.advanced.projects">projects</link>.
    </para><para>
      Invoking <command>bjam</command> without explicitly specifying
      any targets on the command-line builds the project rooted in the
      current directory.  Building a project does not automatically
      cause its sub-projects to be built unless the parent project's
      <filename>Jamfile</filename> explicitly requests it. In our
      example, <filename>top/Jamfile</filename> might contain:

<programlisting>
build-project src ;
</programlisting>

      which would cause the project in <filename>top/src/</filename>
      to be built whenever the project in <filename>top/</filename> is
      built. However, targets in <filename>top/util/foo/</filename>
      will be built only if they are needed by targets in
      <filename>top/</filename> or <filename>top/src/</filename>.
    </para></section><section id="bbv2.tutorial.libs"><title>Libraries and Dependent Targets</title><comment>TODO: need to make this
      section consistent with "examples-v2/libraries".</comment><para>
      Targets that are "needed" by other targets are called
      <firstterm>dependencies</firstterm> of those other targets.  The
      targets that need the other targets are called
      <firstterm>dependent</firstterm> targets.
    </para><para>To get a feeling of target dependencies, let's continue the
      above example and see how <filename>src/Jamfile</filename> can
      use libraries from <filename>util/foo</filename>.  Assume
      util/foo/Jamfile contains:

<programlisting>
lib bar : bar.cpp ;
</programlisting>

      Then, to use this library in <filename>src/Jamfile</filename>, we can write:

<programlisting>
exe app : app.cpp ../util/foo//bar ;
</programlisting>

      While <computeroutput>app.cpp</computeroutput> refers to a regular source file,
      <computeroutput>../util/foo//bar</computeroutput> is a reference to another target:
      a library "bar" declared in the <filename>Jamfile</filename> at
      <filename>../util/foo</filename>.  When linking the
      <command>app</command> executable, the appropriate version of
      <computeroutput>bar</computeroutput> will be built and linked in. What do we mean by
      "appropriate"? For example, suppose we build "app" with:

<screen>
bjam app optimization=full cxxflags=-w-8080
</screen>

      Which properties must be used to build <computeroutput>foo</computeroutput>? The
      answer is that some properties are
      <firstterm>propagated</firstterm> &#x2014; Boost.Build attempts to
      use dependencies with the same value of propagated features. The
      &lt;optimization&gt; feature is propagated, so both "app" and
      "foo" will be compiled with full optimization. But
      &lt;cxxflags&gt; feature is not propagated: its value will be
      added as-is to compiler flags for "a.cpp", but won't affect
      "foo". There is still a couple of problems. First, the library
      probably has some headers which must be used when compiling
      "app.cpp". We could use requirements on "app" to add those
      includes, but then this work will be repeated for all programs
      which use "foo". A better solution is to modify
      util/foo/Jamfilie in this way:

<programlisting>
project 
    : usage-requirements &lt;include&gt;.
    ;

lib foo : foo.cpp ;
</programlisting>

      Usage requirements are requirements which are applied to
      dependents. In this case, &lt;include&gt; will be applied to all
      targets which use "foo" &#x2014; i.e. targets which have "foo"
      either in sources or in dependency properties. You'd need to
      specify usage requirements only once, and programs which use "foo"
      don't have to care about include paths any longer. Or course, the
      path will be interpreted relatively to "util/foo" and will be
      adjusted according to the <command>bjam</command>s invocation
      directory. For
      example, if building from project root, the final compiler's
      command line will contain <option>-Ilib/foo</option>.
    </para><para>The second problem is that we hardcode the path to library's
      Jamfile. Imagine it's hardcoded in 20 different places and we
      change the directory layout. The solution is to use project ids
      &#x2014; symbolic names, not tied to directory layout. First, we
      assign a project id to Jamfile in util/foo:</para><programlisting>
project foo
    : usage-requirements &lt;include&gt;.
    ;
</programlisting><para>
      Second, we use the project id to refer to the library in
      src/Jamfile:

<programlisting>
exe app : app.cpp /foo//bar ;
</programlisting>

      The "/foo//bar" syntax is used to refer to target "foo" in
      project with global id "/foo" (the slash is used to specify global
      id). This way, users of "foo" do not depend on its location, only
      on id, which is supposedly stable. The only thing left, it to make
      sure that src/Jamfile knows the project id that it uses. We add to
      top/Jamfile the following line:

<programlisting>
use-project /foo : util/foo ;
</programlisting>

      Now, all projects can refer to "foo" using the symbolic
      name. If the library is moved somewhere, only a single line in the
      top-level Jamfile should be changed.
    </para></section><section id="bbv2.tutorial.depends"><title>Library dependencies</title><para>The previous example was simple. Often, there are long chains
      of dependencies between libraries. The main application is a thin
      wrapper on top of library with core logic, which uses library of
      utility functions, which uses boost filesystem library.
      Expressing these dependencies is straightforward:</para><programlisting>
lib utils : utils.cpp /boost/filesystem//fs ;   
lib core : core.cpp utils ;
exe app : app.cpp core ;
</programlisting><para>So, what's the reason to even mention this case? First,
      because it's a bit more complex that it seems. When using shared
      linking, libraries are build just as written, and everything will
      work. However, what happens with static linking? It's not
      possible to include another library in static library.
      Boost.Build solves this problem by returning back library targets
      which appear as sources for static libraries. In this case, if
      everything is built statically, the "app" target will link not
      only "core" library, but also "utils" and
      "/boost/filesystem//fs".</para><para>So, the net result is that the above code will work for both
      static linking and for shared linking.</para><para>Sometimes, you want all applications in some project to link
      to a certain library. Putting the library in sources of all
      targets is possible, but verbose. You can do better by using the
      &lt;source&gt; property. For example, if "/boost/filesystem//fs"
      should be linked to all applications in your project, you can add
      &lt;source&gt;/boost/filesystem//fs to requirements of the
      project, like this:</para><programlisting>
project 
   : requirements &lt;source&gt;/boost/filesystem//fs
   ;   
</programlisting></section><section id="bbv2.tutorial.linkage"><title>Static and shared libaries</title><para>While the
      previous section explained how to create and use libraries, it
      omitted one important detail. Libraries can be either
      <emphasis>static</emphasis>, which means they are included in executable
      files which use them, or <emphasis>shared</emphasis> (a.k.a.
      <emphasis>dynamic</emphasis>), which are only referred to from executables,
      and must be available at run time. Boost.Build can work with both
      types. By default, all libraries are shared. This is much more
      efficient in build time and space. But the need to install all
      libraries to some location is not always convenient, especially
      for debug builds. Also, if the installed shared library changes,
      all application which use it might start to behave differently.
    </para><para>Static libraries do not suffer from these problems, but
      considerably increase the size of application. Before describing
      static libraries, it's reasonable to give another, quite simple
      approach. If your project is built with
      &lt;hardcode-dll-paths&gt;true property, then the application
      will include the full paths for all shared libraries, eliminating
      the above problems. Unfortunately, you no longer can move shared
      library to a different location, which makes this option suitable
      only for debug builds. Further, only gcc compiler supports this
      option.</para><para>Building a library statically is easy. You'd need to change
      the value of &lt;link&gt; feature from it's deafault value
      <literal>shared</literal>, to <literal>static</literal>. So, to build everything as
      static libraries, you'd say</para><screen>
bjam link=static
</screen><para>
      on the command line. The linking mode can be fine-tuned on
      per-target basis.

      <orderedlist><listitem><para>
            Suppose your library can be only build statically. This is
            easily achieved using requirements:

<programlisting>
lib l : l.cpp : &lt;link&gt;static ;
</programlisting></para></listitem><listitem><para>
            What if library can be both static and shared, but when
            using it in specific executable, you want it static?
            <link linkend="bbv2.reference.targets.references">Target
              references</link> are here to help:

<programlisting>
exe important : main.cpp helpers/&lt;link&gt;static ;
</programlisting></para></listitem><listitem><para>
            What if the library is defined in some other project, which
            you cannot change. But still, you want static linking to that
            library in all cases. You can use target references everywhere:

<programlisting>
exe e1 : e1.cpp /other_project//bar/&lt;link&gt;static ;
exe e10 : e10.cpp /other_project//bar/&lt;link&gt;static ;
</programlisting>

            but that's far from being convenient. Another way is to
            introduce a level of indirection: create a local target, which will
            refer to static version of <filename>foo</filename>. Here's the
            solution:

<programlisting>
alias foo : /other_project//bar/&lt;link&gt;static ;
exe e1 : e1.cpp foo ;
exe e10 : e10.cpp foo ;
</programlisting>

            Note that the <link linkend="bbv2.builtins.alias">alias</link> 
            rule is specifically used for rename a reference to a target and possibly
            change the properties.

          </para></listitem></orderedlist></para></section><section id="bbv2.tutorial.conditions"><title>Conditions and alternatives</title><para>As we've just figured out, properties can significally affect the
      way targets are built. The processing of the &lt;link&gt; feature is
      built in the build system, and is quite complex. But there is a couple
      of mechanisms which allow ordinary users to do different things 
      depending on properties.
    </para><para>The first mechanism is called <firstterm>conditinal
        requirement</firstterm>. For example, you might want to set specific
      defines when the library is build as shared, or you have your own define
      to be used in release mode. Here's a piece of Jamfile.
<programlisting>
lib network : network.cpp 
    : &lt;link&gt;shared:&lt;define&gt;NEWORK_LIB_SHARED 
      &lt;variant&gt;release:&lt;define&gt;EXTRA_FAST
    ;
</programlisting>
      This will have exactly the effect we wanted: whenever &lt;link&gt;shared
      is in properties, &lt;define&gt;NEWORK_LIB_SHARED will be in properties
      as well.
    </para><para>
      Sometimes different variant of a target are so different, that
      describing them using conditional requirements would be hard. Imagine
      that a library has different sources on two supported toolsets, and
      dummy implementation for all the other toolset. We can express this
      situation using <firstterm>target alternatives</firstterm>:
<programlisting>
lib demangler : dummy_demangler.cpp ;
lib demangler : demangler_gcc.cpp : &lt;toolset&gt;gcc ;
lib demangler : demangler_msvc.cpp : &lt;toolset&gt;msvc ;
</programlisting>
      The proper alternative will be automatically selected. 
    </para></section><section id="bbv2.tutorial.prebuilt"><title>Prebuilt targets</title><para>
      We've just learned how to use libraries which are created by
      Boost.Build. But some libraries are not. At the same time, those
      libraries can have different versions (release and debug, for
      example), that we
      should select depending on build properties. Prebuilt targets
      provide a mechanism for that. Jamfile in util/lib2 can contain:

<programlisting>
lib lib2
    : 
    : &lt;file&gt;lib2_release.a &lt;variant&gt;release
    ;

lib lib2
    : 
    : &lt;file&gt;lib2_debug.a &lt;variant&gt;debug
    ;
</programlisting>

      This defines two alternatives for target "lib2", and for each
      one names a prebuilt file. Naturally, there are no sources.
      Instead, the &lt;file&gt; feature is used to specify the file name.
      Which alternative is selected depends on properties of dependents.
      If "app" binary should use "lib2", we can write:

<programlisting>
exe app : app.cpp ../util/lib2//lib2 ;
</programlisting>

      If we build release version of "app", then it will be linked
      with "lib2_release.a", and debug version will use "lib2_debug.a".
      Another important kind of prebuilt targets are system libraries
      &#x2014; more specifically, libraries which are automatically found
      by the compiler. E.g. gcc uses "-l" switch for that. Such libraries
      should be declared almost like regular ones:

<programlisting>
lib zlib : : &lt;name&gt;z ;
</programlisting>

      We again don't specify any sources, but give a name which
      should be passed to the compiler. In this example, and for gcc
      compiler, the "-lz" option will be added. Paths where library
      should be searched can also be specified:

<programlisting>
lib zlib : : &lt;name&gt;z &lt;search&gt;/opt/lib ;
</programlisting>

      And, of course, two variants can be used:

<programlisting>
lib zlib : : &lt;name&gt;z &lt;variant&gt;release ;
lib zlib : : &lt;name&gt;z_d &lt;variant&gt;debug ;
</programlisting>

      Of course, you'll probably never in your life need debug
      version of zlib, but for other libraries this is quite reasonable.
    </para><para>More advanced use of prebuilt target is described in <link linkend="bbv2.recipies.site-config">a FAQ entry</link>.</para></section></chapter><chapter id="bbv2.advanced" xml:base="../tools/build/v2/doc/src/advanced.xml"><title>User documentation</title><para>This section will provide the information necessary to create your own
  projects using Boost.Build. The information provided here is relatively
  high-level, and <link linkend="bbv2.reference">detailed reference</link> as
  well as the on-line help system must be used to obtain
  low-level documentation (see the <link linkend="bbv2.reference.init.options.help">help option</link>).</para><para>The Boost.Build actually consists of two parts - Boost.Jam, which is a
  build engine with its own interpreted language, and Boost.Build itself,
  implemented in Boost.Jam's language. The chain of event which happen when
  you type "bjam" on the command is:
      <orderedlist><listitem><para>Boost.Jam tries to find Boost.Build and loads the top-level
          module. The exact process is described in the <link linkend="bbv2.reference.init">section on
          initialization</link></para></listitem><listitem><para>Boost.Build top-level module loads user-defined configuration
          files, "user-config.jam" and "site-config.jam", which define
          available toolsets.</para></listitem><listitem><para>The Jamfile in the current directory is read. That in turn
          might cause reading of further Jamfiles. As a result, a tree of
          projects is created, with targets inside projects.</para></listitem><listitem><para>Finally, using build request specified on the command line,
          Boost.Build decides which targets should be built, and how. That
          information is passed back to Boost.Jam, which takes care of
          actually running commands.</para></listitem></orderedlist></para><para>So, to be able to successfully use Boost.Build, you'd need to know only
      three things:
      <itemizedlist><listitem><para><link linkend="bbv2.advanced.configuration">
              How to configure Boost.Build</link></para></listitem><listitem><para><link linkend="bbv2.advanced.jamfiles">
              How to write Jamfiles</link></para></listitem><listitem><para><link linkend="bbv2.advanced.build_process">
              How the build process works</link></para></listitem></itemizedlist></para><section id="bbv2.advanced.configuration"><title>Configuration</title><para>The Boost.Build configuration is specified in the file
    "user-config.jam". You can edit the one which comes with Boost.Build, or
    create a copy in your home directory and edit that. (See the <link linkend="bbv2.reference.init.config">reference</link> for the exact search
    paths.) The primary function of that file is to declarate which compilers
    and other tools are available. The simplest syntax to configure a tool is:
<programlisting>
using &lt;tool-name&gt; ;        
</programlisting>
      The "using" rule is given a name of tool, and will make that tool
      available to Boost.Build. For example, "using gcc ;" will make available
      the gcc compiler.      
    </para><para>
      Since nothing but tool name is specified, Boost.Build will pick some
      default settings -- for example will use gcc found in path, or look in
      some known installation locations. For ordinary users, this is quite
      fine. In case you have several version of a compiler, or it's located in
      some unusual location, or you need to tweak the configuration, you'd
      need to pass additional parameters to the "using" rule. Generally, 
      for every tool module, the parameters differ, and you can obtain the documentaiton
      by running
<programlisting>
bjam --help &lt;tool-name&gt;.init         
</programlisting>
      on the command line. However, for all compilers the meaning of the first
      three parameters is the same: version, invocation command and options.
    </para><para>The "version" parameter identifies the compiler, in case you have
    several. It can have any form you like, but it's recommended that you use
    a numeric identifier, like "7.1". The "invocation command"
    parameter is the command which must be executed to run the compiler. This
    might be just compiler name, or a name with a path in it. Here are some
    examples. 
    </para><para>To configure a compiler installed in non-standard location and not
    present in path, you can do the following:
<programlisting>
using msvc : : Z:/Programs/Microsoft Visual Studio/vc98/bin/cl.exe ;
</programlisting></para><para>To configure several versions of a compiler, the following can be used.
<programlisting>
using gcc : 3.3 ;
using gcc : 3.4 : g++-3.4 ;
using gcc : 3.2 : g++-3.2 ;
</programlisting>
        Note that in the first call to "using", the compiler found in path
      will be used, and there's no need to explicitly specify the command.
    </para><para>As shown above, both "version" and "invocation command" parameters
      are optional, but there's an important restriction: if you configure the
      same compiler more then once, you must pass the "version" parameter
      every time. For example, the following is not allowed:
<programlisting>
using gcc ;
using gcc : 3.4 : g++-3.4 ;
</programlisting>
      because the first "using" does not specify the version. 
    </para><para>The <computeroutput>options</computeroutput> parameter is used to fine-tune the
      configuration. All compilers allow to pass four option, intentionally
      similiar in spelling to builtin features: <computeroutput>cflags</computeroutput>,
      <computeroutput>cxxflags</computeroutput>, <computeroutput>compileflags</computeroutput> and
      <computeroutput>linkflags</computeroutput>. They specify additional options which will be
      always passed to the corresponding tools. The <computeroutput>cflags</computeroutput> option
      applies only to the C compiler, the <computeroutput>cxxflags</computeroutput> option applies
      only to the C++ compiler and the <computeroutput>compileflags</computeroutput> options
      applies to both. For example, to use 64 bit mode with gcc you can use:
<programlisting>
using gcc : 3.4 : : &lt;compileflags&gt;-m64 &lt;linkflags&gt;-m64 ;
</programlisting></para></section><section id="bbv2.advanced.jamfiles"><title>Writing Jamfiles</title><section id="bbv2.advanced.overview"><title>Overview</title><para>Jamfiles are the thing which is most important to the user,
      bacause they declare the targets which should be build. Jamfiles are
      also used for organizing targets -- each Jamfile is a separate project,
      which can be build independently from the other projects.</para><para>Jamfile mostly contain calls to Boost.Build functions, which do
        all the work, specifically:
        <itemizedlist><listitem><para><link linkend="bbv2.advanced.targets">declare main
                targets</link></para></listitem><listitem><para><link linkend="bbv2.advanced.projects">define
            project properties</link></para></listitem><listitem><para><link linkend="bbv2.advanced.other-rules">do various other
            things</link></para></listitem></itemizedlist></para><para>In addition to Jamfiles, Boost.Build has another user-editable
        file, project-root.jam, which is mostly useful to declare constants
        global to all the projects. It is described in more detail <link linkend="bbv2.advanced.project-root">below</link>.
      </para></section><section id="bbv2.advanced.targets"><title>Main targets</title><para id="bbv2.advanced.targets.main"><emphasis>Main target</emphasis> is a user-defined named
        entity which can be build, for example a named executable file.
        Declaring a main target is usually done using one of <link linkend="bbv2.advanced.builtins.targets">main target functions</link>.  The
        user can also declare <link linkend="bbv2.extending.rules"> custom
        main target function</link>.</para><para>Most main targets rules in Boost.Build use similiar
        syntax:</para><anchor id="bbv2.main-target-rule-syntax"/><programlisting>
function-name main-target-name 
    : sources 
    : requirements 
    : default-build 
    : usage-requirements 
    ;
</programlisting><itemizedlist><listitem><simpara>
            "main-target-name" is the name used to request the target
            on command line and to use it from other main targets. Main
            target name may contain alphanumeric characters and symbols '-'
            and '_';
          </simpara></listitem><listitem><simpara>
            "sources" is the list of source files and other main
            targets that must be combined. 
          </simpara></listitem><listitem><simpara>
            "requirements" is the list of properties that must always
            be present when this main target is built.
          </simpara></listitem><listitem><simpara>
            "default-build" is the list of properties that will be used
            unless some other value of the same feature is already
            specified.
          </simpara></listitem><listitem><simpara>
            "usage-requirements" is the list of properties that will be
            propagated to all main targets that use this one, i.e. to all
            dependents.
          </simpara></listitem></itemizedlist><para>Note that the actual requirements, default-build and
        usage-requirements attributes for a target are obtained by combining
        the explicitly specified one with those specified for the project
        where a target is declared.
      </para><para>          
        Some main target rules have shorter list of parameters, and
        you should consult their documentation for details.
      </para><para>The list of sources specifies what should be processed to get
        the resulting targets. Most of the time, it's just a list of
        files. Sometimes, you'd want to use all files with the same
        extension as sources, in which case you can use the "glob"
        rule. Here are two examples:
<programlisting>
exe a : a.cpp ;
exe b : [ glob *.cpp ] ;
</programlisting>
        Unless you specify a files with absolute path, the name is
        considered relative to the source directory -- which is typically
        the same as directory when Jamfile is located, but can be changed as
        described <link linkend="bbv2.advanced.projects.attributes.projectrule">here</link></para><para>
        The list of sources can also reference other main targets. The
        targets in the same project can be referred by using the name, and
        targets in other project need to specify directory or a symbolic
        name of the other project. For example:
<programlisting>
lib helper : helper.cpp ;
exe a : a.cpp helper ;
exe b : b.cpp ..//utils ;
exe c : c.cpp /boost/program_options//program_opions ;
</programlisting>
        The first exe uses the library defined in the same project. The
        second one uses some target (most likely library) defined by Jamfile
        one level higher. Finally, the third target uses some <ulink url="http://boost.org">C++ Boost</ulink> library, using the
        symbolic name to refer to it. More information about it can be found
        in <link linkend="bbv2.tutorial.libs">tutorial</link> and in 
        <link linkend="bbv2.reference.ids">target id reference</link>.          
      </para><para>Requirements are the properties that should always be present when
        building a target. Typically, they are includes and defines:
<programlisting>
exe hello : hello.cpp : &lt;include&gt;/opt/boost &lt;define&gt;MY_DEBUG ;
</programlisting>
        In special circumstances, other properties can be used, for example if
        a library does not work if it's shared, or a file can't be compiled
        with optimization due to a compiler bug, one can use
<programlisting>
lib util : util.cpp : &lt;link&gt;static ;
obj main : main.cpp : &lt;optimization&gt;off ;
</programlisting></para><para>Sometimes, requirements are necessary only for a specific
        compiler, or build variant. The 
        <link linkend="bbv2.reference.variants.propcond">conditional
        properties</link> can be used in that case:
<programlisting>
lib util : util.cpp : &lt;toolset&gt;msvc:&lt;link&gt;static ;
</programlisting>
        In means when whenever <computeroutput>&lt;toolset&gt;msvc</computeroutput> property is
        in build properties, the <computeroutput>&lt;link&gt;static</computeroutput> property will
        be included as well. The conditional requirements can be "chained":
<programlisting>
lib util : util.cpp : &lt;toolset&gt;msvc:&lt;link&gt;static 
                      &lt;link&gt;static:&lt;define&gt;STATIC_LINK ;
</programlisting>
        will set of static link and the <computeroutput>STATIC_LINK</computeroutput> define on the
        <computeroutput>msvc</computeroutput> toolset.
      </para><para>The default-build attribute is
        a set of properties which should be used if build request does not
        specify a value. For example:
<programlisting>
exe hello : hello.cpp : : &lt;threading&gt;multi ;
</programlisting>
        would build the target in multi-threaded mode, unless the user
        explicitly requests single-threaded version. The difference between
        requirements and default-build is that requirements cannot be
        overriden in any way.
      </para><para>A target of the same name can be declared several times. In that
        case is declaration is called an
        <firstterm>alternative</firstterm>. When the target is build, one of
        the alternatives will be selected and use. Alternatives need not be
        defined by the same main target rule. The following is OK:
<programlisting>
lib helpers : helpers.hpp ;
alias helpers : helpers.lib : &lt;toolset&gt;msvc ;
</programlisting></para><para>Building of the same main target can differ greatly from
        platform to platform. For example, you might have different list
        of sources for different compilers, or different options for those
        compilers. Two approaches to this are explained in the 
        <link linkend="bbv2.tutorial.conditions">tutorial</link>.
      </para><para>Sometimes a main target is really needed only by some other main
        target. For example, a rule that declares a test-suite uses a main
        target that represent test, but those main targets are rarely needed
        by themself.</para><para>It is possible to declare target inline, i.e. the "sources"
        parameter may include call to other main rules. For example:</para><programlisting>
exe hello : hello.cpp 
    [ obj helpers : helpers.cpp : &lt;optimization&gt;off ] ;
</programlisting><para>
        Will cause "helpers.cpp" to be always compiled without
        optimization. It's possible to request main targets declared
        inline, but since they are considered local, they are renamed to
        "parent-main-target_name..main-target-name". In the example above,
        to build only helpers, one should run "bjam hello..helpers".
      </para></section><section id="bbv2.advanced.projects"><title>Projects</title><para>As mentioned before, targets are grouped into project, and each
        Jamfile is a separate project. Projects are useful because it allows
        to group related targets together, define properties common to all
        those targets, and assign a symbolic name to the project, allowing to
        easily refer to the targets in the project. Two last goals are
        accompished with the "project" rule.
      </para><para>The rule has this syntax
<programlisting>
project id : &lt;attributes&gt; ;
</programlisting>
        Here, attributes is a sequence of (attribute-name,
        attribute-value) pairs. The list of attribute names along with its
        handling is also shown in the table below. For example, it is
        possible to write:
<programlisting>
project tennis 
    : requirements &lt;threading&gt;multi 
    : default-build release
    ;
</programlisting></para><para>The possible attributes are listed below.</para><para><emphasis>Project id</emphasis> is a short way to denote a project, as
        opposed to the Jamfile's pathname. It is a hierarchical path,
        unrelated to filesystem, such as "boost/thread". <link linkend="bbv2.reference.ids">Target references</link> make use of project ids to
        specify a target.</para><para><emphasis>Source location</emphasis> specifies the directory where sources
        for the project are located.</para><para><emphasis>Project requirements</emphasis> are requirements that apply to
        all the targets in the projects as well as all subprojects.</para><para><emphasis>Default build</emphasis> is the build request that should be
        used when no build request is specified explicitly.</para><para id="bbv2.advanced.projects.attributes.projectrule">
        The default values for those attributes are
        given in the table below.

        <table><title/><tgroup cols="4"><thead><row><entry>Attribute</entry><entry>Name for the 'project' rule</entry><entry>Default value</entry><entry>Handling by the 'project' rule</entry></row></thead><tbody><row><entry>Project id</entry><entry>none</entry><entry>none</entry><entry>Assigned from the first parameter of the 'project' rule.
                  It is assumed to denote absolute project id.</entry></row><row><entry>Source location</entry><entry><literal>source-location</literal></entry><entry>The location of jamfile for the project</entry><entry>Sets to the passed value</entry></row><row><entry>Requirements</entry><entry><literal>requirements</literal></entry><entry>The parent's requirements</entry><entry>The parent's requirements are refined with the passed
                  requirement and the result is used as the project
                  requirements.</entry></row><row><entry>Default build</entry><entry><literal>default-build</literal></entry><entry>none</entry><entry>Sets to the passed value</entry></row><row><entry>Build directory</entry><entry><literal>build-dir</literal></entry><entry>If parent has a build dir set, the value of it, joined
                  with the relative path from parent to the current project.
                  Otherwise, empty</entry><entry>Sets to the passed value, interpreted as relative to the
                  project's location.</entry></row></tbody></tgroup></table></para></section><section id="bbv2.advanced.other-rules"><title>Additional Jamfile rules</title><para>There's a number of other helper rules which can be used in
      Jamfile, described in the following table.</para><table><title/><tgroup cols="2"><thead><row><entry>Rule</entry><entry>Semantic</entry></row></thead><tbody><row><entry><link linkend="bbv2.advanced.projects.attributes.projectrule">project</link></entry><entry>Define project attributes.</entry></row><row><entry><link linkend="bbv2.advanced.projects.relationships.useprojectrule">use-project</link></entry><entry>Make another project known.</entry></row><row><entry><link linkend="bbv2.advanced.projects.relationships.buildprojectrule">build-project</link></entry><entry>Build another project when this one is built.</entry></row><row><entry><link linkend="bbv2.reference.buildprocess.explict">explicit</link></entry><entry>States that the target should be built only by explicit
                request.</entry></row><row><entry>glob</entry><entry>Takes a list of wildcards, and returns the list of files
                which match any of the wildcards.</entry></row></tbody></tgroup></table></section><section id="bbv2.advanced.project-root"><para>Each project is also associated with <emphasis>project root</emphasis>.
        That's a root for a tree of projects, which specifies some global
        properties.</para><title>Project root</title><para>
          Project root for a projects is the nearest parent directory
          which contains a file called
          <filename>project-root.jam</filename>. That file defines
          certain properties which apply to all projects under project
          root. It can:

        <itemizedlist><listitem><simpara>
              configure toolsets, via call to <literal>toolset.using</literal></simpara></listitem><listitem><simpara>
              refer to other projects, via the <literal>use-project</literal>
              rule
            </simpara></listitem><listitem><simpara>
              declare constants, via the <literal>constant</literal> and
              <literal>path-constant</literal> rules.
            </simpara></listitem></itemizedlist></para><para>To facilitate declaration of simple projects, Jamfile and
        project-root can be merged together. To achieve this effect, the
        project root file should call the <literal>project</literal> rule. The
        semantic is precisely the same as if the call was made in
        Jamfile, except that project-root.jam will start to serve as
        Jamfile. The Jamfile in the directory of project-root.jam will be
        ignored, and project-root.jam will be able to declare main
        targets as usual.</para></section></section><section id="bbv2.advanced.build_process"><title>Build process</title><para>When you've described your targets, you want Boost.Build to run the
      right tools and create the needed targets. This section will describe
      two things: how you specify what to build, and how the main targets are
      actually constructed.
    </para><para>The most important thing to note is that in Boost.Build, unlike
      other build tools, the targets you declare do not correspond to specific
      files. What you declare in Jamfiles is more like "metatarget". Depending
      on the properties that you specify on the command line, each
      "metatarget" will produce a set of real targets corresponding to the
      requested properties. It is quite possible that the same metatarget is
      build several times with different properties, and will, of course,
      produce different files.
    </para><tip><para>
        This means that for Boost.Build, you cannot directly obtain build
        variant from Jamfile. There could be several variants requested by the
        user, and each target can be build with different properties. 
      </para></tip><section><title>Build request</title><para>
        The command line specifies which targets to build and with what
        properties. For example:
<programlisting>
bjam app1 lib1//lib1 toolset=gcc variant=debug optimization=full
</programlisting>
        would build two targets, "app1" and "lib1//lib1" with the specified
        properties. You can refer to any targets, using 
        <link linkend="bbv2.reference.ids">target id</link> and specify arbitrary
        properties. Some of the properties are very common, and for them the name
        of the property can be omitted. For example, the above can be written as:
<programlisting>
bjam app1 lib1//lib1 gcc debug optimization=full
</programlisting>
        The complete syntax which has some additional shortcuts if described <link linkend="bbv2.reference.commandline">here</link>.
      </para></section><section><title>Building a main target</title><para>When you request, directly or indirectly, a build of a main target
        with specific requirements, the following steps are made. Some brief
        explanation is provided, and more detailes are given in the <link linkend="bbv2.reference.buildprocess">reference</link>.
        <orderedlist><listitem><para>Applying default build. If the default-build
          property of a target specifies a value of a feature which is not
          present in the build request, that value is added.</para></listitem><listitem><para>Selecting the main target alternative to use. For
              each alternative we look how many properties are present both in
              alternative's requirements, and in build request. The
              alternative with large number of matching properties is selected.
            </para></listitem><listitem><para>Determining "common" properties. The build request
              is <link linkend="bbv2.reference.variants.proprefine">refined</link>
              with target's requirements. The conditional properties in
              requirements are handled as well. Finally, default values of
              features are added.
            </para></listitem><listitem><para>Building targets referred by the sources list and
              dependency properties. The list of sources and the properties
              can refer to other target using <link linkend="bbv2.reference.ids">target references</link>. For each
              reference, we take all <link linkend="bbv2.reference.features.attributes.propagated">propagated</link>
              properties, refine them by explicit properties specified in the
              target reference, and pass the resulting properties as build
              request to the other target.              
            </para></listitem><listitem><para>Adding the usage requirements produces when building
              dependencies to the "common" properties. When dependencies are
              built in the previous step, they return both the set of created
              "real" targets, and usage requirements. The usage requirements
              are added to the common properties and the resulting property
              set will be used for building the current target.              
            </para></listitem><listitem><para>Building the target using generators. To convert the
              sources to the desired type, Boost.Build uses "generators" ---
              objects which correspond to tools like compilers and
              linkers. Each generator declares what type of targets in can
              produce and what type of sources it requires. Using this
              information, Boost.Build determines which generators must be run
              to produce a specific target from specific sources. When
              generators are run, they return the "real" targets.
            </para></listitem><listitem><para>Computing the usage requirements to be returned. The
          conditional properties in usage requirements are expanded and the
          result is returned.</para></listitem></orderedlist></para></section><section><title>Building a project</title><para>Often, user request a build of a complete project, not just one
        main target. In fact, invoking <command>bjam</command> without
        parameters builds the project defined in the current directory.</para><para>When a project is build, the build request is passed without
        modification to all main targets in that project. It's is possible to
        prevent implicit building of a target in a project with the
        <computeroutput>explicit</computeroutput> rule:
<programlisting>
explicit hello_test ;
</programlisting>
        would cause the <computeroutput>hello_test</computeroutput> target to be built only if
        explicitly requested by the user or by some other target.
      </para><para>The Jamfile for a project can include a number of
      <computeroutput>build-project</computeroutput> rule calls, that specify additional projects
      to be built.
      </para></section></section><section id="bbv2.advanced.builtins.targets"><title>Builtin target types</title><section><title>Programs</title><para>Programs are created using the <computeroutput>exe</computeroutput> rule, which
        follows the <link linkend="bbv2.main-target-rule-syntax">common
          syntax</link>. For example:
<programlisting>
exe hello : hello.cpp some_library.lib /some_project//library 
          : &lt;threading&gt;multi 
          ;
</programlisting>
        This will create an executable file from the sources -- in this case,
        one C++ file, one library file present in the same directory, and
        another library which is created by Boost.Build. Generally, sources
        can include C and C++ files, object files and libraries. Boost.Build
        will automatically try to convert targets of other types.
      </para><tip><para>         
          On Windows, if an application uses dynamic libraries, and both
          the application and the libraries are built by Boost.Build, its not
          possible to immediately run the application, because the
          <literal>PATH</literal> environment variable should include the path
          to the libraries. It means you have to either add the paths
          manually, or place the application and the libraries to the same
          directory, for example using the <link linkend="bbv2.builtins.stage">
            stage</link> rule.
      </para></tip></section><section><title>Libraries</title><para>Libraries are created using the <computeroutput>lib</computeroutput> rule, which
        follows the <link linkend="bbv2.main-target-rule-syntax">common
          syntax</link>. For example:
<programlisting>
lib helpers : helpers.cpp : &lt;include&gt;boost : : &lt;include&gt;. ;
</programlisting></para><para>In the most common case, the <computeroutput>lib</computeroutput> creates a library
        from the specified sources. Depending on the value of
        &lt;link&gt; feature the library will be either static or
        shared. There are two other cases. First is when the library is
        installed somewhere in compiler's search paths, and should be
        searched by the compiler (typically, using the <option>-l</option>
        option). The second case is where the library is available as a 
        prebuilt file and the full path is known.          
        </para><para>
        The syntax for these case is given below:
<programlisting>
lib z : : &lt;name&gt;z &lt;search&gt;/home/ghost ;            
lib compress : : &lt;file&gt;/opt/libs/compress.a ;
</programlisting>
        The <computeroutput>name</computeroutput> property specifies the name which should be
        passed to the <option>-l</option> option, and the <computeroutput>file</computeroutput>
        property specifies the file location. The <computeroutput>search</computeroutput> feature
        specifies paths where the library should be searched. That feature can
        be specified several time, or can be omitted -- in which case only
        default compiler paths will be searched.
      </para><para>The difference between using the <computeroutput>file</computeroutput> feature as
        opposed to the <computeroutput>name</computeroutput> name feature together with the
        <computeroutput>search</computeroutput> feature is that <computeroutput>file</computeroutput> is more
        precise. A specific file will be used. On the other hand, the
        <computeroutput>search</computeroutput> feature only adds a library path, and the
        <computeroutput>name</computeroutput> feature gives the basic name of the library. The
        search rules are specific to the linker. For example, given these
        definition:
<programlisting>
lib a : : &lt;variant&gt;release &lt;file&gt;/pool/release/a.so ;
lib a : : &lt;variant&gt;debug &lt;file&gt;/pool/debug/a.so ;
lib b : : &lt;variant&gt;release &lt;file&gt;/pool/release/b.so ;
lib b : : &lt;variant&gt;debug &lt;file&gt;/pool/debug/b.so ;
</programlisting>
        It's possible to use release version of <computeroutput>a</computeroutput> and debug
        version of <computeroutput>b</computeroutput>. Had we used the <computeroutput>name</computeroutput> and
        <computeroutput>search</computeroutput> features, the linker would always pick either
        release or debug versions.
      </para><para>
        For convenience, the following syntax is allowed:
<programlisting>
lib z ;
lib gui db aux ;
</programlisting>
          and is does exactly the same as:
<programlisting>
lib z : : &lt;name&gt;z ;            
lib giu : : &lt;name&gt;gui ;            
lib db : : &lt;name&gt;db ;            
lib aux : : &lt;name&gt;aux ;            
</programlisting></para><para>When a library uses another library you should put that another
        library in the list of sources. This will do the right thing in all
        cases. For portability, you should specify library dependencies even
        for searched and prebuilt libraries, othewise, static linking on
        Unix won't work. For example:
<programlisting>
lib z ;
lib png : z : &lt;name&gt;png ;
</programlisting></para><note><para>When a library (say, <computeroutput>a</computeroutput>), which has another
          library, (say, <computeroutput>b</computeroutput>) is linked dynamically, the <computeroutput>b</computeroutput>
          library will be incorporated in <computeroutput>a</computeroutput>. (If <computeroutput>b</computeroutput>
          is dynamic library as well, then <computeroutput>a</computeroutput> will only refer to
          it, and not include any extra code.) When the <computeroutput>a</computeroutput>
          library is linked statically, Boost.Build will assure that all
          executables which link to <computeroutput>a</computeroutput> will also link to
          <computeroutput>b</computeroutput>.
        </para></note><para>One feature of Boost.Build which is very important for libraries
        is usage requirements. For example, if you write:
<programlisting>
lib helpers : helpers.cpp : : : &lt;include&gt;. ;
</programlisting>
        then compiler include path for all targets which use
        <computeroutput>helpers</computeroutput> will contain the directory where the target is
        defined.path to "helpers.cpp". So, the user need only to add
        <computeroutput>helpers</computeroutput> to the list of sources, and don't bother about
        other requirements. This allows to greatly simplify Jamfiles.
      </para><note><para>If you don't want shared libraries to include all libraries
          which are specified in sources (especially statically linked ones),
          you'd need to use the following:
<programlisting>
lib b : a.cpp ;
lib a : a.cpp : &lt;use&gt;b : : &lt;library&gt;b ;
</programlisting>
          This specifies that <computeroutput>a</computeroutput> uses <computeroutput>b</computeroutput>, and causes
          all executables which link to <computeroutput>a</computeroutput> also link to
          <computeroutput>b</computeroutput>. In this case, even for shared linking, the
          <computeroutput>a</computeroutput> library won't even refer to <computeroutput>b</computeroutput>.
        </para></note></section><section id="bbv2.builtins.alias"><title>Alias</title><para>The <computeroutput>alias</computeroutput> rule follows the <link linkend="bbv2.main-target-rule-syntax">common syntax</link>. For
        example:
<programlisting>
alias core : im reader writer ;
</programlisting>
        will build the sources and return the generated source targets
        without modification. 
      </para><para>
        The <computeroutput>alias</computeroutput> rule is a convenience tool. If you often build
        the same group of targets at the same time, you can define the alias
        to save typing.        
      </para><para>
        Another use of the <computeroutput>alias</computeroutput> rule is to change build
        properties. For example, if you always want static linking for a
        specific C++ Boost library, you can write the following:
<programlisting>
alias boost_thread : /boost/thread//boost_thread : &lt;link&gt;static ;
</programlisting>
        and use only the <computeroutput>boost_thread</computeroutput> alias in your Jamfiles.
      </para><para>
        It is also allowed to specify usage requirements for the
        <computeroutput>alias</computeroutput> target. If you write the following:
<programlisting>
alias header_only_library : : : :  &lt;include&gt;/usr/include/header_only_library ; 
</programlisting>
        then using <computeroutput>header_only_library</computeroutput> in sources will only add an
        include path. Also note that when there are some sources, their usage
        requirements are propagated, too. For example:
<programlisting>
lib lib : lib.cpp : : : &lt;include&gt;. ;
alias lib_alias ;
exe main : main.cpp lib_alias ;
</programlisting>
        will compile <filename>main.cpp</filename> with the additional include.
      </para></section><section id="bbv2.builtins.stage"><title>Installing</title><para>For installing the built target you should use the
        <computeroutput>stage</computeroutput> rule follows the <link linkend="bbv2.main-target-rule-syntax">common syntax</link>. For
        example:
<programlisting>
stage dist : hello helpers ;
</programlisting>
        will cause the targets <computeroutput>hello</computeroutput> and <computeroutput>helpers</computeroutput> to
        be moved to the <filename>dist</filename> directory. The directory can
        be changed with the <computeroutput>location</computeroutput> property:
<programlisting>
stage dist : hello helpers : &lt;location&gt;/usr/bin ;
</programlisting></para><para>
        Specifying the names of all libraries to install can be boring. The
        <computeroutput>stage</computeroutput> allows to specify only the top-level executable
        targets to install, and automatically install all dependencies:
<programlisting>
stage dist : hello 
           : &lt;traverse-dependencies&gt;on &lt;include-type&gt;EXE
             &lt;include-type&gt;LIB
           ;
</programlisting>
        will find all targets that <computeroutput>hello</computeroutput> depends on, and install
        all of the which are either executables or libraries.
      </para></section><section id="bbv2.builtins.testing"><title>Testing</title><para>Boost.Build has convenient support for running unit tests. The
        simplest way is the <computeroutput>unit-test</computeroutput> rule, which follows the
        <link linkend="bbv2.main-target-rule-syntax">common syntax</link>. For
        example:
<programlisting>
unit-test helpers_test : helpers_test.cpp helpers ;
</programlisting></para><para>The <computeroutput>unit-test</computeroutput> rule behaves like the
        <computeroutput>exe</computeroutput> rule, but after the executable is created it is
        run. If the executable returns error, the build system will also
        return error and will try running the executable on the next
        invocation until it runs successfully. This behaviour ensures that you
        can't miss a unit test failure.
      </para><para>There are rules for more elaborate testing: <computeroutput>compile</computeroutput>,
        <computeroutput>compile-fail</computeroutput>, <computeroutput>run</computeroutput> and
        <computeroutput>run-fail</computeroutput>. They are more suitable for automated testing, and
        are not covered here yet.
      </para></section></section><section id="bbv2.advanced.builtins.features"><title>Builtin features</title><variablelist><varlistentry><term><literal>variant</literal></term><listitem><simpara>
            The feature which combines several low-level features in
            order to make building most common variants simple.
          </simpara><para><emphasis role="bold">Allowed values:</emphasis><literal>debug</literal>, <literal>release</literal>,
            <literal>profile</literal></para><para>The value <literal>debug</literal> expands to</para><programlisting>
            &lt;optimization&gt;off &lt;debug-symbols&gt;on &lt;inlining&gt;off &lt;runtime-debugging&gt;on
          </programlisting><para>The value <literal>release</literal> expands to</para><programlisting>
            &lt;optimization&gt;speed &lt;debug-symbols&gt;off &lt;inlining&gt;full &lt;runtime-debugging&gt;off
          </programlisting><para>The value <literal>profile</literal> expands to the same as
            <literal>release</literal>, plus:</para><programlisting>
            &lt;profiling&gt;on &lt;debug-symbols&gt;on
          </programlisting><para><emphasis role="bold">Rationale:</emphasis> Runtime debugging is on in debug build
            to suit expectations of people used various IDEs. It's
            assumed other folks don't have any specific expectation in
            this point.</para></listitem></varlistentry><varlistentry id="bbv2.advanced.builtins.features.link"><term><literal>link</literal></term><listitem><simpara>
            Feature which controls how libraries are built.
          </simpara><para><emphasis role="bold">Allowed values:</emphasis><literal>shared</literal>,
            <literal>static</literal></para></listitem></varlistentry><varlistentry><term><literal>source</literal></term><listitem><simpara>
            Tthe &lt;source&gt;X feature has the same effect on building a target
            as putting X in the list of sources. The feature
            is sometimes more convenient: you can put &lt;source&gt;X in
            the requirements for a project and it will be linked to all
            executables.
          </simpara></listitem></varlistentry><varlistentry><term><literal>library</literal></term><listitem><simpara>
            This feature is equivalent to the &lt;source&gt; feature, and exists
            for backward compatibility reasons.
          </simpara></listitem></varlistentry><varlistentry><term><literal>use</literal></term><listitem><simpara>
            Causes the target referenced by the value of this feature
            to be constructed and adds it's usage requirements to build
            properties. The constructed targets are not used in any other
            way. The primary use case is when you use some library and want
            it's usage requirements (such as include paths) to be applied,
            but don't want to link to the library.
          </simpara></listitem></varlistentry><varlistentry><term><literal>dll-path</literal></term><listitem><simpara>
            Specify an additional path where shared libraries should be
            searched where the executable or shared library is run. This
            feature only affect Unix compilers. Plase see the <link linkend="bbv2.faq.dll-path">FAQ entry</link> for details.
          </simpara></listitem></varlistentry><varlistentry><term><literal>hardcode-dll-paths</literal></term><listitem><simpara>
            Controls automatic generation of dll-path properties.
          </simpara><para><emphasis role="bold">Allowed values:</emphasis><literal>true</literal>, <literal>false</literal>.  This property
            is specific to Unix systems. If an executable is build with
            <computeroutput>&lt;hardcode-dll-paths&gt;true</computeroutput>, the generated binary
            will contain the list of all the paths to the used shared
            libraries. As the result, the executable can be run without
            changing system paths to shared libraries, or installing the
            libraries to system paths. This is very convenient during
            development. Plase see the <link linkend="bbv2.faq.dll-path">FAQ entry</link> for details.
          </para></listitem></varlistentry></variablelist></section><section id="bbv2.advanced.differences_to_v1"><title>Differences to Boost.Build V1</title><para>While Boost.Build V2 is based on the same ideas as Boost.Build V1,
    some of the syntax was changed, and some new important features were
    added. This chapter describes most of the changes.</para><section id="bbv2.advanced.differences_to_v1.configuration"><title>Configuration</title><para>In V1, there were two methods to configure a toolset. One is to
      set some environment variable, or use "-s" command line option to set
      variable inside BJam. Another method was creating new toolset module,
      which would set the variables and then invoke basic toolset. Neither
      method is necessary now, the "using" rule provides a consistent way to
      initialize toolset, including several versions. See <link linkend="bbv2.advanced.configuration">section on configuraton</link> for
      details.
      </para></section><section id="bbv2.advanced.differences_to_v1.jamfiles"><title>Writing Jamfiles</title><para>Probably one of the most important differences in V2 Jamfiles is
      the project requirements. In V1, if several targets have the same
      requirements (for example, common include path), it was necessary to
      manually write that requirements, or use a helper rule. In V2, the
      common properties can be specified with the "requirements" project
      attribute, as documented <link linkend="bbv2.advanced.projects">here</link>.
      </para><para>The <link linkend="bbv2.tutorial.libs">usage requirements</link>
      is also important mechanism to simplify Jamfile. If a library requires
      all clients to use specific includes, or macros when compiling the
      code which depends on the library, this information can be cleanly
      represented.</para><para>The difference between "lib" and "dll" targets in V1 is completely
      eliminated in V2. There's only one target -- "lib", which can create
      either static or shared library depending on the value of the 
        <link linkend="bbv2.advanced.builtins.features.link">&lt;link&gt;
      feature</link>. If your target should be only build in one variant, you
      can add &lt;link&gt;shared or &lt;link&gt;static to requirements.
      </para><para>The syntax for referring to other targets was changed a bit. While
      in V1 one would use:
<programlisting>
exe a : a.cpp &lt;lib&gt;../foo/bar ;
</programlisting> 
        the V2 syntax is:
<programlisting>
exe a : a.cpp ../foo//bar ;
</programlisting>
        Note that you don't need to specify the type of other target, but the
        last element should be separated to double slash, to indicate that
        you're referring to target "bar" in project "../foo", and not to
        project "../foo/bar".
        </para></section><section id="bbv2.advanced.differences_to_v1.build_process"><title>Build process</title><para>The command line syntax in V2 is completely different. For example
<programlisting>
bjam -sTOOLS=msvc -sBUILD=release some_target
</programlisting>
        now becomes:
<programlisting>
bjam toolset=msvc variant=release some_target
</programlisting>
        or, using shortcuts, just:
<programlisting>
bjam msvc release some_target
</programlisting>
      See <link linkend="bbv2.reference.commandline">the reference</link> for
      complete description of the syntax.
      </para></section></section></chapter><chapter id="bbv2.extender" xml:base="../tools/build/v2/doc/src/extending.xml"><title>Extender Manual</title><section id="bbv2.extender.intro"><title>Introduction</title><para>This document explains how to extend Boost.Build to accomodate
  your local requirements. Let's start with quite simple, but
  realistic example.</para><para>Say you're writing an application which generates C++ code. If
  you ever did this, you know that it's not nice. Embedding large
  portions of C++ code in string literals is very awkward. A much
  better solution is:</para><orderedlist><listitem><simpara>
        Write the template of the code to be generated, leaving
    placeholders at the points which will change
      </simpara></listitem><listitem><simpara>
        Access the template in your application and replace
    placeholders with appropriate text.
      </simpara></listitem><listitem><simpara>Write the result.</simpara></listitem></orderedlist><para>It's quite easy to achieve. You write special verbatim files,
  which are just C++, except that the very first line of the file
  gives a name of variable that should be generated. A simple tool
  is created which takes verbatim file and creates a cpp file with
  a single char* variable, which name is taken from the first line
  of verbatim file, and which value is properly quoted content of
  the verbatim file.</para><para>Let's see what Boost.Build can do.</para><para>First off, Boost.Build has no idea about "verbatim files". So,
  you must register a new type. The following code does it:</para><programlisting>
import type ;
type.register VERBATIM : verbatim ;
</programlisting><para>The first parameter to 'type.register' gives the name of
  declared type. By convention, it's uppercase. The second
  parameter is suffix for this type. So, if Boost.Build sees
  "code.verbatim" in the list of sources, it knows that it's of
  type <literal>VERBATIM</literal>.</para><para>Lastly, you need a tool to convert verbatim files to C++. Say
  you've sketched such a tool in Python. Then, you have to inform
  Boost.Build about the tool. The Boost.Build concept which
  represents a tool is <emphasis>generator</emphasis>.</para><para>First, you say that generator 'inline-file' is able to convert
  VERBATIM type into C++:</para><programlisting>
import generators ;
generators.register-standard verbatim.inline-file : VERBATIM : CPP ;
</programlisting><para>Second, you must specify the commands to be run to actually
  perform convertion:</para><programlisting>
actions inline-file
{
    "./inline-file.py" $(&lt;) $(&gt;)
}
</programlisting><para>Now, we're ready to tie it all together. Put all the code
  above in file "verbatim.jam", add "import verbatim ;" to
  "project-root.jam", and it's possible to write the following in
  Jamfile:</para><programlisting>
exe codegen : codegen.cpp class_template.verbatim usage.verbatim ;
</programlisting><para>
The verbatim files will be automatically converted into C++
and linked it.
  </para><para>In the subsequent sections, we will extend this example, and review
        all the mechanisms in detail. The complete code is available in <ulink url="../../tools/build/v2/example/customization">example/customization</ulink>
        directory.
      </para></section><section id="bbv2.extending.targets"><title>Target types</title><para>The first thing we did in the <link linkend="bbv2.extender.intro">intruduction</link> was declaring a
      new target type:
<programlisting>
import type ;
type.register VERBATIM : verbatim ;
</programlisting>
        The type is the most important property of a target. Boost.Build can
        automatically generate necessary build actions only because you
        specify the desired type (using the different main target rules), and
        because Boost.Build can guess the type of sources from their
        extensions.        
      </para><para>The first two parameters for the <computeroutput>type.register</computeroutput> rule
        are the name of new type and the list of extensions associated with
        it. A file with an extension from the list will have the given target
        type. In the case where a target of the declared type is generated
        from other sources, the first specified extension will be used. This
        behaviour can be changed using the
        <computeroutput>type.set-generated-target-suffix</computeroutput> rule.
      </para><para>
        Something about 'main' types.
      </para><para>Something about base types.
      </para><section id="bbv2.extending.scanners"><title>Scanners</title><para>
          Sometimes, a file can refer to other files via some include
          mechanism. To make Boost.Build track dependencies to the included
          files, you need to provide a scanner. The primary limitation is that
          only one scanner can be assigned to a target type.
        </para><para>First, we need to declare a new class for the scanner:
<programlisting>
class verbatim-scanner : common-scanner
{
    rule pattern ( )
    {
        return "//###include[ ]*\"([^\"]*)\"" ;
    }
}
</programlisting>         
          All the complex logic is in the <computeroutput>common-scanner</computeroutput> class,
          and you only need to override the method which returns the regular
          expression to be used for scanning. The paranthethis in the regular
          expression indicate which part of the string is the name of the
          included file. 
        </para><para>After that, we need to register our scanner class:
<programlisting>
scanner.register verbatim-scanner : include ;
</programlisting>
            The value of the second parameter, in this case
            <computeroutput>include</computeroutput>, specifies which properties contain the list
            of paths which should be searched for the included files.
         </para><para>Finally, we assign the new scaner to the <computeroutput>VERBATIM</computeroutput>
        target type:
<programlisting>
type.set-scanner VERBATIM : verbatim-scanner ;
</programlisting>
          That's enough for scanning include dependencies.
        </para></section></section><section id="bbv2.extending.tools"><title>Tools and generators</title><para>
        This section will describe how Boost.Build can be extended to support
        new tools.
      </para><para>For each additional tool, a Boost.Build object called generator
        must be created. That object has specific types of targets which it
        accepts an produces. Using that information, Boost.Build is able
        to automatically invoke the generator. For example, if you declare a
        generator which takes a target of the type <literal>D</literal> and
        produces a target of the type <literal>OBJ</literal>, when placing a
        file with extention <literal>.d</literal> in a list of sources will
        cause Boost.Build to invoke your generator, and then to link the
        resulting object file into an application. (Of course, this requires
        that you specify that the <literal>.d</literal> extension corresponds
        to the <literal>D</literal> type.)
      </para><para>Each generator should be an instance of a class derived from the
        <computeroutput>generator</computeroutput> class. In the simplest case, you don't need to
        create a derived class, but simply create an instance of the
        <computeroutput>generator</computeroutput> class. Let's review the example we've seen in the
        <link linkend="bbv2.extender.intro">introduction</link>.
<programlisting>
import generators ;
generators.register-standard verbatim.inline-file : VERBATIM : CPP ;
actions inline-file
{
    "./inline-file.py" $(&lt;) $(&gt;)
}
</programlisting></para><para>We declare a standard generator, specifying its id, the source type
        and the target type. When invoked, the generator will create a target
        of type <literal>CPP</literal> which will have the source target of
        type <literal>VERBATIM</literal> as the only source. But what command
        will be used to actually generate the file? In bjam, actions are
        specified using named "actions" blocks and the name of the action
        block should be specified when creating targets. By convention,
        generators use the same name of the action block as their own id. So,
        in above example, the "inline-file" actions block will be use to
        convert the source into the target.
      </para><para>
        There are two primary kinds of generators: standard and composing,
        which are registered with the
        <computeroutput>generators.register-standard</computeroutput> and the
        <computeroutput>generators.register-composing</computeroutput> rules, respectively. For
        example:
<programlisting>
generators.register-standard verbatim.inline-file : VERBATIM : CPP ;
generators.register-composing mex.mex : CPP LIB : MEX ;
</programlisting>
        The first generators takes a <emphasis>single</emphasis> source of type
        <computeroutput>VERBATIM</computeroutput> and produces a result. The second generator
        takes any number of sources, which can have either the
        <computeroutput>CPP</computeroutput> or the <computeroutput>LIB</computeroutput> type. Composing generators
        are typically used for generating top-level target type. For example,
        the first generator invoked when building an <computeroutput>exe</computeroutput> target
        is a composing generator corresponding to the proper linker.
      </para><para>You should also know about two specific function for registering
        generators: <computeroutput>generators.register-c-compiler</computeroutput> and
        <computeroutput>generators.register-linker</computeroutput>. The first sets up header
        dependecy scanning for C files, and the seconds handles various
        complexities like searched libraries. For that reason, you should always
        use those functions when adding support for compilers and linkers.
      </para><para>(Need a note about UNIX)</para><bridgehead>Custom generator classes</bridgehead><para>The standard generators allows you to specify source and target
        types, action, and a set of flags. If you need anything more complex,
        you need to create a new generator class with your own logic. Then,
        you have to create an instance of that class and register it. Here's
        an example how you can create your own generator class:
<programlisting>
class custom-generator : generator
{
    rule __init__ ( * : * )
    {
        generator.__init__ $(1) : $(2) : $(3) : $(4) : $(5) : $(6) : $(7) : $(8) : $(9) ;
    }
}

generators.register 
  [ new custom-generator verbatim.inline-file : VERBATIM : CPP ] ;
</programlisting>
        This generator will work exactly like the
        <computeroutput>verbatim.inline-file</computeroutput> generator we've defined above, but
        it's possible to customize the behaviour by overriding methods of the
        <computeroutput>generator</computeroutput> class.
      </para><para>There are two methods of interest. The <computeroutput>run</computeroutput> methods is
        responsible for overall process - it takes a number of source targets,
        converts them the the right types, and creates the result. The
        <computeroutput>generated-targets</computeroutput> method is called when all sources are
        converted to the right types to actually create the result.
      </para><para>The <computeroutput>generated-target</computeroutput> method can be overridden when you
        want to add additional properties to the generated targets or use
        additional sources. For example (which is real), you have a tool for
        analysing programs, which should be given a name of executable and the
        list of all sources. Naturally, you don't want to list all source
        files manually. Here's how the <computeroutput>generated-target</computeroutput> method
        can find the list of sources automatically:
<programlisting>
class itrace-generator : generator {
....
    rule generated-targets ( sources + : property-set : project name ? )
    {
        local leafs ;
        local temp = [ virtual-target.traverse $(sources[1]) : : include-sources ] ;
        for local t in $(temp)
        {
            if ! [ $(t).action ]
            {
                leafs += $(t) ;
            }
        }
        return [ generator.generated-targets $(sources) $(leafs)
          : $(property-set) : $(project) $(name) ] ;
    }
}
generators.register [ new itrace-generator nm.itrace : EXE : ITRACE ] ;
</programlisting>
        The <computeroutput>generated-targets</computeroutput> rule will be called with a single
        source target of type <literal>EXE</literal>. The call to the
        <computeroutput>virtual-target.traverse</computeroutput> will return all targets the
        executable depends on, and we further find files which are not
        produced from anything. The found targets are added to the sources.
      </para><para>The <computeroutput>run</computeroutput> method can be overriden to completely
        customize the way generator works. In particular, the conversion of
        sources to the desired types can be completely customized. Here's
        another real example. Tests for the Boost Python library usually
        consist of two parts: a Python program and a C++ file. The C++ file is
        compiled to Python extension which is loaded by the Python
        program. But in the likely case that both files have the same name,
        the created Python extension must be renamed. Otherwise, Python
        program will import itself, not the extension. Here's how it can be
        done:
<programlisting>
rule run ( project name ? : property-set : sources * : multiple ? )
{       
    local python ;
    for local s in $(sources)
    {
        if [ $(s).type ] = PY
        {
            python = $(s) ;
        }
    }
    
    local libs ;
    for local s in $(sources)
    {
        if [ type.is-derived [ $(s).type ] LIB ]
        {
            libs += $(s) ;
        }
    }
    
    local new-sources ;
    for local s in $(sources)
    {
        if [ type.is-derived [ $(s).type ] CPP ] 
        {
            local name = [ $(s).name ] ;
            if $(name) = [ $(python).name ] 
            {
                name = $(name)_ext ;
            }                                
            new-sources += [ generators.construct $(project) $(name) :
              PYTHON_EXTENSION : $(property-set) : $(s) $(libs) ] ;
        }
    }
        
    result = [ construct-result $(python) $(new-sources) : $(project) $(name) 
                 : $(property-set) ] ;        
}    
</programlisting>        
        First, we separate all source into python files, libraries and C++
        sources. For each C++ source we create a separate Python extension by
        calling <computeroutput>generators.construct</computeroutput> and passing the C++ source
        and the libraries. At this point, we also change the extension's name,
        if necessary.        
      </para></section><section id="bbv2.extending.features"><title>Features</title><para>
        Often, we need to control the options passed the invoked tools. This 
        is done with features. Consider an example:
<programlisting>
# Declare a new feature
import feature : feature ;
feature verbatim-options : : free ;

# Cause the value of the 'verbatim-options' feature to be
# available as 'OPTIONS' variable inside verbatim.inline-file
import toolset : flags ;
flags verbatim.inline-file OPTIONS &lt;verbatim-options&gt; ;

# Use the "OPTIONS" variable
actions inline-file
{
    "./inline-file.py" $(OPTIONS) $(&lt;) $(&gt;)
}
</programlisting>
        We first define a new feature. Then, the <computeroutput>flags</computeroutput> invocation
        says that whenever verbatin.inline-file action is run, the value of
        the <computeroutput>verbatim-options</computeroutput> feature will be added to the
        <computeroutput>OPTIONS</computeroutput> variable, an can be used inside the action body.
        You'd need to consult online help (--help) to find all the features of
        the <computeroutput>toolset.flags</computeroutput> rule.
      </para><para>
      Although you can define any set of features and interpret their values
      in any way, Boost.Build suggests the following coding standard for
      designing features.
    </para><para>Most features should have a fixed set of values, which is portable
      (tool neutral) across the class of tools they are designed to work
      with. The user does not have to adjust the values for a exact tool.  For
      example, <computeroutput>&lt;optimization&gt;speed</computeroutput> has the same meaning for
      all C++ compilers and the user does not have to worry about the exact
      options which are passed to the compiler's command line.
    </para><para>
      Besides such portable features there are special 'raw' features which
      allow the user to pass any value to the command line parameters for a
      particular tool, if so desired. For example, the
      <computeroutput>&lt;cxxflags&gt;</computeroutput> feature allows to pass any command line
      options to a C++ compiler. The <computeroutput>&lt;include&gt;</computeroutput> feature
      allows to pass any value to the <computeroutput>-I</computeroutput> and the interpretation
      is tool-specific. (There an <link linkend="bbv2.faq.external">example</link> of very smart usage of that
      feature).  Of course one should always strive to use the portable
      features but these should still be provided as a backdoor just to make
      sure Boost.Build does not take away any control from the user. 
    </para><para>
      Some of the reasons why portable features are better are:
      <itemizedlist><listitem><para>Since a portable feature have a fixed set of value, you will
            be able to build your project with two different settings of the
            feature. Boost.Build will automatically use two different
            directories for produced files. If you pass raw compiler options,
            Boost.Build assumes you know what you are doing, and would not
            care about what options are passed.
          </para></listitem><listitem><para>Unlike "raw" features, you don't need to use specific
            compiler flags in Jamfile, and it will more likely work on other systems.
          </para></listitem></itemizedlist></para><bridgehead>Steps for adding a feauture</bridgehead><para>Adding a feature requires three steps:

        <orderedlist><listitem><para>Declaring a feature. For that, the "feature.feature"
              rule is used. You should have to decide on the set of <link linkend="bbv2.reference.features.attributes">feature
              attributes</link>:

              <itemizedlist><listitem><para>if feature has several values, and
                    significally affects build, make it "propagated", so that
                    whole project is build with the same value by
                    default</para></listitem><listitem><para>if a feature does not have a fixed list of
                    values, it must be "free".</para></listitem><listitem><para>if feature is used to refer to a path, it must
                be "path".</para></listitem><listitem><para>if feature is used to refer to some target, it
                must be "dependency".</para></listitem></itemizedlist></para></listitem><listitem><para>Converting the feature value into variable. To use
              feature in build action, it must be converted into a variable,
              accessible in build action. This is accomplished by
              "toolset.flags" rule.</para></listitem><listitem><para>Using the variable. The variable set in step 2 can
              be used in build action to form command parameters or
              files.</para></listitem></orderedlist></para><bridgehead>Another example</bridgehead><para>Here's an another example.
        Let's see how we can make a feature which refers to a target. For example,
        when linking dynamic libraries on windows, one sometimes needs to specify
        "DEF file", telling what functions should be exported. It would be nice to
        use this file like this:
<programlisting>
        lib a : a.cpp : &lt;def-file&gt;a.def ;
</programlisting>
        Actually, this feature is already supported, but anyway...
      </para><orderedlist><listitem><para>Since the feature refers to a target, it must be "dependency".
<programlisting>
feature def-file : : free dependency ;
</programlisting></para></listitem><listitem><para>One of the toolsets which cares about DEF files is
msvc. The following line should be added to it.

<programlisting>
flags msvc.link DEF_FILE &lt;def-file&gt; ;
</programlisting></para></listitem><listitem><para>Since the DEF_FILE variable is not used by the
msvc.link action, we need to modify it to be:

<programlisting>
actions link bind DEF_FILE
{
    $(.LD) .... /DEF:$(DEF_FILE) ....
}
</programlisting></para><para> Note the "bind DEF_FILE" part. It tells bjam that DEF_FILE
            refers to a file, otherwise the variable will contain internal
            target name, which is not likely to make sense for the linker.
          </para><para>
            We've almost done, but should stop for a small workaround. Add the following
            code to msvc.jam

<programlisting>
rule link
{
    DEPENDS $(&lt;) : [ on $(&lt;) return $(DEF_FILE) ] ;
}
</programlisting>

            This is needed to accomodate some bug in bjam, which hopefully
            will be fixed one day.</para></listitem></orderedlist><bridgehead>Variants and composite features.</bridgehead><para>Sometimes you want to create a shorcut for some set of
        features. For example, <computeroutput>release</computeroutput> is a value of the
        <computeroutput>variant</computeroutput> and is a shortcut for a set of features.
        </para>.

      <para>It is possible to define your build variants. For example:
<programlisting>
variant crazy : &lt;optimization&gt;speed &lt;inlining&gt;off
                &lt;debug-symbols&gt;on &lt;profiling&gt;on ;
</programlisting>
        will define a new variant with the specified set of properties. You
        can also extend an existing variant:
<programlisting>
variant super_release : release : &lt;define&gt;USE_ASM ;
</programlisting>
        In this case, <computeroutput>super_release</computeroutput> will expand to all properties
        specified by <computeroutput>release</computeroutput>, and the additional one you've specified.
      </para><para>You are not restricted to using the <computeroutput>variant</computeroutput> feature
      only. Here's example which defines a brand new feature:
<programlisting>
feature parallelism : mpi fake none : composite link-incompatible ;
feature.compose &lt;parallelism&gt;mpi : &lt;library&gt;/mpi//mpi/&lt;parallelism&gt;none ;
feature.compose &lt;parallelism&gt;fake : &lt;library&gt;/mpi//fake/&lt;parallelism&gt;none ;
</programlisting>
        This will allow you to specify value of feature
        <computeroutput>parallelism</computeroutput>, which will expand to link to the necessary
        library. 
      </para></section><section id="bbv2.extending.rules"><title>Main target rules</title><para>
      The main target rule is what creates a top-level target, for example "exe" or
      "lib". It's quite likely that you'll want to declare your own and
      there are as many as three ways to do that.
    </para><para>The first is the simplest, but is sufficient in a number of
      cases. Just write a wrapper rule, which will redirect to any of the
      existing rules. For example, you have only one library per directory and
      want all cpp files in the directory to be compiled. You can achieve this
      effect with:
<programlisting>
lib codegen : [ glob *.cpp ] ;
</programlisting>
      but what if you want to make it even simple. Then, you add the following
      definition to the project-root.jam file:
<programlisting>
rule glib ( name : extra-sources * : requirements * )
{
    lib $(name) : [ glob *.cpp ] $(extra-sources) : $(requirements) ;
}
</programlisting>
which would allow to reduce Jamfile to
<programlisting>
glib codegen ;
</programlisting></para><para>The second approach is suitable when your target rule should just
      produce a target of specific type. Then, when declaring a type you
      should tell Boost.Build that a main target rule should be created.
      For example, if you create a module "obfuscate.jam" containing:

<programlisting>
import type ;
type.register OBFUSCATED_CPP  : ocpp : : main ;

import generators ;
generators.register-standard obfuscate.file : CPP : OBFUSCATED_CPP ;
</programlisting>
      and import that module, you'll be able to use the rule "obfuscated-cpp"
      in Jamfiles, which will convert source to the OBFUSCATED_CPP type.
    </para><para>
      The remaining method is to declare your own main target class. The
      simplest example of this can be found in "build/alias.jam" file. The
      current V2 uses this method when transformations are relatively
      complex. However, we might deprecate this approach. If you find that you
      need to use it (that is, the first two approaches are not sufficient),
      please let us know by posting to the mailing list.
    </para></section><section id="bbv2.extending.toolset_modules"><title>Toolset modules</title><para>If your extensions will be used only on one project, they can be
      placed in a separate <filename>.jam</filename> file which will be
      imported by your <filename>project-root.jam</filename>. If the
      extensions will be used on many projects, the users will thank you for 
      a finishing touch.
    </para><para>The standard way to use a tool in Boost.Build is the
      <computeroutput>using</computeroutput> rule. To make it work, you module should provide an
      <computeroutput>init</computeroutput> rule. The rule will be called with the same parameters
      which were passed to the <computeroutput>using</computeroutput> rule. The set of allowed
      parameters is determined by you. For example, you can allow the user to
      specify paths, tool version, or tool options.
    </para><para>Here are some guidelines which help to make Boost.Build more
      consistent:
      <itemizedlist><listitem><para>The <computeroutput>init</computeroutput> rule should never fail. Even if
          user provided a wrong path, you should emit a warning and go
          on. Configuration may be shared between different machines, and
          wrong values on one machine can be OK on another.
          </para></listitem><listitem><para>Prefer specifying command to be executed to specifying
            path. First of all, this gives more control: it's possible to
            specify
<programlisting>
/usr/bin/g++-snapshot
time g++
</programlisting>
            as the command. Second, while some tools have a logical
            "installation root", it better if user don't have to remember if
            a specific tool requires a full command or a path.            
          </para></listitem><listitem><para>Check for multiple initialization. A user can try to
            initialize the module several times. You need to check for this
            and decide what to do. Typically, unless you support several
            versions of a tool, duplicate initialization is a user error. If
            tool version can be specified during initialization, make sure the
            version is either always specified, or never specified (in which
            case the tool is initialied only once). For example, if you allow:
<programlisting>
using yfc ;
using yfc : 3.3 ;
using yfc : 3.4 ;
</programlisting>
            Then it's not clear if the first initialization corresponds to
            version 3.3 of the tool, version 3.4 of the tool, or some other
            version. This can lead to building twice with the same version.
            </para></listitem><listitem><para>If possible, the <computeroutput>init</computeroutput> must be callable
          with no parameters. In which case, it should try to autodetect all
          the necessary information, for example, by looking for a tool in
          <envar>PATH</envar> or in common installation locations. Often this
          is possible and allows the user to simply write:
<programlisting>
using yfc ;
</programlisting></para></listitem><listitem><para>Consider using facilities in the
          <computeroutput>tools/common</computeroutput> module. You can take a look at how
          <computeroutput>tools/gcc.jam</computeroutput> uses that module in the <computeroutput>init</computeroutput> rule.
          </para></listitem></itemizedlist></para></section></chapter><chapter id="bbv2.reference" xml:base="../tools/build/v2/doc/src/reference.xml"><title>Detailed reference</title><section id="bbv2.reference.general"><title>General information</title><section id="bbv2.reference.init"><title>Initialization</title><para>bjam's first job upon startup is to load the Jam code which
        implements the build system. To do this, it searches for a file
        called "boost-build.jam", first in the invocation directory, then
        in its parent and so forth up to the filesystem root, and finally
        in the directories specified by the environment variable
        BOOST_BUILD_PATH. When found, the file is interpreted, and should
        specify the build system location by calling the boost-build
        rule:</para><programlisting>
rule boost-build ( location ? )
</programlisting><para>
        If location is a relative path, it is treated as relative to
        the directory of boost-build.jam. The directory specified by
        location and directories in BOOST_BUILD_PATH are then searched for
        a file called bootstrap.jam which is interpreted and is expected to
        bootstrap the build system. This arrangement allows the build
        system to work without any command-line or environment variable
        settings. For example, if the build system files were located in a
        directory "build-system/" at your project root, you might place a
        boost-build.jam at the project root containing:

<programlisting>
boost-build build-system ;
</programlisting>

        In this case, running bjam anywhere in the project tree will
        automatically find the build system.</para><para>The default "bootstrap.jam", after loading some standard
        definitions, loads two files, which can be provided/customised by
        user: "site-config.jam" and "user-config.jam".</para><para>Locations where those files a search are summarized below:</para><table id="bbv2.reference.init.config"><title>Search paths for configuration files</title><tgroup cols="3"><thead><row><entry/><entry>site-config.jam</entry><entry>user-config.jam</entry></row></thead><tbody><row><entry>Linux</entry><entry><simpara>/etc</simpara><simpara>$HOME</simpara><simpara>$BOOST_BUILD_PATH</simpara></entry><entry><simpara>$HOME</simpara><simpara>$BOOST_BUILD_PATH</simpara></entry></row><row><entry>Windows</entry><entry><simpara>$SystemRoot</simpara><simpara>$HOME</simpara><simpara>$BOOST_BUILD_PATH</simpara></entry><entry><simpara>$HOME</simpara><simpara>$BOOST_BUILD_PATH</simpara></entry></row></tbody></tgroup></table><para>
        Boost.Build comes with default versions of those files,
        which can serve as templates for customized versions.
      </para></section><section id="bbv2.reference.commandline"><title>Command line</title><para>The command line may contain:</para><itemizedlist><listitem><simpara>Jam options,</simpara></listitem><listitem><simpara>Boost.Build <link linkend="bbv2.reference.init.options">options</link>,</simpara></listitem><listitem><simpara>Command line arguments</simpara></listitem></itemizedlist><section id="bbv2.reference.init.args"><title>Command line arguments</title><para>
          Command line arguments specify targets and build
          request using the following rules.
        </para><itemizedlist><listitem><simpara>
              An argument which does not contain slashes or the "="
              symbol is either a value of an implicit feature, or target to
              be built. It is taken to be value of a feature if appropriate
              feature exists. Otherwise, it is considered a <link linkend="bbv2.reference.ids">target id</link>. Special target name "clean"
              has the same effect as "--clean" option.
            </simpara></listitem><listitem><para>
              An argument with either slashes or the "=" symbol specifies
              a number of <link linkend="bbv2.reference.buildreq">build
                request</link>
              elements. In the simplest form, it's just a set of properties,
              separated by slashes, which become a single build request
              element, for example:

<programlisting>
borland/&lt;runtime-link&gt;static
</programlisting>

              More complex form is used to save typing. For example,
              instead of

<programlisting>
borland/runtime-link=static borland/runtime-link=dynamic
</programlisting>

              one can use

<programlisting>
borland/runtime-link=static,dynamic
</programlisting>

              Exactly, the conversion from argument to build request
              elements is performed by (1) splitting the argument at each slash,
              (2) converting each split part into a set of properties and (3)
              taking all possible combination of the property sets. Each split
              part should have the either the form

<programlisting><emphasis>feature-name</emphasis>=<emphasis>feature-value1</emphasis>[","<emphasis>feature-valueN</emphasis>]*   
</programlisting>

              or, in case of implicit feature

<programlisting><emphasis>feature-value1</emphasis>[","<emphasis>feature-valueN</emphasis>;]*   
</programlisting>

              and will be converted into property set

<programlisting>
&lt;feature-name&gt;feature-value1 .... &lt;feature-name&gt;feature-valueN
</programlisting></para></listitem></itemizedlist><para>
          For example, the command line

<programlisting>
target1 debug gcc/runtime-link=dynamic,static
</programlisting>

          would cause target called <literal>target1</literal> to be rebuilt in
          debug mode, except that for gcc, both dynamically and statically
          linked binaries would be created.
        </para></section><section id="bbv2.reference.init.options"><title>Command line options</title><para>All of the Boost.Build options start with the "--" prefix.
          They are described in the following table.</para><table><title>Command line options</title><tgroup cols="2"><thead><row><entry>Option</entry><entry>Description</entry></row></thead><tbody><row><entry><literal>--version</literal></entry><entry>Prints information on Boost.Build and Boost.Jam
                  versions.</entry></row><row id="bbv2.reference.init.options.help"><entry><literal>--help</literal></entry><entry>Access to the online help system. This prints general
                  information on how to use the help system with additional
                  --help* options.</entry></row><row><entry><literal>--clean</literal></entry><entry>Removes everything instead of building. Unlike
                  <literal>clean</literal> target in make, it is possible to clean only
                  some targets.</entry></row><row><entry><literal>--debug</literal></entry><entry>Enables internal checks.</entry></row><row><entry><literal>--dump-projects</literal></entry><entry>Cause the project structure to be output.</entry></row><row><entry><literal>--no-error-backtrace</literal></entry><entry>Don't print backtrace on errors. Primary useful for
                  testing.</entry></row><row><entry><literal>--ignore-config</literal></entry><entry>Do not load <literal>site-config.jam</literal> and
                  <literal>user-config.jam</literal></entry></row></tbody></tgroup></table></section></section></section><section id="bbv2.reference.jamfiles"><title>Writing Jamfiles</title><para>This section describes specific information about writing Jamfiles.</para><section id="bbv2.reference.headers"><title>Generated headers</title><para>Usually, Boost.Build handles implicit dependendies completely
        automatically. For example, for C++ files, all <literal>#include</literal>
        statements are found and handled. The only aspect where user help
        might be needed is implicit dependency on generated files.</para><para>By default, Boost.Build handles such dependencies within one
        main target. For example, assume that main target "app" has two
        sources, "app.cpp" and "parser.y". The latter source is converted
        into "parser.c" and "parser.h". Then, if "app.cpp" includes
        "parser.h", Boost.Build will detect this dependency. Moreover,
        since "parser.h" will be generated into a build directory, the
        path to that directory will automatically added to include
        path.</para><para>Making this mechanism work across main target boundaries is
        possible, but imposes certain overhead. For that reason, if
        there's implicit dependency on files from other main targets, the
        <literal>&lt;implicit-dependency&gt;</literal> [ link ] feature must
        be used, for example:</para><programlisting>
lib parser : parser.y ;
exe app : app.cpp : &lt;implicit-dependency&gt;parser ;
</programlisting><para>
        The above example tells the build system that when scanning
        all sources of "app" for implicit-dependencies, it should consider
        targets from "parser" as potential dependencies.
      </para></section></section><section id="bbv2.reference.buildprocess"><title>Build process</title><para>The general overview of the build process was given in the 
      <link linkend="bbv2.advanced.build_process">user documentation</link>.
      This section provides additional details, and some specific rules.
    </para><para>To recap, building a target with specific properties includes the
      following steps:
      <orderedlist><listitem><para>applying default build,</para></listitem><listitem><para>selecting the main target alternative to use,
          </para></listitem><listitem><para>determining "common" properties</para></listitem><listitem><para>building targets referred by the sources list and
            dependency properties</para></listitem><listitem><para>adding the usage requirements produces when building
            dependencies to the "common" properties</para></listitem><listitem><para>building the target using generators</para></listitem><listitem><para>computing the usage requirements to be returned</para></listitem></orderedlist></para><section id="bbv2.reference.buildprocess.alternatives"><title>Alternative selection</title><para>When there are several alternatives, one of them must be
        selected. The process is as follows:</para><orderedlist><listitem><simpara>
            For each alternative <emphasis>condition</emphasis> is defined
            as the set of base properies in requirements. [Note: it might be
            better to specify the condition explicitly, as in
            conditional requirements].
          </simpara></listitem><listitem><simpara>
            An alternative is viable only if all properties in condition
            are present in build request.
          </simpara></listitem><listitem><simpara>
            If there's one viable alternative, it's choosen. Otherwise,
            an attempt is made to find one best alternative. An alternative
            a is better than another alternative b, iff set of properties
            in b's condition is strict subset of the set of properities of
            'a's condition. If there's one viable alternative, which is
            better than all other, it's selected. Otherwise, an error is
            reported.
          </simpara></listitem></orderedlist></section><section id="bbv2.reference.buildprocess.common"><title>Determining common properties</title><para>The "common" properties is a somewhat artificial term. Those are
        the intermediate property set from which both the build request for
        dependencies and properties for building the target are derived.
      </para><para>Since default build and alternatives are already handled, we have
        only two inputs: build requests and requirements. Here are the rules
        about common properties.
      </para><orderedlist><listitem><para>Non-free feature can have only one
            value</para></listitem><listitem><para>A non-conditional property in requirement in always
            present in common properties.</para></listitem><listitem><para>A property in build request is present in
            common properties, unless (2) tells otherwise.</para></listitem><listitem><para>If either build request, or requirements (non-conditional
            or conditional) include an expandable property (either composite,
            or property with specified subfeature value), the behaviour is
            equivalent to explicitly adding all expanded properties to build
            request or requirements.</para></listitem><listitem><para>If requirements include a conditional property, and
            condiiton of this property is true in context of common
            properties, then the conditional property should be in common
            properties as well.</para></listitem><listitem><para>If no value for a feature is given by other rules
            here, it has default value in common properties.</para></listitem></orderedlist><para>Those rules are declarative, they don't specify how to compute the
        common properties. However, they provide enough information for the
        user. The important point is the handling of conditional
        requirements. The condition can be satisfied either by property in
        build request, by non-conditional requirements, or even by another
        conditional property. For example, the following example works as
        expected:
<programlisting>
exe a : a.cpp 
      : &lt;toolset&gt;gcc:&lt;variant&gt;release 
        &lt;variant&gt;release:&lt;define&gt;FOO ;
</programlisting></para></section></section><section id="bbv2.reference.definitions"><section id="bbv2.reference.features"><title>Features and properties</title><para>A <emphasis>feature</emphasis> is a normalized (toolset-independent)
        aspect of a build configuration, such as whether inlining is
        enabled. Feature names may not contain the '<literal>&gt;</literal>'
        character.</para><para>Each feature in a build configuration has one or more
        associated <emphasis>value</emphasis>s. Feature values for non-free features
        may not contain the '<literal>&lt;</literal>', '<literal>:</literal>', or
        '<literal>=</literal>' characters. Feature values for free features may not
        contain the '<literal>&lt;</literal>' character.</para><para>A <emphasis>property</emphasis> is a (feature,value) pair, expressed as
        &lt;feature&gt;value.</para><para>A <emphasis>subfeature</emphasis> is a feature which only exists in the
        presence of its parent feature, and whose identity can be derived
        (in the context of its parent) from its value. A subfeature's
        parent can never be another subfeature. Thus, features and their
        subfeatures form a two-level hierarchy.</para><para>A <emphasis>value-string</emphasis> for a feature <emphasis role="bold">F</emphasis> is a string of
        the form
        <literal>value-subvalue1-subvalue2</literal>...<literal>-subvalueN</literal>, where
        <literal>value</literal> is a legal value for <emphasis role="bold">F</emphasis> and
        <literal>subvalue1</literal>...<literal>subvalueN</literal> are legal values of some
        of <emphasis role="bold">F</emphasis>'s subfeatures. For example, the properties
        <literal>&lt;toolset&gt;gcc &lt;toolset-version&gt;3.0.1</literal> can be
        expressed more conscisely using a value-string, as
        <literal>&lt;toolset&gt;gcc-3.0.1</literal>.</para><para>A <emphasis>property set</emphasis> is a set of properties (i.e. a
        collection without duplicates), for instance:
        <literal>&lt;toolset&gt;gcc &lt;runtime-link&gt;static</literal>.</para><para>A <emphasis>property path</emphasis> is a property set whose elements have
        been joined into a single string separated by slashes. A property
        path representation of the previous example would be
        <literal>&lt;toolset&gt;gcc/&lt;runtime-link&gt;static</literal>.</para><para>A <emphasis>build specification</emphasis> is a property set which fully
        describes the set of features used to build a target.</para><section id="bbv2.reference.features.validity"><title>Property Validity</title><para>
          For <link linkend="bbv2.reference.features.attributes.free">free</link>
            features, all values are valid. For all other features,
          the valid values are explicitly specified, and the build
          system will report an error for the use of an invalid
          feature-value. Subproperty validity may be restricted so
          that certain values are valid only in the presence of
          certain other subproperties. For example, it is possible
          to specify that the <computeroutput>&lt;gcc-target&gt;mingw</computeroutput>
          property is only valid in the presence of
          <computeroutput>&lt;gcc-version&gt;2.95.2</computeroutput>.
        </para></section><section id="bbv2.reference.features.attributes"><title>Feature Attributes</title><para>Each feature has a collection of zero or more of the following
          attributes. Feature attributes are low-level descriptions of how the
          build system should interpret a feature's values when they appear in
          a build request. We also refer to the attributes of properties, so
          that an <emphasis>incidental</emphasis> property, for example, is
          one whose feature has the <emphasis>incidental</emphasis>
          attribute.</para><itemizedlist><listitem><para><emphasis>incidental</emphasis></para><para>Incidental features are assumed not to affect build
              products at all. As a consequence, the build system may use
              the same file for targets whose build specification differs
              only in incidental features. A feature which controls a
              compiler's warning level is one example of a likely
              incidental feature.</para><para>Non-incidental features are assumed to affect build
              products, so the files for targets whose build specification
              differs in non-incidental features are placed in different
              directories as described in "target paths" below. [ where? ]
            </para></listitem><listitem><para><anchor id="bbv2.reference.features.attributes.propagated"/><emphasis>propagated</emphasis></para><para>Features of this kind are
              propagated to dependencies. That is, if a <link linkend="bbv2.advanced.targets.main">main target</link> is built using a
              propagated
              property, the build systems attempts to use the same property
              when building any of its dependencies as part of that main
              target. For instance, when an optimized exectuable is
              requested, one usually wants it to be linked with optimized
              libraries. Thus, the <literal>&lt;optimization&gt;</literal> feature is
              propagated.</para></listitem><listitem><para><anchor id="bbv2.reference.features.attributes.free"/><emphasis>free</emphasis></para><para>Most features have a finite set of allowed values, and can
              only take on a single value from that set in a given build
              specification. Free features, on the other hand, can have
              several values at a time and each value can be an arbitrary
              string. For example, it is possible to have several
              preprocessor symbols defined simultaneously:</para><programlisting>
&lt;define&gt;NDEBUG=1 &lt;define&gt;HAS_CONFIG_H=1
</programlisting></listitem><listitem><para><emphasis>optional</emphasis></para><para>An optional feature is a feature which is not required to
              appear in a build specification. Every non-optional non-free
              feature has a default value which is used when a value for
              the feature is not otherwise specified, either in a target's
              requirements or in the user's build request. [A feature's
              default value is given by the first value listed in the
              feature's declaration. -- move this elsewhere - dwa]</para></listitem><listitem><para><emphasis>symmetric</emphasis></para><para>A symmetric feature's default value is not automatically
              included in <link linkend="bbv2.reference.variants">build variants</link>.  Normally
              a feature only generates a subvariant directory when its
              value differs from the value specified by the build variant,
              leading to an assymmetric subvariant directory structure for
              certain values of the feature. A symmetric feature, when
              relevant to the toolset, always generates a corresponding
              subvariant directory.</para></listitem><listitem><para><emphasis>path</emphasis></para><para>The value of a path feature specifies a path. The path is
              treated as relative to the directory of Jamfile where path
              feature is used and is translated appropriately by the build
              system when the build is invoked from a different
              directory</para></listitem><listitem><para><emphasis>implicit</emphasis></para><para>Values of implicit features alone identify the feature.
              For example, a user is not required to write
              "&lt;toolset&gt;gcc", but can simply write "gcc". Implicit
              feature names also don't appear in variant paths, although
              the values do. Thus: bin/gcc/... as opposed to
              bin/toolset-gcc/.... There should typically be only a few
              such features, to avoid possible name clashes.</para></listitem><listitem><para><emphasis>composite</emphasis></para><para>Composite features actually correspond to groups of
              properties. For example, a build variant is a composite
              feature. When generating targets from a set of build
              properties, composite features are recursively expanded and
              <emphasis>added</emphasis> to the build property set, so rules can find
              them if neccessary. Non-composite non-free features override
              components of composite features in a build property set.</para></listitem><listitem><para><emphasis>dependency</emphasis></para><para>The value of dependency feature if a target reference.
              When used for building of a main target, the value of
              dependency feature is treated as additional dependency.</para><para>For example, dependency features allow to state that
              library A depends on library B. As the result, whenever an
              application will link to A, it will also link to B.
              Specifying B as dependency of A is different from adding B to
              the sources of A. </para></listitem></itemizedlist><para>Features which are neither free nor incidental are called
          <emphasis>base</emphasis> features.</para></section><section id="bbv2.reference.features.declaration"><title>Feature Declaration</title><para>The low-level feature declaration interface is the
          <literal>feature</literal> rule from the
          <literal>feature</literal> module:
          
<programlisting>
rule feature ( name : allowed-values * : attributes * )
</programlisting>
          
          A feature's allowed-values may be extended with the
          <computeroutput>feature.extend</computeroutput> rule.
        </para></section></section><section id="bbv2.reference.variants"><title>Build Variants</title><para>
        A build variant, or (simply variant) is a special kind of composite
        feature which automatically incorporates the default values of
        features that . Typically you'll want at least two separate
        variants: one for debugging, and one for your release code. [
        Volodya says: "Yea, we'd need to mention that it's a composite
        feature and describe how they are declared, in pacticular that
        default values of non-optional features are incorporated into
        build variant automagically. Also, do we wan't some variant
        inheritance/extension/templates. I don't remember how it works in
        V1, so can't document this for V2.". Will clean up soon -DWA ]
      </para></section><section id="bbv2.reference.variants.proprefine"><title>Property refinement</title><para>When a target with certain properties is requested, and that
        target requires some set of properties, it is needed to find the
        set of properties to use for building. This process is called
        <emphasis>property refinement</emphasis> and is performed by these rules</para><orderedlist><listitem><simpara>
            If original properties and required properties are not
            link-compatible, refinement fails.
          </simpara></listitem><listitem><simpara>
            Each property in the required set is added to the original
            property set
          </simpara></listitem><listitem><simpara>
            If the original property set includes property with a different
            value of non free feature, that property is removed.
          </simpara></listitem></orderedlist></section><section id="bbv2.reference.variants.propcond"><title>Conditional properties</title><para>Sometime it's desirable to apply certain requirements only for
        a specific combination of other properties. For example, one of
        compilers that you use issues a pointless warning that you want to
        suppress by passing a command line option to it. You would not
        want to pass that option to other compilers. Conditional
        properties allow you to do just that. Their syntax is:</para><programlisting>
        property ( "," property ) * ":" property
      </programlisting><para>
        For example, the problem above would be solved by:

<programlisting>
exe hello : hello.cpp : &lt;toolset&gt;yfc:&lt;cxxflags&gt;-disable-pointless-warning ;
</programlisting></para></section><section id="bbv2.reference.ids"><title>Target identifiers and references</title><para><emphasis>Target identifier</emphasis> is used to denote a
        target. The syntax is:</para><programlisting>
target-id -&gt; (project-id | target-name | file-name )
              | (project-id | directory-name) "//" target-name   
project-id -&gt; path
target-name -&gt; path
file-name -&gt; path
directory-name -&gt; path                  
</programlisting><para>
        This grammar allows some elements to be recognized as either
        
        <itemizedlist><listitem><simpara>
              project id (at this point, all project ids start with slash).
            </simpara></listitem><listitem><simpara>
              name of target declared in current Jamfile (note that target
              names may include slash).
            </simpara></listitem><listitem><simpara>
              a regular file, denoted by absolute name or name relative to
              project's sources location.
            </simpara></listitem></itemizedlist>

        To determine the real meaning a check is made if project-id
        by the specified name exists, and then if main target of that
        name exists. For example, valid target ids might be:

<screen>
a                                    -- target in current project
lib/b.cpp                            -- regular file
/boost/thread                        -- project "/boost/thread"
/home/ghost/build/lr_library//parser -- target in specific project
</screen></para><para><emphasis role="bold">Rationale:</emphasis>Target is separated from project by special
        separator (not just slash), because:</para><itemizedlist><listitem><simpara>
            It emphasises that projects and targets are different things.
          </simpara></listitem><listitem><simpara>
            It allows to have main target names with slashes. 

            </simpara></listitem></itemizedlist><para id="bbv2.reference.targets.references"><emphasis>Target reference</emphasis> is used to
        specify a source target, and may additionally specify desired
        properties for that target. It has this syntax:</para><programlisting>
target-reference -&gt; target-id [ "/" requested-properties ]
requested-properties -&gt; property-path
</programlisting><para>
        For example,

        <programlisting>
          exe compiler : compiler.cpp libs/cmdline/&lt;optimization&gt;space ;
        </programlisting>
        
        would cause the version of <literal>cmdline</literal> library,
        optimized for space, to be linked in even if the
        <literal>compiler</literal> executable is build with optimization for
        speed.
      </para></section></section><section id="bbv2.reference.generators"><title>Generators</title><warning><para>The information is this section is likely to be outdated
        and misleading. 
      </para></warning><para>To construct a main target with given properties from sources,
      it is required to create a dependency graph for that main target,
      which will also include actions to be run. The algorithm for
      creating the dependency graph is described here.</para><para>The fundamental concept is <emphasis>generator</emphasis>. If encapsulates
      the notion of build tool and is capable to converting a set of
      input targets into a set of output targets, with some properties.
      Generator matches a build tool as closely as possible: it works
      only when the tool can work with requested properties (for
      example, msvc compiler can't work when requested toolset is gcc),
      and should produce exactly the same targets as the tool (for
      example, if Borland's linker produces additional files with debug
      information, generator should also).</para><para>Given a set of generators, the fundamental operation is to
      construct a target of a given type, with given properties, from a
      set of targets. That operation is performed by rule
      <literal>generators.construct</literal> and the used algorithm is described
      below.</para><section><title>Selecting and ranking viable generators</title><para>Each generator, in addition to target types that it can
        produce, have attribute that affects its applicability in
        particular sitiation. Those attributes are:</para><orderedlist><listitem><simpara>
            Required properties, which are properties absolutely
            necessary for the generator to work. For example, generator
            encapsulating the gcc compiler would have &lt;toolset&gt;gcc as
            required property.
          </simpara></listitem><listitem><simpara>
            Optional properties, which increase the generators
            suitability for a particual build.
          </simpara></listitem></orderedlist><para>
        Generator's required and optional properties may not include
        either free or incidental properties. (Allowing this would
        greatly complicate caching targets).
      </para><para>When trying to construct a target, the first step is to select
        all possible generators for the requested target type, which
        required properties are a subset of requested properties.
        Generators which were already selected up the call stack are
        excluded. In addition, if any composing generators were selected
        up the call stack, all other composing generators are ignored
        (TODO: define composing generators). The found generators
        are assigned a rank, which is the number of optional properties
        present in requested properties. Finally, generators with highest
        rank are selected for futher processing.</para></section><section><title>Running generators</title><para>When generators are selected, each is run to produce a list of
        created targets. This list might include targets which are not of
        requested types, because generators create the same targets as
        some tool, and tool's behaviour is fixed. (Note: should specify
        that in some cases we actually want extra targets). If generator
        fails, it returns an empty list. Generator is free to call
        'construct' again, to convert sources to the types it can handle.
        It also can pass modified properties to 'construct'. However, a
        generator is not allowed to modify any propagated properties,
        otherwise when actually consuming properties we might discover
        that the set of propagated properties is different from what was
        used for building sources.</para><para>For all targets which are not of requested types, we try to
        convert them to requested type, using a second call to
        <literal>construct</literal>. This is done in order to support
        transformation sequences where single source file expands to
        several later. See <ulink url="http://groups.yahoo.com/group/jamboost/message/1667">this
          message</ulink> for details.</para></section><section><title>Selecting dependency graph</title><para>
        After all generators are run,
        it is necessary to decide which of successfull invocation will be
        taken as final result. At the moment, this is not done. Instead,
        it is checked whether all successfull generator invocation
        returned the same target list. Error is issued otherwise.
      </para></section><section><title>Property adjustment</title><para>Because target location is determined by the build system, it
        is sometimes necessary to adjust properties, in order to not
        break actions. For example, if there's an action which generates
        a header, say "a_parser.h", and a source file "a.cpp" which
        includes that file, we must make everything work as if a_parser.h
        is generated in the same directory where it would be generated
        without any subvariants.</para><para>Correct property adjustment can be done only after all targets
        are created, so the approach taken is:</para><orderedlist><listitem><para>
            When dependency graph is constructed, each action can be
            assigned a rule for property adjustment.
          </para></listitem><listitem><para>
            When virtual target is actualized, that rule is run and
            return the final set of properties. At this stage it can use
            information of all created virtual targets.
          </para></listitem></orderedlist><para>In case of quoted includes, no adjustment can give 100% correct
        results. If target dirs are not changed by build system, quoted
        includes are searched in "." and then in include path, while angle
        includes are searched only in include path. When target dirs are
        changed, we'd want to make quoted includes to be search in "." then in
        additional dirs and then in the include path and make angle includes
        be searched in include path, probably with additional paths added at
        some position. Unless, include path already has "." as the first
        element, this is not possible. So, either generated headers should not
        be included with quotes, or first element of include path should be
        ".", which essentially erases the difference between quoted and angle
        includes. <emphasis role="bold">Note:</emphasis> the only way to get
        "." as include path into compiler command line is via verbatim
        compiler option. In all other case, Boost.Build will convert "." into
        directory where it occurs.</para></section><section><title>Transformations cache</title><para>
        Under certain conditions, an
        attempt is made to cache results of transformation search. First,
        the sources are replaced with targets with special name and the
        found target list is stored. Later, when properties, requested
        type, and source type are the same, the store target list is
        retrieved and cloned, with appropriate change in names.
      </para></section></section></chapter><chapter id="bbv2.faq" xml:base="../tools/build/v2/doc/src/faq.xml"><title>Frequently Asked Questions</title><section><title>
        I'm getting "Duplicate name of actual target" error. What
        does it mean?
      </title><para>    
    The most likely case is that you're trying to
    compile the same file twice, with almost the same,
    but differing properties. For example:

<programlisting>
exe a : a.cpp : &lt;include&gt;/usr/local/include ;
exe b : a.cpp ;
</programlisting></para><para>
    The above snippet requires two different compilations
    of 'a.cpp', which differ only in 'include' property.
    Since the 'include' property is free, Boost.Build
    can't generate two objects files into different directories.
    On the other hand, it's dangerous to compile the file only
    once -- maybe you really want to compile with different
    includes.
    </para><para>
    To solve this issue, you need to decide if file should
    be compiled once or twice.</para><orderedlist><listitem><para>Two compile file only once, make sure that properties
      are the same:

<programlisting>
exe a : a.cpp : &lt;include&gt;/usr/local/include ;
exe b : a.cpp : &lt;include&gt;/usr/local/include ;
</programlisting></para></listitem><listitem><para>
      If changing the properties is not desirable, for example
      if 'a' and 'b' target have other sources which need
      specific properties, separate 'a.cpp' into it's own target:

<programlisting>
obj a_obj : a.cpp : &lt;include&gt;/usr/local/include ;
exe a : a_obj ;
</programlisting></para></listitem><listitem><para>
      To compile file twice, you can make the object file local
      to the main target:

<programlisting>
      exe a : [ obj a_obj : a.cpp ] : &lt;include&gt;/usr/local/include ;
      exe b : [ obj a_obj : a.cpp ] ;
</programlisting></para></listitem></orderedlist><para>
   A good question is why Boost.Build can't use some of the above
   approaches automatically. The problem is that such magic would
   require additional implementation complexities and would only
   help in half of the cases, while in other half we'd be silently
   doing the wrong thing. It's simpler and safe to ask user to
   clarify his intention in such cases.
   </para></section><section><title>
      Accessing environment variables
      </title><para>    
      Many users would like to use environment variables in Jamfiles, for
      example, to control location of external libraries. In many cases you
      better declare those external libraries in the site-config.jam file, as
      documented in the <link linkend="bbv2.recipies.site-config">recipes
      section</link>. However, if the users already have the environment variables set
      up, it's not convenient to ask them to set up site-config.jam files as
      well, and using environment variables might be reasonable.
    </para><para>In Boost.Build V2, each Jamfile is a separate namespace, and the
    variables defined in environment is imported into the global
    namespace. Therefore, to access environment variable from Jamfile, you'd
    need the following code:
<programlisting>
import modules ;
local SOME_LIBRARY_PATH = [ modules.peek : SOME_LIBRARY_PATH ] ;
exe a : a.cpp : &lt;include&gt;$(SOME_LIBRARY_PATH) ;
</programlisting></para></section><section><title>
        How to control properties order?
      </title><para>For internal reasons, Boost.Build sorts all the properties
    alphabetically. This means that if you write:
<programlisting>
exe a : a.cpp : &lt;include&gt;b &lt;include&gt;a ;
</programlisting>
      then the command line with first mention the "a" include directory, and
      then "b", even though they are specified in the opposite order. In most
      cases, the user doesn't care. But sometimes the order of includes, or
      other properties, is important. For example, if one uses both the C++
      Boost library and the "boost-sandbox" (libraries in development), then
      include path for boost-sandbox must come first, because some headers may
      override ones in C++ Boost. For such cases, a special syntax is
      provided:
<programlisting>
exe a : a.cpp : &lt;include&gt;a&amp;&amp;b ;        
</programlisting></para><para>The <computeroutput>&amp;&amp;</computeroutput> symbols separate values of an
      property, and specify that the order of the values should be preserved. You
      are advised to use this feature only when the order of properties really
      matters, and not as a convenient shortcut. Using it everywhere might
      negatively affect performance.
    </para></section><section><title>
      How to control the library order on Unix?
    </title><para>On the Unix-like operating systems, the order in which static
      libraries are specified when invoking the linker is important, because by
      default, the linker uses one pass though the libraries list. Passing the
      libraries in the incorrect order will lead to a link error. Further, this
      behaviour is often used to make one library override symbols from
      another. So, sometimes it's necessary to force specific order of
      libraries.    
    </para><para>Boost.Build tries to automatically compute the right order.  The
      primary rule is that if library a "uses" library b, then library a will
      appear on the command line before library b. Library a is considered to
      use b is b is present either in the sources of a or in its
      requirements. To explicitly specify the use relationship one can use the
      &lt;use&gt; feature. For example, both of the following lines will cause
      a to appear before b on the command line:
<programlisting>
lib a : a.cpp b ;
lib a : a.cpp : &lt;use&gt;b ;
</programlisting></para><para>
      The same approach works for searched libraries, too:
<programlisting>
lib z ;
lib png : : &lt;use&gt;z ;
exe viewer : viewer png z ;
</programlisting></para></section><section id="bbv2.faq.external"><title>Can I get output of external program as a variable in a Jamfile?
    </title><para>From time to time users ask how to run an external program and save
    the result in Jamfile variable, something like:
<programlisting>
local gtk_includes = [ RUN_COMMAND gtk-config ] ;
</programlisting>
      Unfortunately, this is not possible at the moment. However, if the
      result of command invocation is to be used in a command to some tool,
      and you're working on Unix, the following workaround is possible.
<programlisting>
 alias gtk+-2.0 : : : :
         &lt;cflags&gt;"`pkg-config --cflags gtk+-2.0`"
         &lt;inkflags&gt;"`pkg-config --libs gtk+-2.0`"
     ;
</programlisting>
      If you use the "gtk+-2.0" target in sources, then the properties
      specified above will be added to the build properties and eventually
      will appear in the command line. Unix command line shell processes
      the backticks quoting by running the tool and using its output --
      which is what's desired in that case. Thanks to Daniel James for
      sharing this approach.
    </para></section><section><title>How to get the project-root location?
    </title><para>You might want to use the location of the project-root in your
      Jamfiles. To do it, you'd need to declare path constant in your
      project-root.jam:
<programlisting>
path-constant TOP : . ;
</programlisting>
      After that, the <computeroutput>TOP</computeroutput> variable can be used in every Jamfile.
    </para></section><section><title>How to change compilation flags for one file?
    </title><para>If one file must be compiled with special options, you need to
      explicitly declare an <computeroutput>obj</computeroutput> target for that file and then use
      that target in your <computeroutput>exe</computeroutput> or <computeroutput>lib</computeroutput> target:
<programlisting>
exe a : a.cpp b ;
obj b : b.cpp : &lt;optimization&gt;off ;
</programlisting>
      Of course you can use other properties, for example to specify specific
      compiler options:
<programlisting>
exe a : a.cpp b ;
obj b : b.cpp : &lt;cflags&gt;-g ;
</programlisting>
      You can also use <link linkend="bbv2.tutorial.conditions">conditional
      properties</link> for finer control:
<programlisting>
exe a : a.cpp b ;
obj b : b.cpp : &lt;variant&gt;release:&lt;optimization&gt;off ;
</programlisting></para></section><section id="bbv2.faq.dll-path"><title>Why are the <computeroutput>dll-path</computeroutput> and
    <computeroutput>hardcode-dll-paths</computeroutput> properties useful?
    </title><para>(This entry is specific to Unix system.)Before answering the
      questions, let's recall a few points about shared libraries. Shared
      libraries can be used by several applications, or other libraries,
      without phisycally including the library in the application. This can
      greatly decrease the total size of applications. It's also possible to
      upgrade a shared library when the application is already
      installed. Finally, shared linking can be faster.
    </para><para>However, the shared library must be found when the application is
      started. The dynamic linker will search in a system-defined list of
      paths, load the library and resolve the symbols. Which means that you
      should either change the system-defined list, given by the
      <envar>LD_LIBRARY_PATH</envar> environment variable, or install the
      libraries to a system location. This can be inconvenient when
      developing, since the libraries are not yet ready to be installed, and
      cluttering system paths is undesirable. Luckily, on Unix there's another
      way.
    </para><para>An executable can include a list of additional library paths, which
      will be searched before system paths. This is excellent for development,
      because the build system knows the paths to all libraries and can include
      them in executables. That's done when the <computeroutput>hardcode-dll-paths</computeroutput>
      feature has the <literal>true</literal> value, which is the
      default. When the executables should be installed, the story is
      different.
    </para><para>
      Obviously, installed executable should not hardcode paths to your
      development tree. (The <computeroutput>stage</computeroutput> rule explicitly disables the
      <computeroutput>hardcode-dll-paths</computeroutput> feature for that reason.) However, you
      can use the <computeroutput>dll-path</computeroutput> feature to add explicit paths
      manually. For example:
<programlisting>
stage installed : application : &lt;dll-path&gt;/usr/lib/snake
                                &lt;location&gt;/usr/bin ;          
</programlisting>
      will allow the application to find libraries placed to
      <filename>/usr/lib/snake</filename>.
    </para><para>If you install libraries to a nonstandard location and add an
      explicit path, you get more control over libraries which will be used. A
      library of the same name in a system location will not be inadvertently
      used.  If you install libraries to a system location and do not add any
      paths, the system administrator will have more control. Each library can
      be individually upgraded, and all applications will use the new library.
    </para><para>Which approach is best depends on your situation. If the libraries
      are relatively standalone and can be used by third party applications,
      they should be installed in the system location. If you have lots of
      libraries which can be used only by our application, it makes sense to
      install it to a nonstandard directory and add an explicit path, like the
      example above shows. Please also note that guidelines for different
      systems differ in this respect. The Debian guidelines prohibit any
      additional search paths, and Solaris guidelines suggest that they should
      always be used.
    </para></section><section id="bbv2.recipies.site-config"><title>Targets in site-config.jam</title><para>It is desirable to declare standard libraries available on a
      given system. Putting target declaration in Jamfile is not really
      good, since locations of the libraries can vary. The solution is
      to put the following to site-config.jam.</para><programlisting>
import project ;
project.initialize $(__name__) ;
project site-config ;
lib zlib : : &lt;name&gt;z ;
</programlisting><para>The second line allows this module to act as project. The
      third line gives id to this project &#x2014; it really has no location
      and cannot be used otherwise. The fourth line just declares a
      target. Now, one can write:
<programlisting>
exe hello : hello.cpp /site-config//zlib ;
</programlisting>
      in any Jamfile.</para></section></chapter><appendix id="bbv2.arch" xml:base="../tools/build/v2/doc/src/architecture.xml"><title>Boost.Build v2 architecture</title><sidebar><para>This document is work-in progress. Don't expect much from it
      yet.</para></sidebar><section id="bbv2.arch.overview"><title>Overview</title><para>The Boost.Build code is structured in four different components:
    "kernel", "util", "build" and "tools". The first two are relatively
    uninteresting, so we'll focus on the remaining pair. The "build" component
    provides classes necessary to declare targets, determine which properties
    should be used for their building, and for creating the dependency
    graph. The "tools" component provides user-visible functionality. It
    mostly allows to declare specific kind of main targets, and declare
    avaiable tools, which are then used when creating the dependency graph.
    </para></section><section id="bbv2.arch.build"><title>The build layer</title><para>The build layer has just four main parts -- abstract targets,
      virtual targets, generators and properties. The abstract targets,
      represented by the "abstract-target" class, correspond to main targets
      -- which, as you recall, can produce different files depending on
      properties. Virtual targets, represented by the 'virtual-target' class
      correspond to real files. The abstract-target class has a method
      'generate', which is given a set of properties and produces virtual
      targets for those properties.       
    </para><para>There are several classes derived from "abstract-target". The
      "main-target" class represents top-level main target, the "project-target"
      acts like container for all main targets, and "basic-target" class is a
      base class for all further target types.
    </para><para>Since each main target can have several alternatives, all top-level
      target objects are just containers, referring to "real" main target
      classes. The type is that container is "main-target". For example, given:
<programlisting>
alias a ;
lib a : a.cpp : &lt;toolset&gt;gcc ;
</programlisting>
      we would have one-top level instance of "main-target-class", which will
      contain one instance of "alias-target-class" and one instance of
      "lib-target-class". The "generate" method of "main-target" decides
      which of the alternative should be used, and call "generate" on the
      corresponding instance.
</para><para>Each alternative is a instance of a class derived from
    "basic-target". The "basic-target.generate" does several things that are
    always should be done:
      <itemizedlist><listitem><para>Determines what properties should be used for building the
          target. This includes looking at requested properties, requirements,
          and usage requirements of all sources.</para></listitem><listitem><para>Builds all sources</para></listitem><listitem><para>Computes the usage requirements which should be passes back.</para></listitem></itemizedlist>
      For the real work of constructing virtual target, a new method
      "construct" is called.
    </para><para>The "construct" method can be implemented in any way by classes
      derived from "basic-target", but one specific derived class plays the
      central role -- "typed-target". That class holds the desired type of file
      to be produces, and calls the generators modules to do the job.
    </para><para>Generators are Boost.Build abstractions for a tool. For example, one
      can register a generator which converts target of type CPP into target of
      type OBJ. When run with on a virtual target with CPP type, the generator
      will construct the virtual target of type OBJ. The "generators" module
      implements an algorithm, which given a list of sources, the desired type
      and a list of properties, find all the generators which can perform the conversion.
    </para><para>The virtual targets which are produces by the main targets form a
      graph. Targets which are produces from other ones refer to an instance of
      "action" class, which in turn refers to action's sources, which can
      further refer to actions. The sources, which are not produces from
      anything, don't refer to any actions.
    </para><para>When all virtual targets are produced, they are "actualized". This
    means that the real file names are computed, and the commands that should
    be run are generated. This is done by "virtual-target.actualize" and
    "action.actualize" methods. The first is conceptually simple, while the
    second need additional explanation. The commands in bjam are generated in
    two-stage process. First, a rule with the appropriate name (for example
    "gcc.compile") is called and is given the names of targets. The rule sets
    some variables, like "OPTIONS". After that, the command string is taken,
    and variable are substitutes, so use of OPTIONS inside the command string
    become the real compile options. 
    </para><para>Boost.Build added a third stage to simplify things. It's now
    possible to automatically convert properties to appropriate assignments to
    variables. For example, &lt;debug-symbols&gt;on would add "-g" to the
    OPTIONS variable, without requiring to manually add this logic to
    gcc.compile. This functionality is part of the "toolset" module.
    </para><para>When target paths are computed and the commands are set, Boost.Build
    just gives control to bjam, which controls the execution of
    commands.</para></section><section id="bbv2.arch.tools"><title>The tools layer</title><para>Write me!</para></section><section id="bbv2.arch.targets"><title>Targets</title><para>NOTE: THIS SECTION IS NOT EXPECTED TO BE READ!
        There are two user-visible kinds of targets in Boost.Build.
  First are "abstract" &#x2014; they correspond to things declared
  by user, for example, projects and executable files. The primary
  thing about abstract target is that it's possible to request them
  to be build with a particular values of some properties. Each
  combination of properties may possible yield different set of
  real file, so abstract target do not have a direct correspondence
  with files.</para><para>File targets, on the contary, are associated with concrete
  files. Dependency graphs for abstract targets with specific
  properties are constructed from file targets. User has no was to
  create file targets, however it can specify rules that detect
  file type for sources, and also rules for transforming between
  file targets of different types. That information is used in
  constructing dependency graph, as desribed in the "next section".
  [ link? ] <emphasis role="bold">Note:</emphasis>File targets are not
  the same as targets in Jam sense; the latter are created from
  file targets at the latest possible moment. <emphasis role="bold">Note:</emphasis>"File
  target" is a proposed name for what we call virtual targets. It
  it more understandable by users, but has one problem: virtual
  targets can potentially be "phony", and not correspond to any
  file.</para><section id="bbv2.arch.depends"><title>Dependency scanning</title><para>Dependency scanning is the process of finding implicit
  dependencies, like "#include" statements in C++. The requirements
  for right dependency scanning mechanism are:</para><itemizedlist><listitem><simpara>
        Support for different scanning algorithms. C++ and XML have
    quite different syntax for includes and rules for looking up
    included files.
      </simpara></listitem><listitem><simpara>
        Ability to scan the same file several times. For example,
    single C++ file can be compiled with different include
    paths.
      </simpara></listitem><listitem><simpara>
        Proper detection of dependencies on generated files.
      </simpara></listitem><listitem><simpara>
        Proper detection of dependencies from generated file.
      </simpara></listitem></itemizedlist><section><title>Support for different scanning algorithms</title><para>Different scanning algorithm are encapsulated by objects
  called "scanners". Please see the documentation for "scanner"
  module for more details.</para></section><section><title>Ability to scan the same file several times</title><para>As said above, it's possible to compile a C++ file twice, with
  different include paths. Therefore, include dependencies for
  those compilations can be different. The problem is that bjam
  does not allow several scans of the same target.</para><para>The solution in Boost.Build is straigtforward. When a virtual
  target is converted to bjam target (via
  <literal>virtual-target.actualize</literal> method), we specify the scanner
  object to be used. The actualize method will create different
  bjam targets for different scanners.</para><para>All targets with specific scanner are made dependent on target
  without scanner, which target is always created. This is done in
  case the target is updated. The updating action will be
  associated with target without scanner, but if sources for that
  action are touched, all targets &#x2014; with scanner and without
  should be considered outdated.</para><para>For example, assume that "a.cpp" is compiled by two compilers
  with different include path. It's also copied into some install
  location. In turn, it's produced from "a.verbatim". The
  dependency graph will look like:</para><programlisting>
a.o (&lt;toolset&gt;gcc)  &lt;--(compile)-- a.cpp (scanner1) ----+
a.o (&lt;toolset&gt;msvc) &lt;--(compile)-- a.cpp (scanner2) ----|
a.cpp (installed copy)    &lt;--(copy) ----------------------- a.cpp (no scanner)
                                                                 ^
                                                                 |
                       a.verbose --------------------------------+
</programlisting></section><section><title>Proper detection of dependencies on generated files.</title><para>This requirement breaks down to the following ones.</para><orderedlist><listitem><simpara>
        If when compiling "a.cpp" there's include of "a.h", the
    "dir" directory is in include path, and a target called "a.h"
    will be generated to "dir", then bjam should discover the
    include, and create "a.h" before compiling "a.cpp".
      </simpara></listitem><listitem><simpara>
      Since almost always Boost.Build generates targets to a
    "bin" directory, it should be supported as well. I.e. in the
    scanario above, Jamfile in "dir" might create a main target,
    which generates "a.h". The file will be generated to "dir/bin"
    directory, but we still have to recornize the dependency.
      </simpara></listitem></orderedlist><para>The first requirement means that when determining what "a.h"
  means, when found in "a.cpp", we have to iterate over all
  directories in include paths, checking for each one:</para><orderedlist><listitem><simpara>
        If there's file "a.h" in that directory, or
      </simpara></listitem><listitem><simpara>
        If there's a target called "a.h", which will be generated
    to that directory.
      </simpara></listitem></orderedlist><para>Classic Jam has built-in facilities for point (1) above, but
  that's not enough. It's hard to implement the right semantic
  without builtin support. For example, we could try to check if
  there's targer called "a.h" somewhere in dependency graph, and
  add a dependency to it. The problem is that without search in
  include path, the semantic may be incorrect. For example, one can
  have an action which generated some "dummy" header, for system
  which don't have the native one. Naturally, we don't want to
  depend on that generated header on platforms where native one is
  included.</para><para>There are two design choices for builtin support. Suppose we
  have files a.cpp and b.cpp, and each one includes header.h,
  generated by some action. Dependency graph created by classic jam
  would look like:</para><programlisting>
a.cpp -----&gt; &lt;scanner1&gt;header.h  [search path: d1, d2, d3]


                  &lt;d2&gt;header.h  --------&gt; header.y
                  [generated in d2]
           
b.cpp -----&gt; &lt;scanner2&gt;header.h [ search path: d1, d2, d4]
</programlisting><para>
In this case, Jam thinks all header.h target are not
realated. The right dependency graph might be:

<programlisting>
a.cpp ---- 
          \
           \     
            &gt;----&gt;  &lt;d2&gt;header.h  --------&gt; header.y
           /       [generated in d2]
          / 
b.cpp ----
</programlisting>

or

<programlisting>
a.cpp -----&gt; &lt;scanner1&gt;header.h  [search path: d1, d2, d3]
                          |
                       (includes)
                          V
                  &lt;d2&gt;header.h  --------&gt; header.y
                  [generated in d2]
                          ^
                      (includes)  
                          |
b.cpp -----&gt; &lt;scanner2&gt;header.h [ search path: d1, d2, d4]
</programlisting></para><para>
The first alternative was used for some time. The problem
however is: what include paths should be used when scanning
header.h? The second alternative was suggested by Matt Armstrong.
It has similiar effect: add targets which depend on
&lt;scanner1&gt;header.h will also depend on &lt;d2&gt;header.h.
But now we have two different target with two different scanners,
and those targets can be scanned independently. The problem of
first alternative is avoided, so the second alternative is
implemented now.
        </para><para>The second sub-requirements is that targets generated to "bin"
  directory are handled as well. Boost.Build implements
  semi-automatic approach. When compiling C++ files the process
  is:</para><orderedlist><listitem><simpara>
        The main target to which compiled file belongs is found.
      </simpara></listitem><listitem><simpara>
        All other main targets that the found one depends on are
    found. Those include main target which are used as sources, or
    present as values of "dependency" features.
      </simpara></listitem><listitem><simpara>
        All directories where files belonging to those main target
    will be generated are added to the include path.
      </simpara></listitem></orderedlist><para>After this is done, dependencies are found by the approach
  explained previously.</para><para>Note that if a target uses generated headers from other main
  target, that main target should be explicitly specified as
  dependency property. It would be better to lift this requirement,
  but it seems not very problematic in practice.</para><para>For target types other than C++, adding of include paths must
  be implemented anew.</para></section><section><title>Proper detection of dependencies from generated files</title><para>Suppose file "a.cpp" includes "a.h" and both are generated by
  some action. Note that classic jam has two stages. In first stage
  dependency graph graph is build and actions which should be run
  are determined. In second stage the actions are executed.
  Initially, neither file exists, so the include is not found. As
  the result, jam might attempt to compile a.cpp before creating
  a.h, and compilation will fail.</para><para>The solution in Boost.Jam is to perform additional dependency
  scans after targets are updated. This break separation between
  build stages in jam &#x2014; which some people consider a good
  thing &#x2014; but I'm not aware of any better solution.</para><para>In order to understand the rest of this section, you better
  read some details about jam dependency scanning, available
  <ulink url="http://public.perforce.com:8080/@md=d&amp;cd=//public/jam/src/&amp;ra=s&amp;c=kVu@//2614?ac=10">
  at this link</ulink>.</para><para>Whenever a target is updated, Boost.Jam rescans it for
  includes. Consider this graph, created before any actions are
  run.</para><programlisting>
A -------&gt; C ----&gt; C.pro
     /
B --/         C-includes   ---&gt; D
</programlisting><para>
Both A and B have dependency on C and C-includes (the latter
dependency is not shown). Say during building we've tried to create
A, then tried to create C and successfully created C.
        </para><para>In that case, the set of includes in C might well have
  changed. We do not bother to detect precisely which includes were
  added or removed. Instead we create another internal node
  C-includes-2. Then we determine what actions should be run to
  update the target. In fact this mean that we perform logic of
  first stage while already executing stage.</para><para>After actions for C-includes-2 are determined, we add
  C-includes-2 to the list of A's dependents, and stage 2 proceeds
  as usual. Unfortunately, we can't do the same with target B,
  since when it's not visited, C target does not know B depends on
  it. So, we add a flag to C which tells and it was rescanned. When
  visiting B target, the flag is notices and C-includes-2 will be
  added to the list of B's dependencies.</para><para>Note also that internal nodes are sometimes updated too.
  Consider this dependency graph:</para><programlisting>
a.o ---&gt; a.cpp
            a.cpp-includes --&gt;  a.h (scanned)
                                   a.h-includes ------&gt; a.h (generated)
                                                                 |
                                                                 |
            a.pro &lt;-------------------------------------------+
</programlisting><para>Here, out handling of generated headers come into play. Say
  that a.h exists but is out of date with respect to "a.pro", then
  "a.h (generated)" and "a.h-includes" will be marking for
  updating, but "a.h (scanned)" won't be marked. We have to rescan
  "a.h" file after it's created, but since "a.h (generated)" has no
  scanner associated with it, it's only possible to rescan "a.h"
  after "a.h-includes" target was updated.</para><para>Tbe above consideration lead to decision that we'll rescan a
  target whenever it's updated, no matter if this target is
  internal or not.</para><warning><para>
    The remainder of this document is not indended to be read at
    all. This will be rearranged in future.
    </para></warning><section><title>File targets</title><para>
  As described above, file targets corresponds
  to files that Boost.Build manages. User's may be concerned about
  file targets in three ways: when declaring file target types,
  when declaring transformations between types, and when
  determining where file target will be placed. File targets can
  also be connected with actions, that determine how the target is
  created. Both file targets and actions are implemented in the
  <literal>virtual-target</literal> module.
          </para><section><title>Types</title><para>A file target can be given a file, which determines
  what transformations can be applied to the file. The
  <literal>type.register</literal> rule declares new types. File type can
  also be assigned a scanner, which is used to find implicit
  dependencies. See "dependency scanning" [ link? ] below.</para></section></section><section><title>Target paths</title><para>To distinguish targets build with different properties, they
  are put in different directories. Rules for determining target
  paths are given below:</para><orderedlist><listitem><simpara>
        All targets are placed under directory corresponding to the
    project where they are defined.
      </simpara></listitem><listitem><simpara>
        Each non free, non incidental property cause an additional
    element to be added to the target path. That element has the
    form <literal>&lt;feature-name&gt;-&lt;feature-value&gt;</literal> for
    ordinary features and <literal>&lt;feature-value&gt;</literal> for
    implicit ones. [Note about composite features].
      </simpara></listitem><listitem><simpara>
        If the set of free, non incidental properties is different
    from the set of free, non incidental properties for the project
    in which the main target that uses the target is defined, a
    part of the form <literal>main_target-&lt;name&gt;</literal> is added to
    the target path. <emphasis role="bold">Note:</emphasis>It would be nice to completely
    track free features also, but this appears to be complex and
    not extremely needed.
      </simpara></listitem></orderedlist><para>For example, we might have these paths:</para><programlisting>
debug/optimization-off
debug/main-target-a
</programlisting></section></section></section></section></appendix></part></book>
