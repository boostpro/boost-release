<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Class template variant</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.66.1">
<link rel="start" href="../index.html" title="The Boost C++ Libraries">
<link rel="up" href="../variant/reference.html#id516960" title="Header &lt;boost/variant/variant.hpp&gt;">
<link rel="prev" href="../id413934.html" title="Macro BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT">
<link rel="next" href="../id503912.html" title="Function template swap">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%">
<td valign="top"><img alt="boost.png (6897 bytes)" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.htm">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="../../../people/people.htm">People</a></td>
<td align="center"><a href="../../../more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../id413934.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../variant/reference.html#id516960"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="../id503912.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.variant"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template variant</span></h2>
<p>boost::variant &#8212; Safe, generic, stack-based discriminated union container.</p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> T1, <span class="bold"><b>typename</b></span> T2 = <span class="emphasis"><em>unspecified</em></span>, ..., 
         <span class="bold"><b>typename</b></span> TN = <span class="emphasis"><em>unspecified</em></span>&gt; 
<span class="bold"><b>class</b></span> variant {
<span class="bold"><b>public</b></span>:
  <span class="emphasis"><em>// types</em></span>
  <span class="bold"><b>typedef</b></span> <span class="emphasis"><em>unspecified</em></span> types;

  <span class="emphasis"><em>// <a href="variant.html#boost.variantconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a href="variant.html#id372464-bb">variant</a>();
  <a href="variant.html#id508111-bb">variant</a>(<span class="bold"><b>const</b></span> variant &amp;);
  <span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> T&gt; <a href="variant.html#id552173-bb">variant</a>(T &amp;);
  <span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> T&gt; <a href="variant.html#id399284-bb">variant</a>(<span class="bold"><b>const</b></span> T &amp;);
  <span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> U1, <span class="bold"><b>typename</b></span> U2, ..., <span class="bold"><b>typename</b></span> UN&gt; 
    <a href="variant.html#id571867-bb">variant</a>(variant&lt;U1, U2, ..., UN&gt; &amp;);
  <span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> U1, <span class="bold"><b>typename</b></span> U2, ..., <span class="bold"><b>typename</b></span> UN&gt; 
    <a href="variant.html#id452740-bb">variant</a>(<span class="bold"><b>const</b></span> variant&lt;U1, U2, ..., UN&gt; &amp;);
  <a href="variant.html#id452937-bb">~variant</a>();

  <span class="emphasis"><em>// <a href="variant.html#id542939-bb">modifiers</a></em></span>
  <span class="type"><span class="bold"><b>void</b></span></span> <a href="variant.html#id558196-bb">swap</a>(variant &amp;);
  <span class="type">variant &amp;</span> <a href="variant.html#id506925-bb"><span class="bold"><b>operator</b></span>=</a>(<span class="bold"><b>const</b></span> variant &amp;);
  <span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> T&gt; <span class="type">variant &amp;</span> <a href="variant.html#id454843-bb"><span class="bold"><b>operator</b></span>=</a>(<span class="bold"><b>const</b></span> T &amp;);

  <span class="emphasis"><em>// <a href="variant.html#id463182-bb">queries</a></em></span>
  <span class="type"><span class="bold"><b>int</b></span></span> <a href="variant.html#id479663-bb">which</a>() <span class="bold"><b>const</b></span>;
  <span class="type"><span class="bold"><b>bool</b></span></span> <a href="variant.html#id489830-bb">empty</a>() <span class="bold"><b>const</b></span>;
  <span class="type"><span class="bold"><b>const</b></span> std::type_info &amp;</span> <a href="variant.html#id443569-bb">type</a>() <span class="bold"><b>const</b></span>;

  <span class="emphasis"><em>// <a href="variant.html#id401169-bb">relational</a></em></span>
  <span class="type"><span class="bold"><b>bool</b></span></span> <a href="variant.html#id266128-bb"><span class="bold"><b>operator</b></span>==</a>(<span class="bold"><b>const</b></span> variant &amp;) <span class="bold"><b>const</b></span>;
  <span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> U&gt; <span class="type"><span class="bold"><b>void</b></span></span> <a href="variant.html#id480375-bb"><span class="bold"><b>operator</b></span>==</a>(<span class="bold"><b>const</b></span> U &amp;) <span class="bold"><b>const</b></span>;
  <span class="type"><span class="bold"><b>bool</b></span></span> <a href="variant.html#id498388-bb"><span class="bold"><b>operator</b></span>&lt;</a>(<span class="bold"><b>const</b></span> variant &amp;) <span class="bold"><b>const</b></span>;
  <span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> U&gt; <span class="type"><span class="bold"><b>void</b></span></span> <a href="variant.html#id458182-bb"><span class="bold"><b>operator</b></span>&lt;</a>(<span class="bold"><b>const</b></span> U &amp;) <span class="bold"><b>const</b></span>;
};</pre></div>
<div class="refsect1" lang="en">
<a name="id647137"></a><h2>Description</h2>
<p>The <tt class="computeroutput">variant</tt> class template (inspired by Andrei
        Alexandrescu's class of the same name
        [<a href="../variant/refs.html#variant.refs.ale01a">Ale01A</a>]) is an efficient,
        <a href="../variant/tutorial.html#variant.tutorial.recursive" title="Recursive variant types">recursive-capable</a>,
        bounded discriminated union value type capable of containing any value
        type (either POD or non-POD). It supports construction from any type
        convertible to one of its bounded types or from a source
        <tt class="computeroutput">variant</tt> whose bounded types are each convertible to one
        of the destination <tt class="computeroutput">variant</tt>'s bounded types. As well,
        through <tt class="computeroutput"><a href="../apply_visitor.html" title="Function apply_visitor">apply_visitor</a></tt>,
        <tt class="computeroutput">variant</tt> supports compile-time checked, type-safe
        visitation; and through <tt class="computeroutput"><a href="../get.html" title="Function get">get</a></tt>,
        <tt class="computeroutput">variant</tt> supports run-time checked, type-safe value
        retrieval.</p>
<p><span class="bold"><b>Notes</b></span>:</p>
<div class="itemizedlist"><ul type="disc">
<li>The bounded types of the <tt class="computeroutput">variant</tt> are exposed
            via the nested typedef <tt class="computeroutput">types</tt>, which is an
            <a href="../../../libs/mpl/index.html" target="_top">MPL</a>-compatible Sequence containing the
            set of types that must be handled by any
            <a href="../variant/reference.html#variant.concepts.static-visitor" title="StaticVisitor">visitor</a> to
            the <tt class="computeroutput">variant</tt>.</li>
<li>All members of <tt class="computeroutput">variant</tt> satisfy at least the
            basic guarantee of exception-safety. That is, all operations on
            a <tt class="computeroutput">variant</tt> remain defined even after previous
            operations have failed.</li>
<li>Each type specified as a template argument to
            <tt class="computeroutput">variant</tt> must meet the requirements of the
            <span class="emphasis"><em><a href="../variant/reference.html#variant.concepts.bounded-type" title="BoundedType">BoundedType</a></em></span>
            concept.</li>
<li>Each type specified as a template argument to
            <tt class="computeroutput">variant</tt> must be distinct after removal of qualifiers.
            Thus, for instance, both <tt class="computeroutput">variant&lt;int, int&gt;</tt> and
            <tt class="computeroutput">variant&lt;int, const int&gt;</tt> have undefined
            behavior.</li>
<li>Conforming implementations of <tt class="computeroutput">variant</tt> must
            allow at least ten types as template arguments. The exact number
            of allowed arguments is exposed by the preprocessor macro
            <tt class="computeroutput"><a href="../BOOST_VARIANT_LIMIT_TYPES.html" title="Macro BOOST_VARIANT_LIMIT_TYPES">BOOST_VARIANT_LIMIT_TYPES</a></tt>.
            (See <tt class="computeroutput"><a href="../make_variant_over.html" title="Class template make_variant_over">make_variant_over</a></tt> for a
            means to specify the bounded types of a <tt class="computeroutput">variant</tt> by
            the elements of an <a href="../../../libs/mpl/index.html" target="_top">MPL</a> or compatible
            Sequence, thus overcoming this limitation.)</li>
</ul></div>
<div class="refsect2" lang="en">
<a name="id647397"></a><h3>
<a name="boost.variantconstruct-copy-destruct"></a><tt class="computeroutput">variant</tt> construct/copy/destruct</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id372464-bb"></a>variant();</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Requires</span></b>:

    The first bounded type of the <tt class="computeroutput">variant</tt> (i.e.,
            <tt class="computeroutput">T1</tt>) must fulfill the requirements of the
            <span class="emphasis"><em>DefaultConstructible</em></span> [20.1.4]
            concept.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Postconditions</span></b>:

    Content of <tt class="computeroutput">*this</tt> is the default value of the
            first bounded type (i.e, <tt class="computeroutput">T1</tt>).<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Throws</span></b>:

    May fail with any exceptions arising from the default
            constructor of <tt class="computeroutput">T1</tt>.</p>
</li>
<li>
<pre class="literallayout"><a name="id508111-bb"></a>variant(<span class="bold"><b>const</b></span> variant &amp; other);</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Postconditions</span></b>:

    Content of <tt class="computeroutput">*this</tt> is a copy of the content of
            <tt class="computeroutput">other</tt>.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Throws</span></b>:

    May fail with any exceptions arising from the
            copy constructor of <tt class="computeroutput">other</tt>'s contained type.</p>
</li>
<li>
<pre class="literallayout"><span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> T&gt; <a name="id552173-bb"></a>variant(T &amp; operand);</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Requires</span></b>:

    <tt class="computeroutput">T</tt> must be unambiguously convertible to one of
            the bounded types (i.e., <tt class="computeroutput">T1</tt>, <tt class="computeroutput">T2</tt>,
            etc.).<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Postconditions</span></b>:

    Content of <tt class="computeroutput">*this</tt> is the best conversion of
            <tt class="computeroutput">operand</tt> to one of the bounded types, as determined
            by standard overload resolution rules.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Throws</span></b>:

    May fail with any exceptions arising from the conversion of
            <tt class="computeroutput">operand</tt> to one of the bounded types.</p>
</li>
<li>
<pre class="literallayout"><span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> T&gt; <a name="id399284-bb"></a>variant(<span class="bold"><b>const</b></span> T &amp; operand);</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Notes</span></b>:

    Same semantics as previous constructor, but allows
            construction from temporaries.</p>
</li>
<li>
<pre class="literallayout"><span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> U1, <span class="bold"><b>typename</b></span> U2, ..., <span class="bold"><b>typename</b></span> UN&gt; 
  <a name="id571867-bb"></a>variant(variant&lt;U1, U2, ..., UN&gt; &amp; operand);</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Requires</span></b>:

    <span class="emphasis"><em>Every</em></span> one of <tt class="computeroutput">U1</tt>,
            <tt class="computeroutput">U2</tt>, ..., <tt class="computeroutput">UN</tt> must have an unambiguous
            conversion to one of the bounded types (i.e., <tt class="computeroutput">T1</tt>,
            <tt class="computeroutput">T2</tt>, ..., <tt class="computeroutput">TN</tt>).<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Postconditions</span></b>:

    If <tt class="computeroutput">variant&lt;U1, U2, ..., UN&gt;</tt> is itself
            one of the bounded types, then content of <tt class="computeroutput">*this</tt> is a
            copy of <tt class="computeroutput">operand</tt>. Otherwise, content of
            <tt class="computeroutput">*this</tt> is the best conversion of the content of
            <tt class="computeroutput">operand</tt> to one of the bounded types, as determined
            by standard overload resolution rules.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Throws</span></b>:

    If <tt class="computeroutput">variant&lt;U1, U2, ..., UN&gt;</tt> is itself
          one of the bounded types, then may fail with any exceptions arising
          from the copy constructor of
          <tt class="computeroutput">variant&lt;U1, U2, ..., UN&gt;</tt>. Otherwise, may fail
          with any exceptions arising from the conversion of the content of
          <tt class="computeroutput">operand</tt> to one of the bounded types.</p>
</li>
<li>
<pre class="literallayout"><span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> U1, <span class="bold"><b>typename</b></span> U2, ..., <span class="bold"><b>typename</b></span> UN&gt; 
  <a name="id452740-bb"></a>variant(<span class="bold"><b>const</b></span> variant&lt;U1, U2, ..., UN&gt; &amp; operand);</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Notes</span></b>:

    Same semantics as previous constructor, but allows
            construction from temporaries.</p>
</li>
<li>
<pre class="literallayout"><a name="id452937-bb"></a>~variant();</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Effects</span></b>:

    Destroys the content of <tt class="computeroutput">*this</tt>.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Throws</span></b>:

    Will not throw.</p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id647992"></a><h3>
<a name="id542939-bb"></a><tt class="computeroutput">variant</tt> modifiers</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type"><span class="bold"><b>void</b></span></span> <a name="id558196-bb"></a>swap(variant &amp; other);</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Requires</span></b>:

    Every bounded type must fulfill the requirements of the
              <a href="../Assignable.html" title="Concept Assignable">Assignable</a>
              concept.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Effects</span></b>:

    Interchanges the content of <tt class="computeroutput">*this</tt> and
              <tt class="computeroutput">other</tt>.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Throws</span></b>:

    If the contained type of <tt class="computeroutput">other</tt> is the same as
              the contained type of <tt class="computeroutput">*this</tt>, then may fail with any
              exceptions arising from the <tt class="computeroutput">swap</tt> of the contents of
              <tt class="computeroutput">*this</tt> and <tt class="computeroutput">other</tt>. Otherwise, may fail
              with any exceptions arising from either of the copy constructors
              of the contained types. Also, in the event of insufficient
              memory, may fail with <tt class="computeroutput">std::bad_alloc</tt>
              (<a href="../variant/design.html#variant.design.never-empty.problem" title="The Implementation Problem">why?</a>).</p>
</li>
<li>
<pre class="literallayout"><span class="type">variant &amp;</span> <a name="id506925-bb"></a><span class="bold"><b>operator</b></span>=(<span class="bold"><b>const</b></span> variant &amp; rhs);</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Requires</span></b>:

    Every bounded type must fulfill the requirements of the
              <a href="../Assignable.html" title="Concept Assignable">Assignable</a>
              concept.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Effects</span></b>:

    If the contained type of <tt class="computeroutput">rhs</tt> is the same as
              the contained type of <tt class="computeroutput">*this</tt>, then assigns the
              content of <tt class="computeroutput">rhs</tt> into the content of
              <tt class="computeroutput">*this</tt>. Otherwise, makes the content of
              <tt class="computeroutput">*this</tt> a copy of the content of <tt class="computeroutput">rhs</tt>,
              destroying the previous content of <tt class="computeroutput">*this</tt>.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Throws</span></b>:

    If the contained type of <tt class="computeroutput">rhs</tt> is the same as
              the contained type of <tt class="computeroutput">*this</tt>, then may fail with any
              exceptions arising from the assignment of the content of
              <tt class="computeroutput">rhs</tt> into the content <tt class="computeroutput">*this</tt>. Otherwise,
              may fail with any exceptions arising from the copy constructor
              of the contained type of <tt class="computeroutput">rhs</tt>. Also, in the event of
              insufficient memory, may fail with <tt class="computeroutput">std::bad_alloc</tt>
              (<a href="../variant/design.html#variant.design.never-empty.problem" title="The Implementation Problem">why?</a>).</p>
</li>
<li>
<pre class="literallayout"><span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> T&gt; <span class="type">variant &amp;</span> <a name="id454843-bb"></a><span class="bold"><b>operator</b></span>=(<span class="bold"><b>const</b></span> T &amp; rhs);</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Requires</span></b>:

    <div class="itemizedlist"><ul type="disc">
<li>
<tt class="computeroutput">T</tt> must be unambiguously convertible to
                one of the bounded types (i.e., <tt class="computeroutput">T1</tt>,
                <tt class="computeroutput">T2</tt>, etc.).</li>
<li>Every bounded type must fulfill the requirements of the
                <a href="../Assignable.html" title="Concept Assignable">Assignable</a>
                concept.</li>
</ul></div><br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Effects</span></b>:

    If the contained type of <tt class="computeroutput">*this</tt> is
              <tt class="computeroutput">T</tt>, then assigns <tt class="computeroutput">rhs</tt> into the content
              of <tt class="computeroutput">*this</tt>. Otherwise, makes the content of
              <tt class="computeroutput">*this</tt> the best conversion of <tt class="computeroutput">rhs</tt> to
              one of the bounded types, as determined by standard overload
              resolution rules, destroying the previous content of
              <tt class="computeroutput">*this</tt>.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Throws</span></b>:

    If the contained type of <tt class="computeroutput">*this</tt> is
              <tt class="computeroutput">T</tt>, then may fail with any exceptions arising from
              the assignment of <tt class="computeroutput">rhs</tt> into the content
              <tt class="computeroutput">*this</tt>. Otherwise, may fail with any exceptions
              arising from the conversion of <tt class="computeroutput">rhs</tt> to one of the
              bounded types. Also, in the event of insufficient memory, may
              fail with <tt class="computeroutput">std::bad_alloc</tt>
              (<a href="../variant/design.html#variant.design.never-empty.problem" title="The Implementation Problem">why?</a>).</p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id648523"></a><h3>
<a name="id463182-bb"></a><tt class="computeroutput">variant</tt> queries</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type"><span class="bold"><b>int</b></span></span> <a name="id479663-bb"></a>which() <span class="bold"><b>const</b></span>;</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Returns</span></b>:

    The zero-based index into the set of bounded types
              of the contained type of <tt class="computeroutput">*this</tt>. (For instance, if
              called on a <tt class="computeroutput">variant&lt;int, std::string&gt;</tt> object
              containing a <tt class="computeroutput">std::string</tt>, <tt class="computeroutput">which()</tt>
              would return <tt class="computeroutput">1</tt>.)<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Throws</span></b>:

    Will not throw.</p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><b>bool</b></span></span> <a name="id489830-bb"></a>empty() <span class="bold"><b>const</b></span>;</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Returns</span></b>:

    <tt class="computeroutput">false</tt>: <tt class="computeroutput">variant</tt> always contains
              exactly one of its bounded types. (See
              <a href="../variant/design.html#variant.design.never-empty" title='"Never-Empty" Guarantee'>the section called &#8220;"Never-Empty" Guarantee&#8221;</a>
              for more information.)<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Rationale</span></b>:

    Facilitates generic compatibility with
              <a href="any.html" title="Class any">boost::any</a>.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Throws</span></b>:

    Will not throw.</p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><b>const</b></span> std::type_info &amp;</span> <a name="id443569-bb"></a>type() <span class="bold"><b>const</b></span>;</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Returns</span></b>:

    <tt class="computeroutput">typeid(x)</tt>, where <tt class="computeroutput">x</tt> is the the
              content of <tt class="computeroutput">*this</tt>.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Throws</span></b>:

    Will not throw.</p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id648778"></a><h3>
<a name="id401169-bb"></a><tt class="computeroutput">variant</tt> relational</h3>
<div class="orderedlist"><ol type="1">
<li>
<p><a name="id558203-bb"></a></p>
<pre class="literallayout"><span class="type"><span class="bold"><b>bool</b></span></span> <a name="id266128-bb"></a><span class="bold"><b>operator</b></span>==(<span class="bold"><b>const</b></span> variant &amp; rhs) <span class="bold"><b>const</b></span>;
<span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> U&gt; <span class="type"><span class="bold"><b>void</b></span></span> <a name="id480375-bb"></a><span class="bold"><b>operator</b></span>==(<span class="bold"><b>const</b></span> U &amp; ) <span class="bold"><b>const</b></span>;</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Notes</span></b>:

    The overload returning <tt class="computeroutput">void</tt> exists only to
              prohibit implicit conversion of the operator's right-hand side
              to <tt class="computeroutput">variant</tt>; thus, its use will (purposefully)
              result in a compile-time error.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Requires</span></b>:

    Every bounded type of the <tt class="computeroutput">variant</tt> must
              fulfill the requirements of the
              <a href="../EqualityComparable.html" title="Concept EqualityComparable">EqualityComparable</a>
              concept.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Returns</span></b>:

    <tt class="computeroutput">true</tt> iff <tt class="computeroutput">which() == rhs.which()</tt><span class="emphasis"><em>and</em></span><tt class="computeroutput">content_this == content_rhs</tt>, where
              <tt class="computeroutput">content_this</tt> is the content of <tt class="computeroutput">*this</tt>
              and <tt class="computeroutput">content_rhs</tt> is the content of
              <tt class="computeroutput">rhs</tt>.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Throws</span></b>:

    If <tt class="computeroutput">which() == rhs.which()</tt> then may fail with
              any exceptions arising from <tt class="computeroutput">operator==(T,T)</tt>, where
              <tt class="computeroutput">T</tt> is the contained type of
              <tt class="computeroutput">*this</tt>.</p>
</li>
<li>
<p><a name="id446606-bb"></a></p>
<pre class="literallayout"><span class="type"><span class="bold"><b>bool</b></span></span> <a name="id498388-bb"></a><span class="bold"><b>operator</b></span>&lt;(<span class="bold"><b>const</b></span> variant &amp; rhs) <span class="bold"><b>const</b></span>;
<span class="bold"><b>template</b></span>&lt;<span class="bold"><b>typename</b></span> U&gt; <span class="type"><span class="bold"><b>void</b></span></span> <a name="id458182-bb"></a><span class="bold"><b>operator</b></span>&lt;(<span class="bold"><b>const</b></span> U &amp; ) <span class="bold"><b>const</b></span>;</pre>
<p><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Notes</span></b>:

    The overload returning <tt class="computeroutput">void</tt> exists only to
              prohibit implicit conversion of the operator's right-hand side
              to <tt class="computeroutput">variant</tt>; thus, its use will (purposefully)
              result in a compile-time error.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Requires</span></b>:

    Every bounded type of the <tt class="computeroutput">variant</tt> must
              fulfill the requirements of the
              <a href="../LessThanComparable.html" title="Concept LessThanComparable">LessThanComparable</a>
              concept.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Returns</span></b>:

    If <tt class="computeroutput">which() == rhs.which()</tt> then:
              <tt class="computeroutput">content_this &lt; content_rhs</tt>, where
              <tt class="computeroutput">content_this</tt> is the content of <tt class="computeroutput">*this</tt>
              and <tt class="computeroutput">content_rhs</tt> is the content of <tt class="computeroutput">rhs</tt>.
              Otherwise: <tt class="computeroutput">which() &lt; rhs.which()</tt>.<br><b xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision"><span class="term">Throws</span></b>:

    If <tt class="computeroutput">which() == rhs.which()</tt> then may fail with
              any exceptions arising from <tt class="computeroutput">operator&lt;(T,T)</tt>,
              where <tt class="computeroutput">T</tt> is the contained type of
              <tt class="computeroutput">*this</tt>.</p>
</li>
</ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><small>Copyright © 2002, 2003 Eric Friedman, Itay Maman</small></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../id413934.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../variant/reference.html#id516960"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="../id503912.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
