<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Class template segment_manager</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../../boost_interprocess_reference.html#header.boost.interprocess.segment_manager_hpp" title="Header &lt;boost/interprocess/segment_manager.hpp&gt;">
<link rel="prev" href="segment_manager_base.html" title="Class template segment_manager_base">
<link rel="next" href="segment_manager/allocator.html" title="Struct template allocator">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../boost.png"></td>
<td align="center"><a href="../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="segment_manager_base.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../boost_interprocess_reference.html#header.boost.interprocess.segment_manager_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="segment_manager/allocator.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" title="Class template segment_manager">
<a name="boost.interprocess.segment_manager"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template segment_manager</span></h2>
<p>boost::interprocess::segment_manager</p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="emphasis"><em>// In header: &lt;<a class="link" href="../../boost_interprocess_reference.html#header.boost.interprocess.segment_manager_hpp" title="Header &lt;boost/interprocess/segment_manager.hpp&gt;">boost/interprocess/segment_manager.hpp</a>&gt;

</em></span><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> CharType, <span class="bold"><strong>typename</strong></span> MemoryAlgorithm, 
         <span class="bold"><strong>template</strong></span>&lt; <span class="bold"><strong>class</strong></span> IndexConfig &gt; <span class="bold"><strong>class</strong></span> IndexType&gt; 
<span class="bold"><strong>class</strong></span> <a class="link" href="segment_manager.html" title="Class template segment_manager">segment_manager</a> :
  <span class="bold"><strong>public</strong></span> boost::interprocess::segment_manager_base&lt; MemoryAlgorithm &gt;
{
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// types</em></span>
  <span class="bold"><strong>typedef</strong></span> MemoryAlgorithm                                                                 <a name="boost.interprocess.segment_manager.memory_algorithm"></a>memory_algorithm;         
  <span class="bold"><strong>typedef</strong></span> Base::void_pointer                                                              <a name="boost.interprocess.segment_manager.void_pointer"></a>void_pointer;             
  <span class="bold"><strong>typedef</strong></span> CharType                                                                        <a name="boost.interprocess.segment_manager.char_type"></a>char_type;                
  <span class="bold"><strong>typedef</strong></span> <a class="link" href="segment_manager_base.html" title="Class template segment_manager_base">segment_manager_base</a>&lt; MemoryAlgorithm &gt;                                         <a name="boost.interprocess.segment_manager.segment_manager_base_type"></a>segment_manager_base_type;
  <span class="bold"><strong>typedef</strong></span> Base::mutex_family                                                              <a name="boost.interprocess.segment_manager.mutex_family"></a>mutex_family;             
  <span class="bold"><strong>typedef</strong></span> transform_iterator&lt; <span class="bold"><strong>typename</strong></span> named_index_t::const_iterator, named_transform &gt;   <a name="boost.interprocess.segment_manager.const_named_iterator"></a>const_named_iterator;     
  <span class="bold"><strong>typedef</strong></span> transform_iterator&lt; <span class="bold"><strong>typename</strong></span> unique_index_t::const_iterator, unique_transform &gt; <a name="boost.interprocess.segment_manager.const_unique_iterator"></a>const_unique_iterator;    

  <span class="emphasis"><em>// member classes/structs/unions</em></span>
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <span class="bold"><strong>struct</strong></span> <a class="link" href="segment_manager/allocator.html" title="Struct template allocator">allocator</a> {
    <span class="emphasis"><em>// types</em></span>
    <span class="bold"><strong>typedef</strong></span> <a class="link" href="allocator.html" title="Class template allocator">boost::interprocess::allocator</a>&lt; T, <a class="link" href="segment_manager.html" title="Class template segment_manager">segment_manager</a> &gt; <a class="link" href="segment_manager/allocator.html#boost.interprocess.segment_manager.allocator.type">type</a>;
  };
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <span class="bold"><strong>struct</strong></span> <a class="link" href="segment_manager/deleter.html" title="Struct template deleter">deleter</a> {
    <span class="emphasis"><em>// types</em></span>
    <span class="bold"><strong>typedef</strong></span> <a class="link" href="deleter.html" title="Class template deleter">boost::interprocess::deleter</a>&lt; T, <a class="link" href="segment_manager.html" title="Class template segment_manager">segment_manager</a> &gt; <a class="link" href="segment_manager/deleter.html#boost.interprocess.segment_manager.deleter.type">type</a>;
  };

  <span class="emphasis"><em>// <a class="link" href="segment_manager.html#boost.interprocess.segment_managerconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a class="link" href="segment_manager.html#id815645-bb">segment_manager</a>(std::size_t);

  <span class="emphasis"><em>// <a class="link" href="segment_manager.html#id815032-bb">public member functions</a></em></span>
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type">std::pair&lt; T *, std::size_t &gt;</span> <a class="link" href="segment_manager.html#id815035-bb">find</a>(<span class="bold"><strong>const</strong></span> CharType *) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type">std::pair&lt; T *, std::size_t &gt;</span> <a class="link" href="segment_manager.html#id815061-bb">find</a>(<span class="emphasis"><em>unspecified</em></span>) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
    <span class="type">std::pair&lt; T *, std::size_t &gt;</span> <a class="link" href="segment_manager.html#id815089-bb">find_no_lock</a>(<span class="bold"><strong>const</strong></span> CharType *) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
    <span class="type">std::pair&lt; T *, std::size_t &gt;</span> <a class="link" href="segment_manager.html#id815116-bb">find_no_lock</a>(<span class="emphasis"><em>unspecified</em></span>) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
    <span class="type">construct_proxy&lt; T &gt;::type</span> <a class="link" href="segment_manager.html#id815144-bb">construct</a>(char_ptr_holder_t) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
    <span class="type">construct_proxy&lt; T &gt;::type</span> <a class="link" href="segment_manager.html#id815169-bb">find_or_construct</a>(char_ptr_holder_t) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
    <span class="type">construct_proxy&lt; T &gt;::type</span> <a class="link" href="segment_manager.html#id815194-bb">construct</a>(char_ptr_holder_t, std::nothrow_t) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
    <span class="type">construct_proxy&lt; T &gt;::type</span> 
    <a class="link" href="segment_manager.html#id815224-bb">find_or_construct</a>(char_ptr_holder_t, std::nothrow_t) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
    <span class="type">construct_iter_proxy&lt; T &gt;::type</span> <a class="link" href="segment_manager.html#id815255-bb">construct_it</a>(char_ptr_holder_t) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
    <span class="type">construct_iter_proxy&lt; T &gt;::type</span> <a class="link" href="segment_manager.html#id815279-bb">find_or_construct_it</a>(char_ptr_holder_t) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
    <span class="type">construct_iter_proxy&lt; T &gt;::type</span> 
    <a class="link" href="segment_manager.html#id815305-bb">construct_it</a>(char_ptr_holder_t, std::nothrow_t) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
    <span class="type">construct_iter_proxy&lt; T &gt;::type</span> 
    <a class="link" href="segment_manager.html#id815336-bb">find_or_construct_it</a>(char_ptr_holder_t, std::nothrow_t) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Func&gt; <span class="type">*<span class="bold"><strong>void</strong></span></span> <a class="link" href="segment_manager.html#id815367-bb">atomic_func</a>(Func &amp;) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="segment_manager.html#id815393-bb">destroy</a>(<span class="emphasis"><em>unspecified</em></span>) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="segment_manager.html#id815420-bb">destroy</a>(<span class="bold"><strong>const</strong></span> CharType *) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="segment_manager.html#id815445-bb">destroy_ptr</a>(<span class="bold"><strong>const</strong></span> T *) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="segment_manager.html#id815470-bb">reserve_named_objects</a>(std::size_t) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="segment_manager.html#id815490-bb">reserve_unique_objects</a>(std::size_t) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="segment_manager.html#id815510-bb">shrink_to_fit_indexes</a>() ;
  <span class="type">std::size_t</span> <a class="link" href="segment_manager.html#id815523-bb">get_num_named_objects</a>() ;
  <span class="type">std::size_t</span> <a class="link" href="segment_manager.html#id815535-bb">get_num_unique_objects</a>() ;
  <span class="type">const_named_iterator</span> <a class="link" href="segment_manager.html#id815547-bb">named_begin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_named_iterator</span> <a class="link" href="segment_manager.html#id815561-bb">named_end</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_unique_iterator</span> <a class="link" href="segment_manager.html#id815574-bb">unique_begin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_unique_iterator</span> <a class="link" href="segment_manager.html#id815587-bb">unique_end</a>() <span class="bold"><strong>const</strong></span>;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><a class="link" href="allocator.html" title="Class template allocator">allocator</a>&lt; T &gt;::type</span> <a class="link" href="segment_manager.html#id815601-bb">get_allocator</a>() ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><a class="link" href="segment_manager/deleter.html" title="Struct template deleter">deleter</a>&lt; T &gt;::type</span> <a class="link" href="segment_manager.html#id815623-bb">get_deleter</a>() ;

  <span class="emphasis"><em>// <a class="link" href="segment_manager.html#id815658-bb">public static functions</a></em></span>
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>const</strong></span> CharType *</span> <a class="link" href="segment_manager.html#id815661-bb">get_instance_name</a>(<span class="bold"><strong>const</strong></span> T *) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><span class="bold"><strong>static</strong></span> std::size_t</span> <a class="link" href="segment_manager.html#id815687-bb">get_instance_length</a>(<span class="bold"><strong>const</strong></span> T *) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><span class="bold"><strong>static</strong></span> instance_type</span> <a class="link" href="segment_manager.html#id815713-bb">get_instance_type</a>(<span class="bold"><strong>const</strong></span> T *) ;
  <span class="type"><span class="bold"><strong>static</strong></span> std::size_t</span> <a class="link" href="segment_manager.html#id815739-bb">get_min_size</a>() ;
  <span class="bold"><strong>static</strong></span> <span class="type"><span class="bold"><strong>const</strong></span> std::size_t</span> PayloadPerAllocation;
};</pre></div>
<div class="refsect1" title="Description">
<a name="id1037462"></a><h2>Description</h2>
<p>This object is placed in the beginning of memory segment and implements the allocation (named or anonymous) of portions of the segment. This object contains two indexes that maintain an association between a name and a portion of the segment.</p>
<p>The first index contains the mappings for normal named objects using the char type specified in the template parameter.</p>
<p>The second index contains the association for unique instances. The key will be the const char * returned from type_info.name() function for the unique type to be constructed.</p>
<p>segment_manager&lt;CharType, MemoryAlgorithm, IndexType&gt; inherits publicly from segment_manager_base&lt;MemoryAlgorithm&gt; and inherits from it many public functions related to anonymous object and raw memory allocation. See segment_manager_base reference to know about those functions. </p>
<div class="refsect2" title="segment_manager public construct/copy/destruct">
<a name="id1037483"></a><h3>
<a name="boost.interprocess.segment_managerconstruct-copy-destruct"></a><code class="computeroutput">segment_manager</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
<pre class="literallayout"><a name="id815645-bb"></a>segment_manager(std::size_t size);</pre>
<p>Constructor of the segment manager "size" is the size of the memory segment where the segment manager is being constructed. Can throw </p>
</li></ol></div>
</div>
<div class="refsect2" title="segment_manager public member functions">
<a name="id1037521"></a><h3>
<a name="id815032-bb"></a><code class="computeroutput">segment_manager</code> public member functions</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <span class="type">std::pair&lt; T *, std::size_t &gt;</span> <a name="id815035-bb"></a>find(<span class="bold"><strong>const</strong></span> CharType * name) ;</pre>
<p>Tries to find a previous named allocation. Returns the address and the object count. On failure the first member of the returned pair is 0. </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type">std::pair&lt; T *, std::size_t &gt;</span> <a name="id815061-bb"></a>find(<span class="emphasis"><em>unspecified</em></span> name) ;</pre>
<p>Tries to find a previous unique allocation. Returns the address and the object count. On failure the first member of the returned pair is 0. </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <span class="type">std::pair&lt; T *, std::size_t &gt;</span> <a name="id815089-bb"></a>find_no_lock(<span class="bold"><strong>const</strong></span> CharType * name) ;</pre>
<p>Tries to find a previous named allocation. Returns the address and the object count. On failure the first member of the returned pair is 0. This search is not mutex-protected! </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <span class="type">std::pair&lt; T *, std::size_t &gt;</span> <a name="id815116-bb"></a>find_no_lock(<span class="emphasis"><em>unspecified</em></span> name) ;</pre>
<p>Tries to find a previous unique allocation. Returns the address and the object count. On failure the first member of the returned pair is 0. This search is not mutex-protected! </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <span class="type">construct_proxy&lt; T &gt;::type</span> <a name="id815144-bb"></a>construct(char_ptr_holder_t name) ;</pre>
<p>Returns throwing "construct" proxy object </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <span class="type">construct_proxy&lt; T &gt;::type</span> <a name="id815169-bb"></a>find_or_construct(char_ptr_holder_t name) ;</pre>
<p>Returns throwing "search or construct" proxy object </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <span class="type">construct_proxy&lt; T &gt;::type</span> 
  <a name="id815194-bb"></a>construct(char_ptr_holder_t name, std::nothrow_t) ;</pre>
<p>Returns no throwing "construct" proxy object </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <span class="type">construct_proxy&lt; T &gt;::type</span> 
  <a name="id815224-bb"></a>find_or_construct(char_ptr_holder_t name, std::nothrow_t) ;</pre>
<p>Returns no throwing "search or construct" proxy object </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <span class="type">construct_iter_proxy&lt; T &gt;::type</span> <a name="id815255-bb"></a>construct_it(char_ptr_holder_t name) ;</pre>Returns throwing "construct from iterators" proxy object. </li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <span class="type">construct_iter_proxy&lt; T &gt;::type</span> 
  <a name="id815279-bb"></a>find_or_construct_it(char_ptr_holder_t name) ;</pre>
<p>Returns throwing "search or construct from iterators" proxy object </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <span class="type">construct_iter_proxy&lt; T &gt;::type</span> 
  <a name="id815305-bb"></a>construct_it(char_ptr_holder_t name, std::nothrow_t) ;</pre>
<p>Returns no throwing "construct from iterators" proxy object </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <span class="type">construct_iter_proxy&lt; T &gt;::type</span> 
  <a name="id815336-bb"></a>find_or_construct_it(char_ptr_holder_t name, std::nothrow_t) ;</pre>
<p>Returns no throwing "search or construct from iterators" proxy object </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Func&gt; <span class="type">*<span class="bold"><strong>void</strong></span></span> <a name="id815367-bb"></a>atomic_func(Func &amp; f) ;</pre>
<p>Calls object function blocking recursive interprocess_mutex and guarantees that no new named_alloc or destroy will be executed by any process while executing the object function call </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id815393-bb"></a>destroy(<span class="emphasis"><em>unspecified</em></span>) ;</pre>
<p>Destroys a previously created unique instance. Returns false if the object was not present. </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id815420-bb"></a>destroy(<span class="bold"><strong>const</strong></span> CharType * name) ;</pre>
<p>Destroys the named object with the given name. Returns false if that object can't be found. </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id815445-bb"></a>destroy_ptr(<span class="bold"><strong>const</strong></span> T * p) ;</pre>
<p>Destroys an anonymous, unique or named object using it's address </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id815470-bb"></a>reserve_named_objects(std::size_t num) ;</pre>
<p>Preallocates needed index resources to optimize the creation of "num" named objects in the managed memory segment. Can throw boost::interprocess::bad_alloc if there is no enough memory. </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id815490-bb"></a>reserve_unique_objects(std::size_t num) ;</pre>
<p>Preallocates needed index resources to optimize the creation of "num" unique objects in the managed memory segment. Can throw boost::interprocess::bad_alloc if there is no enough memory. </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id815510-bb"></a>shrink_to_fit_indexes() ;</pre>
<p>Calls shrink_to_fit in both named and unique object indexes to try to free unused memory from those indexes. </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">std::size_t</span> <a name="id815523-bb"></a>get_num_named_objects() ;</pre>
<p>Returns the number of named objects stored in the segment. </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">std::size_t</span> <a name="id815535-bb"></a>get_num_unique_objects() ;</pre>
<p>Returns the number of unique objects stored in the segment. </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">const_named_iterator</span> <a name="id815547-bb"></a>named_begin() <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns a constant iterator to the beginning of the information about the named allocations performed in this segment manager </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">const_named_iterator</span> <a name="id815561-bb"></a>named_end() <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns a constant iterator to the end of the information about the named allocations performed in this segment manager </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">const_unique_iterator</span> <a name="id815574-bb"></a>unique_begin() <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns a constant iterator to the beginning of the information about the unique allocations performed in this segment manager </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">const_unique_iterator</span> <a name="id815587-bb"></a>unique_end() <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns a constant iterator to the end of the information about the unique allocations performed in this segment manager </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><a class="link" href="allocator.html" title="Class template allocator">allocator</a>&lt; T &gt;::type</span> <a name="id815601-bb"></a>get_allocator() ;</pre>
<p>Returns an instance of the default allocator for type T initialized that allocates memory from this segment manager. </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><a class="link" href="segment_manager/deleter.html" title="Struct template deleter">deleter</a>&lt; T &gt;::type</span> <a name="id815623-bb"></a>get_deleter() ;</pre>
<p>Returns an instance of the default allocator for type T initialized that allocates memory from this segment manager. </p>
</li>
</ol></div>
</div>
<div class="refsect2" title="segment_manager public static functions">
<a name="id1038422"></a><h3>
<a name="id815658-bb"></a><code class="computeroutput">segment_manager</code> public static functions</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>const</strong></span> CharType *</span> <a name="id815661-bb"></a>get_instance_name(<span class="bold"><strong>const</strong></span> T * ptr) ;</pre>
<p>Returns the name of an object created with construct/find_or_construct functions. Does not throw </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><span class="bold"><strong>static</strong></span> std::size_t</span> <a name="id815687-bb"></a>get_instance_length(<span class="bold"><strong>const</strong></span> T * ptr) ;</pre>
<p>Returns the length of an object created with construct/find_or_construct functions. Does not throw. </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type"><span class="bold"><strong>static</strong></span> instance_type</span> <a name="id815713-bb"></a>get_instance_type(<span class="bold"><strong>const</strong></span> T * ptr) ;</pre>
<p>Returns is the the name of an object created with construct/find_or_construct functions. Does not throw </p>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> std::size_t</span> <a name="id815739-bb"></a>get_min_size() ;</pre>
<p>Obtains the minimum size needed by the segment manager </p>
</li>
</ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2005 - 2008 Ion Gaztanaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="segment_manager_base.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../boost_interprocess_reference.html#header.boost.interprocess.segment_manager_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="segment_manager/allocator.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
