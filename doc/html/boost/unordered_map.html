<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Class template unordered_map</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../unordered/reference.html#header.boost.unordered_map_hpp" title="Header &lt;boost/unordered_map.hpp&gt;">
<link rel="prev" href="unordered_multiset.html" title="Class template unordered_multiset">
<link rel="next" href="unordered_multimap.html" title="Class template unordered_multimap">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="unordered_multiset.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../unordered/reference.html#header.boost.unordered_map_hpp"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="unordered_multimap.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" title="Class template unordered_map">
<a name="boost.unordered_map"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template unordered_map</span></h2>
<p>boost::unordered_map &#8212; 
            An unordered associative container that associates unique keys with another value.
          </p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="emphasis"><em>// In header: &lt;<a class="link" href="../unordered/reference.html#header.boost.unordered_map_hpp" title="Header &lt;boost/unordered_map.hpp&gt;">boost/unordered_map.hpp</a>&gt;

</em></span><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Key, <span class="bold"><strong>typename</strong></span> Mapped, <span class="bold"><strong>typename</strong></span> Hash = <span class="type">boost::hash&lt;Key&gt;</span>, 
         <span class="bold"><strong>typename</strong></span> Pred = <span class="type">std::equal_to&lt;Key&gt;</span>, 
         <span class="bold"><strong>typename</strong></span> Alloc = <span class="type">std::allocator&lt;std::pair&lt;Key <span class="bold"><strong>const</strong></span>, Mapped&gt; &gt;</span> &gt; 
<span class="bold"><strong>class</strong></span> <a class="link" href="unordered_map.html" title="Class template unordered_map">unordered_map</a> {
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// <a class="link" href="unordered_map.html#boost.unordered_maptypes">types</a></em></span>
  <span class="bold"><strong>typedef</strong></span> Key                                      <a name="boost.unordered_map.key_type"></a>key_type;            
  <span class="bold"><strong>typedef</strong></span> std::pair&lt;Key <span class="bold"><strong>const</strong></span>, Mapped&gt;             <a name="boost.unordered_map.value_type"></a>value_type;          
  <span class="bold"><strong>typedef</strong></span> Mapped                                   <a name="boost.unordered_map.mapped_type"></a>mapped_type;         
  <span class="bold"><strong>typedef</strong></span> Hash                                     <a name="boost.unordered_map.hasher"></a>hasher;              
  <span class="bold"><strong>typedef</strong></span> Pred                                     <a name="boost.unordered_map.key_equal"></a>key_equal;           
  <span class="bold"><strong>typedef</strong></span> Alloc                                    <a name="boost.unordered_map.allocator_type"></a>allocator_type;      
  <span class="bold"><strong>typedef</strong></span> <span class="bold"><strong>typename</strong></span> allocator_type::pointer         <a name="boost.unordered_map.pointer"></a>pointer;             
  <span class="bold"><strong>typedef</strong></span> <span class="bold"><strong>typename</strong></span> allocator_type::const_pointer   <a name="boost.unordered_map.const_pointer"></a>const_pointer;       
  <span class="bold"><strong>typedef</strong></span> <span class="bold"><strong>typename</strong></span> allocator_type::reference       <a name="boost.unordered_map.reference"></a>reference;             <span class="emphasis"><em>// lvalue of <span class="type">value_type</span>.</em></span>
  <span class="bold"><strong>typedef</strong></span> <span class="bold"><strong>typename</strong></span> allocator_type::const_reference <a name="boost.unordered_map.const_reference"></a>const_reference;       <span class="emphasis"><em>// const lvalue of <span class="type">value_type</span>.</em></span>
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_map.html#boost.unordered_map.size_type">size_type</a>;
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_map.html#boost.unordered_map.difference_type">difference_type</a>;
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_map.html#boost.unordered_map.iterator">iterator</a>;
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_map.html#boost.unordered_map.const_iterator">const_iterator</a>;
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_map.html#boost.unordered_map.local_iterator">local_iterator</a>;
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_map.html#boost.unordered_map.const_local_iterator">const_local_iterator</a>;

  <span class="emphasis"><em>// <a class="link" href="unordered_map.html#boost.unordered_mapconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <span class="bold"><strong>explicit</strong></span> <a class="link" href="unordered_map.html#id1332672-bb">unordered_map</a>(size_type = <span class="emphasis"><em>implementation-defined</em></span>, 
                         hasher <span class="bold"><strong>const</strong></span>&amp; = hasher(), 
                         key_equal <span class="bold"><strong>const</strong></span>&amp; = key_equal(), 
                         allocator_type <span class="bold"><strong>const</strong></span>&amp; = allocator_type());
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a>&gt; 
    <a class="link" href="unordered_map.html#id1332753-bb">unordered_map</a>(InputIterator, InputIterator, 
                  size_type = implementation-defined, 
                  hasher <span class="bold"><strong>const</strong></span>&amp; = hasher(), key_equal <span class="bold"><strong>const</strong></span>&amp; = key_equal(), 
                  allocator_type <span class="bold"><strong>const</strong></span>&amp; = allocator_type());
  <a class="link" href="unordered_map.html#id1331117-bb">unordered_map</a>(unordered_map <span class="bold"><strong>const</strong></span>&amp;);
  <a class="link" href="unordered_map.html#id1331148-bb">unordered_map</a>(unordered_map &amp;&amp;);
  <span class="bold"><strong>explicit</strong></span> <a class="link" href="unordered_map.html#id1331189-bb">unordered_map</a>(Allocator <span class="bold"><strong>const</strong></span>&amp;);
  <a class="link" href="unordered_map.html#id1331217-bb">unordered_map</a>(unordered_map <span class="bold"><strong>const</strong></span>&amp;, Allocator <span class="bold"><strong>const</strong></span>&amp;);
  <a class="link" href="unordered_map.html#id1331257-bb">~unordered_map</a>();
  <span class="type">unordered_map&amp;</span> <a class="link" href="unordered_map.html#id1331270-bb"><span class="bold"><strong>operator</strong></span>=</a>(unordered_map <span class="bold"><strong>const</strong></span>&amp;);
  <span class="type">unordered_map&amp;</span> <a class="link" href="unordered_map.html#id1331321-bb"><span class="bold"><strong>operator</strong></span>=</a>(unordered_map &amp;&amp;);
  <span class="type">allocator_type</span> <a class="link" href="unordered_map.html#id1331374-bb">get_allocator</a>() <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="unordered_map.html#id1331386-bb">size and capacity</a></em></span>
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="unordered_map.html#id1331391-bb">empty</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a class="link" href="unordered_map.html#id1331413-bb">size</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a class="link" href="unordered_map.html#id1331440-bb">max_size</a>() <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="unordered_map.html#id1331462-bb">iterators</a></em></span>
  <span class="type">iterator</span> <a class="link" href="unordered_map.html#id1331471-bb">begin</a>();
  <span class="type">const_iterator</span> <a class="link" href="unordered_map.html#id1331476-bb">begin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">iterator</span> <a class="link" href="unordered_map.html#id1331495-bb">end</a>();
  <span class="type">const_iterator</span> <a class="link" href="unordered_map.html#id1331502-bb">end</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_iterator</span> <a class="link" href="unordered_map.html#id1331519-bb">cbegin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_iterator</span> <a class="link" href="unordered_map.html#id1331537-bb">cend</a>() <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="unordered_map.html#id1331555-bb">modifiers</a></em></span>
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span>... Args&gt; <span class="type">std::pair&lt;iterator, <span class="bold"><strong>bool</strong></span>&gt;</span> <a class="link" href="unordered_map.html#id1331559-bb">emplace</a>(Args&amp;&amp;...);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span>... Args&gt; <span class="type">iterator</span> <a class="link" href="unordered_map.html#id1331656-bb">emplace_hint</a>(const_iterator, Args&amp;&amp;...);
  <span class="type">std::pair&lt;iterator, <span class="bold"><strong>bool</strong></span>&gt;</span> <a class="link" href="unordered_map.html#id1331770-bb">insert</a>(value_type <span class="bold"><strong>const</strong></span>&amp;);
  <span class="type">iterator</span> <a class="link" href="unordered_map.html#id1331841-bb">insert</a>(const_iterator, value_type <span class="bold"><strong>const</strong></span>&amp;);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a>&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_map.html#id1331929-bb">insert</a>(InputIterator, InputIterator);
  <span class="type">iterator</span> <a class="link" href="unordered_map.html#id1332006-bb">erase</a>(const_iterator);
  <span class="type">size_type</span> <a class="link" href="unordered_map.html#id1332089-bb">erase</a>(key_type <span class="bold"><strong>const</strong></span>&amp;);
  <span class="type">iterator</span> <a class="link" href="unordered_map.html#id1332144-bb">erase</a>(const_iterator, const_iterator);
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_map.html#id1332224-bb">quick_erase</a>(const_iterator);
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_map.html#id1332298-bb">erase_return_void</a>(const_iterator);
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_map.html#id1332366-bb">clear</a>();
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_map.html#id1332404-bb">swap</a>(unordered_map&amp;);

  <span class="emphasis"><em>// <a class="link" href="unordered_map.html#id1332456-bb">observers</a></em></span>
  <span class="type">hasher</span> <a class="link" href="unordered_map.html#id1332460-bb">hash_function</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">key_equal</span> <a class="link" href="unordered_map.html#id1332476-bb">key_eq</a>() <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="unordered_map.html#id1332494-bb">lookup</a></em></span>
  <span class="type">iterator</span> <a class="link" href="unordered_map.html#id1332503-bb">find</a>(key_type <span class="bold"><strong>const</strong></span>&amp;);
  <span class="type">const_iterator</span> <a class="link" href="unordered_map.html#id1332521-bb">find</a>(key_type <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> CompatibleKey, <span class="bold"><strong>typename</strong></span> CompatibleHash, 
           <span class="bold"><strong>typename</strong></span> CompatiblePredicate&gt; 
    <span class="type">iterator</span> <a class="link" href="unordered_map.html#id1332541-bb">find</a>(CompatibleKey <span class="bold"><strong>const</strong></span>&amp;, CompatibleHash <span class="bold"><strong>const</strong></span>&amp;, 
                  CompatiblePredicate <span class="bold"><strong>const</strong></span>&amp;);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> CompatibleKey, <span class="bold"><strong>typename</strong></span> CompatibleHash, 
           <span class="bold"><strong>typename</strong></span> CompatiblePredicate&gt; 
    <span class="type">const_iterator</span> 
    <a class="link" href="unordered_map.html#id1332600-bb">find</a>(CompatibleKey <span class="bold"><strong>const</strong></span>&amp;, CompatibleHash <span class="bold"><strong>const</strong></span>&amp;, 
         CompatiblePredicate <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a class="link" href="unordered_map.html#id1330872-bb">count</a>(key_type <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">std::pair&lt;iterator, iterator&gt;</span> <a class="link" href="unordered_map.html#id1330910-bb">equal_range</a>(key_type <span class="bold"><strong>const</strong></span>&amp;);
  <span class="type">std::pair&lt;const_iterator, const_iterator&gt;</span> <a class="link" href="unordered_map.html#id1330928-bb">equal_range</a>(key_type <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">mapped_type&amp;</span> <a class="link" href="unordered_map.html#id1330978-bb"><span class="bold"><strong>operator</strong></span>[]</a>(key_type <span class="bold"><strong>const</strong></span>&amp;);
  <span class="type">Mapped&amp;</span> <a class="link" href="unordered_map.html#id1331060-bb">at</a>(key_type <span class="bold"><strong>const</strong></span>&amp;);
  <span class="type">Mapped <span class="bold"><strong>const</strong></span>&amp;</span> <a class="link" href="unordered_map.html#id1328207-bb">at</a>(key_type <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="unordered_map.html#id1329921-bb">bucket interface</a></em></span>
  <span class="type">size_type</span> <a class="link" href="unordered_map.html#id1329926-bb">bucket_count</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a class="link" href="unordered_map.html#id1329946-bb">max_bucket_count</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a class="link" href="unordered_map.html#id1329966-bb">bucket_size</a>(size_type) <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a class="link" href="unordered_map.html#id1330012-bb">bucket</a>(key_type <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">local_iterator</span> <a class="link" href="unordered_map.html#id1330061-bb">begin</a>(size_type);
  <span class="type">const_local_iterator</span> <a class="link" href="unordered_map.html#id1330080-bb">begin</a>(size_type) <span class="bold"><strong>const</strong></span>;
  <span class="type">local_iterator</span> <a class="link" href="unordered_map.html#id1330133-bb">end</a>(size_type);
  <span class="type">const_local_iterator</span> <a class="link" href="unordered_map.html#id1330151-bb">end</a>(size_type) <span class="bold"><strong>const</strong></span>;
  <span class="type">const_local_iterator</span> <a class="link" href="unordered_map.html#id1330200-bb">cbegin</a>(size_type) <span class="bold"><strong>const</strong></span>;
  <span class="type">const_local_iterator</span> <a class="link" href="unordered_map.html#id1330249-bb">cend</a>(size_type);

  <span class="emphasis"><em>// <a class="link" href="unordered_map.html#id1330297-bb">hash policy</a></em></span>
  <span class="type"><span class="bold"><strong>float</strong></span></span> <a class="link" href="unordered_map.html#id1330302-bb">load_factor</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>float</strong></span></span> <a class="link" href="unordered_map.html#id1330322-bb">max_load_factor</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_map.html#id1330342-bb">max_load_factor</a>(<span class="bold"><strong>float</strong></span>);
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_map.html#id1330373-bb">rehash</a>(size_type);
};

<span class="emphasis"><em>// <a class="link" href="unordered_map.html#id1330423-bb">Equality Comparisons</a></em></span>
<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Key, <span class="bold"><strong>typename</strong></span> Mapped, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, 
         <span class="bold"><strong>typename</strong></span> Alloc&gt; 
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="unordered_map.html#boost.operator==_id1330428"><span class="bold"><strong>operator</strong></span>==</a>(unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp;, 
                  unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp;);
<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Key, <span class="bold"><strong>typename</strong></span> Mapped, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, 
         <span class="bold"><strong>typename</strong></span> Alloc&gt; 
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="unordered_map.html#boost.operator!=_id1330508"><span class="bold"><strong>operator</strong></span>!=</a>(unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp;, 
                  unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp;);

<span class="emphasis"><em>// <a class="link" href="unordered_map.html#id1330590-bb">swap</a></em></span>
<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Key, <span class="bold"><strong>typename</strong></span> Mapped, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, 
         <span class="bold"><strong>typename</strong></span> Alloc&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_map.html#boost.swap_id1330594">swap</a>(unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt;&amp;, 
            unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt;&amp;);</pre></div>
<div class="refsect1" title="Description">
<a name="id2073995"></a><h2>Description</h2>
<p>Based on chapter 23 of
              <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf" target="_top">the working draft of the C++ standard [n2960]</a>.
              But without the updated rules for allocators.
            </p>
<p><span class="bold"><strong>Template Parameters</strong></span>
              </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td><span class="emphasis"><em>Key</em></span></td>
<td>Key must be Assignable and CopyConstructible.</td>
</tr>
<tr>
<td><span class="emphasis"><em>Mapped</em></span></td>
<td>Mapped must be CopyConstructible</td>
</tr>
<tr>
<td><span class="emphasis"><em>Hash</em></span></td>
<td>A unary function object type that acts a hash function for a <code class="computeroutput">Key</code>. It takes a single argument of type <code class="computeroutput">Key</code> and returns a value of type std::size_t.</td>
</tr>
<tr>
<td><span class="emphasis"><em>Pred</em></span></td>
<td>A binary function object that implements an equivalence relation on values of type <code class="computeroutput">Key</code>.
                        A binary function object that induces an equivalence relation on values of type Key.
                        It takes two arguments of type Key and returns a value of type bool.</td>
</tr>
<tr>
<td><span class="emphasis"><em>Alloc</em></span></td>
<td>An allocator whose value type is the same as the container's value type.</td>
</tr>
</tbody>
</table></div>
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
<div class="refsect2" title="unordered_map public types">
<a name="id2074113"></a><h3>
<a name="boost.unordered_maptypes"></a><code class="computeroutput">unordered_map</code> 
        public
       types</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_map.size_type"></a>size_type;</p>
<p>An unsigned integral type.</p>
<p><span class="type">size_type</span> can represent any non-negative value of <span class="type">difference_type</span>.</p>
</li>
<li class="listitem">
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_map.difference_type"></a>difference_type;</p>
<p>A signed integral type.</p>
<p>Is identical to the difference type of <span class="type">iterator</span> and <span class="type">const_iterator</span>.</p>
</li>
<li class="listitem">
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_map.iterator"></a>iterator;</p>
<p>A iterator whose value type is <span class="type">value_type</span>. </p>
<p>The iterator category is at least a forward iterator.</p>
<p>Convertible to <span class="type">const_iterator</span>.</p>
</li>
<li class="listitem">
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_map.const_iterator"></a>const_iterator;</p>
<p>A constant iterator whose value type is <span class="type">value_type</span>. </p>
<p>The iterator category is at least a forward iterator.</p>
</li>
<li class="listitem">
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_map.local_iterator"></a>local_iterator;</p>
<p>An iterator with the same value type, difference type and pointer and reference type as <span class="type">iterator</span>.</p>
<p>A local_iterator object can be used to iterate through a single bucket.</p>
</li>
<li class="listitem">
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_map.const_local_iterator"></a>const_local_iterator;</p>
<p>A constant iterator with the same value type, difference type and pointer and reference type as <span class="type">const_iterator</span>.</p>
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</li>
</ol></div>
</div>
<div class="refsect2" title="unordered_map public construct/copy/destruct">
<a name="id2074338"></a><h3>
<a name="boost.unordered_mapconstruct-copy-destruct"></a><code class="computeroutput">unordered_map</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>explicit</strong></span> <a name="id1332672-bb"></a>unordered_map(size_type n = <span class="emphasis"><em>implementation-defined</em></span>, 
                       hasher <span class="bold"><strong>const</strong></span>&amp; hf = hasher(), 
                       key_equal <span class="bold"><strong>const</strong></span>&amp; eq = key_equal(), 
                       allocator_type <span class="bold"><strong>const</strong></span>&amp; a = allocator_type());</pre>
<p>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td><code class="computeroutput"><a class="link" href="unordered_map.html#id1331413-bb">size</a>() == 0</code></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a>&gt; 
  <a name="id1332753-bb"></a>unordered_map(InputIterator f, InputIterator l, 
                size_type n = implementation-defined, 
                hasher <span class="bold"><strong>const</strong></span>&amp; hf = hasher(), 
                key_equal <span class="bold"><strong>const</strong></span>&amp; eq = key_equal(), 
                allocator_type <span class="bold"><strong>const</strong></span>&amp; a = allocator_type());</pre>
<p>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0 and inserts the elements from [f, l) into it.</p>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1331117-bb"></a>unordered_map(unordered_map <span class="bold"><strong>const</strong></span>&amp;);</pre>
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">value_type</code> is copy constructible</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1331148-bb"></a>unordered_map(unordered_map &amp;&amp;);</pre>
<p>The move constructor.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>This is emulated on compilers without rvalue references.</p></td>
</tr>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p>
                <code class="computeroutput">value_type</code> is move constructible.
                (TODO: This is not actually required in this implementation).
              </p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>explicit</strong></span> <a name="id1331189-bb"></a>unordered_map(Allocator <span class="bold"><strong>const</strong></span>&amp; a);</pre>
<p>Constructs an empty container, using allocator <code class="computeroutput">a</code>.</p>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1331217-bb"></a>unordered_map(unordered_map <span class="bold"><strong>const</strong></span>&amp; x, Allocator <span class="bold"><strong>const</strong></span>&amp; a);</pre>
<p>Constructs an container, copying <code class="computeroutput">x</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code class="computeroutput">a</code>.</p>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1331257-bb"></a>~unordered_map();</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>The destructor is applied to every element, and all memory is deallocated</p></td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<pre class="literallayout"><span class="type">unordered_map&amp;</span> <a name="id1331270-bb"></a><span class="bold"><strong>operator</strong></span>=(unordered_map <span class="bold"><strong>const</strong></span>&amp;);</pre>
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>
                On compilers without rvalue references, there is a single assignment
                operator with the signature <code class="computeroutput">operator=(unordered_map)</code>
                in order to emulate move semantics.
              </p></td>
</tr>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">value_type</code> is copy constructible</p></td>
</tr>
</tbody>
</table></div>
<pre class="literallayout"><span class="type">unordered_map&amp;</span> <a name="id1331321-bb"></a><span class="bold"><strong>operator</strong></span>=(unordered_map &amp;&amp;);</pre>
<p>The move assignment operator.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>
                On compilers without rvalue references, there is a single assignment
                operator with the signature <code class="computeroutput">operator=(unordered_map)</code>
                in order to emulate move semantics.
              </p></td>
</tr>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p>
                <code class="computeroutput">value_type</code> is move constructible.
                (TODO: This is not actually required in this implementation).
              </p></td>
</tr>
</tbody>
</table></div>
<pre class="literallayout"><span class="type">allocator_type</span> <a name="id1331374-bb"></a>get_allocator() <span class="bold"><strong>const</strong></span>;</pre>
<div class="refsect2" title="unordered_map size and capacity">
<a name="id2074816"></a><h3>
<a name="id1331386-bb"></a><code class="computeroutput">unordered_map</code> size and capacity</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id1331391-bb"></a>empty() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><code class="computeroutput"><a class="link" href="unordered_map.html#id1331413-bb">size</a>() == 0</code></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">size_type</span> <a name="id1331413-bb"></a>size() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><code class="computeroutput">std::distance(<a class="link" href="unordered_map.html#id1331466-bb">begin</a>(), <a class="link" href="unordered_map.html#id1331490-bb">end</a>())</code></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">size_type</span> <a name="id1331440-bb"></a>max_size() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>
<code class="computeroutput"><a class="link" href="unordered_map.html#id1331413-bb">size</a>()</code> of the largest possible container.
              </td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" title="unordered_map iterators">
<a name="id2074976"></a><h3>
<a name="id1331462-bb"></a><code class="computeroutput">unordered_map</code> iterators</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><a name="id1331466-bb"></a><span class="type">iterator</span> <a name="id1331471-bb"></a>begin();
<span class="type">const_iterator</span> <a name="id1331476-bb"></a>begin() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.
              </td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1331490-bb"></a><span class="type">iterator</span> <a name="id1331495-bb"></a>end();
<span class="type">const_iterator</span> <a name="id1331502-bb"></a>end() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>An iterator which refers to the past-the-end value for the container.
              </td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id1331519-bb"></a>cbegin() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>A constant iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.
              </td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id1331537-bb"></a>cend() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>A constant iterator which refers to the past-the-end value for the container.
              </td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" title="unordered_map modifiers">
<a name="id2075160"></a><h3>
<a name="id1331555-bb"></a><code class="computeroutput">unordered_map</code> modifiers</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span>... Args&gt; <span class="type">std::pair&lt;iterator, <span class="bold"><strong>bool</strong></span>&gt;</span> <a name="id1331559-bb"></a>emplace(Args&amp;&amp;... args);</pre>
<p>Inserts an object, constructed with the arguments <code class="computeroutput">args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>
<p>The bool component of the return type is true if an insert took place.</p>
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
<p>If the compiler doesn't support variadic template arguments or rvalue
                      references, this is emulated for up to 10 arguments, with no support
                      for rvalue references or move semantics.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span>... Args&gt; 
  <span class="type">iterator</span> <a name="id1331656-bb"></a>emplace_hint(const_iterator hint, Args&amp;&amp;... args);</pre>
<p>Inserts an object, constructed with the arguments <code class="computeroutput">args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
<p>hint is a suggestion to where the element should be inserted.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key. </p>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
<p>If the compiler doesn't support variadic template arguments or rvalue
                      references, this is emulated for up to 10 arguments, with no support
                      for rvalue references or move semantics.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">std::pair&lt;iterator, <span class="bold"><strong>bool</strong></span>&gt;</span> <a name="id1331770-bb"></a>insert(value_type <span class="bold"><strong>const</strong></span>&amp; obj);</pre>
<p>Inserts obj in the container if and only if there is no element in the container with an equivalent key.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>
<p>The bool component of the return type is true if an insert took place.</p>
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">iterator</span> <a name="id1331841-bb"></a>insert(const_iterator hint, value_type <span class="bold"><strong>const</strong></span>&amp; obj);</pre>
<p>Inserts obj in the container if and only if there is no element in the container with an equivalent key.</p>
<p>hint is a suggestion to where the element should be inserted.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key. </p>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a>&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1331929-bb"></a>insert(InputIterator first, InputIterator last);</pre>
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>When inserting a single element, if an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">iterator</span> <a name="id1332006-bb"></a>erase(const_iterator position);</pre>
<p>Erase the element pointed to by <code class="computeroutput">position</code>.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The iterator following <code class="computeroutput">position</code> before the erasure.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>
<p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.</p>
<p>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.</p>
</td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>
                  When the number of elements is a lot smaller than the number of buckets
                  this function can be very inefficient as it has to search through empty
                  buckets for the next element, in order to return the iterator.
                  The method <a class="link" href="unordered_map.html#id1332224-bb">quick_erase</a> is faster, but has yet
                  to be standardized.
                </p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">size_type</span> <a name="id1332089-bb"></a>erase(key_type <span class="bold"><strong>const</strong></span>&amp; k);</pre>
<p>Erase all elements with key equivalent to <code class="computeroutput">k</code>.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The number of elements erased.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">iterator</span> <a name="id1332144-bb"></a>erase(const_iterator first, const_iterator last);</pre>
<p>Erases the elements in the range from <code class="computeroutput">first</code> to <code class="computeroutput">last</code>.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The iterator following the erased elements - i.e. <code class="computeroutput">last</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>
<p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.</p>
<p>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1332224-bb"></a>quick_erase(const_iterator position);</pre>
<p>Erase the element pointed to by <code class="computeroutput">position</code>.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>
<p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.</p>
<p>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.</p>
</td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>
                  This method is faster than <a class="link" href="unordered_map.html#id1332006-bb">erase</a> as
                  it doesn't have to find the next element in the container -
                  a potentially costly operation.
                </p>
<p>
                  As it hasn't been standardized, it's likely that this may
                  change in the future.
                </p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1332298-bb"></a>erase_return_void(const_iterator position);</pre>
<p>Erase the element pointed to by <code class="computeroutput">position</code>.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>
<p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.</p>
<p>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.</p>
</td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>
                  This method is now deprecated, use
                  quick_return instead. Although be
                  warned that as that isn't standardized yet, it could also
                  change.
                </p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1332366-bb"></a>clear();</pre>
<p>Erases all elements in the container.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td><p><code class="computeroutput"><a class="link" href="unordered_map.html#id1331413-bb">size</a>() == 0</code></p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>Never throws an exception.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1332404-bb"></a>swap(unordered_map&amp;);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If the allocators are equal, doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code class="computeroutput">key_equal</code> or <code class="computeroutput">hasher</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>For a discussion of the behavior when allocators aren't equal see
                  <a class="link" href="../unordered/rationale.html#unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</a>.</p></td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" title="unordered_map observers">
<a name="id2076078"></a><h3>
<a name="id1332456-bb"></a><code class="computeroutput">unordered_map</code> observers</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="type">hasher</span> <a name="id1332460-bb"></a>hash_function() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>The container's hash function.
              </td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">key_equal</span> <a name="id1332476-bb"></a>key_eq() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>The container's key equality predicate.
              </td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" title="unordered_map lookup">
<a name="id2076165"></a><h3>
<a name="id1332494-bb"></a><code class="computeroutput">unordered_map</code> lookup</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><a name="id1332498-bb"></a><span class="type">iterator</span> <a name="id1332503-bb"></a>find(key_type <span class="bold"><strong>const</strong></span>&amp; k);
<span class="type">const_iterator</span> <a name="id1332521-bb"></a>find(key_type <span class="bold"><strong>const</strong></span>&amp; k) <span class="bold"><strong>const</strong></span>;
<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> CompatibleKey, <span class="bold"><strong>typename</strong></span> CompatibleHash, 
         <span class="bold"><strong>typename</strong></span> CompatiblePredicate&gt; 
  <span class="type">iterator</span> <a name="id1332541-bb"></a>find(CompatibleKey <span class="bold"><strong>const</strong></span>&amp; k, CompatibleHash <span class="bold"><strong>const</strong></span>&amp; hash, 
                CompatiblePredicate <span class="bold"><strong>const</strong></span>&amp; eq);
<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> CompatibleKey, <span class="bold"><strong>typename</strong></span> CompatibleHash, 
         <span class="bold"><strong>typename</strong></span> CompatiblePredicate&gt; 
  <span class="type">const_iterator</span> 
  <a name="id1332600-bb"></a>find(CompatibleKey <span class="bold"><strong>const</strong></span>&amp; k, CompatibleHash <span class="bold"><strong>const</strong></span>&amp; hash, 
       CompatiblePredicate <span class="bold"><strong>const</strong></span>&amp; eq) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>An iterator pointing to an element with key equivalent to <code class="computeroutput">k</code>, or <code class="computeroutput">b.end()</code> if no such element exists.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>
                The templated overloads are a non-standard extensions which
                allows you to use a compatible hash function and equality
                predicate for a key of a different type in order to avoid
                an expensive type cast. In general, its use is not encouraged.
              </p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">size_type</span> <a name="id1330872-bb"></a>count(key_type <span class="bold"><strong>const</strong></span>&amp; k) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The number of elements with key equivalent to <code class="computeroutput">k</code>.</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1330905-bb"></a><span class="type">std::pair&lt;iterator, iterator&gt;</span> <a name="id1330910-bb"></a>equal_range(key_type <span class="bold"><strong>const</strong></span>&amp; k);
<span class="type">std::pair&lt;const_iterator, const_iterator&gt;</span> <a name="id1330928-bb"></a>equal_range(key_type <span class="bold"><strong>const</strong></span>&amp; k) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A range containing all elements with key equivalent to <code class="computeroutput">k</code>.
                  If the container doesn't container any such elements, returns
                  <code class="computeroutput">std::make_pair(b.end(),b.end())</code>.
                  </p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">mapped_type&amp;</span> <a name="id1330978-bb"></a><span class="bold"><strong>operator</strong></span>[](key_type <span class="bold"><strong>const</strong></span>&amp; k);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td><p>If the container does not already contain an elements with a key equivalent to <code class="computeroutput">k</code>, inserts the value <code class="computeroutput">std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code></p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A reference to <code class="computeroutput">x.second</code> where x is the element already in the container, or the newly inserted element with a key equivalent to <code class="computeroutput">k</code></p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1331056-bb"></a><span class="type">Mapped&amp;</span> <a name="id1331060-bb"></a>at(key_type <span class="bold"><strong>const</strong></span>&amp; k);
<span class="type">Mapped <span class="bold"><strong>const</strong></span>&amp;</span> <a name="id1328207-bb"></a>at(key_type <span class="bold"><strong>const</strong></span>&amp; k) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A reference to <code class="computeroutput">x.second</code> where <code class="computeroutput">x</code> is the (unique) element whose key is equivalent to <code class="computeroutput">k</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>An exception object of type <code class="computeroutput">std::out_of_range</code> if no such element is present.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>This is not specified in the draft standard, but that is probably an oversight. The issue has been raised in
                  <a href="http://groups.google.com/group/comp.std.c++/browse_thread/thread/ab7c22a868fd370b" target="_top">comp.std.c++</a>.</p></td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" title="unordered_map bucket interface">
<a name="id2076710"></a><h3>
<a name="id1329921-bb"></a><code class="computeroutput">unordered_map</code> bucket interface</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="type">size_type</span> <a name="id1329926-bb"></a>bucket_count() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The number of buckets.</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">size_type</span> <a name="id1329946-bb"></a>max_bucket_count() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>An upper bound on the number of buckets.</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">size_type</span> <a name="id1329966-bb"></a>bucket_size(size_type n) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n &lt; <a class="link" href="unordered_map.html#id1329926-bb">bucket_count</a>()</code></p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The number of elements in bucket <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">size_type</span> <a name="id1330012-bb"></a>bucket(key_type <span class="bold"><strong>const</strong></span>&amp; k) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The index of the bucket which would contain an element with key <code class="computeroutput">k</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td><p>The return value is less than <code class="computeroutput">bucket_count()</code></p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1330057-bb"></a><span class="type">local_iterator</span> <a name="id1330061-bb"></a>begin(size_type n);
<span class="type">const_local_iterator</span> <a name="id1330080-bb"></a>begin(size_type n) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A local iterator pointing the first element in the bucket with index <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1330128-bb"></a><span class="type">local_iterator</span> <a name="id1330133-bb"></a>end(size_type n);
<span class="type">const_local_iterator</span> <a name="id1330151-bb"></a>end(size_type n) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A local iterator pointing the 'one past the end' element in the bucket with index <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">const_local_iterator</span> <a name="id1330200-bb"></a>cbegin(size_type n) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A constant local iterator pointing the first element in the bucket with index <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">const_local_iterator</span> <a name="id1330249-bb"></a>cend(size_type n);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" title="unordered_map hash policy">
<a name="id2077169"></a><h3>
<a name="id1330297-bb"></a><code class="computeroutput">unordered_map</code> hash policy</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>float</strong></span></span> <a name="id1330302-bb"></a>load_factor() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The average number of elements per bucket.</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>float</strong></span></span> <a name="id1330322-bb"></a>max_load_factor() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Returns the current maximum load factor.</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1330342-bb"></a>max_load_factor(<span class="bold"><strong>float</strong></span> z);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Effects:</span></p></td>
<td><p>Changes the container's maximum load factor, using <code class="computeroutput">z</code> as a hint.</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1330373-bb"></a>rehash(size_type n);</pre>
<p>Changes the number of buckets so that there at least <code class="computeroutput">n</code> buckets, and so that the load factor is less than the maximum load factor.</p>
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>The function has no effect if an exception is thrown, unless it is thrown by the container's hash function or comparison function.</p></td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" title="unordered_map Equality Comparisons">
<a name="id2077355"></a><h3>
<a name="id1330423-bb"></a><code class="computeroutput">unordered_map</code> Equality Comparisons</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Key, <span class="bold"><strong>typename</strong></span> Mapped, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, 
         <span class="bold"><strong>typename</strong></span> Alloc&gt; 
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="boost.operator==_id1330428"></a><span class="bold"><strong>operator</strong></span>==(unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp; x, 
                  unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp; y);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>This is a boost extension.</p>
<p>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.</p>
</td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Key, <span class="bold"><strong>typename</strong></span> Mapped, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, 
         <span class="bold"><strong>typename</strong></span> Alloc&gt; 
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="boost.operator!=_id1330508"></a><span class="bold"><strong>operator</strong></span>!=(unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp; x, 
                  unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp; y);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>This is a boost extension.</p>
<p>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.</p>
</td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" title="unordered_map swap">
<a name="id2077553"></a><h3>
<a name="id1330590-bb"></a><code class="computeroutput">unordered_map</code> swap</h3>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Key, <span class="bold"><strong>typename</strong></span> Mapped, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, 
         <span class="bold"><strong>typename</strong></span> Alloc&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="boost.swap_id1330594"></a>swap(unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt;&amp; y);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td><p><code class="computeroutput">x.swap(y)</code></p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If the allocators are equal, doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code class="computeroutput">Hash</code> or <code class="computeroutput">Pred</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>For a discussion of the behavior when allocators aren't equal see
                  <a class="link" href="../unordered/rationale.html#unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</a>.</p></td>
</tr>
</tbody>
</table></div>
</li></ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2003, 2004 Jeremy B. Maitin-Shepard<br>Copyright &#169; 2005-2008 Daniel
      James<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="unordered_multiset.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../unordered/reference.html#header.boost.unordered_map_hpp"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="unordered_multimap.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
